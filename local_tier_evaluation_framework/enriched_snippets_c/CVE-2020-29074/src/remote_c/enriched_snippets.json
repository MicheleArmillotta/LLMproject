[
  {
    "function_name": "process_remote_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "843-6324",
    "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
      "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
    ],
    "globals_used": [
      "int send_remote_cmd(char *cmd, int query, int wait);",
      "void check_black_fb(void);",
      "int check_httpdir(void);",
      "void http_connections(int on);",
      "int remote_control_access_ok(void);",
      "char *process_remote_cmd(char *cmd, int stringonly);",
      "static void if_8bpp_do_new_fb(void);",
      "int rc_npieces = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 6318
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_x11vnc_remote_prop",
          "args": [
            "buf"
          ],
          "line": 6317
        },
        "resolved": true,
        "details": {
          "function_name": "set_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3043-3052",
          "snippet": "void set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Atom x11vnc_remote_prop = None;",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nAtom x11vnc_remote_prop = None;\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20*1000"
          ],
          "line": 6312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 6311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "out",
            "\"%s\\n\"",
            "buf"
          ],
          "line": 6310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"w\""
          ],
          "line": 6308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 6306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\"",
            "\"ack=1\""
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"command \\\"%s\\\"\\n\"",
            "tmp"
          ],
          "line": 6293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmp",
            "p",
            "90"
          ],
          "line": 6292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"viewpasswd\""
          ],
          "line": 6278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"passwd\""
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"rfbauth\""
          ],
          "line": 6270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "coff_y"
          ],
          "line": 6267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"coff_y\""
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "coff_x"
          ],
          "line": 6263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"coff_x\""
          ],
          "line": 6262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "cdpy_y"
          ],
          "line": 6259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cdpy_y\""
          ],
          "line": 6258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "cdpy_x"
          ],
          "line": 6255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cdpy_x\""
          ],
          "line": 6254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "off_y"
          ],
          "line": 6251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"off_y\""
          ],
          "line": 6250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "off_x"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"off_x\""
          ],
          "line": 6246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "wdpy_y"
          ],
          "line": 6243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wdpy_y\""
          ],
          "line": 6242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "wdpy_x"
          ],
          "line": 6239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wdpy_x\""
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "dpy_y"
          ],
          "line": 6235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dpy_y\""
          ],
          "line": 6234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "dpy_x"
          ],
          "line": 6231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dpy_x\""
          ],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "indexed_color"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"indexed_color\""
          ],
          "line": 6226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "depth"
          ],
          "line": 6223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"depth\""
          ],
          "line": 6222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "bpp"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"bpp\""
          ],
          "line": 6218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: %s: %s\\n\"",
            "p",
            "buf"
          ],
          "line": 6214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:0x%x\"",
            "p",
            "m"
          ],
          "line": 6211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_mask\""
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:0x%x\"",
            "p",
            "(unsigned int) r"
          ],
          "line": 6209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_root\""
          ],
          "line": 6208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "same_screen"
          ],
          "line": 6207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_same\""
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "py"
          ],
          "line": 6205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_y\""
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "px"
          ],
          "line": 6203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_x\""
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d,%d\"",
            "p",
            "px",
            "py"
          ],
          "line": 6201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_pos\""
          ],
          "line": 6200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&c",
            "&px",
            "&py",
            "&wx",
            "&wy",
            "&m"
          ],
          "line": 6196
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:0x%x\"",
            "p",
            "m"
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_mask\""
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:0x%x\"",
            "p",
            "(unsigned int) rootwin"
          ],
          "line": 6185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_root\""
          ],
          "line": 6184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "same_screen"
          ],
          "line": 6183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_same\""
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "py"
          ],
          "line": 6181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_y\""
          ],
          "line": 6180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "px"
          ],
          "line": 6179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_x\""
          ],
          "line": 6178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d,%d\"",
            "p",
            "px",
            "py"
          ],
          "line": 6177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_pos\""
          ],
          "line": 6176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_mask\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_root\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_same\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_y\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_x\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pointer_pos\""
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: ptr,kbd: %s\\n\"",
            "buf"
          ],
          "line": 6164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d,%d\"",
            "p",
            "ptr_grabbed",
            "kbd_grabbed"
          ],
          "line": 6162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_state",
          "args": [
            "&ptr_grabbed",
            "&kbd_grabbed"
          ],
          "line": 6161
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"grab_state\""
          ],
          "line": 6158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "cursor_y"
          ],
          "line": 6155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"mouse_y\""
          ],
          "line": 6154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "cursor_x"
          ],
          "line": 6151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"mouse_x\""
          ],
          "line": 6150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "button_mask"
          ],
          "line": 6147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"button_mask\""
          ],
          "line": 6146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "num_buttons"
          ],
          "line": 6143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"num_buttons\""
          ],
          "line": 6142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:0x%x\"",
            "p",
            "(unsigned int) rootwin"
          ],
          "line": 6138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"rootwin\""
          ],
          "line": 6137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xrandr_present"
          ],
          "line": 6134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xrandr\""
          ],
          "line": 6133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xdamage_present"
          ],
          "line": 6130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xdamage\""
          ],
          "line": 6129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xfixes_present"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xfixes\""
          ],
          "line": 6125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "overlay_present"
          ],
          "line": 6122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_overlay\""
          ],
          "line": 6121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xinerama_present"
          ],
          "line": 6118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xinerama\""
          ],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xshm_present"
          ],
          "line": 6114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xshm\""
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xkb_present"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xkb\""
          ],
          "line": 6109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xrecord_present"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xrecord\""
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xtrap_present"
          ],
          "line": 6102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xtrap\""
          ],
          "line": 6101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "xtest_present"
          ],
          "line": 6098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ext_xtest\""
          ],
          "line": 6097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "(int) getpid()"
          ],
          "line": 6094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 6094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pid\""
          ],
          "line": 6093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "client_count"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"client_count\""
          ],
          "line": 6089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 6086
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "str"
          ],
          "line": 6085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_clients",
          "args": [],
          "line": 6084
        },
        "resolved": true,
        "details": {
          "function_name": "list_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/appshare.c",
          "lines": "1313-1323",
          "snippet": "static void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAX 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"x11vnc.h\"\n\n#define CMAX 128\n\nstatic void list_clients(void) {\n\tint i, n = 0;\n\tfor (i=0; i < CMAX; i++) {\n\t\tif (clients[i] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stdout, \"client[%02d] %s\\n\", ++n, clients[i]);\n\t}\n\tfprintf(stdout, \"total clients: %d\\n\", n);\n\tff();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clients\""
          ],
          "line": 6083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(pipeinput_str)"
          ],
          "line": 6079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "pipeinput_str"
          ],
          "line": 6080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"pipeinput\""
          ],
          "line": 6078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "get_net_latency()"
          ],
          "line": 6075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net_latency",
          "args": [],
          "line": 6075
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "323-335",
          "snippet": "int get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_latency = 0;",
            "int speeds_net_latency_measured = 0;",
            "int get_net_latency(void);",
            "static int get_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_latency = 0;\nint speeds_net_latency_measured = 0;\nint get_net_latency(void);\nstatic int get_latency(void);\n\nint get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"netlatency\""
          ],
          "line": 6074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "get_net_rate()"
          ],
          "line": 6071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net_rate",
          "args": [],
          "line": 6071
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "309-321",
          "snippet": "int get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_rate = 0;",
            "int speeds_net_rate_measured = 0;",
            "int get_cmp_rate(void);",
            "int get_net_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_rate_measured = 0;\nint get_cmp_rate(void);\nint get_net_rate(void);\n\nint get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"netrate\""
          ],
          "line": 6070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "get_read_rate()"
          ],
          "line": 6067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_read_rate",
          "args": [],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "get_read_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "272-280",
          "snippet": "int get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_read_rate = 0;",
            "int speeds_read_rate_measured = 0;",
            "int get_read_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nint get_read_rate(void);\n\nint get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"readrate\""
          ],
          "line": 6066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "use_threads"
          ],
          "line": 6063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"threads\""
          ],
          "line": 6062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(sigpipe)"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "sigpipe"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"sigpipe\""
          ],
          "line": 6058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "opts_bg"
          ],
          "line": 6055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"bg\""
          ],
          "line": 6054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(lastmod)"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "lastmod"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"lastmod\""
          ],
          "line": 6050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"version\""
          ],
          "line": 6049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"V\""
          ],
          "line": 6049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"help\""
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"h\""
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "got_norc"
          ],
          "line": 6045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"norc\""
          ],
          "line": 6044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(s)"
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "s"
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"rc\""
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(rm_flagfile)"
          ],
          "line": 6033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "rm_flagfile"
          ],
          "line": 6033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"rmflag\""
          ],
          "line": 6032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(flagfile)"
          ],
          "line": 6029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "flagfile"
          ],
          "line": 6029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"flag\""
          ],
          "line": 6028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(logfile)"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "logfile"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"o\""
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"logfile\""
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "!using_shm"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"using_shm\""
          ],
          "line": 6020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "usepw"
          ],
          "line": 6017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"usepw\""
          ],
          "line": 6016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "https_port_redir"
          ],
          "line": 6013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"httpsredir\""
          ],
          "line": 6012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "https_port_num"
          ],
          "line": 6009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"https\""
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(stunnel_pem)"
          ],
          "line": 6005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "stunnel_pem"
          ],
          "line": 6005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"stunnel_pem\""
          ],
          "line": 6004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "use_stunnel"
          ],
          "line": 6001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"stunnel\""
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(ssl_verify)"
          ],
          "line": 5997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "ssl_verify"
          ],
          "line": 5997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"sslverify\""
          ],
          "line": 5996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(openssl_pem)"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "openssl_pem"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ssl_pem\""
          ],
          "line": 5992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "use_openssl"
          ],
          "line": 5989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ssl\""
          ],
          "line": 5988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(unixpw_list)"
          ],
          "line": 5985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "unixpw_list"
          ],
          "line": 5985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unixpw_list\""
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "unixpw_nis"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unixpw_nis\""
          ],
          "line": 5980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "unixpw"
          ],
          "line": 5977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unixpw\""
          ],
          "line": 5976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(passwdfile)"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "passwdfile"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"passwdfile\""
          ],
          "line": 5972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "no_external_cmds"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocmds\""
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "more_safe"
          ],
          "line": 5965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"safer\""
          ],
          "line": 5964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "!safe_remote_only"
          ],
          "line": 5961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unsafe\""
          ],
          "line": 5960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "priv_remote"
          ],
          "line": 5957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"privremote\""
          ],
          "line": 5956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "inetd"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"inetd\""
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaling_interpolate"
          ],
          "line": 5948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaling_interpolate\""
          ],
          "line": 5947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaling_pad"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaling_pad\""
          ],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaling_nomult4"
          ],
          "line": 5940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaling_nomult4\""
          ],
          "line": 5939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaling_blend"
          ],
          "line": 5936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaling_blend\""
          ],
          "line": 5935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%f\"",
            "p",
            "scale_fac_y"
          ],
          "line": 5932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_fac_y\""
          ],
          "line": 5931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%f\"",
            "p",
            "scale_fac_x"
          ],
          "line": 5928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_fac_x\""
          ],
          "line": 5927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scale_denom"
          ],
          "line": 5924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_denom\""
          ],
          "line": 5923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scale_numer"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_numer\""
          ],
          "line": 5919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaled_y"
          ],
          "line": 5916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaled_y\""
          ],
          "line": 5915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "scaled_x"
          ],
          "line": 5912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scaled_x\""
          ],
          "line": 5911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(scale_str)"
          ],
          "line": 5908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scale_str"
          ],
          "line": 5908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_str\""
          ],
          "line": 5907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "clipshift"
          ],
          "line": 5904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clipshift\""
          ],
          "line": 5903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "rootshift"
          ],
          "line": 5900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"rootshift\""
          ],
          "line": 5899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(users_list)"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "users_list"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"users\""
          ],
          "line": 5895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(auth_file)"
          ],
          "line": 5892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "auth_file"
          ],
          "line": 5892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xauth\""
          ],
          "line": 5891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"auth\""
          ],
          "line": 5891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "\"http_not_active\""
          ],
          "line": 5886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:http://%s:%d\"",
            "p",
            "NONUL(screen->thisHost)",
            "screen->httpPort"
          ],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "screen->thisHost"
          ],
          "line": 5884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:\"",
            "p"
          ],
          "line": 5881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"http_url\""
          ],
          "line": 5879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(dbus_session())"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "dbus_session()"
          ],
          "line": 5876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_session",
          "args": [],
          "line": 5876
        },
        "resolved": true,
        "details": {
          "function_name": "dbus_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "555-649",
          "snippet": "char *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *dbus_session(void);",
            "static char _dbus_str[1100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic char _dbus_str[1100];\n\nchar *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"guess_dbus\""
          ],
          "line": 5874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(guess_desktop())"
          ],
          "line": 5870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "guess_desktop()"
          ],
          "line": 5871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_desktop",
          "args": [],
          "line": 5871
        },
        "resolved": true,
        "details": {
          "function_name": "guess_desktop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1232-1292",
          "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"guess_desktop\""
          ],
          "line": 5869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(rfb_desktop_name)"
          ],
          "line": 5865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "rfb_desktop_name"
          ],
          "line": 5866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"desktopname\""
          ],
          "line": 5864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "0"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"loopbg\""
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"loop\""
          ],
          "line": 5860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "auto_port"
          ],
          "line": 5857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"autoport\""
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%d\"",
            "p",
            "icon_mode"
          ],
          "line": 5853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"icon_mode\""
          ],
          "line": 5852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "NONUL(vnc_desktop_name)"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "vnc_desktop_name"
          ],
          "line": 5849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"vncdisplay\""
          ],
          "line": 5847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s\"",
            "p",
            "d"
          ],
          "line": 5842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:%s%s\"",
            "p",
            "host",
            "d"
          ],
          "line": 5838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 5837
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:\"",
            "p"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"aro=%s:rawfb:%p\"",
            "p",
            "raw_fb_addr"
          ],
          "line": 5828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"display\""
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\"",
            "id"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "p",
            "&id"
          ],
          "line": 5815
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"trayunembed:\""
          ],
          "line": 5814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"trayunembed\""
          ],
          "line": 5809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\"",
            "id"
          ],
          "line": 5804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"trayembed:\""
          ],
          "line": 5800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"trayembed\""
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed view only passwd.\\n\""
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbRandomBytes",
          "args": [
            "(unsigned char*)tmp"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4 + CHALLENGESIZE"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"viewpasswd:\""
          ],
          "line": 5772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"viewpasswd:\""
          ],
          "line": 5771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*sizeof(char *)"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"viewpasswd\""
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed full access passwd.\\n\""
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"passwd:\""
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"passwd:\""
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*sizeof(char *)"
          ],
          "line": 5742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"passwd\""
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noop\""
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_client_info_sock",
          "args": [
            "p"
          ],
          "line": 5732
        },
        "resolved": true,
        "details": {
          "function_name": "start_client_info_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "4206-4279",
          "snippet": "void start_client_info_sock(char *host_port_cookie) {\n\tchar *host = NULL, *cookie = NULL, *p;\n\tchar *str = strdup(host_port_cookie);\n\tint i, port, sock, next = -1;\n\tstatic time_t start_time[ICON_MODE_SOCKS];\n\ttime_t oldest = 0;\n\tint db = 0;\n\n\tport = -1;\n\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] < 0) {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (oldest == 0 || start_time[i] < oldest) {\n\t\t\tnext = i;\n\t\t\toldest = start_time[i];\n\t\t}\n\t}\n\n\tp = strtok(str, \":\");\n\ti = 0;\n\twhile (p) {\n\t\tif (i == 0) {\n\t\t\thost = strdup(p);\n\t\t} else if (i == 1) {\n\t\t\tport = atoi(p);\n\t\t} else if (i == 2) {\n\t\t\tcookie = strdup(p);\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(str);\n\n\tif (db) fprintf(stderr, \"%s/%d/%s next=%d\\n\", host, port, cookie, next);\n\n\tif (host && port && cookie) {\n\t\tif (*host == '\\0') {\n\t\t\tfree(host);\n\t\t\thost = strdup(\"localhost\");\n\t\t}\n\t\tsock = connect_tcp(host, port);\n\t\tif (sock < 0) {\n\t\t\tusleep(200 * 1000);\n\t\t\tsock = connect_tcp(host, port);\n\t\t}\n\t\tif (sock >= 0) {\n\t\t\tchar *lst = list_clients();\n\t\t\ticon_mode_socks[next] = sock;\n\t\t\tstart_time[next] = time(NULL);\n\t\t\twrite(sock, \"COOKIE:\", strlen(\"COOKIE:\"));\n\t\t\twrite(sock, cookie, strlen(cookie));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, lst, strlen(lst));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\tif (db) {\n\t\t\t\tfprintf(stderr, \"list: %s\\n\", lst);\n\t\t\t}\n\t\t\tfree(lst);\n\t\t\trfbLog(\"client_info_sock to: %s:%d\\n\", host, port);\n\t\t} else {\n\t\t\trfbLog(\"failed client_info_sock: %s:%d\\n\", host, port);\n\t\t}\n\t} else {\n\t\trfbLog(\"malformed client_info_sock: %s\\n\", host_port_cookie);\t\n\t}\n\n\tif (host) free(host);\n\tif (cookie) free(cookie);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *list_clients(void);",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void start_client_info_sock(char *host_port_cookie);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid start_client_info_sock(char *host_port_cookie);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid start_client_info_sock(char *host_port_cookie) {\n\tchar *host = NULL, *cookie = NULL, *p;\n\tchar *str = strdup(host_port_cookie);\n\tint i, port, sock, next = -1;\n\tstatic time_t start_time[ICON_MODE_SOCKS];\n\ttime_t oldest = 0;\n\tint db = 0;\n\n\tport = -1;\n\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] < 0) {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (oldest == 0 || start_time[i] < oldest) {\n\t\t\tnext = i;\n\t\t\toldest = start_time[i];\n\t\t}\n\t}\n\n\tp = strtok(str, \":\");\n\ti = 0;\n\twhile (p) {\n\t\tif (i == 0) {\n\t\t\thost = strdup(p);\n\t\t} else if (i == 1) {\n\t\t\tport = atoi(p);\n\t\t} else if (i == 2) {\n\t\t\tcookie = strdup(p);\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(str);\n\n\tif (db) fprintf(stderr, \"%s/%d/%s next=%d\\n\", host, port, cookie, next);\n\n\tif (host && port && cookie) {\n\t\tif (*host == '\\0') {\n\t\t\tfree(host);\n\t\t\thost = strdup(\"localhost\");\n\t\t}\n\t\tsock = connect_tcp(host, port);\n\t\tif (sock < 0) {\n\t\t\tusleep(200 * 1000);\n\t\t\tsock = connect_tcp(host, port);\n\t\t}\n\t\tif (sock >= 0) {\n\t\t\tchar *lst = list_clients();\n\t\t\ticon_mode_socks[next] = sock;\n\t\t\tstart_time[next] = time(NULL);\n\t\t\twrite(sock, \"COOKIE:\", strlen(\"COOKIE:\"));\n\t\t\twrite(sock, cookie, strlen(cookie));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, lst, strlen(lst));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\tif (db) {\n\t\t\t\tfprintf(stderr, \"list: %s\\n\", lst);\n\t\t\t}\n\t\t\tfree(lst);\n\t\t\trfbLog(\"client_info_sock to: %s:%d\\n\", host, port);\n\t\t} else {\n\t\t\trfbLog(\"failed client_info_sock: %s:%d\\n\", host, port);\n\t\t}\n\t} else {\n\t\trfbLog(\"malformed client_info_sock: %s\\n\", host_port_cookie);\t\n\t}\n\n\tif (host) free(host);\n\tif (cookie) free(cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"client_info_sock\""
          ],
          "line": 5728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling remote commands.\\n\""
          ],
          "line": 5724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!accept_remote_cmds"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noremote\""
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set hack_val to: %d\\n\"",
            "hack_val"
          ],
          "line": 5715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"hack:\""
          ],
          "line": 5713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "hack_val"
          ],
          "line": 5710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"hack:\""
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"hack\""
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable macosx_us_kbd.\\n\""
          ],
          "line": 5703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_us_kbd"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacuskbd\""
          ],
          "line": 5699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable macosx_us_kbd.\\n\""
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_us_kbd"
          ],
          "line": 5693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macuskbd\""
          ],
          "line": 5691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable macosx_ncache_macmenu.\\n\""
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_ncache_macmenu"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacmenu\""
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macnomenu\""
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable macosx_ncache_macmenu.\\n\""
          ],
          "line": 5679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_ncache_macmenu"
          ],
          "line": 5677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macmenu\""
          ],
          "line": 5675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set macosx_icon_anim_time to: %d\\n\"",
            "macosx_icon_anim_time"
          ],
          "line": 5672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"maciconanim:\""
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "macosx_icon_anim_time"
          ],
          "line": 5667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"maciconanim:\""
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"maciconanim\""
          ],
          "line": 5664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable macosx_resize.\\n\""
          ],
          "line": 5660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_resize"
          ],
          "line": 5658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacnoresize\""
          ],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macresize\""
          ],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable macosx_resize.\\n\""
          ],
          "line": 5652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_resize"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macnoresize\""
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable macosx_swap23.\\n\""
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_swap23"
          ],
          "line": 5642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacnoswap\""
          ],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macswap\""
          ],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable macosx_swap23.\\n\""
          ],
          "line": 5636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_swap23"
          ],
          "line": 5634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macnoswap\""
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set macosx_mouse_wheel_speed to: %d\\n\"",
            "macosx_mouse_wheel_speed"
          ],
          "line": 5629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"macwheel:\""
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "macosx_mouse_wheel_speed"
          ],
          "line": 5624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"macwheel:\""
          ],
          "line": 5622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"macwheel\""
          ],
          "line": 5621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable macosx_wait_for_switch.\\n\""
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_wait_for_switch"
          ],
          "line": 5615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacnowait\""
          ],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macwait\""
          ],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable macosx_wait_for_switch.\\n\""
          ],
          "line": 5609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_wait_for_switch"
          ],
          "line": 5607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macnowait\""
          ],
          "line": 5605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turn off macnosaver.\\n\""
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!macosx_noscreensaver"
          ],
          "line": 5599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomacnosaver\""
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macsaver\""
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turn on macnosaver.\\n\""
          ],
          "line": 5593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "macosx_noscreensaver"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"macnosaver\""
          ],
          "line": 5589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set crash_debug to: %d\\n\"",
            "crash_debug"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!crash_debug"
          ],
          "line": 5582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodbg\""
          ],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set crash_debug to: %d\\n\"",
            "crash_debug"
          ],
          "line": 5577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "crash_debug"
          ],
          "line": 5573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dbg\""
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_sel to: %d\\n\"",
            "debug_sel"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_sel"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_sel\""
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_sel to: %d\\n\"",
            "debug_sel"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_sel"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_sel\""
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_grabs to: %d\\n\"",
            "debug_grabs"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_grabs"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_grabs\""
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_grabs to: %d\\n\"",
            "debug_grabs"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_grabs"
          ],
          "line": 5537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_grabs\""
          ],
          "line": 5535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_tiles to: %d\\n\"",
            "debug_tiles"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug_tiles:\""
          ],
          "line": 5530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "debug_tiles"
          ],
          "line": 5526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"debug_tiles:\""
          ],
          "line": 5524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug_tiles\""
          ],
          "line": 5523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_tiles to: %d\\n\"",
            "debug_tiles"
          ],
          "line": 5520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_tiles"
          ],
          "line": 5516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodbt\""
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_tiles\""
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_tiles to: %d\\n\"",
            "debug_tiles"
          ],
          "line": 5511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_tiles"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dbt\""
          ],
          "line": 5505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_tiles\""
          ],
          "line": 5505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_scroll to: %d\\n\"",
            "debug_scroll"
          ],
          "line": 5502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug_scroll:\""
          ],
          "line": 5500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "debug_scroll"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"debug_scroll:\""
          ],
          "line": 5494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug_scroll\""
          ],
          "line": 5493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_scroll to: %d\\n\"",
            "debug_scroll"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_scroll"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_scroll\""
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_scroll to: %d\\n\"",
            "debug_scroll"
          ],
          "line": 5481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_scroll"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_scroll\""
          ],
          "line": 5475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_wireframe to: %d\\n\"",
            "debug_wireframe"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug_wireframe:\""
          ],
          "line": 5470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "debug_wireframe"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"debug_wireframe:\""
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug_wireframe\""
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_wireframe to: %d\\n\"",
            "debug_wireframe"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_wireframe"
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_wireframe\""
          ],
          "line": 5454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_wireframe to: %d\\n\"",
            "debug_wireframe"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_wireframe"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_wireframe\""
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xdamage to: %d\\n\"",
            "debug_xdamage"
          ],
          "line": 5442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug_xdamage:\""
          ],
          "line": 5440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "debug_xdamage"
          ],
          "line": 5437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"debug_xdamage:\""
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug_xdamage\""
          ],
          "line": 5434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xdamage to: %d\\n\"",
            "debug_xdamage"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_xdamage"
          ],
          "line": 5427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_xdamage\""
          ],
          "line": 5425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xdamage to: %d\\n\"",
            "debug_xdamage"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_xdamage"
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_xdamage\""
          ],
          "line": 5416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xevents to: %d\\n\"",
            "debug_xevents"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"debug_xevents:\""
          ],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "debug_xevents"
          ],
          "line": 5408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"debug_xevents:\""
          ],
          "line": 5406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"debug_xevents\""
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xevents to: %d\\n\"",
            "debug_xevents"
          ],
          "line": 5402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_xevents"
          ],
          "line": 5398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_xevents\""
          ],
          "line": 5396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set debug_xevents to: %d\\n\"",
            "debug_xevents"
          ],
          "line": 5393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_xevents"
          ],
          "line": 5389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_xevents\""
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting desktop name to %s\\n\"",
            "rfb_desktop_name"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"desktop:\""
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(rfb_desktop_name)"
          ],
          "line": 5372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "rfb_desktop_name"
          ],
          "line": 5373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"desktop:\""
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"desktop:\""
          ],
          "line": 5369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"desktop\""
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off dontdisconnect.\\n\""
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t == 0"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodontdisconnect\""
          ],
          "line": 5358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning on dontdisconnect.\\n\""
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t != 0"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dontdisconnect\""
          ],
          "line": 5348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off nevershared.\\n\""
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t == 0"
          ],
          "line": 5341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noalwaysshared\""
          ],
          "line": 5338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning on nevershared.\\n\""
          ],
          "line": 5334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t != 0"
          ],
          "line": 5331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nevershared\""
          ],
          "line": 5328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off alwaysshared.\\n\""
          ],
          "line": 5324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t == 0"
          ],
          "line": 5321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noalwaysshared\""
          ],
          "line": 5318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning on alwaysshared.\\n\""
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "t != 0"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"alwaysshared\""
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off enablehttpproxy.\\n\""
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ht == 0"
          ],
          "line": 5301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noenablehttpproxy\""
          ],
          "line": 5298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning on enablehttpproxy.\\n\""
          ],
          "line": 5293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ht != 0"
          ],
          "line": 5290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"enablehttpproxy\""
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_connections",
          "args": [
            "1"
          ],
          "line": 5282
        },
        "resolved": true,
        "details": {
          "function_name": "http_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "496-564",
          "snippet": "void http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);",
            "void http_connections(int on);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\nvoid http_connections(int on);\n\nvoid http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"no change in httpdir: %s\\n\"",
            "http_dir"
          ],
          "line": 5274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "http_dir",
            "p"
          ],
          "line": 5273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"httpdir:\""
          ],
          "line": 5272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(http_dir)"
          ],
          "line": 5268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "http_dir"
          ],
          "line": 5269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"httpdir:\""
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"httpdir\""
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_httpport",
          "args": [
            "orig",
            "hp"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "reset_httpport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "566-620",
          "snippet": "static void reset_httpport(int old, int newp) {\n\tint hp = newp;\n\n\tif (! screen->httpDir) {\n\t\treturn;\n\t} else if (inetd) {\n\t\trfbLog(\"reset_httpport: cannot set httpport: %d in inetd.\\n\", hp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_httpport: no screen.\\n\");\n\t\treturn;\n\t} else if (hp < 0) {\n\t\trfbLog(\"reset_httpport: invalid httpport: %d\\n\", hp);\n\t\treturn;\n\t} else if (hp == old) {\n\t\trfbLog(\"reset_httpport: unchanged httpport: %d\\n\", hp);\n\t\treturn;\n\t}\n\n\tif (screen->httpListenSock > -1) {\n\t\tclose(screen->httpListenSock);\n\t\tscreen->httpListenSock = -1;\n\t}\n\n\tscreen->httpPort = hp;\n\tscreen->httpInitDone = FALSE;\n\n\trfbLog(\"reset_httpport: setting httpport %d -> %d.\\n\",\n\t    old == -1 ? hp : old, hp);\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_httpport()\\n\");\n\t\t}\n\t} else if (screen->httpPort == 0) {\n\t\t;\n\t} else {\n\t\trfb_http_init_sockets();\n\t}\n\n\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\trfbLog(\"reset_httpport: failed to listen on http port: %d\\n\",\n\t\t    screen->httpPort);\n\t}\n\n\tif (ipv6_http_fd >= 0) {\n\t\tclose(ipv6_http_fd);\n\t\tipv6_http_fd = -1;\n\t}\n\tif (ipv6_listen && screen->httpPort > 0) {\n\t\tipv6_http_fd = listen6(screen->httpPort);\n\t\trfbLog(\"reset_httpport: ipv6_http_fd: %d  port: %d\\n\",\n\t\t    ipv6_http_fd, screen->httpPort);\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void http_connections(int on);",
            "static void reset_httpport(int old, int newp);",
            "static void reset_rfbport(int old, int newp) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nstatic void reset_httpport(int old, int newp);\nstatic void reset_rfbport(int old, int newp) ;\n\nstatic void reset_httpport(int old, int newp) {\n\tint hp = newp;\n\n\tif (! screen->httpDir) {\n\t\treturn;\n\t} else if (inetd) {\n\t\trfbLog(\"reset_httpport: cannot set httpport: %d in inetd.\\n\", hp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_httpport: no screen.\\n\");\n\t\treturn;\n\t} else if (hp < 0) {\n\t\trfbLog(\"reset_httpport: invalid httpport: %d\\n\", hp);\n\t\treturn;\n\t} else if (hp == old) {\n\t\trfbLog(\"reset_httpport: unchanged httpport: %d\\n\", hp);\n\t\treturn;\n\t}\n\n\tif (screen->httpListenSock > -1) {\n\t\tclose(screen->httpListenSock);\n\t\tscreen->httpListenSock = -1;\n\t}\n\n\tscreen->httpPort = hp;\n\tscreen->httpInitDone = FALSE;\n\n\trfbLog(\"reset_httpport: setting httpport %d -> %d.\\n\",\n\t    old == -1 ? hp : old, hp);\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_httpport()\\n\");\n\t\t}\n\t} else if (screen->httpPort == 0) {\n\t\t;\n\t} else {\n\t\trfb_http_init_sockets();\n\t}\n\n\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\trfbLog(\"reset_httpport: failed to listen on http port: %d\\n\",\n\t\t    screen->httpPort);\n\t}\n\n\tif (ipv6_http_fd >= 0) {\n\t\tclose(ipv6_http_fd);\n\t\tipv6_http_fd = -1;\n\t}\n\tif (ipv6_listen && screen->httpPort > 0) {\n\t\tipv6_http_fd = listen6(screen->httpPort);\n\t\trfbLog(\"reset_httpport: ipv6_http_fd: %d  port: %d\\n\",\n\t\t    ipv6_http_fd, screen->httpPort);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"httpport:\""
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "orig"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"httpport:\""
          ],
          "line": 5255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"httpport\""
          ],
          "line": 5253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_httpdir",
          "args": [],
          "line": 5247
        },
        "resolved": true,
        "details": {
          "function_name": "check_httpdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "349-471",
          "snippet": "int check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\n\nint check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off listening for http connections.\\n\""
          ],
          "line": 5246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"already not listening for http connections.\\n\""
          ],
          "line": 5244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!(ls > -1)"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nohttp\""
          ],
          "line": 5237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning on listening for http connections.\\n\""
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"already listening for http connections.\\n\""
          ],
          "line": 5228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "(ls > -1)"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"http\""
          ],
          "line": 5221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_rfbport",
          "args": [
            "orig",
            "rp"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rfbport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "622-692",
          "snippet": "static void reset_rfbport(int old, int newp)  {\n\tint rp = newp;\n\n\tif (inetd) {\n\t\trfbLog(\"reset_rfbport: cannot set rfbport: %d in inetd.\\n\", rp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_rfbport: no screen.\\n\");\n\t\treturn;\n\t} else if (rp < 0) {\n\t\trfbLog(\"reset_rfbport: invalid rfbport: %d\\n\", rp);\n\t\treturn;\n\t} else if (rp == old) {\n\t\trfbLog(\"reset_rfbport: unchanged rfbport: %d\\n\", rp);\n\t\treturn;\n\t}\n\n\trfbLog(\"reset_rfbport: setting rfbport %d -> %d.\\n\", old == -1 ? rp : old, rp);\n\n\tscreen->port = rp;\n\n\tif (use_openssl) {\n\t\topenssl_port(1);\n\t\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\",\n\t\t\t    screen->port);\n\t\t} else {\n\t\t\tset_vnc_desktop_name();\n\t\t}\n\t\tif (https_port_num >= 0) {\n\t\t\thttps_port(1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (screen->listenSock >= 0) {\n\t\tFD_CLR(screen->listenSock, &(screen->allFds));\n\t\tclose(screen->listenSock);\n\t\tscreen->listenSock = -1;\n\t}\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_rfbport()\\n\");\n\t\t}\n\t} else {\n\t\tscreen->listenSock = listen_tcp(screen->port, screen->listenInterface, 0);\n\t\tif (screen->listenSock >= 0) {\n\t\t\tif (screen->listenSock > screen->maxFd) {\n\t\t\t\tscreen->maxFd = screen->listenSock;\n\t\t\t}\n\t\t\tFD_SET(screen->listenSock, &(screen->allFds));\n\t\t}\n\t}\n\n\tif (ipv6_listen_fd >= 0) {\n\t\tclose(ipv6_listen_fd);\n\t\tipv6_listen_fd = -1;\n\t}\n\tif (ipv6_listen && screen->port > 0) {\n\t\tipv6_listen_fd = listen6(screen->port);\n\t\trfbLog(\"reset_rfbport: ipv6_listen_fd: %d  port: %d\\n\",\n\t\t    ipv6_listen_fd, screen->port);\n\t}\n\n\tif (screen->listenSock < 0 && ipv6_listen_fd < 0) {\n\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\", screen->port);\n\t} else {\n\t\tset_vnc_desktop_name();\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void http_connections(int on);",
            "static void reset_httpport(int old, int newp);",
            "static void reset_rfbport(int old, int newp) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nstatic void reset_httpport(int old, int newp);\nstatic void reset_rfbport(int old, int newp) ;\n\nstatic void reset_rfbport(int old, int newp)  {\n\tint rp = newp;\n\n\tif (inetd) {\n\t\trfbLog(\"reset_rfbport: cannot set rfbport: %d in inetd.\\n\", rp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_rfbport: no screen.\\n\");\n\t\treturn;\n\t} else if (rp < 0) {\n\t\trfbLog(\"reset_rfbport: invalid rfbport: %d\\n\", rp);\n\t\treturn;\n\t} else if (rp == old) {\n\t\trfbLog(\"reset_rfbport: unchanged rfbport: %d\\n\", rp);\n\t\treturn;\n\t}\n\n\trfbLog(\"reset_rfbport: setting rfbport %d -> %d.\\n\", old == -1 ? rp : old, rp);\n\n\tscreen->port = rp;\n\n\tif (use_openssl) {\n\t\topenssl_port(1);\n\t\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\",\n\t\t\t    screen->port);\n\t\t} else {\n\t\t\tset_vnc_desktop_name();\n\t\t}\n\t\tif (https_port_num >= 0) {\n\t\t\thttps_port(1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (screen->listenSock >= 0) {\n\t\tFD_CLR(screen->listenSock, &(screen->allFds));\n\t\tclose(screen->listenSock);\n\t\tscreen->listenSock = -1;\n\t}\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_rfbport()\\n\");\n\t\t}\n\t} else {\n\t\tscreen->listenSock = listen_tcp(screen->port, screen->listenInterface, 0);\n\t\tif (screen->listenSock >= 0) {\n\t\t\tif (screen->listenSock > screen->maxFd) {\n\t\t\t\tscreen->maxFd = screen->listenSock;\n\t\t\t}\n\t\t\tFD_SET(screen->listenSock, &(screen->allFds));\n\t\t}\n\t}\n\n\tif (ipv6_listen_fd >= 0) {\n\t\tclose(ipv6_listen_fd);\n\t\tipv6_listen_fd = -1;\n\t}\n\tif (ipv6_listen && screen->port > 0) {\n\t\tipv6_listen_fd = listen6(screen->port);\n\t\trfbLog(\"reset_rfbport: ipv6_listen_fd: %d  port: %d\\n\",\n\t\t    ipv6_listen_fd, screen->port);\n\t}\n\n\tif (screen->listenSock < 0 && ipv6_listen_fd < 0) {\n\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\", screen->port);\n\t} else {\n\t\tset_vnc_desktop_name();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rfbport:\""
          ],
          "line": 5216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "orig"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"rfbport:\""
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rfbport\""
          ],
          "line": 5209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting progressive %d -> %d.\\n\"",
            "screen->progressiveSliceHeight",
            "f"
          ],
          "line": 5203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"progressive:\""
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "f"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"progressive:\""
          ],
          "line": 5190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"progressive\""
          ],
          "line": 5188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_always",
          "args": [
            "atoi(p)"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "568-570",
          "snippet": "void set_uinput_always(int a) {\n\tuinput_always = a;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_always(int);",
            "static double a[7];",
            "static int uinput_always = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_always(int);\nstatic double a[7];\nstatic int uinput_always = 0;\n\nvoid set_uinput_always(int a) {\n\tuinput_always = a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_always: %s\\n\"",
            "p"
          ],
          "line": 5184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"uinput_always:\""
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "get_uinput_always()"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uinput_always",
          "args": [],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "get_uinput_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "590-592",
          "snippet": "int get_uinput_always(void) {\n\treturn uinput_always;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_uinput_always();",
            "static int uinput_always = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_always();\nstatic int uinput_always = 0;\n\nint get_uinput_always(void) {\n\treturn uinput_always;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"uinput_always:\""
          ],
          "line": 5177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"uinput_always\""
          ],
          "line": 5176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_reset",
          "args": [
            "atoi(p)"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "563-566",
          "snippet": "void set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_reset(int ms);",
            "static double zero_delay = 0.15;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_reset(int ms);\nstatic double zero_delay = 0.15;\n\nvoid set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_reset: %s\\n\"",
            "p"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"uinput_reset:\""
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "get_uinput_reset()"
          ],
          "line": 5167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uinput_reset",
          "args": [],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "get_uinput_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "586-588",
          "snippet": "int get_uinput_reset(void) {\n\treturn (int) (1000 * zero_delay);\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_uinput_reset();",
            "static double zero_delay = 0.15;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_reset();\nstatic double zero_delay = 0.15;\n\nint get_uinput_reset(void) {\n\treturn (int) (1000 * zero_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"uinput_reset:\""
          ],
          "line": 5165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"uinput_reset\""
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_thresh",
          "args": [
            "p"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "550-561",
          "snippet": "int set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_uinput_accel(char *str);",
            "int set_uinput_thresh(char *str);",
            "void parse_uinput_str(char *str);",
            "static int thresh = 5;",
            "static int thresh_or = 1;",
            "static char *uinput_thresh_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic int thresh = 5;\nstatic int thresh_or = 1;\nstatic char *uinput_thresh_str = NULL;\n\nint set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_thresh: %s\\n\"",
            "p"
          ],
          "line": 5160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"uinput_thresh:\""
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(get_uinput_thresh())"
          ],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "get_uinput_thresh()"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uinput_thresh",
          "args": [],
          "line": 5156
        },
        "resolved": true,
        "details": {
          "function_name": "get_uinput_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "583-585",
          "snippet": "char *get_uinput_thresh(void) {\n\treturn uinput_thresh_str;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_uinput_thresh();",
            "static char *uinput_thresh_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *get_uinput_thresh();\nstatic char *uinput_thresh_str = NULL;\n\nchar *get_uinput_thresh(void) {\n\treturn uinput_thresh_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"uinput_thresh:\""
          ],
          "line": 5153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"uinput_thresh\""
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_accel",
          "args": [
            "p"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_accel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "532-548",
          "snippet": "int set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_uinput_accel(char *str);",
            "int set_uinput_thresh(char *str);",
            "void parse_uinput_str(char *str);",
            "static void set_uinput_accel_xy(double fx, double fy);",
            "static char *uinput_accel_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic char *uinput_accel_str = NULL;\n\nint set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_accel: %s\\n\"",
            "p"
          ],
          "line": 5148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"uinput_accel:\""
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(get_uinput_accel())"
          ],
          "line": 5143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "get_uinput_accel()"
          ],
          "line": 5144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uinput_accel",
          "args": [],
          "line": 5144
        },
        "resolved": true,
        "details": {
          "function_name": "get_uinput_accel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "580-582",
          "snippet": "char *get_uinput_accel(void) {\n\treturn uinput_accel_str;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_uinput_accel();",
            "static char *uinput_accel_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *get_uinput_accel();\nstatic char *uinput_accel_str = NULL;\n\nchar *get_uinput_accel(void) {\n\treturn uinput_accel_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"uinput_accel:\""
          ],
          "line": 5141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"uinput_accel\""
          ],
          "line": 5140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 5136
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"hang on tight, here we go...\\n\""
          ],
          "line": 5134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_raw_fb_params",
          "args": [
            "1"
          ],
          "line": 5132
        },
        "resolved": true,
        "details": {
          "function_name": "set_raw_fb_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "607-756",
          "snippet": "void set_raw_fb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int vo0, us0, sm0, ws0, wp0, wc0, wb0, na0, tn0;  \n\tstatic int xr0, xrm0, sb0, re0;\n\tstatic char *mc0;\n\n\t/*\n\t * set turn off a bunch of parameters not compatible with \n\t * -rawfb mode: 1) ignoring the X server 2) ignoring user input. \n\t */\n\t\n\tif (first) {\n\t\t/* at least save the initial settings... */\n\t\tvo0 = view_only;\n\t\tws0 = watch_selection;\n\t\twp0 = watch_primary;\n\t\twc0 = watch_clipboard;\n\t\twb0 = watch_bell;\n\t\tna0 = no_autorepeat;\n\t\tsb0 = use_solid_bg;\n\n\t\tus0 = use_snapfb;\n\t\tsm0 = using_shm;\n\t\ttn0 = take_naps;\n\t\txr0 = xrandr;\n\t\txrm0 = xrandr_maybe;\n\t\tre0 = noxrecord;\n\t\tmc0 = multiple_cursors_mode;\n\n\t\tfirst = 0;\n\t}\n\n\tif (restore) {\n\t\tview_only = vo0;\n\t\twatch_selection = ws0;\n\t\twatch_primary = wp0;\n\t\twatch_clipboard = wc0;\n\t\twatch_bell = wb0;\n\t\tno_autorepeat = na0;\n\t\tuse_solid_bg = sb0;\n\n\t\tuse_snapfb = us0;\n\t\tusing_shm = sm0;\n\t\ttake_naps = tn0;\n\t\txrandr = xr0;\n\t\txrandr_maybe = xrm0;\n\t\tnoxrecord = re0;\n\t\tmultiple_cursors_mode = mc0;\n\n\t\tif (! dpy && raw_fb_orig_dpy) {\n\t\t\tdpy = XOpenDisplay_wr(raw_fb_orig_dpy);\n\t\t\tlast_open_xdisplay = time(NULL);\n\t\t\tif (dpy) {\n\t\t\t\tif (! quiet) rfbLog(\"reopened DISPLAY: %s\\n\",\n\t\t\t\t    raw_fb_orig_dpy);\n\t\t\t\tscr = DefaultScreen(dpy);\n\t\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\t\tcheck_xevents(1);\n\t\t\t} else {\n\t\t\t\tif (! quiet) rfbLog(\"WARNING: failed to reopen \"\n\t\t\t\t    \"DISPLAY: %s\\n\", raw_fb_orig_dpy);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"set_raw_fb_params: modifying settings for \"\n\t\t    \"-rawfb mode.\\n\");\n\t}\n\n\tif (got_noviewonly) {\n\t\t/*\n\t\t * The user input parameters are not unset under\n\t\t * -noviewonly... this usage should be very rare\n\t\t * (i.e. rawfb but also send user input to the X\n\t\t * display, most likely using /dev/fb0 for some reason...)\n\t\t */\n\t\tif (verbose) {\n\t\t   rfbLog(\"rawfb: -noviewonly mode: still sending mouse and\\n\");\n\t\t   rfbLog(\"rawfb:   keyboard input to the X DISPLAY!!\\n\");\n\t\t}\n\t} else {\n\t\t/* Normal case: */\n#if 0\n\t\tif (! view_only && ! pipeinput_str) {\n\t\t\tif (! quiet) rfbLog(\"  rawfb: setting view_only\\n\");\n\t\t\tview_only = 1;\n\t\t}\n#endif\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else if (watch_selection) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_selection\\n\");\n\t\t\twatch_selection = 0;\n\t\t}\n\t\tif (watch_primary) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_primary\\n\");\n\t\t\twatch_primary = 0;\n\t\t}\n\t\tif (watch_clipboard) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_clipboard\\n\");\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (watch_bell) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off watch_bell\\n\");\n\t\t\twatch_bell = 0;\n\t\t}\n\t\tif (no_autorepeat) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"no_autorepeat\\n\");\n\t\t\tno_autorepeat = 0;\n\t\t}\n\t\tif (use_solid_bg) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"use_solid_bg\\n\");\n\t\t\tuse_solid_bg = 0;\n\t\t}\n#ifndef MACOSX\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else {\n\t\t\tmultiple_cursors_mode = strdup(\"arrow\");\n\t\t}\n#endif\n\t}\n\tif (using_shm) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off using_shm\\n\");\n\t\tusing_shm = 0;\n\t}\n\tif (take_naps) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off take_naps\\n\");\n\t\ttake_naps = 0;\n\t}\n\tif (xrandr) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr\\n\");\n\t\txrandr = 0;\n\t}\n\tif (xrandr_maybe) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr_maybe\\n\");\n\t\txrandr_maybe = 0;\n\t}\n\tif (! noxrecord) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrecord\\n\");\n\t\tnoxrecord = 1;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_nofb_params(int restore);",
            "void set_raw_fb_params(int restore);",
            "int parse_rotate_string(char *str, int *mode);",
            "static char *raw_fb_orig_dpy = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_nofb_params(int restore);\nvoid set_raw_fb_params(int restore);\nint parse_rotate_string(char *str, int *mode);\nstatic char *raw_fb_orig_dpy = NULL;\n\nvoid set_raw_fb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int vo0, us0, sm0, ws0, wp0, wc0, wb0, na0, tn0;  \n\tstatic int xr0, xrm0, sb0, re0;\n\tstatic char *mc0;\n\n\t/*\n\t * set turn off a bunch of parameters not compatible with \n\t * -rawfb mode: 1) ignoring the X server 2) ignoring user input. \n\t */\n\t\n\tif (first) {\n\t\t/* at least save the initial settings... */\n\t\tvo0 = view_only;\n\t\tws0 = watch_selection;\n\t\twp0 = watch_primary;\n\t\twc0 = watch_clipboard;\n\t\twb0 = watch_bell;\n\t\tna0 = no_autorepeat;\n\t\tsb0 = use_solid_bg;\n\n\t\tus0 = use_snapfb;\n\t\tsm0 = using_shm;\n\t\ttn0 = take_naps;\n\t\txr0 = xrandr;\n\t\txrm0 = xrandr_maybe;\n\t\tre0 = noxrecord;\n\t\tmc0 = multiple_cursors_mode;\n\n\t\tfirst = 0;\n\t}\n\n\tif (restore) {\n\t\tview_only = vo0;\n\t\twatch_selection = ws0;\n\t\twatch_primary = wp0;\n\t\twatch_clipboard = wc0;\n\t\twatch_bell = wb0;\n\t\tno_autorepeat = na0;\n\t\tuse_solid_bg = sb0;\n\n\t\tuse_snapfb = us0;\n\t\tusing_shm = sm0;\n\t\ttake_naps = tn0;\n\t\txrandr = xr0;\n\t\txrandr_maybe = xrm0;\n\t\tnoxrecord = re0;\n\t\tmultiple_cursors_mode = mc0;\n\n\t\tif (! dpy && raw_fb_orig_dpy) {\n\t\t\tdpy = XOpenDisplay_wr(raw_fb_orig_dpy);\n\t\t\tlast_open_xdisplay = time(NULL);\n\t\t\tif (dpy) {\n\t\t\t\tif (! quiet) rfbLog(\"reopened DISPLAY: %s\\n\",\n\t\t\t\t    raw_fb_orig_dpy);\n\t\t\t\tscr = DefaultScreen(dpy);\n\t\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\t\tcheck_xevents(1);\n\t\t\t} else {\n\t\t\t\tif (! quiet) rfbLog(\"WARNING: failed to reopen \"\n\t\t\t\t    \"DISPLAY: %s\\n\", raw_fb_orig_dpy);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"set_raw_fb_params: modifying settings for \"\n\t\t    \"-rawfb mode.\\n\");\n\t}\n\n\tif (got_noviewonly) {\n\t\t/*\n\t\t * The user input parameters are not unset under\n\t\t * -noviewonly... this usage should be very rare\n\t\t * (i.e. rawfb but also send user input to the X\n\t\t * display, most likely using /dev/fb0 for some reason...)\n\t\t */\n\t\tif (verbose) {\n\t\t   rfbLog(\"rawfb: -noviewonly mode: still sending mouse and\\n\");\n\t\t   rfbLog(\"rawfb:   keyboard input to the X DISPLAY!!\\n\");\n\t\t}\n\t} else {\n\t\t/* Normal case: */\n#if 0\n\t\tif (! view_only && ! pipeinput_str) {\n\t\t\tif (! quiet) rfbLog(\"  rawfb: setting view_only\\n\");\n\t\t\tview_only = 1;\n\t\t}\n#endif\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else if (watch_selection) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_selection\\n\");\n\t\t\twatch_selection = 0;\n\t\t}\n\t\tif (watch_primary) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_primary\\n\");\n\t\t\twatch_primary = 0;\n\t\t}\n\t\tif (watch_clipboard) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_clipboard\\n\");\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (watch_bell) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off watch_bell\\n\");\n\t\t\twatch_bell = 0;\n\t\t}\n\t\tif (no_autorepeat) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"no_autorepeat\\n\");\n\t\t\tno_autorepeat = 0;\n\t\t}\n\t\tif (use_solid_bg) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"use_solid_bg\\n\");\n\t\t\tuse_solid_bg = 0;\n\t\t}\n#ifndef MACOSX\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else {\n\t\t\tmultiple_cursors_mode = strdup(\"arrow\");\n\t\t}\n#endif\n\t}\n\tif (using_shm) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off using_shm\\n\");\n\t\tusing_shm = 0;\n\t}\n\tif (take_naps) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off take_naps\\n\");\n\t\ttake_naps = 0;\n\t}\n\tif (xrandr) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr\\n\");\n\t\txrandr = 0;\n\t}\n\tif (xrandr_maybe) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr_maybe\\n\");\n\t\txrandr_maybe = 0;\n\t}\n\tif (! noxrecord) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrecord\\n\");\n\t\tnoxrecord = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restoring per-rawfb settings...\\n\""
          ],
          "line": 5131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "raw_fb_fd"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "raw_fb_addr",
            "raw_fb_mmap"
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\"",
            "p"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unsafe rawfb setup: %s\\n\"",
            "p"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"setup:\""
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 5106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rawfb:\""
          ],
          "line": 5104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(raw_fb_str)"
          ],
          "line": 5100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "raw_fb_str"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"rawfb:\""
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rawfb\""
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off snapfb mode.\\n\""
          ],
          "line": 5089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_snapfb"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosnapfb\""
          ],
          "line": 5083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on snapfb mode.\\n\""
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_snapfb"
          ],
          "line": 5073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"snapfb\""
          ],
          "line": 5070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting tile_fuzz %d -> %d.\\n\"",
            "tile_fuzz",
            "f"
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"fuzz:\""
          ],
          "line": 5062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "tile_fuzz"
          ],
          "line": 5059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"fuzz:\""
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"fuzz\""
          ],
          "line": 5055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting grow_fill %d -> %d.\\n\"",
            "grow_fill",
            "g"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"grow:\""
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "grow_fill"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"grow:\""
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"grow\""
          ],
          "line": 5040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting gaps_fill %d -> %d.\\n\"",
            "gaps_fill",
            "g"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 5033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"gaps:\""
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "gaps_fill"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"gaps:\""
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"gaps\""
          ],
          "line": 5025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -fs frac to %f\\n\"",
            "fs_frac"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"fs:\""
          ],
          "line": 5020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%f\"",
            "p",
            "co",
            "fs_frac"
          ],
          "line": 5017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"fs:\""
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"fs\""
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_text_chat",
          "args": [
            "NULL",
            "rfbTextChatFinished",
            "\"\""
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "set_text_chat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "2083-2141",
          "snippet": "void set_text_chat(rfbClientPtr cl, int len, char *txt) {\n\tint dochat = 1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl2;\n\tunsigned int ulen = (unsigned int) len;\n\n\tif (no_ultra_ext || ! dochat) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_text_chat: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAS_TEXTCHAT\n\n\tif (chat_window && chat_window_client == NULL && ulen == rfbTextChatOpen) {\n\t\ttry_local_chat_window();\n\t}\n\n\tsaw_ultra_chat = 1;\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl2 = rfbClientIteratorNext(iter)) ) {\n\t\tunsigned int ulen = (unsigned int) len;\n\t\tif (cl2 == cl) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl2->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tSEND_LOCK(cl2);\n\n\t\tif (ulen == rfbTextChatOpen) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatOpen, \"\");\n\t\t} else if (ulen == rfbTextChatClose) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatClose, \"\");\n\t\t\t/* not clear what is going on WRT close and finished... */\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (ulen == rfbTextChatFinished) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (len <= rfbTextMaxSize) {\n\t\t\trfbSendTextChatMessage(cl2, len, txt);\n\t\t}\n\n\t\tSEND_UNLOCK(cl2);\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (ulen == rfbTextChatClose && cl != NULL) {\n\t\t/* not clear what is going on WRT close and finished... */\n\t\tSEND_LOCK(cl);\n\t\trfbSendTextChatMessage(cl, rfbTextChatFinished, \"\");\n\t\tSEND_UNLOCK(cl);\n\t}\n#endif\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xcut_receive(char *text, int len, rfbClientPtr cl);",
            "void kbd_release_all_keys(rfbClientPtr cl);",
            "int get_file_transfer_permitted(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nvoid set_text_chat(rfbClientPtr cl, int len, char *txt) {\n\tint dochat = 1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl2;\n\tunsigned int ulen = (unsigned int) len;\n\n\tif (no_ultra_ext || ! dochat) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_text_chat: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAS_TEXTCHAT\n\n\tif (chat_window && chat_window_client == NULL && ulen == rfbTextChatOpen) {\n\t\ttry_local_chat_window();\n\t}\n\n\tsaw_ultra_chat = 1;\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl2 = rfbClientIteratorNext(iter)) ) {\n\t\tunsigned int ulen = (unsigned int) len;\n\t\tif (cl2 == cl) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl2->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tSEND_LOCK(cl2);\n\n\t\tif (ulen == rfbTextChatOpen) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatOpen, \"\");\n\t\t} else if (ulen == rfbTextChatClose) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatClose, \"\");\n\t\t\t/* not clear what is going on WRT close and finished... */\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (ulen == rfbTextChatFinished) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (len <= rfbTextMaxSize) {\n\t\t\trfbSendTextChatMessage(cl2, len, txt);\n\t\t}\n\n\t\tSEND_UNLOCK(cl2);\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (ulen == rfbTextChatClose && cl != NULL) {\n\t\t/* not clear what is going on WRT close and finished... */\n\t\tSEND_LOCK(cl);\n\t\trfbSendTextChatMessage(cl, rfbTextChatFinished, \"\");\n\t\tSEND_UNLOCK(cl);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning local chat window off.\\n\""
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "(chat_window_client == NULL)"
          ],
          "line": 5006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"chatoff\""
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning local chat window on.\\n\""
          ],
          "line": 4999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "(chat_window_client != NULL)"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"chaton\""
          ],
          "line": 4994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling the local chat window.\\n\""
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!chat_window"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nochatwindow\""
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling the local chat window.\\n\""
          ],
          "line": 4981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "chat_window"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"chatwindow\""
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -noultraext mode.\\n\""
          ],
          "line": 4972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!no_ultra_ext"
          ],
          "line": 4969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ultraext\""
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -noultraext mode.\\n\""
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "no_ultra_ext"
          ],
          "line": 4960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noultraext\""
          ],
          "line": 4958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -noserverdpms mode.\\n\""
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!no_ultra_dpms"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"serverdpms\""
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -noserverdpms mode.\\n\""
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "no_ultra_dpms"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noserverdpms\""
          ],
          "line": 4940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -forcedpms mode.\\n\""
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!force_dpms"
          ],
          "line": 4933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noforcedpms\""
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -forcedpms mode.\\n\""
          ],
          "line": 4927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "force_dpms"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"forcedpms\""
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -clientdpms mode.\\n\""
          ],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!client_dpms"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noclientdpms\""
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -clientdpms mode.\\n\""
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "client_dpms"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clientdpms\""
          ],
          "line": 4904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -nodpms mode.\\n\""
          ],
          "line": 4900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_dpms"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodpms\""
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -nodpms mode.\\n\""
          ],
          "line": 4891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_dpms"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dpms\""
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -nofbpm mode.\\n\""
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_fbpm"
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nofbpm\""
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -nofbpm mode.\\n\""
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_fbpm"
          ],
          "line": 4870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"fbpm\""
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting screen_blank %d -> %d sec.\\n\"",
            "screen_blank",
            "w"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"screen_blank:\""
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "screen_blank"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"screen_blank:\""
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"screen_blank\""
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting screen_blank %d -> %d sec.\\n\"",
            "screen_blank",
            "w"
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sb:\""
          ],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "screen_blank"
          ],
          "line": 4842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"sb:\""
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sb\""
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off nap mode.\\n\""
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!take_naps"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nonap\""
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on nap mode.\\n\""
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "take_naps"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nap\""
          ],
          "line": 4820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\"",
            "orig",
            "w"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"readtimeout:\""
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "rfbMaxClientWait/1000"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"readtimeout:\""
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"readtimeout\""
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting wait %d -> %d ms.\\n\"",
            "waitms",
            "w"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wait:\""
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "waitms"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wait:\""
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wait\""
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\"",
            "xrefresh",
            "w"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"xrefresh:\""
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%.2f\"",
            "p",
            "co",
            "xrefresh"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"xrefresh:\""
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xrefresh\""
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\"",
            "slow_fb",
            "w"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"slow_fb:\""
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%.2f\"",
            "p",
            "co",
            "slow_fb"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"slow_fb:\""
          ],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"slow_fb\""
          ],
          "line": 4760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting wait_bog to %d\\n\"",
            "wait_bog"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!wait_bog"
          ],
          "line": 4753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowait_bog\""
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting wait_bog to %d\\n\"",
            "wait_bog"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "wait_bog"
          ],
          "line": 4744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wait_bog\""
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\"",
            "wait_ui",
            "w"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wait_ui:\""
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%.2f\"",
            "p",
            "co",
            "wait_ui"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wait_ui:\""
          ],
          "line": 4729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wait_ui\""
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting extra_fbur to %d\\n\"",
            "extra_fbur"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"extra_fbur:\""
          ],
          "line": 4722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "extra_fbur"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"extra_fbur:\""
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"extra_fbur\""
          ],
          "line": 4716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting set_defer to %d\\n\"",
            "set_defer"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"setdefer:\""
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "set_defer"
          ],
          "line": 4708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"setdefer:\""
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"setdefer\""
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting defer to %d ms.\\n\"",
            "d"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"defer:\""
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "d"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"defer:\""
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"defer\""
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting defer to %d ms.\\n\"",
            "d"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"deferupdate:\""
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "d"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"deferupdate:\""
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"deferupdate\""
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=bcx_xattach:%s:%s\"",
            "p",
            "res"
          ],
          "line": 4656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "4*500*1000"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "try*400*1000"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointer_event",
          "args": [
            "0",
            "dpy_x/2 + try",
            "dpy_y/2 + try",
            "NULL"
          ],
          "line": 4633
        },
        "resolved": true,
        "details": {
          "function_name": "pointer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "700-1005",
          "snippet": "void pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int pointer_queued_sent = 0;",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint pointer_queued_sent = 0;\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\"",
            "p",
            "res",
            "try"
          ],
          "line": 4631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "res",
            "\"GRAB_FAIL\""
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\"",
            "p",
            "res"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "res",
            "\"GRAB_FAIL_INIT\""
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"NULL\""
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcx_xattach",
          "args": [
            "p",
            "&pg_init",
            "&kg_init"
          ],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "bcx_xattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3239-3522",
          "snippet": "char *bcx_xattach(char *str, int *pg_init, int *kg_init) {\n\tint grab_check = 1;\n\tint shift = 20;\n\tint final_x = 30, final_y = 30;\n\tint extra_x = -1, extra_y = -1;\n\tint t1, t2, dt = 40 * 1000;\n\tint ifneeded = 0;\n\tchar *dir = \"none\", *flip = \"none\", *q;\n\tint pg1, kg1, pg2, kg2;\n\tchar _bcx_res[128];\n\t\n\t/* str:[up,down,left,right]+nograbcheck+shift=n+final=x+y+extra_move=x+y+[master_to_slave,slave_to_master,M2S,S2M]+dt=n+retry=n+ifneeded */\n\n\tif (strstr(str, \"up\")) {\n\t\tdir = \"up\";\n\t} else if (strstr(str, \"down\")) {\n\t\tdir = \"down\";\n\t} else if (strstr(str, \"left\")) {\n\t\tdir = \"left\";\n\t} else if (strstr(str, \"right\")) {\n\t\tdir = \"right\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_DIRECTION_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"master_to_slave\") || strstr(str, \"M2S\")) {\n\t\tflip = \"M2S\";\n\t} else if (strstr(str, \"slave_to_master\") || strstr(str, \"S2M\")) {\n\t\tflip = \"S2M\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_MODE_CHANGE_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"nograbcheck\")) {\n\t\tgrab_check = 0;\n\t}\n\tif (strstr(str, \"ifneeded\")) {\n\t\tifneeded = 1;\n\t}\n\tq = strstr(str, \"shift=\");\n\tif (q && sscanf(q, \"shift=%d\", &t1) == 1) {\n\t\tshift = t1;\n\t}\n\tq = strstr(str, \"final=\");\n\tif (q && sscanf(q, \"final=%d+%d\", &t1, &t2) == 2) {\n\t\tfinal_x = t1;\n\t\tfinal_y = t2;\n\t}\n\tq = strstr(str, \"extra_move=\");\n\tif (q && sscanf(q, \"extra_move=%d+%d\", &t1, &t2) == 2) {\n\t\textra_x = t1;\n\t\textra_y = t2;\n\t}\n\tq = strstr(str, \"dt=\");\n\tif (q && sscanf(q, \"dt=%d\", &t1) == 1) {\n\t\tdt = t1 * 1000;\n\t}\n\n\tif (grab_check) {\n\t\tint read_init = 0;\n\n\t\tif (*pg_init >=0 && *kg_init >=0)  {\n\t\t\tpg1 = *pg_init;\n\t\t\tkg1 = *kg_init;\n\t\t\tread_init = 1;\n\t\t} else {\n\t\t\tgrab_state(&pg1, &kg1);\n\t\t\tread_init = 0;\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (ifneeded && pg1 == 1 && kg1 == 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (ifneeded && pg1 == 0 && kg1 == 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t}\n\n\t\tif (read_init) {\n\t\t\t;\n\t\t} else if (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 != 0 || kg1 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 != 1 || kg1 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t}\n\t\tif (!read_init) {\n\t\t\t*pg_init = pg1;\n\t\t\t*kg_init = kg1;\n\t\t}\n\t}\n\n\t/*\n\t * A guide for BARCO xattach:\n\t *\n\t *   For -cursor_rule 'b(0):%:t(1),t(1):%:b(0)'\n\t *\tdown+M2S  up+S2M\n\t *   For -cursor_rule 'r(0):%:l(1),l(1):%:r(0)'\n\t *\tright+M2S  left+S2M\n\t *\n\t *   For -cursor_rule 't(0):%:b(1),b(1):%:t(0)'\n\t *\tup+M2S  down+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0)'\n\t *\tleft+M2S  right+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0),r(0):%:l(1),l(1):%:r(0)'\n\t *\tleft+M2S  right+S2M  (we used to do both 'right')\n\t */\n\n\tif (!strcmp(flip, \"M2S\")) {\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 0);\t\t/* go to top edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-1);\t/* go to bottom edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(0, shift);\t\t/* go to left edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-1, shift);\t\t/* go to right edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for Motion Notify  */\n\t\t}\n\t} else if (!strcmp(flip, \"S2M\")) {\n\t\tint dts = dt/2;\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 2);\t\t/* Approach top edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 0);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* go to height-2 for extra pixel (slave y now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* go to 1 to be sure slave y == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-3);\t/* Approach bottom edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-1);\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* go to 1 for extra pixel (slave y now == dpy_y-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* go to dpy_y-2 to be sure slave y == dpy_y-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(2, shift);\t\t/* Approach left edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* go to width-2 for extra pixel (slave x now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* go to 1 to be sure slave x == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-3, shift);\t\t/* Approach right edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* go to 1 to extra pixel (slave x now == dpy_x-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* go to dpy_x-2 to be sure slave x == dpy_x-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* move 1 for MotionNotify */\n\t\t}\n\t}\n\n\tusleep(dt);\n\tpmove(final_x, final_y);\n\tusleep(dt);\n\n\tif (extra_x >= 0 && extra_y >= 0) {\n\t\tpmove(extra_x, extra_y);\n\t\tusleep(dt);\n\t}\n\n\tstrcpy(_bcx_res, \"DONE\");\n\n\tif (grab_check) {\n\t\tchar st[64];\n\n\t\tusleep(3*dt);\n\t\tgrab_state(&pg2, &kg2);\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg2 != 1 || kg2 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg2 != 0 || kg2 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t}\n\n\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\n\t\tif (getenv(\"GRAB_CHECK_LOOP\")) {\n\t\t\tint i, n = atoi(getenv(\"GRAB_CHECK_LOOP\"));\n\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tusleep(dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\t\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 == 0 && kg1 == 0 && pg2 == 1 && kg2 == 1) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 1 && kg2 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 0 && kg1 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 == 1 && kg1 == 1 && pg2 == 0 && kg2 == 0) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 0 && kg2 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 1 && kg1 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup(_bcx_res);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "char *bcx_xattach(char *str, int *pg_init, int *kg_init);",
            "static rfbClientPtr *client_match(char *str);",
            "static void ugly_geom(char *p, int *x, int *y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nchar *bcx_xattach(char *str, int *pg_init, int *kg_init);\nstatic rfbClientPtr *client_match(char *str);\nstatic void ugly_geom(char *p, int *x, int *y);\n\nchar *bcx_xattach(char *str, int *pg_init, int *kg_init) {\n\tint grab_check = 1;\n\tint shift = 20;\n\tint final_x = 30, final_y = 30;\n\tint extra_x = -1, extra_y = -1;\n\tint t1, t2, dt = 40 * 1000;\n\tint ifneeded = 0;\n\tchar *dir = \"none\", *flip = \"none\", *q;\n\tint pg1, kg1, pg2, kg2;\n\tchar _bcx_res[128];\n\t\n\t/* str:[up,down,left,right]+nograbcheck+shift=n+final=x+y+extra_move=x+y+[master_to_slave,slave_to_master,M2S,S2M]+dt=n+retry=n+ifneeded */\n\n\tif (strstr(str, \"up\")) {\n\t\tdir = \"up\";\n\t} else if (strstr(str, \"down\")) {\n\t\tdir = \"down\";\n\t} else if (strstr(str, \"left\")) {\n\t\tdir = \"left\";\n\t} else if (strstr(str, \"right\")) {\n\t\tdir = \"right\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_DIRECTION_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"master_to_slave\") || strstr(str, \"M2S\")) {\n\t\tflip = \"M2S\";\n\t} else if (strstr(str, \"slave_to_master\") || strstr(str, \"S2M\")) {\n\t\tflip = \"S2M\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_MODE_CHANGE_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"nograbcheck\")) {\n\t\tgrab_check = 0;\n\t}\n\tif (strstr(str, \"ifneeded\")) {\n\t\tifneeded = 1;\n\t}\n\tq = strstr(str, \"shift=\");\n\tif (q && sscanf(q, \"shift=%d\", &t1) == 1) {\n\t\tshift = t1;\n\t}\n\tq = strstr(str, \"final=\");\n\tif (q && sscanf(q, \"final=%d+%d\", &t1, &t2) == 2) {\n\t\tfinal_x = t1;\n\t\tfinal_y = t2;\n\t}\n\tq = strstr(str, \"extra_move=\");\n\tif (q && sscanf(q, \"extra_move=%d+%d\", &t1, &t2) == 2) {\n\t\textra_x = t1;\n\t\textra_y = t2;\n\t}\n\tq = strstr(str, \"dt=\");\n\tif (q && sscanf(q, \"dt=%d\", &t1) == 1) {\n\t\tdt = t1 * 1000;\n\t}\n\n\tif (grab_check) {\n\t\tint read_init = 0;\n\n\t\tif (*pg_init >=0 && *kg_init >=0)  {\n\t\t\tpg1 = *pg_init;\n\t\t\tkg1 = *kg_init;\n\t\t\tread_init = 1;\n\t\t} else {\n\t\t\tgrab_state(&pg1, &kg1);\n\t\t\tread_init = 0;\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (ifneeded && pg1 == 1 && kg1 == 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (ifneeded && pg1 == 0 && kg1 == 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t}\n\n\t\tif (read_init) {\n\t\t\t;\n\t\t} else if (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 != 0 || kg1 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 != 1 || kg1 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t}\n\t\tif (!read_init) {\n\t\t\t*pg_init = pg1;\n\t\t\t*kg_init = kg1;\n\t\t}\n\t}\n\n\t/*\n\t * A guide for BARCO xattach:\n\t *\n\t *   For -cursor_rule 'b(0):%:t(1),t(1):%:b(0)'\n\t *\tdown+M2S  up+S2M\n\t *   For -cursor_rule 'r(0):%:l(1),l(1):%:r(0)'\n\t *\tright+M2S  left+S2M\n\t *\n\t *   For -cursor_rule 't(0):%:b(1),b(1):%:t(0)'\n\t *\tup+M2S  down+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0)'\n\t *\tleft+M2S  right+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0),r(0):%:l(1),l(1):%:r(0)'\n\t *\tleft+M2S  right+S2M  (we used to do both 'right')\n\t */\n\n\tif (!strcmp(flip, \"M2S\")) {\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 0);\t\t/* go to top edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-1);\t/* go to bottom edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(0, shift);\t\t/* go to left edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-1, shift);\t\t/* go to right edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for Motion Notify  */\n\t\t}\n\t} else if (!strcmp(flip, \"S2M\")) {\n\t\tint dts = dt/2;\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 2);\t\t/* Approach top edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 0);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* go to height-2 for extra pixel (slave y now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* go to 1 to be sure slave y == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-3);\t/* Approach bottom edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-1);\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* go to 1 for extra pixel (slave y now == dpy_y-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* go to dpy_y-2 to be sure slave y == dpy_y-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(2, shift);\t\t/* Approach left edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* go to width-2 for extra pixel (slave x now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* go to 1 to be sure slave x == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-3, shift);\t\t/* Approach right edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* go to 1 to extra pixel (slave x now == dpy_x-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* go to dpy_x-2 to be sure slave x == dpy_x-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* move 1 for MotionNotify */\n\t\t}\n\t}\n\n\tusleep(dt);\n\tpmove(final_x, final_y);\n\tusleep(dt);\n\n\tif (extra_x >= 0 && extra_y >= 0) {\n\t\tpmove(extra_x, extra_y);\n\t\tusleep(dt);\n\t}\n\n\tstrcpy(_bcx_res, \"DONE\");\n\n\tif (grab_check) {\n\t\tchar st[64];\n\n\t\tusleep(3*dt);\n\t\tgrab_state(&pg2, &kg2);\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg2 != 1 || kg2 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg2 != 0 || kg2 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t}\n\n\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\n\t\tif (getenv(\"GRAB_CHECK_LOOP\")) {\n\t\t\tint i, n = atoi(getenv(\"GRAB_CHECK_LOOP\"));\n\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tusleep(dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\t\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 == 0 && kg1 == 0 && pg2 == 1 && kg2 == 1) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 1 && kg2 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 0 && kg1 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 == 1 && kg1 == 1 && pg2 == 0 && kg2 == 0) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 0 && kg2 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 1 && kg1 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup(_bcx_res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"retry=%d\"",
            "&n"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"retry=\""
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"retry=\""
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"bcx_xattach:\""
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:N/A\"",
            "p"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"bcx_xattach:\""
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"bcx_xattach\""
          ],
          "line": 4600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=wininfo:%s%s:%s\"",
            "t",
            "p",
            "res"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"NULL\""
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wininfo",
          "args": [
            "win",
            "show_children"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "wininfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3617-3680",
          "snippet": "char *wininfo(Window win, int show_children) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!win || !show_children) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tint n, size = X11VNC_REMOTE_MAX;\n\tchar get_str[X11VNC_REMOTE_MAX+1];\n\tunsigned int nchildren;\n\tWindow rr, pr, *children; \n\n\tRAWFB_RET(NULL)\n\n\tif (win == None) {\n\t\treturn strdup(\"None\");\n\t}\n\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn strdup(\"Invalid\");\n\t}\n\tget_str[0] = '\\0';\n\n\tif (show_children) {\n\t\tXQueryTree_wr(dpy, win, &rr, &pr, &children, &nchildren);\n\t} else {\n\t\tnchildren = 1;\n\t\tchildren = (Window *) calloc(2 * sizeof(Window), 1);\n\t\tchildren[0] = win;\n\t}\n\tfor (n=0; n < (int) nchildren; n++) {\n\t\tchar tmp[32];\n\t\tchar *str = \"Invalid\";\n\t\tWindow w = children[n];\n\t\tif (valid_window(w, &attr, 1)) {\n\t\t\tif (!show_children) {\n\t\t\t\tstr = win_fmt(w, attr);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"0x%lx\", w);\n\t\t\t\tstr = tmp;\n\t\t\t}\n\t\t}\n\t\tif ((int) (strlen(get_str) + 1 + strlen(str)) >= size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n > 0) {\n\t\t\tstrcat(get_str, \",\");\n\t\t}\n\t\tstrcat(get_str, str);\n\t}\n\tget_str[size] = '\\0';\n\tif (!show_children) {\n\t\tfree(children);\n\t} else if (nchildren) {\n\t\tXFree_wr(children);\n\t}\n\trfbLog(\"wininfo computed: %s\\n\", get_str);\n\tX_UNLOCK;\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "char *get_xprop(char *prop, Window win);",
            "char *wininfo(Window win, int show_children);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nchar *get_xprop(char *prop, Window win);\nchar *wininfo(Window win, int show_children);\nstatic rfbClientPtr *client_match(char *str);\n\nchar *wininfo(Window win, int show_children) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!win || !show_children) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tint n, size = X11VNC_REMOTE_MAX;\n\tchar get_str[X11VNC_REMOTE_MAX+1];\n\tunsigned int nchildren;\n\tWindow rr, pr, *children; \n\n\tRAWFB_RET(NULL)\n\n\tif (win == None) {\n\t\treturn strdup(\"None\");\n\t}\n\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn strdup(\"Invalid\");\n\t}\n\tget_str[0] = '\\0';\n\n\tif (show_children) {\n\t\tXQueryTree_wr(dpy, win, &rr, &pr, &children, &nchildren);\n\t} else {\n\t\tnchildren = 1;\n\t\tchildren = (Window *) calloc(2 * sizeof(Window), 1);\n\t\tchildren[0] = win;\n\t}\n\tfor (n=0; n < (int) nchildren; n++) {\n\t\tchar tmp[32];\n\t\tchar *str = \"Invalid\";\n\t\tWindow w = children[n];\n\t\tif (valid_window(w, &attr, 1)) {\n\t\t\tif (!show_children) {\n\t\t\t\tstr = win_fmt(w, attr);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"0x%lx\", w);\n\t\t\t\tstr = tmp;\n\t\t\t}\n\t\t}\n\t\tif ((int) (strlen(get_str) + 1 + strlen(str)) >= size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n > 0) {\n\t\t\tstrcat(get_str, \",\");\n\t\t}\n\t\tstrcat(get_str, str);\n\t}\n\tget_str[size] = '\\0';\n\tif (!show_children) {\n\t\tfree(children);\n\t} else if (nchildren) {\n\t\tXFree_wr(children);\n\t}\n\trfbLog(\"wininfo computed: %s\\n\", get_str);\n\tX_UNLOCK;\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"root\""
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wininfo:\""
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:N/A\"",
            "p"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wininfo:\""
          ],
          "line": 4574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wininfo\""
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=set_xprop:%s:%d\"",
            "p",
            "rc"
          ],
          "line": 4562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_xprop",
          "args": [
            "p",
            "win",
            "q+1"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "set_xprop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3524-3549",
          "snippet": "int set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_xprop(char *prop, Window win);",
            "int set_xprop(char *prop, Window win, char *value);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\nstatic int action_match(char *action, int rc);\n\nint set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id=\""
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"id=\""
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"set_xprop:\""
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:N/A\"",
            "p"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"set_xprop:\""
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"set_xprop\""
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=get_xprop:%s:%s\"",
            "p",
            "res"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"NULL\""
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xprop",
          "args": [
            "p",
            "win"
          ],
          "line": 4523
        },
        "resolved": true,
        "details": {
          "function_name": "get_xprop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3551-3605",
          "snippet": "char *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "char *get_xprop(char *prop, Window win);",
            "int set_xprop(char *prop, Window win, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\n\nchar *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id=\""
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"id=\""
          ],
          "line": 4513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"get_xprop:\""
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:N/A\"",
            "p"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"get_xprop:\""
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"get_xprop\""
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: done sleeping.\\n\""
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(int) (1.0e+6 * atof(p))"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: sleeping: %s\\n\"",
            "p"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sleep:\""
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sleep\""
          ],
          "line": 4491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTestFakeButtonEvent_wr",
          "args": [
            "dpy",
            "-1",
            "mb",
            "down ? True : False",
            "CurrentTime"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "XTestFakeButtonEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1046-1108",
          "snippet": "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !button || !is_press || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeButtonEvent_wr(dpy, button, is_press, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"button: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeButtonEvent(%d, %d)  %.4f\\n\",\n\t\t    button, is_press, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        XDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceButtonEvent(dpy, &xdev, button, is_press, NULL, 0, delay);\t  \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeButtonEvent(dpy, button, is_press, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "void XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nvoid XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestDiscard_wr(Display *dpy);\n\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !button || !is_press || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeButtonEvent_wr(dpy, button, is_press, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"button: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeButtonEvent(%d, %d)  %.4f\\n\",\n\t\t    button, is_press, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        XDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceButtonEvent(dpy, &xdev, button, is_press, NULL, 0, delay);\t  \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeButtonEvent(dpy, button, is_press, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\"",
            "mb",
            "down"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d,%d\"",
            "&mb",
            "&down"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: insert fakebuttonevent: %s\\n\"",
            "p"
          ],
          "line": 4480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"fakebuttonevent:\""
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"fakebuttonevent\""
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: bad ptr:x,y,mask\\n\""
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d,%d\"",
            "&x",
            "&y"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d,%d,%d\"",
            "&x",
            "&y",
            "&m"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: insert pointer event: %s\\n\"",
            "p"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ptr:\""
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ptr\""
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyboard",
          "args": [
            "down",
            "ks",
            "NULL"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "keyboard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "3065-3434",
          "snippet": "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tKeyCode k;\n\tint idx, isbutton = 0;\n\tallowed_input_t input;\n\ttime_t now = time(NULL);\n\tdouble tnow;\n\tstatic int skipped_last_down;\n\tstatic rfbBool last_down;\n\tstatic rfbKeySym last_keysym = NoSymbol;\n\tstatic rfbKeySym max_keyrepeat_last_keysym = NoSymbol;\n\tstatic double max_keyrepeat_last_time = 0.0;\n#ifdef MAX_KEYREPEAT\n\tstatic double max_keyrepeat_always = -1.0;\n#endif\n        ClientData *cd = (ClientData *) client->clientData;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tdtime0(&tnow);\n\tgot_keyboard_calls++;\n\n\tif (debug_keyboard) {\n\t\tchar *str;\n\t\tX_LOCK;\n\t\tstr = XKeysymToString((KeySym) keysym);\n\t\tX_UNLOCK;\n\t\trfbLog(\"# keyboard(%s, 0x%x \\\"%s\\\") uip=%d  %.4f\\n\",\n\t\t    down ? \"down\":\"up\", (int) keysym, str ? str : \"null\",\n\t\t    unixpw_in_progress, tnow - x11vnc_start);\n\t}\n\n\tif (keysym <= 0) {\n\t\trfbLog(\"keyboard: skipping 0x0 keysym\\n\");\n\t\treturn;\n\t}\n\t\n\tif (unixpw_in_progress) {\n\t\tif (unixpw_denied) {\n\t\t\trfbLog(\"keyboard: ignoring keystroke 0x%x in \"\n\t\t\t    \"unixpw_denied=1 state\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\t\tif (client != unixpw_client) {\n\t\t\trfbLog(\"keyboard: skipping other client in unixpw\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tunixpw_keystroke(down, keysym, 0);\n\n\t\treturn;\n\t}\n\n\tif (skip_duplicate_key_events) {\n\t\tif (keysym == last_keysym && down == last_down) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"skipping dup key event: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (skip_lockkeys) {\n\t\t/*  we don't handle XK_ISO*_Lock or XK_Kana_Lock ... */\n\t\tif (keysym == XK_Scroll_Lock || keysym == XK_Num_Lock ||\n\t\t    keysym == XK_Caps_Lock || keysym == XK_Shift_Lock) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"skipping lock key event: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (keysym >= XK_KP_0 && keysym <= XK_KP_9) {\n\t\t\t/* ugh this is probably what they meant... assume NumLock. */\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"changed KP digit to regular digit: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\tkeysym = (keysym - XK_KP_0) + XK_0;\n\t\t} else if (keysym == XK_KP_Decimal) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"changed XK_KP_Decimal to XK_period: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\tkeysym = XK_period; \n\t\t}\n\t}\n\n\tINPUT_LOCK;\n\n\tlast_down = down;\n\tlast_keysym = keysym;\n\tlast_keyboard_time = tnow;\n\n\tlast_rfb_down = down;\n\tlast_rfb_keysym = keysym;\n\tlast_rfb_keytime = tnow;\n\tlast_rfb_key_accepted = FALSE;\n\n\tif (key_history_idx == -1) {\n\t\tfor (idx=0; idx<KEY_HIST; idx++) {\n\t\t\tkey_history[idx].sym = NoSymbol;\n\t\t\tkey_history[idx].down = FALSE;\n\t\t\tkey_history[idx].time = 0.0;\n\t\t}\n\t}\n\tidx = ++key_history_idx;\n\tif (key_history_idx >= KEY_HIST) {\n\t\tkey_history_idx = 0;\n\t\tidx = 0;\n\t}\n\tkey_history[idx].sym = keysym;\n\tkey_history[idx].down = down;\n\tkey_history[idx].time = tnow;\n\n\tif (down && (keysym == XK_Alt_L || keysym == XK_Super_L)) {\n\t\tint i, k, run = 0, ups = 0;\n\t\tdouble delay = 1.0;\n\t\tKeySym ks;\n\t\tfor (i=0; i<16; i++) {\n\t\t\tk = idx - i;\n\t\t\tif (k < 0) k += KEY_HIST;\n\t\t\tif (!key_history[k].down) {\n\t\t\t\tups++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tks = key_history[k].sym;\n\t\t\tif (key_history[k].time < tnow - delay) {\n\t\t\t\tbreak;\n\t\t\t} else if (ks == keysym && ks == XK_Alt_L) {\n\t\t\t\trun++;\n\t\t\t} else if (ks == keysym && ks == XK_Super_L) {\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ups < 2) {\n\t\t\t;\n\t\t} else if (run == 3 && keysym == XK_Alt_L) {\n\t\t\trfbLog(\"3*Alt_L, calling: refresh_screen(0)\\n\");\n\t\t\trefresh_screen(0);\n\t\t} else if (run == 4 && keysym == XK_Alt_L) {\n\t\t\trfbLog(\"4*Alt_L, setting: do_copy_screen\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t} else if (run == 5 && keysym == XK_Alt_L) {\n\t\t\t;\n\t\t} else if (run == 3 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"3*Super_L, calling: set_xdamage_mark()\\n\");\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t} else if (run == 4 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"4*Super_L, calling: check_xrecord_reset()\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else if (run == 5 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"5*Super_L, calling: push_black_screen(0)\\n\");\n\t\t\tpush_black_screen(0);\n\t\t}\n\t}\n\n#ifdef MAX_KEYREPEAT \n\tif (max_keyrepeat_always < 0.0) {\n\t\tif (getenv(\"MAX_KEYREPEAT\")) {\n\t\t\tmax_keyrepeat_always = atof(getenv(\"MAX_KEYREPEAT\"));\n\t\t} else {\n\t\t\tmax_keyrepeat_always = 0.0;\n\t\t}\n\t}\n\tif (max_keyrepeat_always > 0.0) {\n\t\tmax_keyrepeat_time = max_keyrepeat_always;\n\t}\n#endif\n\tif (!down && skipped_last_down) {\n\t\tint db = debug_scroll;\n\t\tif (keysym == max_keyrepeat_last_keysym) {\n\t\t\tskipped_last_down = 0;\n\t\t\tif (db) rfbLog(\"--- scroll keyrate skipping 0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (down && max_keyrepeat_time > 0.0) {\n\t\tint skip = 0;\n\t\tint db = debug_scroll;\n\n\t\tif (max_keyrepeat_last_keysym != NoSymbol &&\n\t\t    max_keyrepeat_last_keysym != keysym) {\n\t\t\t;\n\t\t} else {\n\t\t\tif (tnow < max_keyrepeat_last_time+max_keyrepeat_time) {\n\t\t\t\tskip = 1;\n\t\t\t}\n\t\t}\n\t\tmax_keyrepeat_time = 0.0;\n\t\tif (skip) {\n\t\t\tif (db) rfbLog(\"--- scroll keyrate skipping 0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t\tmax_keyrepeat_last_keysym = keysym;\n\t\t\tskipped_last_down = 1;\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (db) rfbLog(\"--- scroll keyrate KEEPING  0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t}\n\t}\n\tmax_keyrepeat_last_keysym = keysym;\n\tmax_keyrepeat_last_time = tnow;\n\tskipped_last_down = 0;\n\tlast_rfb_key_accepted = TRUE;\n\n\tif (pipeinput_fh != NULL || pipeinput_int) {\n\t\tpipe_keyboard(down, keysym, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tlast_keyboard_client = client;\n\t\t\t\tlast_event = last_input = now;\n\t\t\t\tlast_keyboard_input = now;\n\t\t\n\t\t\t\tlast_keysym = keysym;\n\n\t\t\t\tlast_rfb_down = down;\n\t\t\t\tlast_rfb_keysym = keysym;\n\t\t\t\tlast_rfb_keytime = tnow;\n\t\t\t\tlast_rfb_key_injected = dnow();\n\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_keyboard_input++;\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\ttrack_mod_state(keysym, down, TRUE);\t/* ignores remaps */\n\n\tlast_keyboard_client = client;\n\tlast_event = last_input = now;\n\tlast_keyboard_input = now;\n\n\tlast_keysym = keysym;\n\n\tlast_rfb_down = down;\n\tlast_rfb_keysym = keysym;\n\tlast_rfb_keytime = tnow;\n\tlast_rfb_key_injected = dnow();\n\n\tgot_user_input++;\n\tgot_keyboard_input++;\n\t\n\tRAWFB_RET_VOID;\n\n\n\tapply_remap(&keysym, &isbutton);\n\n\tif (use_xrecord && ! xrecording && down) {\n\n\t\tif (!strcmp(scroll_copyrect, \"never\")) {\n\t\t\t;\n\t\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\t\t;\n\t\t} else if (skip_cr_when_scaling(\"scroll\")) {\n\t\t\t;\n\t\t} else if (! xrecord_skip_keysym(keysym)) {\n\t\t\tsnapshot_stack_list(0, 0.25);\n\t\t\txrecord_watch(1, SCR_KEY);\n\t\t\txrecord_set_by_keys = 1;\n\t\t\txrecord_keysym = keysym;\n\t\t} else {\n\t\t\tif (debug_scroll) {\n\t\t\t\tchar *str = XKeysymToString(keysym);\n\t\t\t\trfbLog(\"xrecord_skip_keysym: %s\\n\",\n\t\t\t\t    str ? str : \"NoSymbol\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isbutton) {\n\t\tint mask, button = (int) keysym;\n\t\tchar *b, bstr[32];\n\t\t\n\t\tif (! down) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\t/* nothing to send */\n\t\t}\n\t\tif (debug_keyboard) {\n\t\t\trfbLog(\"keyboard(): remapping keystroke to button %d\"\n\t\t\t    \" click\\n\", button);\n\t\t}\n\t\tdtime0(&last_key_to_button_remap_time);\n\n\t\tX_LOCK;\n\t\t/*\n\t\t * This in principle can be a little dicey... i.e. even\n\t\t * remap the button click to keystroke sequences!\n\t\t * Usually just will simulate the button click.\n\t\t */\n\t\n\t\t/* loop over possible multiclicks: Button123 */\n\t\tsprintf(bstr, \"%d\", button);\n\t\tb = bstr;\n\t\twhile (*b != '\\0') {\n\t\t\tchar t[2];\n\t\t\tint butt;\n\t\t\tt[0] = *b;\n\t\t\tt[1] = '\\0';\n\t\t\tif (sscanf(t, \"%d\", &butt) == 1) {\n\t\t\t\tmask = 1<<(butt-1);\n\t\t\t\tdo_button_mask_change(mask, butt, client);\t/* down */\n\t\t\t\tmask = 0;\n\t\t\t\tdo_button_mask_change(mask, butt, client);\t/* up */\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tif (use_modifier_tweak) {\n\t\tmodifier_tweak_keyboard(down, keysym, client);\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tX_LOCK;\n\n\tk = XKeysymToKeycode(dpy, (KeySym) keysym);\n\n\tif (k == NoSymbol && add_keysyms && ! IsModifierKey(keysym)) {\n\t\tint new_kc = add_keysym(keysym);\n\t\tif (new_kc) {\n\t\t\tk = new_kc;\n\t\t}\n\t}\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(keysym);\n\t\trfbLog(\"keyboard(): KeySym 0x%x \\\"%s\\\" -> KeyCode 0x%x%s\\n\",\n\t\t    (int) keysym, str ? str : \"null\", (int) k,\n\t\t    k ? \"\" : \" *ignored*\");\n\t}\n\n\n\tif ( k != NoSymbol ) {\n               \n XTestFakeKeyEvent_wr(dpy, cd->kbd_id, k, (Bool) down, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t}\n\n\tX_UNLOCK;\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define KEY_HIST 256"
          ],
          "globals_used": [
            "int add_keysym(KeySym keysym);",
            "int sloppy_key_check(int key, rfbBool down, rfbKeySym keysym, int *new_kc);",
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static int key_history_idx = -1;",
            "static keyevent_t key_history[KEY_HIST];",
            "static rfbClientPtr last_keyboard_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define KEY_HIST 256\n\nint add_keysym(KeySym keysym);\nint sloppy_key_check(int key, rfbBool down, rfbKeySym keysym, int *new_kc);\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic int key_history_idx = -1;\nstatic keyevent_t key_history[KEY_HIST];\nstatic rfbClientPtr last_keyboard_client = NULL;\n\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tKeyCode k;\n\tint idx, isbutton = 0;\n\tallowed_input_t input;\n\ttime_t now = time(NULL);\n\tdouble tnow;\n\tstatic int skipped_last_down;\n\tstatic rfbBool last_down;\n\tstatic rfbKeySym last_keysym = NoSymbol;\n\tstatic rfbKeySym max_keyrepeat_last_keysym = NoSymbol;\n\tstatic double max_keyrepeat_last_time = 0.0;\n#ifdef MAX_KEYREPEAT\n\tstatic double max_keyrepeat_always = -1.0;\n#endif\n        ClientData *cd = (ClientData *) client->clientData;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tdtime0(&tnow);\n\tgot_keyboard_calls++;\n\n\tif (debug_keyboard) {\n\t\tchar *str;\n\t\tX_LOCK;\n\t\tstr = XKeysymToString((KeySym) keysym);\n\t\tX_UNLOCK;\n\t\trfbLog(\"# keyboard(%s, 0x%x \\\"%s\\\") uip=%d  %.4f\\n\",\n\t\t    down ? \"down\":\"up\", (int) keysym, str ? str : \"null\",\n\t\t    unixpw_in_progress, tnow - x11vnc_start);\n\t}\n\n\tif (keysym <= 0) {\n\t\trfbLog(\"keyboard: skipping 0x0 keysym\\n\");\n\t\treturn;\n\t}\n\t\n\tif (unixpw_in_progress) {\n\t\tif (unixpw_denied) {\n\t\t\trfbLog(\"keyboard: ignoring keystroke 0x%x in \"\n\t\t\t    \"unixpw_denied=1 state\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\t\tif (client != unixpw_client) {\n\t\t\trfbLog(\"keyboard: skipping other client in unixpw\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tunixpw_keystroke(down, keysym, 0);\n\n\t\treturn;\n\t}\n\n\tif (skip_duplicate_key_events) {\n\t\tif (keysym == last_keysym && down == last_down) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"skipping dup key event: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (skip_lockkeys) {\n\t\t/*  we don't handle XK_ISO*_Lock or XK_Kana_Lock ... */\n\t\tif (keysym == XK_Scroll_Lock || keysym == XK_Num_Lock ||\n\t\t    keysym == XK_Caps_Lock || keysym == XK_Shift_Lock) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"skipping lock key event: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (keysym >= XK_KP_0 && keysym <= XK_KP_9) {\n\t\t\t/* ugh this is probably what they meant... assume NumLock. */\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"changed KP digit to regular digit: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\tkeysym = (keysym - XK_KP_0) + XK_0;\n\t\t} else if (keysym == XK_KP_Decimal) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"changed XK_KP_Decimal to XK_period: %d 0x%x\\n\",\n\t\t\t\t    down, keysym);\n\t\t\t}\n\t\t\tkeysym = XK_period; \n\t\t}\n\t}\n\n\tINPUT_LOCK;\n\n\tlast_down = down;\n\tlast_keysym = keysym;\n\tlast_keyboard_time = tnow;\n\n\tlast_rfb_down = down;\n\tlast_rfb_keysym = keysym;\n\tlast_rfb_keytime = tnow;\n\tlast_rfb_key_accepted = FALSE;\n\n\tif (key_history_idx == -1) {\n\t\tfor (idx=0; idx<KEY_HIST; idx++) {\n\t\t\tkey_history[idx].sym = NoSymbol;\n\t\t\tkey_history[idx].down = FALSE;\n\t\t\tkey_history[idx].time = 0.0;\n\t\t}\n\t}\n\tidx = ++key_history_idx;\n\tif (key_history_idx >= KEY_HIST) {\n\t\tkey_history_idx = 0;\n\t\tidx = 0;\n\t}\n\tkey_history[idx].sym = keysym;\n\tkey_history[idx].down = down;\n\tkey_history[idx].time = tnow;\n\n\tif (down && (keysym == XK_Alt_L || keysym == XK_Super_L)) {\n\t\tint i, k, run = 0, ups = 0;\n\t\tdouble delay = 1.0;\n\t\tKeySym ks;\n\t\tfor (i=0; i<16; i++) {\n\t\t\tk = idx - i;\n\t\t\tif (k < 0) k += KEY_HIST;\n\t\t\tif (!key_history[k].down) {\n\t\t\t\tups++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tks = key_history[k].sym;\n\t\t\tif (key_history[k].time < tnow - delay) {\n\t\t\t\tbreak;\n\t\t\t} else if (ks == keysym && ks == XK_Alt_L) {\n\t\t\t\trun++;\n\t\t\t} else if (ks == keysym && ks == XK_Super_L) {\n\t\t\t\trun++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ups < 2) {\n\t\t\t;\n\t\t} else if (run == 3 && keysym == XK_Alt_L) {\n\t\t\trfbLog(\"3*Alt_L, calling: refresh_screen(0)\\n\");\n\t\t\trefresh_screen(0);\n\t\t} else if (run == 4 && keysym == XK_Alt_L) {\n\t\t\trfbLog(\"4*Alt_L, setting: do_copy_screen\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t} else if (run == 5 && keysym == XK_Alt_L) {\n\t\t\t;\n\t\t} else if (run == 3 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"3*Super_L, calling: set_xdamage_mark()\\n\");\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t} else if (run == 4 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"4*Super_L, calling: check_xrecord_reset()\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else if (run == 5 && keysym == XK_Super_L) {\n\t\t\trfbLog(\"5*Super_L, calling: push_black_screen(0)\\n\");\n\t\t\tpush_black_screen(0);\n\t\t}\n\t}\n\n#ifdef MAX_KEYREPEAT \n\tif (max_keyrepeat_always < 0.0) {\n\t\tif (getenv(\"MAX_KEYREPEAT\")) {\n\t\t\tmax_keyrepeat_always = atof(getenv(\"MAX_KEYREPEAT\"));\n\t\t} else {\n\t\t\tmax_keyrepeat_always = 0.0;\n\t\t}\n\t}\n\tif (max_keyrepeat_always > 0.0) {\n\t\tmax_keyrepeat_time = max_keyrepeat_always;\n\t}\n#endif\n\tif (!down && skipped_last_down) {\n\t\tint db = debug_scroll;\n\t\tif (keysym == max_keyrepeat_last_keysym) {\n\t\t\tskipped_last_down = 0;\n\t\t\tif (db) rfbLog(\"--- scroll keyrate skipping 0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (down && max_keyrepeat_time > 0.0) {\n\t\tint skip = 0;\n\t\tint db = debug_scroll;\n\n\t\tif (max_keyrepeat_last_keysym != NoSymbol &&\n\t\t    max_keyrepeat_last_keysym != keysym) {\n\t\t\t;\n\t\t} else {\n\t\t\tif (tnow < max_keyrepeat_last_time+max_keyrepeat_time) {\n\t\t\t\tskip = 1;\n\t\t\t}\n\t\t}\n\t\tmax_keyrepeat_time = 0.0;\n\t\tif (skip) {\n\t\t\tif (db) rfbLog(\"--- scroll keyrate skipping 0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t\tmax_keyrepeat_last_keysym = keysym;\n\t\t\tskipped_last_down = 1;\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (db) rfbLog(\"--- scroll keyrate KEEPING  0x%lx %s \"\n\t\t\t    \"%.4f  %.4f\\n\", keysym, down ? \"down\":\"up  \",\n\t\t\t    tnow - x11vnc_start, tnow - max_keyrepeat_last_time); \n\t\t}\n\t}\n\tmax_keyrepeat_last_keysym = keysym;\n\tmax_keyrepeat_last_time = tnow;\n\tskipped_last_down = 0;\n\tlast_rfb_key_accepted = TRUE;\n\n\tif (pipeinput_fh != NULL || pipeinput_int) {\n\t\tpipe_keyboard(down, keysym, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tlast_keyboard_client = client;\n\t\t\t\tlast_event = last_input = now;\n\t\t\t\tlast_keyboard_input = now;\n\t\t\n\t\t\t\tlast_keysym = keysym;\n\n\t\t\t\tlast_rfb_down = down;\n\t\t\t\tlast_rfb_keysym = keysym;\n\t\t\t\tlast_rfb_keytime = tnow;\n\t\t\t\tlast_rfb_key_injected = dnow();\n\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_keyboard_input++;\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\ttrack_mod_state(keysym, down, TRUE);\t/* ignores remaps */\n\n\tlast_keyboard_client = client;\n\tlast_event = last_input = now;\n\tlast_keyboard_input = now;\n\n\tlast_keysym = keysym;\n\n\tlast_rfb_down = down;\n\tlast_rfb_keysym = keysym;\n\tlast_rfb_keytime = tnow;\n\tlast_rfb_key_injected = dnow();\n\n\tgot_user_input++;\n\tgot_keyboard_input++;\n\t\n\tRAWFB_RET_VOID;\n\n\n\tapply_remap(&keysym, &isbutton);\n\n\tif (use_xrecord && ! xrecording && down) {\n\n\t\tif (!strcmp(scroll_copyrect, \"never\")) {\n\t\t\t;\n\t\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\t\t;\n\t\t} else if (skip_cr_when_scaling(\"scroll\")) {\n\t\t\t;\n\t\t} else if (! xrecord_skip_keysym(keysym)) {\n\t\t\tsnapshot_stack_list(0, 0.25);\n\t\t\txrecord_watch(1, SCR_KEY);\n\t\t\txrecord_set_by_keys = 1;\n\t\t\txrecord_keysym = keysym;\n\t\t} else {\n\t\t\tif (debug_scroll) {\n\t\t\t\tchar *str = XKeysymToString(keysym);\n\t\t\t\trfbLog(\"xrecord_skip_keysym: %s\\n\",\n\t\t\t\t    str ? str : \"NoSymbol\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isbutton) {\n\t\tint mask, button = (int) keysym;\n\t\tchar *b, bstr[32];\n\t\t\n\t\tif (! down) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\t/* nothing to send */\n\t\t}\n\t\tif (debug_keyboard) {\n\t\t\trfbLog(\"keyboard(): remapping keystroke to button %d\"\n\t\t\t    \" click\\n\", button);\n\t\t}\n\t\tdtime0(&last_key_to_button_remap_time);\n\n\t\tX_LOCK;\n\t\t/*\n\t\t * This in principle can be a little dicey... i.e. even\n\t\t * remap the button click to keystroke sequences!\n\t\t * Usually just will simulate the button click.\n\t\t */\n\t\n\t\t/* loop over possible multiclicks: Button123 */\n\t\tsprintf(bstr, \"%d\", button);\n\t\tb = bstr;\n\t\twhile (*b != '\\0') {\n\t\t\tchar t[2];\n\t\t\tint butt;\n\t\t\tt[0] = *b;\n\t\t\tt[1] = '\\0';\n\t\t\tif (sscanf(t, \"%d\", &butt) == 1) {\n\t\t\t\tmask = 1<<(butt-1);\n\t\t\t\tdo_button_mask_change(mask, butt, client);\t/* down */\n\t\t\t\tmask = 0;\n\t\t\t\tdo_button_mask_change(mask, butt, client);\t/* up */\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tif (use_modifier_tweak) {\n\t\tmodifier_tweak_keyboard(down, keysym, client);\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tX_LOCK;\n\n\tk = XKeysymToKeycode(dpy, (KeySym) keysym);\n\n\tif (k == NoSymbol && add_keysyms && ! IsModifierKey(keysym)) {\n\t\tint new_kc = add_keysym(keysym);\n\t\tif (new_kc) {\n\t\t\tk = new_kc;\n\t\t}\n\t}\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(keysym);\n\t\trfbLog(\"keyboard(): KeySym 0x%x \\\"%s\\\" -> KeyCode 0x%x%s\\n\",\n\t\t    (int) keysym, str ? str : \"null\", (int) k,\n\t\t    k ? \"\" : \" *ignored*\");\n\t}\n\n\n\tif ( k != NoSymbol ) {\n               \n XTestFakeKeyEvent_wr(dpy, cd->kbd_id, k, (Bool) down, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t}\n\n\tX_UNLOCK;\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\"",
            "p",
            "ks",
            "str",
            "down"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XKeysymToString",
          "args": [
            "ks"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "XKeysymToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "1449-2807",
          "snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: bad keysym: %s\\n\"",
            "p"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XStringToKeysym",
          "args": [
            "p"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "XStringToKeysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "88-1446",
          "snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%u\"",
            "&in"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"0x%x\"",
            "&in"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "c+1"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"keysym:\""
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"keysym\""
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTestFakeKeyEvent_wr",
          "args": [
            "dpy",
            "-1",
            "kc",
            "down",
            "CurrentTime"
          ],
          "line": 4415
        },
        "resolved": true,
        "details": {
          "function_name": "XTestFakeKeyEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "933-1017",
          "snippet": "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay) {\n\tstatic int first = 1;\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !key || !down || !delay || !first) {}\n\treturn;\n#else\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(XKeycodeToKeysym_wr(dpy, key, 0));\n\t\trfbLog(\"XTestFakeKeyEvent(dpy, keycode=0x%x \\\"%s\\\", %s)\\n\",\n\t\t    key, str ? str : \"null\", down ? \"down\":\"up\");\n\t}\n\tif (first) { \n\t\tinit_track_keycode_state();\n\t\tfirst = 0;\n\t}\n\tif (down) {\n\t\tlast_keyboard_keycode = -key;\n\t} else {\n\t\tlast_keyboard_keycode = key;\n\t}\n\n\tif (grab_kbd) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_ptr && ungrab_both) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeKeyEvent_wr(dpy, key, down, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"keyboard: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_keyboard) {\n\t\trfbLog(\"calling XTestFakeKeyEvent(%d, %d)  %.4f\\n\",\n\t\t    key, down, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n\tXDevice xdev;\n        xdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n\tXTestFakeDeviceKeyEvent(dpy, &xdev, key, down, NULL, 0, delay);        \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeKeyEvent(dpy, key, down, delay);\n\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n\tif (debug_keyboard) {\n\t\tupup_downdown_warning(key, down);\n\t}\n\tkeycode_state[(int) key] = down ? 1 : 0;\n#endif\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "int keycode_state[256];",
            "void init_track_keycode_state(void);",
            "void XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestDiscard_wr(Display *dpy);",
            "static void upup_downdown_warning(KeyCode key, Bool down);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nint keycode_state[256];\nvoid init_track_keycode_state(void);\nvoid XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestDiscard_wr(Display *dpy);\nstatic void upup_downdown_warning(KeyCode key, Bool down);\n\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay) {\n\tstatic int first = 1;\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !key || !down || !delay || !first) {}\n\treturn;\n#else\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(XKeycodeToKeysym_wr(dpy, key, 0));\n\t\trfbLog(\"XTestFakeKeyEvent(dpy, keycode=0x%x \\\"%s\\\", %s)\\n\",\n\t\t    key, str ? str : \"null\", down ? \"down\":\"up\");\n\t}\n\tif (first) { \n\t\tinit_track_keycode_state();\n\t\tfirst = 0;\n\t}\n\tif (down) {\n\t\tlast_keyboard_keycode = -key;\n\t} else {\n\t\tlast_keyboard_keycode = key;\n\t}\n\n\tif (grab_kbd) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_ptr && ungrab_both) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeKeyEvent_wr(dpy, key, down, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"keyboard: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_keyboard) {\n\t\trfbLog(\"calling XTestFakeKeyEvent(%d, %d)  %.4f\\n\",\n\t\t    key, down, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n\tXDevice xdev;\n        xdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n\tXTestFakeDeviceKeyEvent(dpy, &xdev, key, down, NULL, 0, delay);        \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeKeyEvent(dpy, key, down, delay);\n\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n\tif (debug_keyboard) {\n\t\tupup_downdown_warning(key, down);\n\t}\n\tkeycode_state[(int) key] = down ? 1 : 0;\n#endif\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_keycode_inject",
          "args": [
            "down",
            "kc"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_keycode_inject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "954-961",
          "snippet": "void macosxCG_keycode_inject(int down, int keycode) {\n\tCGKeyCode keyCode = (CGKeyCode) keycode;\n\tCGCharCode keyChar = 0;\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keycode_inject(down=%d, keycode=%d)\\n\", down, keycode);\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_keycode_inject(int down, int keycode) {\n\tCGKeyCode keyCode = (CGKeyCode) keycode;\n\tCGCharCode keyChar = 0;\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keycode_inject(down=%d, keycode=%d)\\n\", down, keycode);\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: insert keycode %d down=%d\\n\"",
            "kc",
            "down"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "c+1"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"keycode:\""
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"keycode\""
          ],
          "line": 4385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off debug_keyboard.\\n\""
          ],
          "line": 4381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_keyboard"
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodk\""
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_keyboard\""
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on debug_keyboard.\\n\""
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_keyboard"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dk\""
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_keyboard\""
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off debug_pointer.\\n\""
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!debug_pointer"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodp\""
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_pointer\""
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on debug_pointer.\\n\""
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "debug_pointer"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dp\""
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_pointer\""
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -wmdt to: %s\\n\"",
            "p"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wmdt:\""
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(wmdt_str)"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wmdt_str"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wmdt:\""
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wmdt\""
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_speeds",
          "args": [],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_speeds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "197-270",
          "snippet": "void initialize_speeds(void) {\n\tchar *s, *s_in, *p;\n\tint i;\n\n\tspeeds_read_rate = 0;\n\tspeeds_net_rate = 0;\n\tspeeds_net_latency = 0;\n\tif (! speeds_str || *speeds_str == '\\0') {\n\t\ts_in = strdup(\"\");\n\t} else {\n\t\ts_in = strdup(speeds_str);\n\t}\n\n\tif (!strcmp(s_in, \"modem\")) {\n\t\ts = strdup(\"6,4,200\");\n\t} else if (!strcmp(s_in, \"dsl\")) {\n\t\ts = strdup(\"6,100,50\");\n\t} else if (!strcmp(s_in, \"lan\")) {\n\t\ts = strdup(\"6,5000,1\");\n\t} else {\n\t\ts = strdup(s_in);\n\t}\n\n\tp = strtok(s, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tdouble val;\n\t\tif (*p != '\\0') {\n\t\t\tval = atof(p);\n\t\t\tif (i==0) {\n\t\t\t\tspeeds_read_rate = (int) 1000000 * val;\n\t\t\t} else if (i==1) {\n\t\t\t\tspeeds_net_rate = (int) 1000 * val;\n\t\t\t} else if (i==2) {\n\t\t\t\tspeeds_net_latency = (int) val;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\tfree(s_in);\n\n\tif (! speeds_read_rate) {\n\t\tint n = 0;\n\t\tdouble dt, timer;\n#ifdef MACOSX\n\t\tif (macosx_console && macosx_read_opengl && fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tusleep(10 * 1000);\n\t\t}\n#endif\n\n\t\tdtime0(&timer);\n\t\tif (fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tn = fullscreen->bytes_per_line * fullscreen->height;\n\t\t} else if (scanline) {\n\t\t\tcopy_image(scanline, 0, 0, 0, 0);\n\t\t\tn = scanline->bytes_per_line * scanline->height;\n\t\t}\n\t\tdt = dtime(&timer);\n\t\tif (n && dt > 0.0) {\n\t\t\tdouble rate = ((double) n) / dt;\n\t\t\tspeeds_read_rate_measured = (int) (rate/1000000.0);\n\t\t\tif (speeds_read_rate_measured < 1) {\n\t\t\t\tspeeds_read_rate_measured = 1;\n\t\t\t} else {\n\t\t\t\trfbLog(\"fb read rate: %d MB/sec\\n\",\n\t\t\t\t    speeds_read_rate_measured);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_rate = 0;",
            "int speeds_net_latency = 0;",
            "int speeds_read_rate = 0;",
            "int speeds_read_rate_measured = 0;",
            "void initialize_speeds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_latency = 0;\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nvoid initialize_speeds(void);\n\nvoid initialize_speeds(void) {\n\tchar *s, *s_in, *p;\n\tint i;\n\n\tspeeds_read_rate = 0;\n\tspeeds_net_rate = 0;\n\tspeeds_net_latency = 0;\n\tif (! speeds_str || *speeds_str == '\\0') {\n\t\ts_in = strdup(\"\");\n\t} else {\n\t\ts_in = strdup(speeds_str);\n\t}\n\n\tif (!strcmp(s_in, \"modem\")) {\n\t\ts = strdup(\"6,4,200\");\n\t} else if (!strcmp(s_in, \"dsl\")) {\n\t\ts = strdup(\"6,100,50\");\n\t} else if (!strcmp(s_in, \"lan\")) {\n\t\ts = strdup(\"6,5000,1\");\n\t} else {\n\t\ts = strdup(s_in);\n\t}\n\n\tp = strtok(s, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tdouble val;\n\t\tif (*p != '\\0') {\n\t\t\tval = atof(p);\n\t\t\tif (i==0) {\n\t\t\t\tspeeds_read_rate = (int) 1000000 * val;\n\t\t\t} else if (i==1) {\n\t\t\t\tspeeds_net_rate = (int) 1000 * val;\n\t\t\t} else if (i==2) {\n\t\t\t\tspeeds_net_latency = (int) val;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\tfree(s_in);\n\n\tif (! speeds_read_rate) {\n\t\tint n = 0;\n\t\tdouble dt, timer;\n#ifdef MACOSX\n\t\tif (macosx_console && macosx_read_opengl && fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tusleep(10 * 1000);\n\t\t}\n#endif\n\n\t\tdtime0(&timer);\n\t\tif (fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tn = fullscreen->bytes_per_line * fullscreen->height;\n\t\t} else if (scanline) {\n\t\t\tcopy_image(scanline, 0, 0, 0, 0);\n\t\t\tn = scanline->bytes_per_line * scanline->height;\n\t\t}\n\t\tdt = dtime(&timer);\n\t\tif (n && dt > 0.0) {\n\t\t\tdouble rate = ((double) n) / dt;\n\t\t\tspeeds_read_rate_measured = (int) (rate/1000000.0);\n\t\t\tif (speeds_read_rate_measured < 1) {\n\t\t\t\tspeeds_read_rate_measured = 1;\n\t\t\t} else {\n\t\t\t\trfbLog(\"fb read rate: %d MB/sec\\n\",\n\t\t\t\t    speeds_read_rate_measured);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\"",
            "p"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"speeds:\""
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(speeds_str)"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "speeds_str"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"speeds:\""
          ],
          "line": 4321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"speeds\""
          ],
          "line": 4320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting ssltimeout: %d\\n\"",
            "is"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ssltimeout:\""
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "ssl_timeout_secs"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"ssltimeout:\""
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ssltimeout\""
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_client_input",
          "args": [
            "p"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "set_client_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "381-415",
          "snippet": "void set_client_input(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\tchar *p, *val;\n\n\t/* str is \"match:value\" */\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tp = strrchr(str, ':');\n\tif (! p) {\n\t\treturn;\n\t}\n\t*p = '\\0';\n\tp++;\n\tval = short_kmbcf(p);\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\tClientData *cd = (ClientData *) (*cp)->clientData;\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tcd->input[0] = '\\0';\n\t\tstrcat(cd->input, \"_\");\n\t\tstrcat(cd->input, val);\n\t\tcp++;\n\t}\n\n\tfree(val);\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "int set_xprop(char *prop, Window win, char *value);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nint set_xprop(char *prop, Window win, char *value);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_client_input(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\tchar *p, *val;\n\n\t/* str is \"match:value\" */\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tp = strrchr(str, ':');\n\tif (! p) {\n\t\treturn;\n\t}\n\t*p = '\\0';\n\tp++;\n\tval = short_kmbcf(p);\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\tClientData *cd = (ClientData *) (*cp)->clientData;\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tcd->input[0] = '\\0';\n\t\tstrcat(cd->input, \"_\");\n\t\tstrcat(cd->input, val);\n\t\tcp++;\n\t}\n\n\tfree(val);\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"client_input:\""
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"client_input\""
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -grablocal to: %d\\n\"",
            "grab_local"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"grablocal:\""
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "grab_local"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"grablocal:\""
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"grablocal\""
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled grab_always\\n\""
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_grabs",
          "args": [
            "0",
            "0"
          ],
          "line": 4281
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_grabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "4335-4372",
          "snippet": "void adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void adjust_grabs(int grab, int quiet);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid adjust_grabs(int grab, int quiet);\n\nvoid adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XUngrabPointer",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabKeyboard",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!grab_always"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nograbalways\""
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled grab_always\\n\""
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "grab_always"
          ],
          "line": 4254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"grabalways\""
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled grab_ptr\\n\""
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabPointer",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!grab_ptr"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nograbptr\""
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled ungrab_both\\n\""
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ungrab_both"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noungrabboth\""
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled ungrab_both\\n\""
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ungrab_both"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ungrabboth\""
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled grab_ptr\\n\""
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "grab_ptr"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"grabptr\""
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled grab_kbd\\n\""
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabKeyboard",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!grab_kbd"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nograbkbd\""
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled grab_kbd\\n\""
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "grab_kbd"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"grabkbd\""
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_allowed_input",
          "args": [],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2430-2507",
          "snippet": "void initialize_allowed_input(void) {\n\tchar *str;\n\n\tif (allowed_input_normal) {\n\t\tfree(allowed_input_normal);\n\t\tallowed_input_normal = NULL;\n\t}\n\tif (allowed_input_view_only) {\n\t\tfree(allowed_input_view_only);\n\t\tallowed_input_view_only = NULL;\n\t}\n\n\tif (! allowed_input_str) {\n\t\tallowed_input_normal = strdup(\"KMBCF\");\n\t\tallowed_input_view_only = strdup(\"\");\n\t} else {\n\t\tchar *p, *str = strdup(allowed_input_str);\n\t\tp = strchr(str, ',');\n\t\tif (p) {\n\t\t\tallowed_input_view_only = strdup(p+1);\n\t\t\t*p = '\\0';\n\t\t\tallowed_input_normal = strdup(str);\n\t\t} else {\n\t\t\tallowed_input_normal = strdup(str);\n\t\t\tallowed_input_view_only = strdup(\"\");\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* shorten them */\n\tstr = short_kmbcf(allowed_input_normal);\n\tfree(allowed_input_normal);\n\tallowed_input_normal = str;\n\n\tstr = short_kmbcf(allowed_input_view_only);\n\tfree(allowed_input_view_only);\n\tallowed_input_view_only = str;\n\n\tif (screen) {\n\t\trfbClientIteratorPtr iter;\n\t\trfbClientPtr cl;\n\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n#if 0\nrfbLog(\"cd: %p\\n\", cd);\nrfbLog(\"cd->input: %s\\n\", cd->input);\nrfbLog(\"cd->login_viewonly: %d\\n\", cd->login_viewonly);\nrfbLog(\"allowed_input_view_only: %s\\n\", allowed_input_view_only);\n#endif\n\n\t\t\tif (cd->input[0] == '=') {\n\t\t\t\t;\t/* custom setting */\n\t\t\t} else if (cd->login_viewonly) {\n\t\t\t\tif (*allowed_input_view_only != '\\0') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_view_only, CILEN);\n\t\t\t\t} else {\n\t\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allowed_input_normal) {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_normal, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void initialize_allowed_input(void);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "static void add_dead_keysyms(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid initialize_allowed_input(void);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nstatic void add_dead_keysyms(char *str);\n\nvoid initialize_allowed_input(void) {\n\tchar *str;\n\n\tif (allowed_input_normal) {\n\t\tfree(allowed_input_normal);\n\t\tallowed_input_normal = NULL;\n\t}\n\tif (allowed_input_view_only) {\n\t\tfree(allowed_input_view_only);\n\t\tallowed_input_view_only = NULL;\n\t}\n\n\tif (! allowed_input_str) {\n\t\tallowed_input_normal = strdup(\"KMBCF\");\n\t\tallowed_input_view_only = strdup(\"\");\n\t} else {\n\t\tchar *p, *str = strdup(allowed_input_str);\n\t\tp = strchr(str, ',');\n\t\tif (p) {\n\t\t\tallowed_input_view_only = strdup(p+1);\n\t\t\t*p = '\\0';\n\t\t\tallowed_input_normal = strdup(str);\n\t\t} else {\n\t\t\tallowed_input_normal = strdup(str);\n\t\t\tallowed_input_view_only = strdup(\"\");\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* shorten them */\n\tstr = short_kmbcf(allowed_input_normal);\n\tfree(allowed_input_normal);\n\tallowed_input_normal = str;\n\n\tstr = short_kmbcf(allowed_input_view_only);\n\tfree(allowed_input_view_only);\n\tallowed_input_view_only = str;\n\n\tif (screen) {\n\t\trfbClientIteratorPtr iter;\n\t\trfbClientPtr cl;\n\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n#if 0\nrfbLog(\"cd: %p\\n\", cd);\nrfbLog(\"cd->input: %s\\n\", cd->input);\nrfbLog(\"cd->login_viewonly: %d\\n\", cd->login_viewonly);\nrfbLog(\"allowed_input_view_only: %s\\n\", allowed_input_view_only);\n#endif\n\n\t\t\tif (cd->input[0] == '=') {\n\t\t\t\t;\t/* custom setting */\n\t\t\t} else if (cd->login_viewonly) {\n\t\t\t\tif (*allowed_input_view_only != '\\0') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_view_only, CILEN);\n\t\t\t\t} else {\n\t\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allowed_input_normal) {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input,\n\t\t\t\t\t    allowed_input_normal, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting input %s\\n\"",
            "p"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "allowed_input_str"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"input:\""
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(allowed_input_str)"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allowed_input_str"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"input:\""
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"input\""
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled input_eagerly\\n\""
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!handle_events_eagerly"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noinput_eagerly\""
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled allinput\\n\""
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled input_eagerly\\n\""
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "handle_events_eagerly"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"input_eagerly\""
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled allinput\\n\""
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!all_input"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noallinput\""
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabled input_eagerly\\n\""
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabled allinput\\n\""
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "all_input"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"allinput\""
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting input_skip %d\\n\"",
            "is"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"input_skip:\""
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "ui_skip"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"input_skip:\""
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"input_skip\""
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting pointer_mode %d\\n\"",
            "pm"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\"",
            "pointer_mode_max",
            "pm"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pm:\""
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "pointer_mode"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"pm:\""
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"pm\""
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting pointer_mode %d\\n\"",
            "pm"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\"",
            "pointer_mode_max",
            "pm"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pointer_mode:\""
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "pointer_mode"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"pointer_mode:\""
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"pointer_mode\""
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"RECORD is disabled, not resetting.\\n\""
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xrecord_reset",
          "args": [
            "1"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1558-1636",
          "snippet": "void check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecording = 0;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "void check_xrecord_reset(int force);",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecording = 0;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid check_xrecord_reset(int force);\nstatic void check_xrecord_grabserver(void);\n\nvoid check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"resetting RECORD\\n\""
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"reset_record\""
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xrecord",
          "args": [],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "187-283",
          "snippet": "void initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "void initialize_xrecord(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nvoid initialize_xrecord(void);\n\nvoid initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set noxrecord to: %d\\n\"",
            "noxrecord"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!noxrecord"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xrecord\""
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_xrecord",
          "args": [],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "285-340",
          "snippet": "void shutdown_xrecord(void) {\n#if HAVE_RECORD\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t}\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = NULL;\n\trr_CW = NULL;\n\trr_GS = NULL;\n\n\tX_LOCK;\n\tif (rdpy_ctrl && rc_scroll) {\n\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\tXRecordFreeContext(rdpy_ctrl, rc_scroll);\n\t\tXSync(rdpy_ctrl, False);\n\t\trc_scroll = 0;\n\t}\n\t\t\n\tif (gdpy_ctrl && rc_grab) {\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXSync(gdpy_ctrl, False);\n\t\trc_grab = 0;\n\t}\n\t\t\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\tX_UNLOCK;\n#endif\n\tuse_xrecord = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord-done: %.5f\\n\", dnowx());\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "void shutdown_xrecord(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nvoid shutdown_xrecord(void);\n\nvoid shutdown_xrecord(void) {\n#if HAVE_RECORD\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t}\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = NULL;\n\trr_CW = NULL;\n\trr_GS = NULL;\n\n\tX_LOCK;\n\tif (rdpy_ctrl && rc_scroll) {\n\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\tXRecordFreeContext(rdpy_ctrl, rc_scroll);\n\t\tXSync(rdpy_ctrl, False);\n\t\trc_scroll = 0;\n\t}\n\t\t\n\tif (gdpy_ctrl && rc_grab) {\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXSync(gdpy_ctrl, False);\n\t\trc_grab = 0;\n\t}\n\t\t\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\tX_UNLOCK;\n#endif\n\tuse_xrecord = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord-done: %.5f\\n\", dnowx());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set noxrecord to: %d\\n\"",
            "noxrecord"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "noxrecord"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxrecord\""
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -fixscreen %s.\\n\"",
            "NONUL(screen_fixup_str)"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "screen_fixup_str"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_fixscreen",
          "args": [],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "parse_fixscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "282-316",
          "snippet": "void parse_fixscreen(void) {\n\tchar *str, *p;\n\n\tscreen_fixup_V = 0.0;\n\tscreen_fixup_C = 0.0;\n\tscreen_fixup_X = 0.0;\n\tscreen_fixup_8 = 0.0;\n\n\tif (! screen_fixup_str) {\n\t\treturn;\n\t}\n\n\tstr = strdup(screen_fixup_str);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tdouble t;\n\t\tif (*p == 'V' && sscanf(p, \"V=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_V = t;\n\t\t} else if (*p == 'C' && sscanf(p, \"C=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_C = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"X=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_X = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"8=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_8 = t;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (screen_fixup_V < 0.0) screen_fixup_V = 0.0;\n\tif (screen_fixup_C < 0.0) screen_fixup_C = 0.0;\n\tif (screen_fixup_X < 0.0) screen_fixup_X = 0.0;\n\tif (screen_fixup_8 < 0.0) screen_fixup_8 = 0.0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void parse_fixscreen(void);",
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_fixscreen(void);\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\n\nvoid parse_fixscreen(void) {\n\tchar *str, *p;\n\n\tscreen_fixup_V = 0.0;\n\tscreen_fixup_C = 0.0;\n\tscreen_fixup_X = 0.0;\n\tscreen_fixup_8 = 0.0;\n\n\tif (! screen_fixup_str) {\n\t\treturn;\n\t}\n\n\tstr = strdup(screen_fixup_str);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tdouble t;\n\t\tif (*p == 'V' && sscanf(p, \"V=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_V = t;\n\t\t} else if (*p == 'C' && sscanf(p, \"C=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_C = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"X=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_X = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"8=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_8 = t;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (screen_fixup_V < 0.0) screen_fixup_V = 0.0;\n\tif (screen_fixup_C < 0.0) screen_fixup_C = 0.0;\n\tif (screen_fixup_X < 0.0) screen_fixup_X = 0.0;\n\tif (screen_fixup_8 < 0.0) screen_fixup_8 = 0.0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"fixscreen:\""
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(screen_fixup_str)"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "screen_fixup_str"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"fixscreen:\""
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"fixscreen\""
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(scroll_copyrect)"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_scrollcopyrect_mode",
          "args": [
            "\"never\""
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "set_scrollcopyrect_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "528-553",
          "snippet": "void set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%s\"",
            "p",
            "NONUL(scroll_copyrect)"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noscr\""
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noscrollcopyrect\""
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(scroll_copyrect)"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr:\""
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(scroll_copyrect)"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr:\""
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr:\""
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scr\""
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(scroll_copyrect)"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scrollcopyrect:\""
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(scroll_copyrect)"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scrollcopyrect:\""
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scrollcopyrect\""
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -scr_parms %s.\\n\"",
            "NONUL(scroll_copyrect_str)"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_copyrect_str"
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_scroll_copyrect",
          "args": [],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scroll_copyrect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "274-280",
          "snippet": "void parse_scroll_copyrect(void) {\n\tparse_scroll_copyrect_str(SCROLL_COPYRECT_PARMS);\n\tif (! scroll_copyrect_str) {\n\t\tscroll_copyrect_str = strdup(SCROLL_COPYRECT_PARMS);\n\t}\n\tparse_scroll_copyrect_str(scroll_copyrect_str);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void parse_scroll_copyrect(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_scroll_copyrect(void);\n\nvoid parse_scroll_copyrect(void) {\n\tparse_scroll_copyrect_str(SCROLL_COPYRECT_PARMS);\n\tif (! scroll_copyrect_str) {\n\t\tscroll_copyrect_str = strdup(SCROLL_COPYRECT_PARMS);\n\t}\n\tparse_scroll_copyrect_str(scroll_copyrect_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_parms:\""
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_parms:\""
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_parms\""
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_max_keyrepeat",
          "args": [],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_max_keyrepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "765-787",
          "snippet": "void initialize_max_keyrepeat(void) {\n\tchar *str;\n\tint lo, hi;\n\n\tif (max_keyrepeat_str != NULL && *max_keyrepeat_str != '\\0') {\n\t\tstr = max_keyrepeat_str;\n\t} else {\n\t\tstr = max_keyrepeat_str0;\n\t}\n\n\tif (sscanf(str, \"%d-%d\", &lo, &hi) != 2) {\n\t\trfbLog(\"skipping invalid -scr_keyrepeat string: %s\\n\", str);\n\t\tsscanf(max_keyrepeat_str0, \"%d-%d\", &lo, &hi);\n\t}\n\tmax_keyrepeat_lo = lo;\n\tmax_keyrepeat_hi = hi;\n\tif (max_keyrepeat_lo < 1) {\n\t\tmax_keyrepeat_lo = 1;\n\t}\n\tif (max_keyrepeat_hi > 40) {\n\t\tmax_keyrepeat_hi = 40;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void initialize_max_keyrepeat(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_max_keyrepeat(void);\n\nvoid initialize_max_keyrepeat(void) {\n\tchar *str;\n\tint lo, hi;\n\n\tif (max_keyrepeat_str != NULL && *max_keyrepeat_str != '\\0') {\n\t\tstr = max_keyrepeat_str;\n\t} else {\n\t\tstr = max_keyrepeat_str0;\n\t}\n\n\tif (sscanf(str, \"%d-%d\", &lo, &hi) != 2) {\n\t\trfbLog(\"skipping invalid -scr_keyrepeat string: %s\\n\", str);\n\t\tsscanf(max_keyrepeat_str0, \"%d-%d\", &lo, &hi);\n\t}\n\tmax_keyrepeat_lo = lo;\n\tmax_keyrepeat_hi = hi;\n\tif (max_keyrepeat_lo < 1) {\n\t\tmax_keyrepeat_lo = 1;\n\t}\n\tif (max_keyrepeat_hi > 40) {\n\t\tmax_keyrepeat_hi = 40;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_keyrepeat to: %s\\n\"",
            "max_keyrepeat_str"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_keyrepeat:\""
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(s)"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "s"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_keyrepeat:\""
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_keyrepeat\""
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_scroll_term",
          "args": [],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_scroll_term",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "740-763",
          "snippet": "void initialize_scroll_term(void) {\n\tchar *str;\n\tint n;\n\n\tdestroy_str_list(scroll_term);\n\tscroll_term = NULL;\n\n\tif (scroll_term_str != NULL && *scroll_term_str != '\\0') {\n\t\tstr = scroll_term_str;\n\t} else {\n\t\tstr = scroll_term_str0;\n\t}\n\tif (!strcmp(str, \"none\")) {\n\t\treturn;\n\t}\n\tscroll_term = create_str_list(str);\n\n\tn = 0;\n\twhile (scroll_term[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\t/* pull parameters out at some point */\n\t\ts = NULL;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void initialize_scroll_term(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_term(void);\n\nvoid initialize_scroll_term(void) {\n\tchar *str;\n\tint n;\n\n\tdestroy_str_list(scroll_term);\n\tscroll_term = NULL;\n\n\tif (scroll_term_str != NULL && *scroll_term_str != '\\0') {\n\t\tstr = scroll_term_str;\n\t} else {\n\t\tstr = scroll_term_str0;\n\t}\n\tif (!strcmp(str, \"none\")) {\n\t\treturn;\n\t}\n\tscroll_term = create_str_list(str);\n\n\tn = 0;\n\twhile (scroll_term[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\t/* pull parameters out at some point */\n\t\ts = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_term to: %s\\n\"",
            "scroll_term_str"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_term:\""
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(s)"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "s"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_term:\""
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_term\""
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_scroll_keys",
          "args": [],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_scroll_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "555-630",
          "snippet": "void initialize_scroll_keys(void) {\n\tchar *str, *p;\n\tint i, nkeys = 0, saw_builtin = 0;\n\tint ks_max = 2 * 0xFFFF;\n\n\tif (scroll_key_list) {\n\t\tfree(scroll_key_list);\n\t\tscroll_key_list = NULL;\n\t}\n\tif (! scroll_key_list_str || *scroll_key_list_str == '\\0') {\n\t\treturn;\n\t}\n\n\tif (strstr(scroll_key_list_str, \"builtin\")) {\n\t\tint k;\n\t\t/* add in number of keysyms builtin gives */\n\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\tnkeys++;\n\t\t\t}\n\t\t}\n\t}\n\n\tnkeys++;\t/* first key, i.e. no commas. */\n\tp = str = strdup(scroll_key_list_str);\n\twhile(*p) {\n\t\tif (*p == ',') {\n\t\t\tnkeys++;\t/* additional key. */\n\t\t}\n\t\tp++;\n\t}\n\t\n\tnkeys++;\t/* exclude/include 0 element */\n\tnkeys++;\t/* trailing NoSymbol */\n\n\tscroll_key_list = (KeySym *) malloc(nkeys*sizeof(KeySym)); \n\tfor (i=0; i<nkeys; i++) {\n\t\tscroll_key_list[i] = NoSymbol;\n\t}\n\tif (*str == '-') {\n\t\tscroll_key_list[0] = 1;\n\t\tp = strtok(str+1, \",\");\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\ti = 1;\n\twhile (p) {\n\t\tif (!strcmp(p, \"builtin\")) {\n\t\t\tint k;\n\t\t\tif (saw_builtin) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_builtin = 1;\n\t\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\t\tscroll_key_list[i++] = (rfbKeySym) k;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int in;\n\t\t\tif (sscanf(p, \"%u\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (XStringToKeysym(p) != NoSymbol) { \n\t\t\t\tscroll_key_list[i++] = XStringToKeysym(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"initialize_scroll_keys: skip unknown \"\n\t\t\t\t    \"keysym: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void initialize_scroll_keys(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_keys(void);\n\nvoid initialize_scroll_keys(void) {\n\tchar *str, *p;\n\tint i, nkeys = 0, saw_builtin = 0;\n\tint ks_max = 2 * 0xFFFF;\n\n\tif (scroll_key_list) {\n\t\tfree(scroll_key_list);\n\t\tscroll_key_list = NULL;\n\t}\n\tif (! scroll_key_list_str || *scroll_key_list_str == '\\0') {\n\t\treturn;\n\t}\n\n\tif (strstr(scroll_key_list_str, \"builtin\")) {\n\t\tint k;\n\t\t/* add in number of keysyms builtin gives */\n\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\tnkeys++;\n\t\t\t}\n\t\t}\n\t}\n\n\tnkeys++;\t/* first key, i.e. no commas. */\n\tp = str = strdup(scroll_key_list_str);\n\twhile(*p) {\n\t\tif (*p == ',') {\n\t\t\tnkeys++;\t/* additional key. */\n\t\t}\n\t\tp++;\n\t}\n\t\n\tnkeys++;\t/* exclude/include 0 element */\n\tnkeys++;\t/* trailing NoSymbol */\n\n\tscroll_key_list = (KeySym *) malloc(nkeys*sizeof(KeySym)); \n\tfor (i=0; i<nkeys; i++) {\n\t\tscroll_key_list[i] = NoSymbol;\n\t}\n\tif (*str == '-') {\n\t\tscroll_key_list[0] = 1;\n\t\tp = strtok(str+1, \",\");\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\ti = 1;\n\twhile (p) {\n\t\tif (!strcmp(p, \"builtin\")) {\n\t\t\tint k;\n\t\t\tif (saw_builtin) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_builtin = 1;\n\t\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\t\tscroll_key_list[i++] = (rfbKeySym) k;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int in;\n\t\t\tif (sscanf(p, \"%u\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (XStringToKeysym(p) != NoSymbol) { \n\t\t\t\tscroll_key_list[i++] = XStringToKeysym(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"initialize_scroll_keys: skip unknown \"\n\t\t\t\t    \"keysym: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_keys to: %s\\n\"",
            "scroll_key_list_str"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_keys:\""
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(scroll_key_list_str)"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scroll_key_list_str"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_keys:\""
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_keys\""
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_scroll_matches",
          "args": [],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_scroll_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "643-738",
          "snippet": "void initialize_scroll_matches(void) {\n\tchar *str, *imp = \"__IMPOSSIBLE_STR__\";\n\tint i, n, nkey, nmouse;\n\n\tdestroy_str_list(scroll_good_all);\n\tscroll_good_all = NULL;\n\tdestroy_str_list(scroll_good_key);\n\tscroll_good_key = NULL;\n\tdestroy_str_list(scroll_good_mouse);\n\tscroll_good_mouse = NULL;\n\n\tdestroy_str_list(scroll_skip_all);\n\tscroll_skip_all = NULL;\n\tdestroy_str_list(scroll_skip_key);\n\tscroll_skip_key = NULL;\n\tdestroy_str_list(scroll_skip_mouse);\n\tscroll_skip_mouse = NULL;\n\n\t/* scroll_good: */\n\tif (scroll_good_str != NULL && *scroll_good_str != '\\0') {\n\t\tstr = scroll_good_str;\n\t} else {\n\t\tstr = scroll_good_str0;\n\t}\n\tscroll_good_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_good_all[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_good_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_good_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_good_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_good_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_good_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_good_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_good_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t}\n\t}\n\n\t/* scroll_skip: */\n\tif (scroll_skip_str != NULL && *scroll_skip_str != '\\0') {\n\t\tstr = scroll_skip_str;\n\t} else {\n\t\tstr = scroll_skip_str0;\n\t}\n\tscroll_skip_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_skip_all[n] != NULL) {\n\t\tchar *s = scroll_skip_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_skip_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_skip_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_skip_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_skip_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_skip_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_skip_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_skip_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void initialize_scroll_matches(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_matches(void);\n\nvoid initialize_scroll_matches(void) {\n\tchar *str, *imp = \"__IMPOSSIBLE_STR__\";\n\tint i, n, nkey, nmouse;\n\n\tdestroy_str_list(scroll_good_all);\n\tscroll_good_all = NULL;\n\tdestroy_str_list(scroll_good_key);\n\tscroll_good_key = NULL;\n\tdestroy_str_list(scroll_good_mouse);\n\tscroll_good_mouse = NULL;\n\n\tdestroy_str_list(scroll_skip_all);\n\tscroll_skip_all = NULL;\n\tdestroy_str_list(scroll_skip_key);\n\tscroll_skip_key = NULL;\n\tdestroy_str_list(scroll_skip_mouse);\n\tscroll_skip_mouse = NULL;\n\n\t/* scroll_good: */\n\tif (scroll_good_str != NULL && *scroll_good_str != '\\0') {\n\t\tstr = scroll_good_str;\n\t} else {\n\t\tstr = scroll_good_str0;\n\t}\n\tscroll_good_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_good_all[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_good_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_good_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_good_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_good_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_good_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_good_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_good_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t}\n\t}\n\n\t/* scroll_skip: */\n\tif (scroll_skip_str != NULL && *scroll_skip_str != '\\0') {\n\t\tstr = scroll_skip_str;\n\t} else {\n\t\tstr = scroll_skip_str0;\n\t}\n\tscroll_skip_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_skip_all[n] != NULL) {\n\t\tchar *s = scroll_skip_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_skip_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_skip_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_skip_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_skip_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_skip_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_skip_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_skip_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_inc to: %s\\n\"",
            "scroll_good_str"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_inc:\""
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(s)"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "s"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_inc:\""
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_inc\""
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_skip to: %s\\n\"",
            "scroll_skip_str"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_skip:\""
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(s)"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "s"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_skip:\""
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_skip\""
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -scr_area to: %d\\n\"",
            "scrollcopyrect_min_area"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scr_area:\""
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "scrollcopyrect_min_area"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scr_area:\""
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scr_area\""
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_wirecopyrect_mode",
          "args": [
            "\"never\""
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "set_wirecopyrect_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "501-523",
          "snippet": "void set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%s\"",
            "p",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowcr\""
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowirecopyrect\""
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wcr:\""
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wcr:\""
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wcr\""
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\"",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wirecopyrect:\""
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(wireframe_copyrect)"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "wireframe_copyrect"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wirecopyrect:\""
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wirecopyrect\""
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -nowireframelocal mode.\\n\""
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!wireframe_local"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowfl\""
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowireframelocal\""
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -wireframelocal mode.\\n\""
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "wireframe_local"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wfl\""
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wireframelocal\""
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -nowireframe mode.\\n\""
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!wireframe"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowf\""
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nowireframe\""
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -wireframe mode.\\n\""
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "wireframe"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wf\""
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"wireframe\""
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -wireframe mode.\\n\""
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_wireframe",
          "args": [],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "parse_wireframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "490-496",
          "snippet": "void parse_wireframe(void) {\n\tparse_wireframe_str(WIREFRAME_PARMS);\n\tif (! wireframe_str) {\n\t\twireframe_str = strdup(WIREFRAME_PARMS);\n\t}\n\tparse_wireframe_str(wireframe_str);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void parse_wireframe(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_wireframe(void);\n\nvoid parse_wireframe(void) {\n\tparse_wireframe_str(WIREFRAME_PARMS);\n\tif (! wireframe_str) {\n\t\twireframe_str = strdup(WIREFRAME_PARMS);\n\t}\n\tparse_wireframe_str(wireframe_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wf:\""
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "wireframe"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wf:\""
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wf:\""
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -wireframe mode.\\n\""
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wireframe:\""
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "wireframe"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wireframe:\""
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wireframe:\""
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -wireframe mode.\\n\""
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wireframe_mode:\""
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "wireframe_str ? wireframe_str : WIREFRAME_PARMS"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"wireframe_mode:\""
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"wireframe_mode\""
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled debug_ncache\\n\""
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncdb"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodebug_ncache\""
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabled debug_ncache\\n\""
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncdb"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"debug_ncache\""
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "1",
            "0"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting ncache %d to: %d\\n\"",
            "orig",
            "ncache"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ncache_size:\""
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "ncache"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"ncache_size:\""
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ncache_size\""
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled ncache %d\\n\"",
            "ncache"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache\""
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set ncache %d\\n\"",
            "ncache"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!!ncache"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache\""
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting ncache_pad %d to: %d\\n\"",
            "orig",
            "n"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ncache_pad:\""
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "ncache_pad"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"ncache_pad:\""
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ncache_pad\""
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_old_wm\\n\""
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_old_wm"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_old_wm\""
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_old_wm\\n\""
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_old_wm"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_old_wm\""
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_keep_anims\\n\""
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kde_no_animate",
          "args": [
            "1"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "kde_no_animate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1055-1160",
          "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_keep_anims"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_keep_anims\""
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_keep_anims\\n\""
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_keep_anims"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_keep_anims\""
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ncache_xrootpmap",
          "args": [],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "set_ncache_xrootpmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8167-8238",
          "snippet": "void set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_ncache_xrootpmap(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_ncache_xrootpmap(void);\n\nvoid set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: resetting root pixmap.\\n\""
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_xrootpmap"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncrp\""
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_reset_rootpixmap\""
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_no_rootpixmap\\n\""
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_xrootpmap"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_no_rootpixmap\""
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_no_rootpixmap\\n\""
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_xrootpmap"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_no_rootpixmap\""
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_no_dt_change\\n\""
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_dt_change"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_no_dtchange\""
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_no_dt_change\\n\""
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_dt_change"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_no_dtchange\""
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_no_moveraise\\n\""
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_wf_raises"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_no_moveraise\""
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_no_moveraise\\n\""
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_wf_raises"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_no_moveraise\""
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -ncache_cr %d\\n\"",
            "ncache_copyrect"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ncache_copyrect"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noncache_cr\""
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -ncache_cr %d\\n\"",
            "ncache_copyrect"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ncache_copyrect"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ncache_cr\""
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling mouse nodragging mode.\\n\""
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!show_dragging"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodragging\""
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling mouse dragging mode.\\n\""
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "show_dragging"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"dragging\""
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_pointer_map",
          "args": [
            "p"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_pointer_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "253-335",
          "snippet": "void initialize_pointer_map(char *pointer_remap) {\n\tunsigned char map[MAX_BUTTONS];\n\tint i, k;\n\t/*\n\t * This routine counts the number of pointer buttons on the X\n\t * server (to avoid problems, even crashes, if a client has more\n\t * buttons).  And also initializes any pointer button remapping\n\t * from -buttonmap option.\n\t */\n\t\n\tif (!raw_fb_str) {\n#if NO_X11\n\t\tnum_buttons = 5;\n#else\n\t\tX_LOCK;\n\t\tnum_buttons = XGetPointerMapping(dpy, map, MAX_BUTTONS);\n\t\tX_UNLOCK;\n\t\trfbLog(\"The X server says there are %d mouse buttons.\\n\", num_buttons);\n#endif\n\t} else {\n\t\tnum_buttons = 5;\n\t\trfbLog(\"Manually set num_buttons to: %d\\n\", num_buttons);\n\t}\n\n\tif (num_buttons < 0) {\n\t\tnum_buttons = 0;\n\t}\n\n\t/* FIXME: should use info in map[] */\n\tfor (i=1; i<= MAX_BUTTONS; i++) {\n\t\tfor (k=0; k < MAX_BUTTON_EVENTS; k++) {\n\t\t\tpointer_map[i][k].end = 1;\n\t\t}\n\t\tpointer_map[i][0].keysym  = NoSymbol;\n\t\tpointer_map[i][0].keycode = NoSymbol;\n\t\tpointer_map[i][0].button = i;\n\t\tpointer_map[i][0].end    = 0;\n\t\tpointer_map[i][0].down   = 0;\n\t\tpointer_map[i][0].up     = 0;\n\t}\n\n\tif (pointer_remap && *pointer_remap != '\\0') {\n\t\t/* -buttonmap, format is like: 12-21=2 */\n\t\tchar *p, *q, *remap = strdup(pointer_remap);\t\n\t\tint n;\n\n\t\tif ((p = strchr(remap, '=')) != NULL) {\n\t\t\t/* undocumented max button number */\n\t\t\tn = atoi(p+1);\t\n\t\t\t*p = '\\0';\n\t\t\tif (n < num_buttons || num_buttons == 0) {\n\t\t\t\tnum_buttons = n;\n\t\t\t} else {\n\t\t\t\trfbLog(\"warning: increasing number of mouse \"\n\t\t\t\t    \"buttons from %d to %d\\n\", num_buttons, n);\n\t\t\t\tnum_buttons = n;\n\t\t\t}\n\t\t}\n\t\tif ((q = strchr(remap, '-')) != NULL) {\n\t\t\t/*\n\t\t\t * The '-' separates the 'from' and 'to' lists,\n\t\t\t * then it is kind of like tr(1).  \n\t\t\t */\n\t\t\tchar str[2];\n\t\t\tint from;\n\n\t\t\trfbLog(\"remapping pointer buttons using string:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", remap);\n\n\t\t\tp = remap;\n\t\t\tq++;\n\t\t\ti = 0;\n\t\t\tstr[1] = '\\0';\n\t\t\twhile (*p != '-') {\n\t\t\t\tstr[0] = *p;\n\t\t\t\tfrom = atoi(str);\n\t\t\t\tbuttonparse(from, &q);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tfree(remap);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_BUTTON_EVENTS 50"
          ],
          "globals_used": [
            "void initialize_pointer_map(char *pointer_remap);",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void buttonparse(int from, char **s);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);",
            "static prtremap_t pointer_map[MAX_BUTTONS+1][MAX_BUTTON_EVENTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define MAX_BUTTON_EVENTS 50\n\nvoid initialize_pointer_map(char *pointer_remap);\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void buttonparse(int from, char **s);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\nstatic prtremap_t pointer_map[MAX_BUTTONS+1][MAX_BUTTON_EVENTS];\n\nvoid initialize_pointer_map(char *pointer_remap) {\n\tunsigned char map[MAX_BUTTONS];\n\tint i, k;\n\t/*\n\t * This routine counts the number of pointer buttons on the X\n\t * server (to avoid problems, even crashes, if a client has more\n\t * buttons).  And also initializes any pointer button remapping\n\t * from -buttonmap option.\n\t */\n\t\n\tif (!raw_fb_str) {\n#if NO_X11\n\t\tnum_buttons = 5;\n#else\n\t\tX_LOCK;\n\t\tnum_buttons = XGetPointerMapping(dpy, map, MAX_BUTTONS);\n\t\tX_UNLOCK;\n\t\trfbLog(\"The X server says there are %d mouse buttons.\\n\", num_buttons);\n#endif\n\t} else {\n\t\tnum_buttons = 5;\n\t\trfbLog(\"Manually set num_buttons to: %d\\n\", num_buttons);\n\t}\n\n\tif (num_buttons < 0) {\n\t\tnum_buttons = 0;\n\t}\n\n\t/* FIXME: should use info in map[] */\n\tfor (i=1; i<= MAX_BUTTONS; i++) {\n\t\tfor (k=0; k < MAX_BUTTON_EVENTS; k++) {\n\t\t\tpointer_map[i][k].end = 1;\n\t\t}\n\t\tpointer_map[i][0].keysym  = NoSymbol;\n\t\tpointer_map[i][0].keycode = NoSymbol;\n\t\tpointer_map[i][0].button = i;\n\t\tpointer_map[i][0].end    = 0;\n\t\tpointer_map[i][0].down   = 0;\n\t\tpointer_map[i][0].up     = 0;\n\t}\n\n\tif (pointer_remap && *pointer_remap != '\\0') {\n\t\t/* -buttonmap, format is like: 12-21=2 */\n\t\tchar *p, *q, *remap = strdup(pointer_remap);\t\n\t\tint n;\n\n\t\tif ((p = strchr(remap, '=')) != NULL) {\n\t\t\t/* undocumented max button number */\n\t\t\tn = atoi(p+1);\t\n\t\t\t*p = '\\0';\n\t\t\tif (n < num_buttons || num_buttons == 0) {\n\t\t\t\tnum_buttons = n;\n\t\t\t} else {\n\t\t\t\trfbLog(\"warning: increasing number of mouse \"\n\t\t\t\t    \"buttons from %d to %d\\n\", num_buttons, n);\n\t\t\t\tnum_buttons = n;\n\t\t\t}\n\t\t}\n\t\tif ((q = strchr(remap, '-')) != NULL) {\n\t\t\t/*\n\t\t\t * The '-' separates the 'from' and 'to' lists,\n\t\t\t * then it is kind of like tr(1).  \n\t\t\t */\n\t\t\tchar str[2];\n\t\t\tint from;\n\n\t\t\trfbLog(\"remapping pointer buttons using string:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", remap);\n\n\t\t\tp = remap;\n\t\t\tq++;\n\t\t\ti = 0;\n\t\t\tstr[1] = '\\0';\n\t\t\twhile (*p != '-') {\n\t\t\t\tstr[0] = *p;\n\t\t\t\tfrom = atoi(str);\n\t\t\t\tbuttonparse(from, &q);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tfree(remap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\"",
            "p"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"buttonmap:\""
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(pointer_remap)"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "pointer_remap"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"buttonmap:\""
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"buttonmap\""
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off always_inject mode.\\n\""
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!always_inject"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noalways_inject\""
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on always_inject mode.\\n\""
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "always_inject"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"always_inject\""
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off xwarppointer mode.\\n\""
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_xwarppointer"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noxwarp\""
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noxwarppointer\""
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on xwarppointer mode.\\n\""
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_xwarppointer"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xwarp\""
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xwarppointer\""
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_cursors_and_push",
          "args": [],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cursors_and_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "876-879",
          "snippet": "void setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void first_cursor(void);",
            "void setup_cursors_and_push(void);",
            "static void setup_cursors(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid first_cursor(void);\nvoid setup_cursors_and_push(void);\nstatic void setup_cursors(void);\n\nvoid setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable alphablend\\n\""
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!alpha_blend"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noalphablend\""
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable alphablend\\n\""
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "alpha_blend"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"alphablend\""
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable alpharemove\\n\""
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!alpha_remove"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"noalpharemove\""
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable alpharemove\\n\""
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "alpha_remove"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"alpharemove\""
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\"",
            "alpha_frac",
            "a"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"alphafrac:\""
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%f\"",
            "p",
            "co",
            "alpha_frac"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"alphafrac:\""
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"alphafrac\""
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\""
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\"",
            "alpha_threshold",
            "a"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"alphacut:\""
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "alpha_threshold"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"alphacut:\""
          ],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"alphacut\""
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\"",
            "xdamage_memory",
            "a"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"xd_mem:\""
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%.3f\"",
            "p",
            "co",
            "xdamage_memory"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"xd_mem:\""
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xd_mem\""
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\"",
            "xdamage_max_area",
            "a"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"xd_area:\""
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "xdamage_max_area"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"xd_area:\""
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xd_area\""
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_xdamage_if_needed",
          "args": [],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "787-808",
          "snippet": "void destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void destroy_xdamage_if_needed(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid destroy_xdamage_if_needed(void);\n\nvoid destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_xdamage",
          "args": [],
          "line": 3296
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "736-768",
          "snippet": "void initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "void initialize_xdamage(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nvoid initialize_xdamage(void);\n\nvoid initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling xdamage hints.\\n\""
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\""
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_xdamage"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxdamage\""
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_xdamage_if_needed",
          "args": [
            "0"
          ],
          "line": 3278
        },
        "resolved": true,
        "details": {
          "function_name": "create_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "770-785",
          "snippet": "void create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void create_xdamage_if_needed(int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid create_xdamage_if_needed(int force);\n\nvoid create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\""
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\""
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_xdamage"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xdamage\""
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_cursor",
          "args": [],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "first_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "576-589",
          "snippet": "void first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int got_xfixes_cursor_notify = 0;",
            "void first_cursor(void);",
            "int get_which_cursor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint got_xfixes_cursor_notify = 0;\nvoid first_cursor(void);\nint get_which_cursor(void);\n\nvoid first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_xfixes",
          "args": [],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xfixes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "992-1006",
          "snippet": "void initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int xfixes_first_initialized = 0;",
            "int use_xfixes = 1;",
            "void initialize_xfixes(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint use_xfixes = 1;\nvoid initialize_xfixes(void);\n\nvoid initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -xfixes.\\n\""
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\""
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_xfixes"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxfixes\""
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\""
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\""
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_xfixes"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xfixes\""
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting alt_arrow: %d.\\n\"",
            "alt_arrow"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"arrow:\""
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "alt_arrow"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"arrow:\""
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"arrow\""
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_cursors_mode",
          "args": [],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_cursors_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1470-1510",
          "snippet": "void initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void initialize_cursors_mode(void);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nunsigned long get_cursor_serial(int mode);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nvoid initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling show_cursor.\\n\""
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "multiple_cursors_mode"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!show_cursor"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocursor\""
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noshow_cursor\""
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\"",
            "multiple_cursors_mode"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "prev_cursors_mode"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"none\""
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling show_cursor.\\n\""
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "show_cursor"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"show_cursor\""
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\"",
            "show_cursor"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"none\""
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\"",
            "multiple_cursors_mode"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "multiple_cursors_mode"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cursor:\""
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(multiple_cursors_mode)"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "multiple_cursors_mode"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"cursor:\""
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"cursor\""
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting cursor_drag_changes: %d.\\n\"",
            "cursor_drag_changes"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!cursor_drag_changes"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocursor_drag\""
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting cursor_drag_changes: %d.\\n\"",
            "cursor_drag_changes"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "cursor_drag_changes"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cursor_drag\""
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off cursorpos mode.\\n\""
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!cursor_pos_updates"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocursorpos\""
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on cursorpos mode.\\n\""
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "cursor_pos_updates"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cursorpos\""
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_cursor_shape_updates",
          "args": [
            "screen"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "disable_cursor_shape_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1711-1750",
          "snippet": "void disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_no_cursor",
          "args": [],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "set_no_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1955-1957",
          "snippet": "void set_no_cursor(void) {\n\tset_rfb_cursor(CURS_EMPTY);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_no_cursor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_no_cursor(void);\n\nvoid set_no_cursor(void) {\n\tset_rfb_cursor(CURS_EMPTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off cursorshape mode.\\n\""
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!cursor_shape_updates"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocursorshape\""
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_cursor_shape_updates",
          "args": [
            "screen"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "restore_cursor_shape_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1675-1709",
          "snippet": "void restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on cursorshape mode.\\n\""
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "cursor_shape_updates"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"cursorshape\""
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: calling set_no_cursor()\\n\""
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"set_no_cursor\""
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting -seldir to %s\\n\"",
            "p"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"seldir:\""
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(sel_direction)"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "sel_direction"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"seldir:\""
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"seldir\""
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling set_clipboard.\\n\""
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!set_clipboard"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosetclipboard\""
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling set_clipboard.\\n\""
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "set_clipboard"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"setclipboard\""
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling watch_clipboard.\\n\""
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_clipboard"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noclipboard\""
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling watch_clipboard.\\n\""
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_clipboard"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clipboard\""
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling set_primary.\\n\""
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!set_primary"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosetprimary\""
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling set_primary.\\n\""
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "set_primary"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"setprimary\""
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling watch_primary.\\n\""
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_primary"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noprimary\""
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling watch_primary.\\n\""
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_primary"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"primary\""
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling watch selection+primary.\\n\""
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_selection"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosel\""
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling watch selection+primary.\\n\""
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_selection"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"sel\""
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendBell",
          "args": [
            "screen"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"sendbell\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_watch_bell",
          "args": [],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_watch_bell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xkb_bell.c",
          "lines": "141-144",
          "snippet": "void initialize_watch_bell(void) {\n\twatch_bell = 0;\n\tsound_bell = 0;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_watch_bell(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_watch_bell(void);\n\nvoid initialize_watch_bell(void) {\n\twatch_bell = 0;\n\tsound_bell = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling bell.\\n\""
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!sound_bell"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nobell\""
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling bell (if supported).\\n\""
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "sound_bell"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"bell\""
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nofb_params",
          "args": [
            "0"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "set_nofb_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "511-603",
          "snippet": "void set_nofb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int save[100];\n\tstatic char *scroll = NULL;\n\tint i = 0;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tsave[i++] = use_xfixes;\n\t\tsave[i++] = use_xdamage;\n\t\tsave[i++] = use_xrecord;\n\t\tsave[i++] = wireframe;\n\t\tsave[i++] = use_solid_bg;\n\t\tsave[i++] = overlay;\n\t\tsave[i++] = overlay_cursor;\n\t\tsave[i++] = using_shm;\n\t\tsave[i++] = single_copytile;\n\t\tsave[i++] = take_naps;\n\t\tsave[i++] = measure_speeds;\n\t\tsave[i++] = grab_buster;\n\t\tsave[i++] = show_cursor;\n\t\tsave[i++] = cursor_shape_updates;\n\t\tsave[i++] = cursor_pos_updates;\n\t\tsave[i++] = ncache;\n\n\t\tscroll = scroll_copyrect;\n\t}\n\tif (restore) {\n\t\ti = 0;\n\t\tuse_xfixes            = save[i++];\n\t\tuse_xdamage           = save[i++];\n\t\tuse_xrecord           = save[i++];\n\t\twireframe             = save[i++];\n\t\tuse_solid_bg          = save[i++];\n\t\toverlay               = save[i++];\n\t\toverlay_cursor        = save[i++];\n\t\tusing_shm             = save[i++];\n\t\tsingle_copytile       = save[i++];\n\t\ttake_naps             = save[i++];\n\t\tmeasure_speeds        = save[i++];\n\t\tgrab_buster           = save[i++];\n\t\tshow_cursor           = save[i++];\n\t\tcursor_shape_updates  = save[i++];\n\t\tcursor_pos_updates    = save[i++];\n\t\tncache                = save[i++];\n\n\t\tscroll_copyrect = scroll;\n\n\t\tif (cursor_shape_updates) {\n\t\t\trestore_cursor_shape_updates(screen);\n\t\t}\n\t\tinitialize_cursors_mode();\n\n\t\treturn;\n\t}\n\n\tuse_xfixes = 0;\n\tuse_xdamage = 0;\n\tuse_xrecord = 0;\n\twireframe = 0;\n\n\tuse_solid_bg = 0;\n\toverlay = 0;\n\toverlay_cursor = 0;\n\n\tusing_shm = 0;\n\tsingle_copytile = 1;\n\n\ttake_naps = 0;\n\tmeasure_speeds = 0;\n\n\t/* got_grab_buster? */\n\tgrab_buster = 0;\n\n\tshow_cursor = 0;\n\tshow_multiple_cursors = 0;\n\tcursor_shape_updates = 0;\n\tif (! got_cursorpos) {\n\t\tcursor_pos_updates = 0;\n\t}\n\n\tncache = 0;\n\n\tscroll_copyrect = \"never\";\n\n\tif (! quiet) {\n\t\trfbLog(\"disabling: xfixes, xdamage, solid, overlay, shm,\\n\");\n\t\trfbLog(\"  wireframe, scrollcopyrect, ncache,\\n\");\n\t\trfbLog(\"  noonetile, nap, cursor, %scursorshape\\n\",\n\t\t    got_cursorpos ? \"\" : \"cursorpos, \" );\n\t\trfbLog(\"  in -nofb mode.\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_nofb_params(int restore);",
            "void set_raw_fb_params(int restore);",
            "int parse_rotate_string(char *str, int *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_nofb_params(int restore);\nvoid set_raw_fb_params(int restore);\nint parse_rotate_string(char *str, int *mode);\n\nvoid set_nofb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int save[100];\n\tstatic char *scroll = NULL;\n\tint i = 0;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tsave[i++] = use_xfixes;\n\t\tsave[i++] = use_xdamage;\n\t\tsave[i++] = use_xrecord;\n\t\tsave[i++] = wireframe;\n\t\tsave[i++] = use_solid_bg;\n\t\tsave[i++] = overlay;\n\t\tsave[i++] = overlay_cursor;\n\t\tsave[i++] = using_shm;\n\t\tsave[i++] = single_copytile;\n\t\tsave[i++] = take_naps;\n\t\tsave[i++] = measure_speeds;\n\t\tsave[i++] = grab_buster;\n\t\tsave[i++] = show_cursor;\n\t\tsave[i++] = cursor_shape_updates;\n\t\tsave[i++] = cursor_pos_updates;\n\t\tsave[i++] = ncache;\n\n\t\tscroll = scroll_copyrect;\n\t}\n\tif (restore) {\n\t\ti = 0;\n\t\tuse_xfixes            = save[i++];\n\t\tuse_xdamage           = save[i++];\n\t\tuse_xrecord           = save[i++];\n\t\twireframe             = save[i++];\n\t\tuse_solid_bg          = save[i++];\n\t\toverlay               = save[i++];\n\t\toverlay_cursor        = save[i++];\n\t\tusing_shm             = save[i++];\n\t\tsingle_copytile       = save[i++];\n\t\ttake_naps             = save[i++];\n\t\tmeasure_speeds        = save[i++];\n\t\tgrab_buster           = save[i++];\n\t\tshow_cursor           = save[i++];\n\t\tcursor_shape_updates  = save[i++];\n\t\tcursor_pos_updates    = save[i++];\n\t\tncache                = save[i++];\n\n\t\tscroll_copyrect = scroll;\n\n\t\tif (cursor_shape_updates) {\n\t\t\trestore_cursor_shape_updates(screen);\n\t\t}\n\t\tinitialize_cursors_mode();\n\n\t\treturn;\n\t}\n\n\tuse_xfixes = 0;\n\tuse_xdamage = 0;\n\tuse_xrecord = 0;\n\twireframe = 0;\n\n\tuse_solid_bg = 0;\n\toverlay = 0;\n\toverlay_cursor = 0;\n\n\tusing_shm = 0;\n\tsingle_copytile = 1;\n\n\ttake_naps = 0;\n\tmeasure_speeds = 0;\n\n\t/* got_grab_buster? */\n\tgrab_buster = 0;\n\n\tshow_cursor = 0;\n\tshow_multiple_cursors = 0;\n\tcursor_shape_updates = 0;\n\tif (! got_cursorpos) {\n\t\tcursor_pos_updates = 0;\n\t}\n\n\tncache = 0;\n\n\tscroll_copyrect = \"never\";\n\n\tif (! quiet) {\n\t\trfbLog(\"disabling: xfixes, xdamage, solid, overlay, shm,\\n\");\n\t\trfbLog(\"  wireframe, scrollcopyrect, ncache,\\n\");\n\t\trfbLog(\"  noonetile, nap, cursor, %scursorshape\\n\",\n\t\t    got_cursorpos ? \"\" : \"cursorpos, \" );\n\t\trfbLog(\"  in -nofb mode.\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_black_screen",
          "args": [
            "4"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "push_black_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "502-515",
          "snippet": "void push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void push_sleep(int n);",
            "void push_black_screen(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling nofb mode.\\n\""
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "nofb"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nofb\""
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"     cursorpos, cursorshape, bell.\\n\""
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"     overlay, shm, noonetile, nap, cursor\\n\""
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"     xfixes, xdamage, solid, flashcmap\\n\""
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  you may need to these turn back on:\\n\""
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling nofb mode.\\n\""
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!nofb"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"fb\""
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "0",
            "0"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -norepeat mode.\\n\""
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "no_autorepeat"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"norepeat\""
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -repeat mode.\\n\""
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!no_autorepeat"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"repeat\""
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_remap",
          "args": [
            "remap_file"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "804-878",
          "snippet": "void initialize_remap(char *infile) {\n\tFILE *in;\n\tchar *p, *q, line[256];\n\n\tif (keyremaps != NULL) {\n\t\t/* free last remapping */\n\t\tkeyremap_t *next_remap, *curr_remap = keyremaps;\n\t\twhile (curr_remap != NULL) {\n\t\t\tnext_remap = curr_remap->next;\n\t\t\tfree(curr_remap);\n\t\t\tcurr_remap = next_remap;\n\t\t}\n\t\tkeyremaps = NULL;\n\t}\n\tif (infile == NULL || *infile == '\\0') {\n\t\t/* just unset remapping */\n\t\treturn;\n\t}\n\n\tin = fopen(infile, \"r\"); \n\tif (in == NULL) {\n\t\t/* assume cmd line key1-key2,key3-key4 */\n\t\tif (strstr(infile, \"DEAD\") == infile) {\n\t\t\t;\n\t\t} else if (!strchr(infile, '-')) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"remap: cannot open: %s\\n\", infile);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif ((in = tmpfile()) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"remap: cannot open tmpfile for %s\\n\", infile);\n\t\t\trfbLogPerror(\"tmpfile\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/* copy in the string to file format */\n\t\tp = infile;\n\t\twhile (*p) {\n\t\t\tif (*p == '-') {\n\t\t\t\tfprintf(in, \" \");\n\t\t\t} else if (*p == ',' || *p == ' ' ||  *p == '\\t') {\n\t\t\t\tfprintf(in, \"\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"%c\", *p);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tfprintf(in, \"\\n\");\n\t\tfflush(in);\t\n\t\trewind(in);\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tp = lblanks(line);\n\t\tif (*p == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(line, '#')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(p, \"DEAD\") == p)  {\n\t\t\tadd_dead_keysyms(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((q = strchr(line, '-')) != NULL) {\n\t\t\t/* allow Keysym1-Keysym2 notation */\n\t\t\t*q = ' ';\t\n\t\t}\n\t\tadd_remap(p);\n\t}\n\tfclose(in);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_remap(char *infile);",
            "static void add_remap(char *line);",
            "static keyremap_t *keyremaps = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_remap(char *infile);\nstatic void add_remap(char *line);\nstatic keyremap_t *keyremaps = NULL;\n\nvoid initialize_remap(char *infile) {\n\tFILE *in;\n\tchar *p, *q, line[256];\n\n\tif (keyremaps != NULL) {\n\t\t/* free last remapping */\n\t\tkeyremap_t *next_remap, *curr_remap = keyremaps;\n\t\twhile (curr_remap != NULL) {\n\t\t\tnext_remap = curr_remap->next;\n\t\t\tfree(curr_remap);\n\t\t\tcurr_remap = next_remap;\n\t\t}\n\t\tkeyremaps = NULL;\n\t}\n\tif (infile == NULL || *infile == '\\0') {\n\t\t/* just unset remapping */\n\t\treturn;\n\t}\n\n\tin = fopen(infile, \"r\"); \n\tif (in == NULL) {\n\t\t/* assume cmd line key1-key2,key3-key4 */\n\t\tif (strstr(infile, \"DEAD\") == infile) {\n\t\t\t;\n\t\t} else if (!strchr(infile, '-')) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"remap: cannot open: %s\\n\", infile);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif ((in = tmpfile()) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"remap: cannot open tmpfile for %s\\n\", infile);\n\t\t\trfbLogPerror(\"tmpfile\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\t/* copy in the string to file format */\n\t\tp = infile;\n\t\twhile (*p) {\n\t\t\tif (*p == '-') {\n\t\t\t\tfprintf(in, \" \");\n\t\t\t} else if (*p == ',' || *p == ' ' ||  *p == '\\t') {\n\t\t\t\tfprintf(in, \"\\n\");\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"%c\", *p);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tfprintf(in, \"\\n\");\n\t\tfflush(in);\t\n\t\trewind(in);\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tp = lblanks(line);\n\t\tif (*p == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strchr(line, '#')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(p, \"DEAD\") == p)  {\n\t\t\tadd_dead_keysyms(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((q = strchr(line, '-')) != NULL) {\n\t\t\t/* allow Keysym1-Keysym2 notation */\n\t\t\t*q = ' ';\t\n\t\t}\n\t\tadd_remap(p);\n\t}\n\tfclose(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   %s\\n\"",
            "remap_file"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: %s\\n\"",
            "before"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changed -remap\\n\""
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "remap_file"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "remap_file",
            "'-'"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_item",
          "args": [
            "remap_file",
            "p"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "delete_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "301-327",
          "snippet": "static char *delete_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(\"\");\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item) || *p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\treturn str;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *add_item(char *instr, char *item);",
            "static char *delete_item(char *instr, char *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *add_item(char *instr, char *item);\nstatic char *delete_item(char *instr, char *item);\n\nstatic char *delete_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(\"\");\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item) || *p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_item",
          "args": [
            "remap_file",
            "p"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "261-299",
          "snippet": "static char *add_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len, saw_item = 0;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(item);\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1 + strlen(item) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item)) {\n\t\t\tif (saw_item) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_item = 1;\n\t\t} else if (*p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tif (! saw_item) {\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, item);\n\t}\n\treturn str;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *add_item(char *instr, char *item);",
            "static char *delete_item(char *instr, char *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *add_item(char *instr, char *item);\nstatic char *delete_item(char *instr, char *item);\n\nstatic char *add_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len, saw_item = 0;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(item);\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1 + strlen(item) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item)) {\n\t\t\tif (saw_item) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_item = 1;\n\t\t} else if (*p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tif (! saw_item) {\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, item);\n\t}\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "remap_file"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"in '-remap %s' mode.\\n\"",
            "remap_file"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot use remap:+/-\\n\""
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "remap_file",
            "'/'"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"remap:\""
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(remap_file)"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "remap_file"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"remap:\""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"remap\""
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"keystate[%03d] %d\\n\"",
            "i",
            "state[i]"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_keystate",
          "args": [
            "state"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "get_keystate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "94-120",
          "snippet": "void get_keystate(int *keystate) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!keystate) {}\n\treturn;\n#else\n\tint i, k;\n\tchar keys[32];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tXQueryKeymap(dpy, keys);\n\tfor (i=0; i<32; i++) {\n\t\tchar c = keys[i];\n\n\t\tfor (k=0; k < 8; k++) {\n\t\t\tif (c & 0x1) {\n\t\t\t\tkeystate[8*i + k] = 1;\n\t\t\t} else {\n\t\t\t\tkeystate[8*i + k] = 0;\n\t\t\t}\n\t\t\tc = c >> 1;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\n\nvoid get_keystate(int *keystate) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!keystate) {}\n\treturn;\n#else\n\tint i, k;\n\tchar keys[32];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tXQueryKeymap(dpy, keys);\n\tfor (i=0; i<32; i++) {\n\t\tchar c = keys[i];\n\n\t\tfor (k=0; k < 8; k++) {\n\t\t\tif (c & 0x1) {\n\t\t\t\tkeystate[8*i + k] = 1;\n\t\t\t} else {\n\t\t\t\tkeystate[8*i + k] = 0;\n\t\t\t}\n\t\t\tc = c >> 1;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"keystate\""
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_locks",
          "args": [],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "clear_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "289-349",
          "snippet": "void clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clear_locks(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clear_locks(void);\n\nvoid clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_locks\""
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_keys",
          "args": [],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "clear_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "271-286",
          "snippet": "void clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_keys(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_keys(void);\n\nvoid clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: doing clear_all action.\\n\""
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "clear_mods == 3"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_all\""
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -clear_keys mode.\\n\""
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!(clear_mods == 2)"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noclear_keys\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -clear_keys mode.\\n\""
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "clear_mods == 2"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_keys\""
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -clear_mods mode.\\n\""
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!(clear_mods == 1)"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noclear_mods\""
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_modifiers",
          "args": [
            "0"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "clear_modifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "125-197",
          "snippet": "void clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_modifiers(int init);",
            "int add_keysym(KeySym keysym);",
            "char *short_kmbcf(char *str);",
            "static void add_dead_keysyms(char *str);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_modifiers(int init);\nint add_keysym(KeySym keysym);\nchar *short_kmbcf(char *str);\nstatic void add_dead_keysyms(char *str);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\n\nvoid clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -clear_mods mode.\\n\""
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "clear_mods == 1"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clear_mods\""
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -add_keysyms mode.\\n\""
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!add_keysyms"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noadd_keysyms\""
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -add_keysyms mode.\\n\""
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "add_keysyms"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"add_keysyms\""
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -skip_dups mode\\n\""
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!skip_duplicate_key_events"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noskip_dups\""
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -skip_dups mode\\n\""
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "skip_duplicate_key_events"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"skip_dups\""
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set sloppy_keys to: %d\\n\"",
            "sloppy_keys"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!sloppy_keys"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosloppy_keys\""
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set sloppy_keys to: %d\\n\"",
            "sloppy_keys"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "sloppy_keys"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"sloppy_keys\""
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_modtweak",
          "args": [],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_modtweak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2509-2613",
          "snippet": "void initialize_modtweak(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tKeySym keysym, *keymap;\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tint use_lowest_index = 0;\n\n\tif (use_xkb_modtweak) {\n\t\tinitialize_xkb_modtweak();\n\t\treturn;\n\t}\n\tmemset(modifiers, -1, sizeof(modifiers));\n\tfor (i=0; i<0x100; i++) {\n\t\tkeycodes[i] = NoSymbol;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (getenv(\"MODTWEAK_LOWEST\")) {\n\t\tuse_lowest_index = 1;\n\t}\n\n\tX_LOCK;\n\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t    &syms_per_keycode);\n\n\t/* handle alphabetic char with only one keysym (no upper + lower) */\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tKeySym lower, upper;\n\t\t/* 2nd one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 1];\n\t\tif (keysym != NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* 1st one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 0];\n\t\tif (keysym == NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\tXConvertCase(keysym, &lower, &upper);\n\t\tif (lower != upper) {\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 0] = lower;\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 1] = upper;\n\t\t}\n\t}\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tif (debug_keyboard) {\n\t\t\tif (i == minkey) {\n\t\t\t\trfbLog(\"initialize_modtweak: keycode -> \"\n\t\t\t\t    \"keysyms mapping info:\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  %03d  \", i);\n\t\t}\n\t\tfor (j = 0; j < syms_per_keycode; j++) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\tchar *sym;\n#if 0\n\t\t\t\tsym =XKeysymToString(XKeycodeToKeysym_wr(dpy,i,j));\n#else\n\t\t\t\tkeysym = keymap[(i-minkey)*syms_per_keycode+j];\n\t\t\t\tsym = XKeysymToString(keysym);\n#endif\n\t\t\t\tfprintf(stderr, \"%-18s \", sym ? sym : \"null\");\n\t\t\t\tif (j == syms_per_keycode - 1) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 4) {\n\t\t\t\t/*\n\t\t\t\t * Something wacky in the keymapping.\n\t\t\t\t * Ignore these non Shift/AltGr chords\n\t\t\t\t * for now... n.b. we try to automatically\n\t\t\t\t * switch to -xkb for this case.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif ( keysym >= ' ' && keysym < 0x100\n\t\t\t    && i == XKeysymToKeycode(dpy, keysym) ) {\n\t\t\t\tif (use_lowest_index && keycodes[keysym] != NoSymbol) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tkeycodes[keysym] = i;\n\t\t\t\tmodifiers[keysym] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tleft_shift_code = XKeysymToKeycode(dpy, XK_Shift_L);\n\tright_shift_code = XKeysymToKeycode(dpy, XK_Shift_R);\n\taltgr_code = XKeysymToKeycode(dpy, XK_Mode_switch);\n\tiso_level3_code = NoSymbol;\n#ifdef XK_ISO_Level3_Shift\n\tiso_level3_code = XKeysymToKeycode(dpy, XK_ISO_Level3_Shift);\n#endif\n\n\tXFree_wr ((void *) keymap);\n\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int add_keysym(KeySym keysym);",
            "void initialize_modtweak(void);",
            "static void initialize_xkb_modtweak(void);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];",
            "static KeyCode left_shift_code, right_shift_code, altgr_code, iso_level3_code;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint add_keysym(KeySym keysym);\nvoid initialize_modtweak(void);\nstatic void initialize_xkb_modtweak(void);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\nstatic KeyCode left_shift_code, right_shift_code, altgr_code, iso_level3_code;\n\nvoid initialize_modtweak(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tKeySym keysym, *keymap;\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tint use_lowest_index = 0;\n\n\tif (use_xkb_modtweak) {\n\t\tinitialize_xkb_modtweak();\n\t\treturn;\n\t}\n\tmemset(modifiers, -1, sizeof(modifiers));\n\tfor (i=0; i<0x100; i++) {\n\t\tkeycodes[i] = NoSymbol;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (getenv(\"MODTWEAK_LOWEST\")) {\n\t\tuse_lowest_index = 1;\n\t}\n\n\tX_LOCK;\n\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t    &syms_per_keycode);\n\n\t/* handle alphabetic char with only one keysym (no upper + lower) */\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tKeySym lower, upper;\n\t\t/* 2nd one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 1];\n\t\tif (keysym != NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* 1st one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 0];\n\t\tif (keysym == NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\tXConvertCase(keysym, &lower, &upper);\n\t\tif (lower != upper) {\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 0] = lower;\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 1] = upper;\n\t\t}\n\t}\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tif (debug_keyboard) {\n\t\t\tif (i == minkey) {\n\t\t\t\trfbLog(\"initialize_modtweak: keycode -> \"\n\t\t\t\t    \"keysyms mapping info:\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  %03d  \", i);\n\t\t}\n\t\tfor (j = 0; j < syms_per_keycode; j++) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\tchar *sym;\n#if 0\n\t\t\t\tsym =XKeysymToString(XKeycodeToKeysym_wr(dpy,i,j));\n#else\n\t\t\t\tkeysym = keymap[(i-minkey)*syms_per_keycode+j];\n\t\t\t\tsym = XKeysymToString(keysym);\n#endif\n\t\t\t\tfprintf(stderr, \"%-18s \", sym ? sym : \"null\");\n\t\t\t\tif (j == syms_per_keycode - 1) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 4) {\n\t\t\t\t/*\n\t\t\t\t * Something wacky in the keymapping.\n\t\t\t\t * Ignore these non Shift/AltGr chords\n\t\t\t\t * for now... n.b. we try to automatically\n\t\t\t\t * switch to -xkb for this case.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif ( keysym >= ' ' && keysym < 0x100\n\t\t\t    && i == XKeysymToKeycode(dpy, keysym) ) {\n\t\t\t\tif (use_lowest_index && keycodes[keysym] != NoSymbol) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tkeycodes[keysym] = i;\n\t\t\t\tmodifiers[keysym] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tleft_shift_code = XKeysymToKeycode(dpy, XK_Shift_L);\n\tright_shift_code = XKeysymToKeycode(dpy, XK_Shift_R);\n\taltgr_code = XKeysymToKeycode(dpy, XK_Mode_switch);\n\tiso_level3_code = NoSymbol;\n#ifdef XK_ISO_Level3_Shift\n\tiso_level3_code = XKeysymToKeycode(dpy, XK_ISO_Level3_Shift);\n#endif\n\n\tXFree_wr ((void *) keymap);\n\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on modtweak.\\n\""
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on xkb.\\n\""
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: warning xkb not present\\n\""
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\"",
            "p"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"skip_keycodes:\""
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(skip_keycodes)"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "skip_keycodes"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"skip_keycodes:\""
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"skip_keycodes\""
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -skip_lockkeys mode\\n\""
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!skip_lockkeys"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noskip_lockkeys\""
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -skip_lockkeys mode\\n\""
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "skip_lockkeys"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"skip_lockkeys\""
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -capslock mode\\n\""
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!watch_capslock"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nocapslock\""
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -capslock mode\\n\""
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "watch_capslock"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"capslock\""
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -xkb modtweak mode.\\n\""
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\""
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_xkb_modtweak"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxkb\""
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\""
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\""
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_xkb_modtweak"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xkb\""
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -nomodtweak mode.\\n\""
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_modifier_tweak"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomodtweak\""
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -modtweak mode.\\n\""
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_modifier_tweak"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"modtweak\""
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off quiet mode.\\n\""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!quiet"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noquiet\""
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on quiet mode.\\n\""
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "quiet"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"q\""
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"quiet\""
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set padgeom to: %s\\n\"",
            "pad_geometry"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_padded_fb",
          "args": [
            "pad_geometry"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "install_padded_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1129-1149",
          "snippet": "void install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_padded_fb(char *geom);",
            "static void install_fake_fb(int w, int h, int bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void install_fake_fb(int w, int h, int bpp);\n\nvoid install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: invoking install_padded_fb()\\n\""
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"go\"",
            "p"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"do\"",
            "p"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"force\"",
            "p"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"padgeom:\""
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(pad_geometry)"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "pad_geometry"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"padgeom:\""
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"padgeom\""
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set rotate to \\\"%s\\\"\\n\"",
            "rotating_str"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rotate:\""
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(rotating_str)"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "rotating_str"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"rotate:\""
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rotate\""
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: XRANDR ext. not present.\\n\""
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xrandr",
          "args": [],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xrandr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "61-84",
          "snippet": "void initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "void initialize_xrandr(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nvoid initialize_xrandr(void);\n\nvoid initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable xrandr mode.\\n\""
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable xrandr mode.\\n\""
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping unknown xrandr mode: %s\\n\"",
            "p"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_xrandr_mode",
          "args": [
            "p"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "known_xrandr_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "292-305",
          "snippet": "int known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_xrandr_mode(char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\n\nint known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"none\"",
            "p"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"xrandr_mode:\""
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(xrandr_mode)"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "xrandr_mode"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"xrandr_mode:\""
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"xrandr_mode\""
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: XRANDR ext. not present.\\n\""
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable xrandr mode.\\n\""
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!xrandr"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxrandr\""
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: XRANDR ext. not present.\\n\""
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable xrandr mode.\\n\""
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "xrandr"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xrandr\""
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_grabserver",
          "args": [
            "dpy",
            "1"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "disable_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1313-1372",
          "snippet": "void disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void disable_grabserver(Display *in_dpy, int change);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid disable_grabserver(Display *in_dpy, int change);\n\nvoid disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\""
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!xtrap_input"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxtrap\""
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\""
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "xtrap_input"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xtrap\""
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_blackouts_and_xinerama",
          "args": [],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_blackouts_and_xinerama",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "471-487",
          "snippet": "void initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int blackouts = 0;",
            "void initialize_blackouts_and_xinerama(void);",
            "static void blackout_tiles(void);",
            "static void initialize_xinerama (void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint blackouts = 0;\nvoid initialize_blackouts_and_xinerama(void);\nstatic void blackout_tiles(void);\nstatic void initialize_xinerama (void);\n\nvoid initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable xinerama mode. (if applicable).\\n\""
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!xinerama"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noxinerama\""
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable xinerama mode. (if applicable).\\n\""
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "xinerama"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"xinerama\""
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"resetting single_copytile to: %d\\n\"",
            "single_copytile_orig"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "blackout_str",
            "\"\""
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   %s\\n\"",
            "blackout_str"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: %s\\n\"",
            "before"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: changing -blackout\\n\""
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "blackout_str"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "blackout_str"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"blackout:\""
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(blackout_str)"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "blackout_str"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"blackout:\""
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"blackout\""
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "1"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable -solid mode\\n\""
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!use_solid_bg"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nosolid\""
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_default"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable -solid mode\\n\""
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "use_solid_bg"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"solid\""
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "solid_str",
            "newc"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: solid %s -> %s\\n\"",
            "NONUL(solid_str)",
            "newc"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "solid_str"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_default"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"solid_color:\""
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(solid_str)"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "solid_str"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"solid_color:\""
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"solid_color\""
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\"",
            "tile_shm_count",
            "ntiles_x"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable -onetile mode.\\n\""
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!single_copytile"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noonetile\""
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable -onetile mode.\\n\""
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "single_copytile"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"onetile\""
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  using shm, not resetting fb\\n\""
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off flipbyteorder mode.\\n\""
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!flip_byte_order"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noflipbyteorder\""
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  using shm, not resetting fb\\n\""
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on flipbyteorder mode.\\n\""
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "flip_byte_order"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"flipbyteorder\""
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" already in noshm mode.\\n\""
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on noshm mode.\\n\""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!using_shm"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noshm\""
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" already in shm mode.\\n\""
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off noshm mode.\\n\""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "using_shm"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"shm\""
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsafe: %s\\n\"",
            "p"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"popup\""
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"\""
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"gone:\""
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(gone_cmd)"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "gone_cmd"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"gone:\""
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"gone\""
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsafe: %s\\n\"",
            "p"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"\""
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"afteraccept:\""
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(afteraccept_cmd)"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "afteraccept_cmd"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"afteraccept:\""
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"afteraccept\""
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsafe: %s\\n\"",
            "p"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"popup\""
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"\""
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"accept:\""
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(accept_cmd)"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "accept_cmd"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"accept:\""
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"accept\""
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling hostname lookup.\\n\""
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!host_lookup"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nolookup\""
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling hostname lookup.\\n\""
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "host_lookup"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"lookup\""
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid listen string: %s\\n\"",
            "listen_str"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"allow list is: '%s'\\n\"",
            "NONUL(allow_list)"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allow_list"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting -allow list to 127.0.0.1\\n\""
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\""
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allow_list",
            "\"localhost\""
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allow_list",
            "\"127.0.0.1\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "listen_str"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_NONE"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "listen_str"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_str",
            "\"localhost\""
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_str",
            "\"any\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   \\\"%s\\\"\\n\"",
            "listen_str"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: \\\"%s\\\"\\n\"",
            "before"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: modified listen_str:\\n\""
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "listen_str"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"listen:\""
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "listen_str"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot change listen in -unixpw\\n\""
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(listen_str)"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "listen_str"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"listen:\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"listen\""
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"allow list is: '%s'\\n\"",
            "NONUL(allow_list)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allow_list"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listening on ALL network interfaces.\\n\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   \\\"%s\\\"\\n\"",
            "allow_list"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: \\\"%s\\\"\\n\"",
            "before"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: modified allow_list:\\n\""
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "allow_list"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allow_list"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot change localhost in -unixpw\\n\""
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!state"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"localhost\""
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"127.0.0.1\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nolocalhost\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"allow list is: '%s'\\n\"",
            "NONUL(allow_list)"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allow_list"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listening on loopback network only.\\n\""
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"localhost\""
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   \\\"%s\\\"\\n\"",
            "allow_list"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: \\\"%s\\\"\\n\"",
            "before"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: modified allow_list:\\n\""
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "allow_list"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allow_list"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "state"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"localhost\""
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"127.0.0.1\""
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"localhost\""
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "https_port",
          "args": [
            "1"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "https_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2902-2984",
          "snippet": "void https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "void openssl_port(int restart);",
            "void https_port(int restart);",
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid openssl_port(int restart);\nvoid https_port(int restart);\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabling -6 IPv6 listening mode.\\n\""
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "ipv6_listen"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"6\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabling -6 IPv6 listening mode.\\n\""
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!ipv6_listen"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"no6\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\""
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!noipv4"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ipv4\""
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\""
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "noipv4"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noipv4\""
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\""
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!noipv6"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ipv6\""
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "noipv6"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noipv6\""
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" to:   \\\"%s\\\"\\n\"",
            "allow_list"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" from: \\\"%s\\\"\\n\"",
            "before"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: modified allow_list:\\n\""
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "before",
            "allow_list"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allow_list"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"in '-allow %s' mode.\\n\"",
            "allow_list"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot use allow:host\\n\""
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "allow_list",
            "'/'"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"allow:\""
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: cannot change allow in -unixpw\\n\""
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(allow_list)"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allow_list"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"allow:\""
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"allow\""
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set allow_once %s\\n\"",
            "allow_once"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"allowonce:\""
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(allow_once)"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "allow_once"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"allowonce:\""
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"allowonce\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -proxy %s\\n\"",
            "connect_proxy"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabled -proxy\\n\""
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "p",
            "\"none\""
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"\""
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"proxy:\""
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(connect_proxy)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "connect_proxy"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"proxy:\""
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"proxy\""
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverse_connect",
          "args": [
            "p"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2853-3026",
          "snippet": "void reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "void send_client_info(char *str);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"connect:\""
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"connect\""
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_reset",
          "args": [],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "379-399",
          "snippet": "void avahi_reset(void) {\n\tint i;\nif (db) fprintf(stderr, \"in  avahi_reset\\n\");\n\tfor (i=0; i<NREG; i++) {\n\t\tif (registered[i].name) {\n\t\t\tfree(registered[i].name);\n\t\t\tregistered[i].name = NULL;\n\t\t}\n\t\tif (registered[i].host) {\n\t\t\tfree(registered[i].host);\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t}\n\tif (!_client || !_group) {\nif (db) fprintf(stderr, \"    avahi_reset client/group null\\n\");\n\t\treturn;\n\t}\n\tavahi_entry_group_reset(_group);\n\trfbLog(\"Avahi resetting group.\\n\");\nif (db) fprintf(stderr, \"out avahi_reset\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NREG 16"
          ],
          "globals_used": [
            "void avahi_reset(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_reset(void);\n\nvoid avahi_reset(void) {\n\tint i;\nif (db) fprintf(stderr, \"in  avahi_reset\\n\");\n\tfor (i=0; i<NREG; i++) {\n\t\tif (registered[i].name) {\n\t\t\tfree(registered[i].name);\n\t\t\tregistered[i].name = NULL;\n\t\t}\n\t\tif (registered[i].host) {\n\t\t\tfree(registered[i].host);\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t}\n\tif (!_client || !_group) {\nif (db) fprintf(stderr, \"    avahi_reset client/group null\\n\");\n\t\treturn;\n\t}\n\tavahi_entry_group_reset(_group);\n\trfbLog(\"Avahi resetting group.\\n\");\nif (db) fprintf(stderr, \"out avahi_reset\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable -avahi mDNS mode.\\n\""
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!avahi"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nozeroconf\""
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nomdns\""
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noavahi\""
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_advertise",
          "args": [
            "vnc_desktop_name",
            "host",
            "screen->port"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_advertise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "331-377",
          "snippet": "void avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NREG 16"
          ],
          "globals_used": [
            "void avahi_advertise(char *name, char *host, uint16_t port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nvoid avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_initialise",
          "args": [],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_initialise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "203-250",
          "snippet": "void avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NREG 16"
          ],
          "globals_used": [
            "void avahi_initialise(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_initialise(void);\n\nvoid avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable -avahi mDNS mode.\\n\""
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "avahi"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"zeroconf\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"mdns\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"avahi\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: allowing new connections.\\n\""
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!deny_all"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"unlock\""
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nodeny\""
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: denying new connections.\\n\""
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "deny_all"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"lock\""
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"deny\""
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: invalid rfbversion: %s\\n\"",
            "p"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set rfbversion to: %d.%d\\n\"",
            "maj",
            "min"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d.%d\"",
            "&maj",
            "&min"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rfbversion:\""
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d.%d\"",
            "p",
            "3",
            "8"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d.%d\"",
            "p",
            "screen->protocolMajorVersion",
            "screen->protocolMinorVersion"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"rfbversion:\""
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"rfbversion\""
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -ultrafilexfer for clients.\\n\""
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "1"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "screen->permitFileTransfer == FALSE"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noultrafilexfer\""
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -ultrafilexfer for clients.\\n\""
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "0"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "screen->permitFileTransfer == TRUE"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ultrafilexfer\""
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: -tightfilexfer not supported in this binary.\\n\""
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbUnregisterTightVNCFileTransferExtension",
          "args": [],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\""
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\""
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!tightfilexfer"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"notightfilexfer\""
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: -tightfilexfer not supported in this binary.\\n\""
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbRegisterTightVNCFileTransferExtension",
          "args": [],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbRegisterTightVNCFileTransferExtension: 4\\n\""
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\""
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "tightfilexfer"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"tightfilexfer\""
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -timeout to %d\\n\"",
            "-to"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"timeout:\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "first_conn_timeout"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"timeout:\""
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"timeout\""
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable -forever mode.\\n\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "connect_once"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"once\""
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noforever\""
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable -forever mode.\\n\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "1-connect_once"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"forever\""
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable sharing.\\n\""
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!shared"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noshared\""
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable sharing.\\n\""
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "shared"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"shared\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: disable viewonly mode.\\n\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!view_only"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noviewonly\""
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: enable viewonly mode.\\n\""
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "view_only"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"viewonly\""
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scale_cursor:\""
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(scale_cursor_str)"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scale_cursor_str"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scale_cursor:\""
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scale_cursor:\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale_cursor\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_black_fb",
          "args": [],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "check_black_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "337-347",
          "snippet": "void check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_black_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid check_black_fb(void);\n\nvoid check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"scale:\""
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(scale_str)"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "scale_str"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"scale:\""
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"scale:\""
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"scale\""
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"visual:\""
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(visual_str)"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "visual_str"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"visual:\""
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"visual\""
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsetting: %d %d/%d\\n\"",
            "visual_str",
            "(int) visual_id",
            "visual_depth"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -24to32 mode.\\n\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!xform24to32"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"no24to32\""
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -24to32 mode.\\n\""
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "xform24to32"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"24to32\""
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set cmap8to24_str to: %s\\n\"",
            "cmap8to24_str"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"8to24_opts:\""
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(cmap8to24_str)"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "cmap8to24_str"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"8to24_opts:\""
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"8to24_opts\""
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off -8to24 mode.\\n\""
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!cmap8to24"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"no8to24\""
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabling -overlay in -8to24 mode.\\n\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -8to24 mode.\\n\""
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabling -overlay in -8to24 mode.\\n\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "cmap8to24"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"8to24\""
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" -R cursor:... to re-enable any cursors.\\n\""
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"You may want to run -R show_cursor or\\n\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: not in -overlay mode.\\n\""
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: overlay extension not present.\\n\""
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off overlay_cursor mode\\n\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!overlay_cursor"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"overlay_nocursor\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nooverlay_yescursor\""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nooverlay_cursor\""
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\""
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"You may want to run -R noshow_cursor or\\n\""
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: not in -overlay mode.\\n\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: overlay extension not present.\\n\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on overlay_cursor mode.\\n\""
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "overlay_cursor"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nooverlay_nocursor\""
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"overlay_yescursor\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"overlay_cursor\""
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping: already not in -overlay mode.\\n\""
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: overlay extension not present.\\n\""
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off overlay mode\\n\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!overlay"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nooverlay\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting -noshm mode.\\n\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping: already in -overlay mode.\\n\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping: overlay extension not present.\\n\""
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on -overlay mode.\\n\""
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "overlay"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"overlay\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_8bpp_do_new_fb",
          "args": [],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "if_8bpp_do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "329-335",
          "snippet": "static void if_8bpp_do_new_fb(void) {\n\tif (bpp == 8) {\n\t\tdo_new_fb(0);\n\t} else {\n\t\trfbLog(\"  bpp(%d) is not 8bpp, not resetting fb\\n\", bpp);\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void if_8bpp_do_new_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void if_8bpp_do_new_fb(void);\n\nstatic void if_8bpp_do_new_fb(void) {\n\tif (bpp == 8) {\n\t\tdo_new_fb(0);\n\t} else {\n\t\trfbLog(\"  bpp(%d) is not 8bpp, not resetting fb\\n\", bpp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on notruecolor mode.\\n\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "force_indexed_color"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"notruecolor\""
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off notruecolor mode.\\n\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!force_indexed_color"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"truecolor\""
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: set -shiftcmap %d\\n\"",
            "shift_cmap"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"shiftcmap:\""
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%d\"",
            "p",
            "co",
            "shift_cmap"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"shiftcmap:\""
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"shiftcmap\""
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning off flashcmap mode.\\n\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!flash_cmap"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"noflashcmap\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: turning on flashcmap mode.\\n\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "flash_cmap"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"flashcmap\""
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_geom",
          "args": [
            "p",
            "&w",
            "&h",
            "&x",
            "&y",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "parse_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "210-237",
          "snippet": "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dabs(double x);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);\n\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"clip:\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s%s\"",
            "p",
            "co",
            "NONUL(clip_str)"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "clip_str"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"clip:\""
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"clip:\""
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clip\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "!subwin_wait_mapped"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"nowaitmapped\""
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%d\"",
            "p",
            "subwin_wait_mapped"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"waitmapped\""
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid sub-window: 0x%lx\\n\"",
            "twin"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "twin",
            "NULL",
            "0"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-sid: skipping incorrect hex/dec number: %s\\n\"",
            "p"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_windowid",
          "args": [
            "&twin"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "pick_windowid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "405-478",
          "snippet": "int pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsafe: '-sid pick'\\n\""
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"pick\"",
            "p"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"root\"",
            "p"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sid:\""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s0x%lx\"",
            "p",
            "co",
            "!rootshift ? 0 : subwin"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"sid:\""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sid\""
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid sub-window: 0x%lx\\n\"",
            "twin"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\"",
            "p"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unsafe: '-id pick'\\n\""
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"pick\"",
            "p"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"root\"",
            "p"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id:\""
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s%s0x%lx\"",
            "p",
            "co",
            "rootshift ? 0 : subwin"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COLON_CHECK",
          "args": [
            "\"id:\""
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"id\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_cmd",
          "args": [
            "p"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "id_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "600-756",
          "snippet": "void id_cmd(char *cmd) {\n\tint rc, dx = 0, dy = 0, dw = 0, dh = 0;\n\tint x0, y0, w0, h0;\n\tint x, y, w, h, do_move = 0, do_resize = 0;\n\tint disp_x = DisplayWidth(dpy, scr);\n\tint disp_y = DisplayHeight(dpy, scr);\n\tWindow win = subwin;\n\tXWindowAttributes attr;\n\tXErrorHandler old_handler = NULL;\n\tWindow twin;\n\n\tif (!cmd || !strcmp(cmd, \"\")) { \n\t\treturn;\n\t}\n\tif (strstr(cmd, \"win=\") == cmd) {\n\t\tif (! scan_hexdec(cmd + strlen(\"win=\"), &win)) {\n\t\t\trfbLog(\"id_cmd: incorrect win= hex/dec number: %s\\n\", cmd);\n\t\t\treturn;\n\t\t} else {\n\t\t\tchar *q = strchr(cmd, ':');\n\t\t\tif (!q) {\n\t\t\t\trfbLog(\"id_cmd: incorrect win=...: hex/dec number: %s\\n\", cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLog(\"id_cmd:%s set window id to 0x%lx\\n\", cmd, win);\n\t\t\tcmd = q+1;\n\t\t}\n\t}\n\tif (!win) {\n\t\trfbLog(\"id_cmd:%s not in sub-window mode or no win=0xNNNN.\\n\", cmd);\n\t\treturn;\n\t}\n#if !NO_X11\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tw0 = w = attr.width;\n\th0 = h = attr.height;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tXTranslateCoordinates(dpy, win, rootwin, 0, 0, &x, &y, &twin);\n\tx0 = x;\n\ty0 = y;\n\tif (strstr(cmd, \"move:\") == cmd) {\n\t\tif (sscanf(cmd, \"move:%d%d\", &dx, &dy) == 2) {\n\t\t\tx = x + dx;\n\t\t\ty = y + dy;\n\t\t\tdo_move = 1;\n\t\t}\n\t} else if (strstr(cmd, \"resize:\") == cmd) {\n\t\tif (sscanf(cmd, \"resize:%d%d\", &dw, &dh) == 2) {\n\t\t\tw = w + dw;\n\t\t\th = h + dh;\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t}\n\t} else if (strstr(cmd, \"geom:\") == cmd) {\n\t\tif (parse_geom(cmd+strlen(\"geom:\"), &w, &h, &x, &y, disp_x, disp_y)) {\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t\tif (w <= 0) {\n\t\t\t\tw = w0;\n\t\t\t}\n\t\t\tif (h <= 0) {\n\t\t\t\th = h0;\n\t\t\t}\n\t\t\tif (scaling && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t\tx /= scale_fac_x;\n\t\t\t\ty /= scale_fac_y;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(cmd, \"raise\")) {\n\t\trc = XRaiseWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"lower\")) {\n\t\trc = XLowerWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"map\")) {\n\t\trc= XMapRaised(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"unmap\")) {\n\t\trc= XUnmapWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"iconify\")) {\n\t\trc= XIconifyWindow(dpy, win, scr);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"wm_name:\") == cmd) {\n\t\trc= XStoreName(dpy, win, cmd+strlen(\"wm_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"icon_name:\") == cmd) {\n\t\trc= XSetIconName(dpy, win, cmd+strlen(\"icon_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"wm_delete\")) {\n\t\tXClientMessageEvent ev;\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.type = ClientMessage;\n\t\tev.send_event = True;\n\t\tev.display = dpy;\n\t\tev.window = win;\n\t\tev.message_type = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\t\tev.format = 32;\n\t\tev.data.l[0] = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\t\trc = XSendEvent(dpy, win, False, 0, (XEvent *) &ev);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else {\n\t\trfbLog(\"id_cmd:%s unrecognized command.\\n\", cmd);\n\t}\n\tif (do_move || do_resize) {\n\t\tif (w >= disp_x) {\n\t\t\tw = disp_x - 4;\n\t\t}\n\t\tif (h >= disp_y) {\n\t\t\th = disp_y - 4;\n\t\t}\n\t\tif (w < 1) {\n\t\t\tw = 1;\n\t\t}\n\t\tif (h < 1) {\n\t\t\th = 1;\n\t\t}\n\t\tif (x + w > disp_x) {\n\t\t\tx = disp_x - w - 1;\n\t\t}\n\t\tif (y + h > disp_y) {\n\t\t\ty = disp_y - h - 1;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 1;\n\t\t}\n\t\tif (y < 0) {\n\t\t\ty = 1;\n\t\t}\n\t\trc = 0;\n\t\trc += XMoveWindow(dpy, win, x, y);\n\t\toff_x = x;\n\t\toff_y = y;\n\n\t\trc += XResizeWindow(dpy, win, w, h);\n\n\t\trfbLog(\"id_cmd:%s rc=%d dx=%d dy=%d dw=%d dh=%d %dx%d+%d+%d -> %dx%d+%d+%d\\n\",\n\t\t    cmd, rc, dx, dy, dw, dh, w0, h0, x0, y0, w, h, x, h);\n\t}\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trfbLog(\"id_cmd:%s trapped_xerror.\\n\", cmd);\n\t}\n\ttrapped_xerror = 0;\n\tif (do_resize) {\n\t\trfbLog(\"id_cmd:%s calling check_xrandr_event.\\n\", cmd);\n\t\tcheck_xrandr_event(\"id_cmd\");\n\t}\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid id_cmd(char *cmd) {\n\tint rc, dx = 0, dy = 0, dw = 0, dh = 0;\n\tint x0, y0, w0, h0;\n\tint x, y, w, h, do_move = 0, do_resize = 0;\n\tint disp_x = DisplayWidth(dpy, scr);\n\tint disp_y = DisplayHeight(dpy, scr);\n\tWindow win = subwin;\n\tXWindowAttributes attr;\n\tXErrorHandler old_handler = NULL;\n\tWindow twin;\n\n\tif (!cmd || !strcmp(cmd, \"\")) { \n\t\treturn;\n\t}\n\tif (strstr(cmd, \"win=\") == cmd) {\n\t\tif (! scan_hexdec(cmd + strlen(\"win=\"), &win)) {\n\t\t\trfbLog(\"id_cmd: incorrect win= hex/dec number: %s\\n\", cmd);\n\t\t\treturn;\n\t\t} else {\n\t\t\tchar *q = strchr(cmd, ':');\n\t\t\tif (!q) {\n\t\t\t\trfbLog(\"id_cmd: incorrect win=...: hex/dec number: %s\\n\", cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLog(\"id_cmd:%s set window id to 0x%lx\\n\", cmd, win);\n\t\t\tcmd = q+1;\n\t\t}\n\t}\n\tif (!win) {\n\t\trfbLog(\"id_cmd:%s not in sub-window mode or no win=0xNNNN.\\n\", cmd);\n\t\treturn;\n\t}\n#if !NO_X11\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tw0 = w = attr.width;\n\th0 = h = attr.height;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tXTranslateCoordinates(dpy, win, rootwin, 0, 0, &x, &y, &twin);\n\tx0 = x;\n\ty0 = y;\n\tif (strstr(cmd, \"move:\") == cmd) {\n\t\tif (sscanf(cmd, \"move:%d%d\", &dx, &dy) == 2) {\n\t\t\tx = x + dx;\n\t\t\ty = y + dy;\n\t\t\tdo_move = 1;\n\t\t}\n\t} else if (strstr(cmd, \"resize:\") == cmd) {\n\t\tif (sscanf(cmd, \"resize:%d%d\", &dw, &dh) == 2) {\n\t\t\tw = w + dw;\n\t\t\th = h + dh;\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t}\n\t} else if (strstr(cmd, \"geom:\") == cmd) {\n\t\tif (parse_geom(cmd+strlen(\"geom:\"), &w, &h, &x, &y, disp_x, disp_y)) {\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t\tif (w <= 0) {\n\t\t\t\tw = w0;\n\t\t\t}\n\t\t\tif (h <= 0) {\n\t\t\t\th = h0;\n\t\t\t}\n\t\t\tif (scaling && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t\tx /= scale_fac_x;\n\t\t\t\ty /= scale_fac_y;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(cmd, \"raise\")) {\n\t\trc = XRaiseWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"lower\")) {\n\t\trc = XLowerWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"map\")) {\n\t\trc= XMapRaised(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"unmap\")) {\n\t\trc= XUnmapWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"iconify\")) {\n\t\trc= XIconifyWindow(dpy, win, scr);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"wm_name:\") == cmd) {\n\t\trc= XStoreName(dpy, win, cmd+strlen(\"wm_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"icon_name:\") == cmd) {\n\t\trc= XSetIconName(dpy, win, cmd+strlen(\"icon_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"wm_delete\")) {\n\t\tXClientMessageEvent ev;\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.type = ClientMessage;\n\t\tev.send_event = True;\n\t\tev.display = dpy;\n\t\tev.window = win;\n\t\tev.message_type = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\t\tev.format = 32;\n\t\tev.data.l[0] = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\t\trc = XSendEvent(dpy, win, False, 0, (XEvent *) &ev);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else {\n\t\trfbLog(\"id_cmd:%s unrecognized command.\\n\", cmd);\n\t}\n\tif (do_move || do_resize) {\n\t\tif (w >= disp_x) {\n\t\t\tw = disp_x - 4;\n\t\t}\n\t\tif (h >= disp_y) {\n\t\t\th = disp_y - 4;\n\t\t}\n\t\tif (w < 1) {\n\t\t\tw = 1;\n\t\t}\n\t\tif (h < 1) {\n\t\t\th = 1;\n\t\t}\n\t\tif (x + w > disp_x) {\n\t\t\tx = disp_x - w - 1;\n\t\t}\n\t\tif (y + h > disp_y) {\n\t\t\ty = disp_y - h - 1;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 1;\n\t\t}\n\t\tif (y < 0) {\n\t\t\ty = 1;\n\t\t}\n\t\trc = 0;\n\t\trc += XMoveWindow(dpy, win, x, y);\n\t\toff_x = x;\n\t\toff_y = y;\n\n\t\trc += XResizeWindow(dpy, win, w, h);\n\n\t\trfbLog(\"id_cmd:%s rc=%d dx=%d dy=%d dw=%d dh=%d %dx%d+%d+%d -> %dx%d+%d+%d\\n\",\n\t\t    cmd, rc, dx, dy, dw, dh, w0, h0, x0, y0, w, h, x, h);\n\t}\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trfbLog(\"id_cmd:%s trapped_xerror.\\n\", cmd);\n\t}\n\ttrapped_xerror = 0;\n\tif (do_resize) {\n\t\trfbLog(\"id_cmd:%s calling check_xrandr_event.\\n\", cmd);\n\t\tcheck_xrandr_event(\"id_cmd\");\n\t}\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"id_cmd:\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"id_cmd\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_clients",
          "args": [
            "p"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"disconnect:\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"disconnect\""
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"close:\""
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"close\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\"",
            "delay"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d\"",
            "&delay"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"damagefb:\""
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_sleep",
          "args": [
            "4"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "push_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "489-497",
          "snippet": "void push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void push_sleep(int n);",
            "void push_black_screen(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_sleep(int n) {\n\tint i;\n\tfor (i=0; i<n; i++) {\n\t\trfbPE(-1);\n\t\tif (i != n-1 && defer_update) {\n\t\t\tusleep(defer_update * 1000);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "0"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "x2"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"zeroing rect: %s\\n\"",
            "p"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d,%d,%d,%d\"",
            "&x1",
            "&y1",
            "&x2",
            "&y2"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"zero:\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"reset\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"refresh\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"zero\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"blacken\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"resend_primary\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"resend_clipboard\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"resend_cutbuffer\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%s\"",
            "p",
            "\"unknown\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "bufn",
            "\"ans=%s:%s\"",
            "p",
            "rfb_desktop_name"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ping:\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ping\""
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_all_clients",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "close_all_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "251-265",
          "snippet": "void close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\n\nvoid close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: setting shut_down flag\\n\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"cmd=noop\\n\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"w\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"shutdown\""
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"exit\""
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"quit\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"stop\""
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_cmd: bad CR string: %s\\n\"",
            "p"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"did\\n\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "r",
            "dx",
            "dy",
            "0"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\"",
            "x",
            "y",
            "x+w",
            "y+h",
            "dx",
            "dy"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"CR:\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ignoring malformed command: %s\\n\"",
            "cmd"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"qry=\""
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "res"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\"",
            "buf",
            "res"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "res"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "pieces[k]",
            "1"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "tmp",
            "q",
            "1000"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"qry=\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\",\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd + strlen(\"qry=\")"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"qry=\""
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cmd) * sizeof(char *)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd",
            "','"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"qry=\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*t)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\";\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "tmp",
            "t",
            "1000"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"cmd=\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"qry=\""
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t",
            "\"cmd=\""
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "q"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\";\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(p) * sizeof(char *)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "p",
            "tmp"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'#'"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "tmp",
            "1024",
            "f"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sbuf.st_size + 1",
            "1"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "p",
            "\"r\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reading script from file '%s'\\n\"",
            "p"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"file=\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"file=\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"script:\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"script:\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cmd=\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"cmd=\""
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remote_control_access_ok",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "remote_control_access_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "700-831",
          "snippet": "int remote_control_access_ok(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tstruct stat sbuf;\n\n\tif (client_connect_file) {\n\t\tif (stat(client_connect_file, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"connect file is writable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"connect file is writable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dpy) {\n\t\tchar tmp[1000];\n\t\tchar *home, *xauth;\n\t\tchar *dpy_str = DisplayString(dpy);\n\t\tDisplay *dpy2;\n\t\tXHostAddress *xha;\n\t\tBool enabled;\n\t\tint n;\n\n\t\thome = get_home_dir();\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t} else if (home) {\n\t\t\tint len = 1000 - strlen(\"/.Xauthority\") - 1;\n\t\t\tstrncpy(tmp, home, len); \n\t\t\tstrcat(tmp, \"/.Xauthority\");\n\t\t\txauth = tmp;\n\t\t} else {\n\t\t\trfbLog(\"cannot determine default XAUTHORITY.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (home) {\n\t\t\tfree(home);\n\t\t}\n\t\tif (stat(xauth, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by others!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by group!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IROTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IRGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\txha = XListHosts(dpy, &n, &enabled);\n\t\tX_UNLOCK;\n\t\tif (! enabled) {\n\t\t\trfbLog(\"X access control is disabled, X clients can\\n\");\n\t\t\trfbLog(\"   connect from any host.  Run 'xhost -'\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (xha) {\n\t\t\tint i;\n\t\t\trfbLog(\"The following hosts can connect w/o X11 \"\n\t\t\t    \"auth:\\n\");\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tif (xha[i].family == FamilyInternet) {\n\t\t\t\t\tchar *str = raw2host(xha[i].address,\n\t\t\t\t\t    xha[i].length);\n\t\t\t\t\tchar *ip = raw2ip(xha[i].address);\n\t\t\t\t\trfbLog(\"  %s/%s\\n\", str, ip);\n\t\t\t\t\tfree(str);\n\t\t\t\t\tfree(ip);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"  unknown-%d\\n\", i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFree_wr(xha);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (getenv(\"XAUTHORITY\")) {\n\t\t\txauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t} else {\n\t\t\txauth = NULL;\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"/impossible/xauthfile\");\n\n\t\tfprintf(stderr, \"\\nChecking if display %s requires \"\n\t\t    \"XAUTHORITY\\n\", dpy_str);\n\t\tfprintf(stderr, \"   -- (ignore any Xlib: errors that\"\n\t\t    \" follow) --\\n\");\n\t\tdpy2 = XOpenDisplay_wr(dpy_str); \n\t\tfflush(stderr);\n\t\tfprintf(stderr, \"   -- (done checking) --\\n\\n\");\n\n\t\tif (xauth) {\n\t\t\tset_env(\"XAUTHORITY\", xauth);\n\t\t\tfree(xauth);\n\t\t} else {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t\tif (xauth) {\n\t\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t\t}\n\t\t}\n\t\tif (dpy2) {\n\t\t\trfbLog(\"XAUTHORITY is not required on display.\\n\");\n\t\t\trfbLog(\"   %s\\n\", DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\tdpy2 = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void http_connections(int on);",
            "int remote_control_access_ok(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nint remote_control_access_ok(void);\n\nint remote_control_access_ok(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tstruct stat sbuf;\n\n\tif (client_connect_file) {\n\t\tif (stat(client_connect_file, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"connect file is writable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"connect file is writable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dpy) {\n\t\tchar tmp[1000];\n\t\tchar *home, *xauth;\n\t\tchar *dpy_str = DisplayString(dpy);\n\t\tDisplay *dpy2;\n\t\tXHostAddress *xha;\n\t\tBool enabled;\n\t\tint n;\n\n\t\thome = get_home_dir();\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t} else if (home) {\n\t\t\tint len = 1000 - strlen(\"/.Xauthority\") - 1;\n\t\t\tstrncpy(tmp, home, len); \n\t\t\tstrcat(tmp, \"/.Xauthority\");\n\t\t\txauth = tmp;\n\t\t} else {\n\t\t\trfbLog(\"cannot determine default XAUTHORITY.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (home) {\n\t\t\tfree(home);\n\t\t}\n\t\tif (stat(xauth, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by others!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by group!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IROTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IRGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\txha = XListHosts(dpy, &n, &enabled);\n\t\tX_UNLOCK;\n\t\tif (! enabled) {\n\t\t\trfbLog(\"X access control is disabled, X clients can\\n\");\n\t\t\trfbLog(\"   connect from any host.  Run 'xhost -'\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (xha) {\n\t\t\tint i;\n\t\t\trfbLog(\"The following hosts can connect w/o X11 \"\n\t\t\t    \"auth:\\n\");\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tif (xha[i].family == FamilyInternet) {\n\t\t\t\t\tchar *str = raw2host(xha[i].address,\n\t\t\t\t\t    xha[i].length);\n\t\t\t\t\tchar *ip = raw2ip(xha[i].address);\n\t\t\t\t\trfbLog(\"  %s/%s\\n\", str, ip);\n\t\t\t\t\tfree(str);\n\t\t\t\t\tfree(ip);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"  unknown-%d\\n\", i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFree_wr(xha);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (getenv(\"XAUTHORITY\")) {\n\t\t\txauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t} else {\n\t\t\txauth = NULL;\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"/impossible/xauthfile\");\n\n\t\tfprintf(stderr, \"\\nChecking if display %s requires \"\n\t\t    \"XAUTHORITY\\n\", dpy_str);\n\t\tfprintf(stderr, \"   -- (ignore any Xlib: errors that\"\n\t\t    \" follow) --\\n\");\n\t\tdpy2 = XOpenDisplay_wr(dpy_str); \n\t\tfflush(stderr);\n\t\tfprintf(stderr, \"   -- (done checking) --\\n\\n\");\n\n\t\tif (xauth) {\n\t\t\tset_env(\"XAUTHORITY\", xauth);\n\t\t\tfree(xauth);\n\t\t} else {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t\tif (xauth) {\n\t\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t\t}\n\t\t}\n\t\tif (dpy2) {\n\t\t\trfbLog(\"XAUTHORITY is not required on display.\\n\");\n\t\t\trfbLog(\"   %s\\n\", DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\tdpy2 = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skip remote command: %s unixpw_in_progress.\\n\"",
            "cmd"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote commands disabled: %s\\n\"",
            "cmd"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
  },
  {
    "function_name": "remote_control_access_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "700-831",
    "snippet": "int remote_control_access_ok(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tstruct stat sbuf;\n\n\tif (client_connect_file) {\n\t\tif (stat(client_connect_file, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"connect file is writable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"connect file is writable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dpy) {\n\t\tchar tmp[1000];\n\t\tchar *home, *xauth;\n\t\tchar *dpy_str = DisplayString(dpy);\n\t\tDisplay *dpy2;\n\t\tXHostAddress *xha;\n\t\tBool enabled;\n\t\tint n;\n\n\t\thome = get_home_dir();\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t} else if (home) {\n\t\t\tint len = 1000 - strlen(\"/.Xauthority\") - 1;\n\t\t\tstrncpy(tmp, home, len); \n\t\t\tstrcat(tmp, \"/.Xauthority\");\n\t\t\txauth = tmp;\n\t\t} else {\n\t\t\trfbLog(\"cannot determine default XAUTHORITY.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (home) {\n\t\t\tfree(home);\n\t\t}\n\t\tif (stat(xauth, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by others!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by group!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IROTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IRGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\txha = XListHosts(dpy, &n, &enabled);\n\t\tX_UNLOCK;\n\t\tif (! enabled) {\n\t\t\trfbLog(\"X access control is disabled, X clients can\\n\");\n\t\t\trfbLog(\"   connect from any host.  Run 'xhost -'\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (xha) {\n\t\t\tint i;\n\t\t\trfbLog(\"The following hosts can connect w/o X11 \"\n\t\t\t    \"auth:\\n\");\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tif (xha[i].family == FamilyInternet) {\n\t\t\t\t\tchar *str = raw2host(xha[i].address,\n\t\t\t\t\t    xha[i].length);\n\t\t\t\t\tchar *ip = raw2ip(xha[i].address);\n\t\t\t\t\trfbLog(\"  %s/%s\\n\", str, ip);\n\t\t\t\t\tfree(str);\n\t\t\t\t\tfree(ip);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"  unknown-%d\\n\", i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFree_wr(xha);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (getenv(\"XAUTHORITY\")) {\n\t\t\txauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t} else {\n\t\t\txauth = NULL;\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"/impossible/xauthfile\");\n\n\t\tfprintf(stderr, \"\\nChecking if display %s requires \"\n\t\t    \"XAUTHORITY\\n\", dpy_str);\n\t\tfprintf(stderr, \"   -- (ignore any Xlib: errors that\"\n\t\t    \" follow) --\\n\");\n\t\tdpy2 = XOpenDisplay_wr(dpy_str); \n\t\tfflush(stderr);\n\t\tfprintf(stderr, \"   -- (done checking) --\\n\\n\");\n\n\t\tif (xauth) {\n\t\t\tset_env(\"XAUTHORITY\", xauth);\n\t\t\tfree(xauth);\n\t\t} else {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t\tif (xauth) {\n\t\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t\t}\n\t\t}\n\t\tif (dpy2) {\n\t\t\trfbLog(\"XAUTHORITY is not required on display.\\n\");\n\t\t\trfbLog(\"   %s\\n\", DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\tdpy2 = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void http_connections(int on);",
      "int remote_control_access_ok(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "dpy2"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "DisplayString(dpy)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XAUTHORITY is not required on display.\\n\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xauth"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"XAUTHORITY\"",
            "xauth"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   -- (done checking) --\\n\\n\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dpy_str"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   -- (ignore any Xlib: errors that\"\n\t\t    \" follow) --\\n\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nChecking if display %s requires \"\n\t\t    \"XAUTHORITY\\n\"",
            "dpy_str"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"XAUTHORITY\")"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "xha"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  unknown-%d\\n\"",
            "i+1"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  %s/%s\\n\"",
            "str",
            "ip"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw2ip",
          "args": [
            "xha[i].address"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "raw2ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "108-110",
          "snippet": "char *raw2ip(char *raw) {\n\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *raw2ip(char *raw);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *raw2ip(char *raw);\n\nchar *raw2ip(char *raw) {\n\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw2host",
          "args": [
            "xha[i].address",
            "xha[i].length"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "raw2host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "88-106",
          "snippet": "char *raw2host(char *raw, int len) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr(raw, len, AF_INET);\n\tif (!hp) {\n\t\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *raw2host(char *raw, int len);",
            "char *raw2ip(char *raw);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *raw2host(char *raw, int len);\nchar *raw2ip(char *raw);\n\nchar *raw2host(char *raw, int len) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr(raw, len, AF_INET);\n\tif (!hp) {\n\t\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"The following hosts can connect w/o X11 \"\n\t\t\t    \"auth:\\n\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   connect from any host.  Run 'xhost -'\\n\""
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X access control is disabled, X clients can\\n\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XListHosts",
          "args": [
            "dpy",
            "&n",
            "&enabled"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "xauth"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XAUTHORITY is readable by group.\\n\""
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "xauth"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XAUTHORITY is readable by others.\\n\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "xauth"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XAUTHORITY is writable by group!!\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "xauth"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XAUTHORITY is writable by others!!\\n\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "xauth",
            "&sbuf"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot determine default XAUTHORITY.\\n\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\"/.Xauthority\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmp",
            "home",
            "len"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/.Xauthority\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_home_dir",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "get_home_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "295-314",
          "snippet": "char *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_home_dir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_home_dir(void);\n\nchar *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "client_connect_file"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect file is writable by group.\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "client_connect_file"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect file is writable by others.\\n\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nint remote_control_access_ok(void);\n\nint remote_control_access_ok(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tstruct stat sbuf;\n\n\tif (client_connect_file) {\n\t\tif (stat(client_connect_file, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"connect file is writable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"connect file is writable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", client_connect_file);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dpy) {\n\t\tchar tmp[1000];\n\t\tchar *home, *xauth;\n\t\tchar *dpy_str = DisplayString(dpy);\n\t\tDisplay *dpy2;\n\t\tXHostAddress *xha;\n\t\tBool enabled;\n\t\tint n;\n\n\t\thome = get_home_dir();\n\t\tif (getenv(\"XAUTHORITY\") != NULL) {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t} else if (home) {\n\t\t\tint len = 1000 - strlen(\"/.Xauthority\") - 1;\n\t\t\tstrncpy(tmp, home, len); \n\t\t\tstrcat(tmp, \"/.Xauthority\");\n\t\t\txauth = tmp;\n\t\t} else {\n\t\t\trfbLog(\"cannot determine default XAUTHORITY.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (home) {\n\t\t\tfree(home);\n\t\t}\n\t\tif (stat(xauth, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mode & S_IWOTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by others!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IWGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is writable by group!!\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IROTH) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by others.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (sbuf.st_mode & S_IRGRP) {\n\t\t\t\trfbLog(\"XAUTHORITY is readable by group.\\n\");\n\t\t\t\trfbLog(\"   %s\\n\", xauth);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\txha = XListHosts(dpy, &n, &enabled);\n\t\tX_UNLOCK;\n\t\tif (! enabled) {\n\t\t\trfbLog(\"X access control is disabled, X clients can\\n\");\n\t\t\trfbLog(\"   connect from any host.  Run 'xhost -'\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (xha) {\n\t\t\tint i;\n\t\t\trfbLog(\"The following hosts can connect w/o X11 \"\n\t\t\t    \"auth:\\n\");\n\t\t\tfor (i=0; i<n; i++) {\n\t\t\t\tif (xha[i].family == FamilyInternet) {\n\t\t\t\t\tchar *str = raw2host(xha[i].address,\n\t\t\t\t\t    xha[i].length);\n\t\t\t\t\tchar *ip = raw2ip(xha[i].address);\n\t\t\t\t\trfbLog(\"  %s/%s\\n\", str, ip);\n\t\t\t\t\tfree(str);\n\t\t\t\t\tfree(ip);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"  unknown-%d\\n\", i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tXFree_wr(xha);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (getenv(\"XAUTHORITY\")) {\n\t\t\txauth = strdup(getenv(\"XAUTHORITY\"));\n\t\t} else {\n\t\t\txauth = NULL;\n\t\t}\n\t\tset_env(\"XAUTHORITY\", \"/impossible/xauthfile\");\n\n\t\tfprintf(stderr, \"\\nChecking if display %s requires \"\n\t\t    \"XAUTHORITY\\n\", dpy_str);\n\t\tfprintf(stderr, \"   -- (ignore any Xlib: errors that\"\n\t\t    \" follow) --\\n\");\n\t\tdpy2 = XOpenDisplay_wr(dpy_str); \n\t\tfflush(stderr);\n\t\tfprintf(stderr, \"   -- (done checking) --\\n\\n\");\n\n\t\tif (xauth) {\n\t\t\tset_env(\"XAUTHORITY\", xauth);\n\t\t\tfree(xauth);\n\t\t} else {\n\t\t\txauth = getenv(\"XAUTHORITY\");\n\t\t\tif (xauth) {\n\t\t\t\t*(xauth-2) = '_';\t/* yow */\n\t\t\t}\n\t\t}\n\t\tif (dpy2) {\n\t\t\trfbLog(\"XAUTHORITY is not required on display.\\n\");\n\t\t\trfbLog(\"   %s\\n\", DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy2);\n\t\t\tdpy2 = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "reset_rfbport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "622-692",
    "snippet": "static void reset_rfbport(int old, int newp)  {\n\tint rp = newp;\n\n\tif (inetd) {\n\t\trfbLog(\"reset_rfbport: cannot set rfbport: %d in inetd.\\n\", rp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_rfbport: no screen.\\n\");\n\t\treturn;\n\t} else if (rp < 0) {\n\t\trfbLog(\"reset_rfbport: invalid rfbport: %d\\n\", rp);\n\t\treturn;\n\t} else if (rp == old) {\n\t\trfbLog(\"reset_rfbport: unchanged rfbport: %d\\n\", rp);\n\t\treturn;\n\t}\n\n\trfbLog(\"reset_rfbport: setting rfbport %d -> %d.\\n\", old == -1 ? rp : old, rp);\n\n\tscreen->port = rp;\n\n\tif (use_openssl) {\n\t\topenssl_port(1);\n\t\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\",\n\t\t\t    screen->port);\n\t\t} else {\n\t\t\tset_vnc_desktop_name();\n\t\t}\n\t\tif (https_port_num >= 0) {\n\t\t\thttps_port(1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (screen->listenSock >= 0) {\n\t\tFD_CLR(screen->listenSock, &(screen->allFds));\n\t\tclose(screen->listenSock);\n\t\tscreen->listenSock = -1;\n\t}\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_rfbport()\\n\");\n\t\t}\n\t} else {\n\t\tscreen->listenSock = listen_tcp(screen->port, screen->listenInterface, 0);\n\t\tif (screen->listenSock >= 0) {\n\t\t\tif (screen->listenSock > screen->maxFd) {\n\t\t\t\tscreen->maxFd = screen->listenSock;\n\t\t\t}\n\t\t\tFD_SET(screen->listenSock, &(screen->allFds));\n\t\t}\n\t}\n\n\tif (ipv6_listen_fd >= 0) {\n\t\tclose(ipv6_listen_fd);\n\t\tipv6_listen_fd = -1;\n\t}\n\tif (ipv6_listen && screen->port > 0) {\n\t\tipv6_listen_fd = listen6(screen->port);\n\t\trfbLog(\"reset_rfbport: ipv6_listen_fd: %d  port: %d\\n\",\n\t\t    ipv6_listen_fd, screen->port);\n\t}\n\n\tif (screen->listenSock < 0 && ipv6_listen_fd < 0) {\n\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\", screen->port);\n\t} else {\n\t\tset_vnc_desktop_name();\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void http_connections(int on);",
      "static void reset_httpport(int old, int newp);",
      "static void reset_rfbport(int old, int newp) ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_vnc_desktop_name",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "set_vnc_desktop_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3970-4055",
          "snippet": "void set_vnc_desktop_name(void) {\n\tsprintf(vnc_desktop_name, \"unknown\");\n\tif (inetd) {\n\t\tchar *host = this_host();\n\t\tsprintf(vnc_desktop_name, \"%s/inetd-no-further-clients\", host);\n\t\tfree(host);\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (screen->port) {\n\n\t\tdo_mention_java_urls();\n\n\t\tif (use_openssl) {\n\t\t\tannounce(screen->port, 1, listen_str);\n\t\t} else {\n\t\t\tannounce(screen->port, 0, listen_str);\n\t\t}\n\t\tif (stunnel_port) {\n\t\t\tannounce(stunnel_port, 1, NULL);\n\t\t}\n\n\t\tdo_announce_http();\n\t\t\n\t\tfflush(stderr);\t\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port != 0) */\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (enc_str) {\n\t\t\t\t\tfprintf(stdout, \"ENCPORT=%d\\n\", screen->port);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfflush(stdout);\t\n\t\t\tif (flagfile) {\n\t\t\t\tFILE *flag = fopen(flagfile, \"w\");\n\t\t\t\tif (flag) {\n\t\t\t\t\tfprintf(flag, \"PORT=%d\\n\",screen->port);\n\t\t\t\t\tif (stunnel_port) {\n\t\t\t\t\t\tfprintf(flag, \"SSL_PORT=%d\\n\",\n\t\t\t\t\t\t    stunnel_port);\n\t\t\t\t\t}\n\t\t\t\t\tfflush(flag);\t\n\t\t\t\t\tfclose(flag);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"could not open flag file: %s\\n\",\n\t\t\t\t\t    flagfile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rm_flagfile) {\n\t\t\t\tint create = 0;\n\t\t\t\tstruct stat sb;\n\t\t\t\tif (strstr(rm_flagfile, \"create:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 1;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"create:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tif (strstr(rm_flagfile, \"nocreate:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 0;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"nocreate:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t} else if (stat(rm_flagfile, &sb) != 0) {\n\t\t\t\t\tcreate = 1;\n\t\t\t\t}\n\t\t\t\tif (create) {\n\t\t\t\t\tFILE *flag = fopen(rm_flagfile, \"w\");\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tfprintf(flag, \"%d\\n\", getpid());\n\t\t\t\t\t\tfclose(flag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\t\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_vnc_desktop_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_vnc_desktop_name(void);\n\nvoid set_vnc_desktop_name(void) {\n\tsprintf(vnc_desktop_name, \"unknown\");\n\tif (inetd) {\n\t\tchar *host = this_host();\n\t\tsprintf(vnc_desktop_name, \"%s/inetd-no-further-clients\", host);\n\t\tfree(host);\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (screen->port) {\n\n\t\tdo_mention_java_urls();\n\n\t\tif (use_openssl) {\n\t\t\tannounce(screen->port, 1, listen_str);\n\t\t} else {\n\t\t\tannounce(screen->port, 0, listen_str);\n\t\t}\n\t\tif (stunnel_port) {\n\t\t\tannounce(stunnel_port, 1, NULL);\n\t\t}\n\n\t\tdo_announce_http();\n\t\t\n\t\tfflush(stderr);\t\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port != 0) */\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (enc_str) {\n\t\t\t\t\tfprintf(stdout, \"ENCPORT=%d\\n\", screen->port);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfflush(stdout);\t\n\t\t\tif (flagfile) {\n\t\t\t\tFILE *flag = fopen(flagfile, \"w\");\n\t\t\t\tif (flag) {\n\t\t\t\t\tfprintf(flag, \"PORT=%d\\n\",screen->port);\n\t\t\t\t\tif (stunnel_port) {\n\t\t\t\t\t\tfprintf(flag, \"SSL_PORT=%d\\n\",\n\t\t\t\t\t\t    stunnel_port);\n\t\t\t\t\t}\n\t\t\t\t\tfflush(flag);\t\n\t\t\t\t\tfclose(flag);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"could not open flag file: %s\\n\",\n\t\t\t\t\t    flagfile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rm_flagfile) {\n\t\t\t\tint create = 0;\n\t\t\t\tstruct stat sb;\n\t\t\t\tif (strstr(rm_flagfile, \"create:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 1;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"create:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tif (strstr(rm_flagfile, \"nocreate:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 0;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"nocreate:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t} else if (stat(rm_flagfile, &sb) != 0) {\n\t\t\t\t\tcreate = 1;\n\t\t\t\t}\n\t\t\t\tif (create) {\n\t\t\t\t\tFILE *flag = fopen(rm_flagfile, \"w\");\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tfprintf(flag, \"%d\\n\", getpid());\n\t\t\t\t\t\tfclose(flag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: warning could not listen on port: %d\\n\"",
            "screen->port"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: ipv6_listen_fd: %d  port: %d\\n\"",
            "ipv6_listen_fd",
            "screen->port"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "screen->port"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipv6_listen_fd"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "screen->listenSock",
            "&(screen->allFds)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "screen->port",
            "screen->listenInterface",
            "0"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TESTING: IPV4_FAILS for reset_rfbport()\\n\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_CLR",
          "args": [
            "screen->listenSock",
            "&(screen->allFds)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "https_port",
          "args": [
            "1"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "https_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2902-2984",
          "snippet": "void https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "void openssl_port(int restart);",
            "void https_port(int restart);",
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid openssl_port(int restart);\nvoid https_port(int restart);\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: warning could not listen on port: %d\\n\"",
            "screen->port"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openssl_port",
          "args": [
            "1"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "openssl_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2793-2900",
          "snippet": "void openssl_port(int restart) {\n\tint sock = -1, shutdown = 0;\n\tstatic int port = -1;\n\tstatic in_addr_t iface = INADDR_ANY;\n\tint db = 0, fd6 = -1;\n\n\tif (! screen) {\n\t\trfbLog(\"openssl_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tif (ipv6_listen && screen->port <= 0) {\n\t\tif (got_rfbport) {\n\t\t\tscreen->port = got_rfbport_val;\n\t\t} else {\n\t\t\tint ap = 5900;\n\t\t\tif (auto_port > 0) {\n\t\t\t\tap = auto_port;\n\t\t\t}\n\t\t\tscreen->port = find_free_port6(ap, ap+200);\n\t\t}\n\t\trfbLog(\"openssl_port: reset port from 0 => %d\\n\", screen->port);\n\t}\n\n\tif (restart) {\n\t\tport = screen->port;\n\t} else if (screen->listenSock > -1 && screen->port > 0) {\n\t\tport = screen->port;\n\t\tshutdown = 1;\n\t} else if (ipv6_listen && screen->port > 0) {\n\t\tport = screen->port;\n\t} else if (screen->port == 0) {\n\t\tport = screen->port;\n\t}\n\n\tiface = screen->listenInterface;\n\n\tif (shutdown) {\n\t\tif (db) fprintf(stderr, \"shutting down %d/%d\\n\",\n\t\t    port, screen->listenSock);\n#if LIBVNCSERVER_HAS_SHUTDOWNSOCKETS\n\t\trfbShutdownSockets(screen);\n#endif\n\t}\n\n\tif (openssl_sock >= 0) {\n\t\tclose(openssl_sock);\n\t\topenssl_sock = -1;\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tclose(openssl_sock6);\n\t\topenssl_sock6 = -1;\n\t}\n\n\tif (port < 0) {\n\t\trfbLog(\"openssl_port: could not obtain listening port %d\\n\", port);\n\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t}\n\t\tclean_up_exit(1);\n\t} else if (port == 0) {\n\t\t/* no listen case, i.e. -connect */\n\t\tsock = -1;\n\t} else {\n\t\tsock = listen_tcp(port, iface, 0);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} else if (!got_rfbport && !got_ipv6_listen) {\n\t\t\tif (sock < 0) {\n\t\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t\t}\n\t\t}\n\t\tif (sock < 0) {\n\t\t\tif (fd6 < 0) {\n\t\t\t\trfbLog(\"openssl_port: could not reopen port %d\\n\", port);\n\t\t\t\tif (!restart) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trfbLog(\"openssl_port: Info: listening on IPv6 only.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\trfbLog(\"openssl_port: listen on port/sock %d/%d\\n\", port, sock);\n\tif (ipv6_listen && port > 0) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\tipv6_listen = 0;\n\t\t} else {\n\t\t\trfbLog(\"openssl_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\topenssl_sock6 = fd6;\n\t\t}\n\t}\n\tif (!quiet && sock >=0) {\n\t\tannounce(port, 1, NULL);\n\t}\n\topenssl_sock = sock;\n\topenssl_port_num = port;\n\n\tssl_initialized = 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int openssl_port_num = 0;",
            "void openssl_port(int restart);",
            "void https_port(int restart);",
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint openssl_port_num = 0;\nvoid openssl_port(int restart);\nvoid https_port(int restart);\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid openssl_port(int restart) {\n\tint sock = -1, shutdown = 0;\n\tstatic int port = -1;\n\tstatic in_addr_t iface = INADDR_ANY;\n\tint db = 0, fd6 = -1;\n\n\tif (! screen) {\n\t\trfbLog(\"openssl_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tif (ipv6_listen && screen->port <= 0) {\n\t\tif (got_rfbport) {\n\t\t\tscreen->port = got_rfbport_val;\n\t\t} else {\n\t\t\tint ap = 5900;\n\t\t\tif (auto_port > 0) {\n\t\t\t\tap = auto_port;\n\t\t\t}\n\t\t\tscreen->port = find_free_port6(ap, ap+200);\n\t\t}\n\t\trfbLog(\"openssl_port: reset port from 0 => %d\\n\", screen->port);\n\t}\n\n\tif (restart) {\n\t\tport = screen->port;\n\t} else if (screen->listenSock > -1 && screen->port > 0) {\n\t\tport = screen->port;\n\t\tshutdown = 1;\n\t} else if (ipv6_listen && screen->port > 0) {\n\t\tport = screen->port;\n\t} else if (screen->port == 0) {\n\t\tport = screen->port;\n\t}\n\n\tiface = screen->listenInterface;\n\n\tif (shutdown) {\n\t\tif (db) fprintf(stderr, \"shutting down %d/%d\\n\",\n\t\t    port, screen->listenSock);\n#if LIBVNCSERVER_HAS_SHUTDOWNSOCKETS\n\t\trfbShutdownSockets(screen);\n#endif\n\t}\n\n\tif (openssl_sock >= 0) {\n\t\tclose(openssl_sock);\n\t\topenssl_sock = -1;\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tclose(openssl_sock6);\n\t\topenssl_sock6 = -1;\n\t}\n\n\tif (port < 0) {\n\t\trfbLog(\"openssl_port: could not obtain listening port %d\\n\", port);\n\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t}\n\t\tclean_up_exit(1);\n\t} else if (port == 0) {\n\t\t/* no listen case, i.e. -connect */\n\t\tsock = -1;\n\t} else {\n\t\tsock = listen_tcp(port, iface, 0);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} else if (!got_rfbport && !got_ipv6_listen) {\n\t\t\tif (sock < 0) {\n\t\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t\t}\n\t\t}\n\t\tif (sock < 0) {\n\t\t\tif (fd6 < 0) {\n\t\t\t\trfbLog(\"openssl_port: could not reopen port %d\\n\", port);\n\t\t\t\tif (!restart) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trfbLog(\"openssl_port: Info: listening on IPv6 only.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\trfbLog(\"openssl_port: listen on port/sock %d/%d\\n\", port, sock);\n\tif (ipv6_listen && port > 0) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\tipv6_listen = 0;\n\t\t} else {\n\t\t\trfbLog(\"openssl_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\topenssl_sock6 = fd6;\n\t\t}\n\t}\n\tif (!quiet && sock >=0) {\n\t\tannounce(port, 1, NULL);\n\t}\n\topenssl_sock = sock;\n\topenssl_port_num = port;\n\n\tssl_initialized = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: setting rfbport %d -> %d.\\n\"",
            "old == -1 ? rp : old",
            "rp"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: unchanged rfbport: %d\\n\"",
            "rp"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: invalid rfbport: %d\\n\"",
            "rp"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: no screen.\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_rfbport: cannot set rfbport: %d in inetd.\\n\"",
            "rp"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nstatic void reset_httpport(int old, int newp);\nstatic void reset_rfbport(int old, int newp) ;\n\nstatic void reset_rfbport(int old, int newp)  {\n\tint rp = newp;\n\n\tif (inetd) {\n\t\trfbLog(\"reset_rfbport: cannot set rfbport: %d in inetd.\\n\", rp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_rfbport: no screen.\\n\");\n\t\treturn;\n\t} else if (rp < 0) {\n\t\trfbLog(\"reset_rfbport: invalid rfbport: %d\\n\", rp);\n\t\treturn;\n\t} else if (rp == old) {\n\t\trfbLog(\"reset_rfbport: unchanged rfbport: %d\\n\", rp);\n\t\treturn;\n\t}\n\n\trfbLog(\"reset_rfbport: setting rfbport %d -> %d.\\n\", old == -1 ? rp : old, rp);\n\n\tscreen->port = rp;\n\n\tif (use_openssl) {\n\t\topenssl_port(1);\n\t\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\",\n\t\t\t    screen->port);\n\t\t} else {\n\t\t\tset_vnc_desktop_name();\n\t\t}\n\t\tif (https_port_num >= 0) {\n\t\t\thttps_port(1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (screen->listenSock >= 0) {\n\t\tFD_CLR(screen->listenSock, &(screen->allFds));\n\t\tclose(screen->listenSock);\n\t\tscreen->listenSock = -1;\n\t}\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_rfbport()\\n\");\n\t\t}\n\t} else {\n\t\tscreen->listenSock = listen_tcp(screen->port, screen->listenInterface, 0);\n\t\tif (screen->listenSock >= 0) {\n\t\t\tif (screen->listenSock > screen->maxFd) {\n\t\t\t\tscreen->maxFd = screen->listenSock;\n\t\t\t}\n\t\t\tFD_SET(screen->listenSock, &(screen->allFds));\n\t\t}\n\t}\n\n\tif (ipv6_listen_fd >= 0) {\n\t\tclose(ipv6_listen_fd);\n\t\tipv6_listen_fd = -1;\n\t}\n\tif (ipv6_listen && screen->port > 0) {\n\t\tipv6_listen_fd = listen6(screen->port);\n\t\trfbLog(\"reset_rfbport: ipv6_listen_fd: %d  port: %d\\n\",\n\t\t    ipv6_listen_fd, screen->port);\n\t}\n\n\tif (screen->listenSock < 0 && ipv6_listen_fd < 0) {\n\t\trfbLog(\"reset_rfbport: warning could not listen on port: %d\\n\", screen->port);\n\t} else {\n\t\tset_vnc_desktop_name();\n\t}\n}"
  },
  {
    "function_name": "reset_httpport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "566-620",
    "snippet": "static void reset_httpport(int old, int newp) {\n\tint hp = newp;\n\n\tif (! screen->httpDir) {\n\t\treturn;\n\t} else if (inetd) {\n\t\trfbLog(\"reset_httpport: cannot set httpport: %d in inetd.\\n\", hp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_httpport: no screen.\\n\");\n\t\treturn;\n\t} else if (hp < 0) {\n\t\trfbLog(\"reset_httpport: invalid httpport: %d\\n\", hp);\n\t\treturn;\n\t} else if (hp == old) {\n\t\trfbLog(\"reset_httpport: unchanged httpport: %d\\n\", hp);\n\t\treturn;\n\t}\n\n\tif (screen->httpListenSock > -1) {\n\t\tclose(screen->httpListenSock);\n\t\tscreen->httpListenSock = -1;\n\t}\n\n\tscreen->httpPort = hp;\n\tscreen->httpInitDone = FALSE;\n\n\trfbLog(\"reset_httpport: setting httpport %d -> %d.\\n\",\n\t    old == -1 ? hp : old, hp);\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_httpport()\\n\");\n\t\t}\n\t} else if (screen->httpPort == 0) {\n\t\t;\n\t} else {\n\t\trfb_http_init_sockets();\n\t}\n\n\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\trfbLog(\"reset_httpport: failed to listen on http port: %d\\n\",\n\t\t    screen->httpPort);\n\t}\n\n\tif (ipv6_http_fd >= 0) {\n\t\tclose(ipv6_http_fd);\n\t\tipv6_http_fd = -1;\n\t}\n\tif (ipv6_listen && screen->httpPort > 0) {\n\t\tipv6_http_fd = listen6(screen->httpPort);\n\t\trfbLog(\"reset_httpport: ipv6_http_fd: %d  port: %d\\n\",\n\t\t    ipv6_http_fd, screen->httpPort);\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void http_connections(int on);",
      "static void reset_httpport(int old, int newp);",
      "static void reset_rfbport(int old, int newp) ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: ipv6_http_fd: %d  port: %d\\n\"",
            "ipv6_http_fd",
            "screen->httpPort"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "screen->httpPort"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipv6_http_fd"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: failed to listen on http port: %d\\n\"",
            "screen->httpPort"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfb_http_init_sockets",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "rfb_http_init_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "473-494",
          "snippet": "static void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void http_connections(int on);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\n\nstatic void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TESTING: IPV4_FAILS for reset_httpport()\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: setting httpport %d -> %d.\\n\"",
            "old == -1 ? hp : old",
            "hp"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: unchanged httpport: %d\\n\"",
            "hp"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: invalid httpport: %d\\n\"",
            "hp"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: no screen.\\n\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset_httpport: cannot set httpport: %d in inetd.\\n\"",
            "hp"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\nstatic void reset_httpport(int old, int newp);\nstatic void reset_rfbport(int old, int newp) ;\n\nstatic void reset_httpport(int old, int newp) {\n\tint hp = newp;\n\n\tif (! screen->httpDir) {\n\t\treturn;\n\t} else if (inetd) {\n\t\trfbLog(\"reset_httpport: cannot set httpport: %d in inetd.\\n\", hp);\n\t\treturn;\n\t} else if (!screen) {\n\t\trfbLog(\"reset_httpport: no screen.\\n\");\n\t\treturn;\n\t} else if (hp < 0) {\n\t\trfbLog(\"reset_httpport: invalid httpport: %d\\n\", hp);\n\t\treturn;\n\t} else if (hp == old) {\n\t\trfbLog(\"reset_httpport: unchanged httpport: %d\\n\", hp);\n\t\treturn;\n\t}\n\n\tif (screen->httpListenSock > -1) {\n\t\tclose(screen->httpListenSock);\n\t\tscreen->httpListenSock = -1;\n\t}\n\n\tscreen->httpPort = hp;\n\tscreen->httpInitDone = FALSE;\n\n\trfbLog(\"reset_httpport: setting httpport %d -> %d.\\n\",\n\t    old == -1 ? hp : old, hp);\n\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for reset_httpport()\\n\");\n\t\t}\n\t} else if (screen->httpPort == 0) {\n\t\t;\n\t} else {\n\t\trfb_http_init_sockets();\n\t}\n\n\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\trfbLog(\"reset_httpport: failed to listen on http port: %d\\n\",\n\t\t    screen->httpPort);\n\t}\n\n\tif (ipv6_http_fd >= 0) {\n\t\tclose(ipv6_http_fd);\n\t\tipv6_http_fd = -1;\n\t}\n\tif (ipv6_listen && screen->httpPort > 0) {\n\t\tipv6_http_fd = listen6(screen->httpPort);\n\t\trfbLog(\"reset_httpport: ipv6_http_fd: %d  port: %d\\n\",\n\t\t    ipv6_http_fd, screen->httpPort);\n\t}\n}"
  },
  {
    "function_name": "http_connections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "496-564",
    "snippet": "void http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_httpdir(void);",
      "void http_connections(int on);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ipv6_http_fd"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: turning off http service.\\n\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\"",
            "screen->httpListenSock < 0 ? \"only\" : \"also\"",
            "screen->httpPort",
            "ipv6_http_fd"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "screen->httpPort"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: trying IPv6 only mode.\\n\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: failed to listen on http port: %d\\n\"",
            "screen->httpPort"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTP_LISTEN_LOCALHOST\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfb_http_init_sockets",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "rfb_http_init_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "473-494",
          "snippet": "static void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void http_connections(int on);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\n\nstatic void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_httpdir",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "check_httpdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "349-471",
          "snippet": "int check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_httpdir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\n\nint check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_free_port",
          "args": [
            "5800",
            "5850"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: turning on http service.\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\nvoid http_connections(int on);\n\nvoid http_connections(int on) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (on) {\n\t\trfbLog(\"http_connections: turning on http service.\\n\");\n\n\t\tif (inetd && use_openssl) {\n\t\t\t/*\n\t\t\t * try to work around rapid fire https requests\n\t\t\t * in inetd mode... ugh.\n\t\t\t */\n\t\t\tif (screen->httpPort == 0) {\n\t\t\t\tint port = find_free_port(5800, 5850);\n\t\t\t\tif (port) {\n\t\t\t\t\t/* mutex */\n\t\t\t\t\tscreen->httpPort = port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscreen->httpInitDone = FALSE;\n\t\tif (check_httpdir()) {\n\t\t\tint fd6 = -1;\n\t\t\tchar *save = listen_str6;\n\n\t\t\tscreen->httpDir = http_dir;\n\n\t\t\trfb_http_init_sockets();\n\n\t\t\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\t\t\tlisten_str6 = \"localhost\";\n\t\t\t}\n\n\t\t\tif (screen->httpPort != 0 && screen->httpListenSock < 0) {\n\t\t\t\trfbLog(\"http_connections: failed to listen on http port: %d\\n\", screen->httpPort);\n\t\t\t\tif (ipv6_listen) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"http_connections: trying IPv6 only mode.\\n\");\n\t\t\t}\n\t\t\tif (ipv6_listen && screen->httpPort > 0) {\n\t\t\t\tif (fd6 < 0) {\n\t\t\t\t\tfd6 = listen6(screen->httpPort);\n\t\t\t\t}\n\t\t\t\tipv6_http_fd = fd6;\n\t\t\t\tif (ipv6_http_fd >= 0) {\n\t\t\t\t\trfbLog(\"http_connections: Listening %s on IPv6 port %d (socket %d)\\n\",\n\t\t\t\t\t    screen->httpListenSock < 0 ? \"only\" : \"also\",\n\t\t\t\t\t    screen->httpPort, ipv6_http_fd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisten_str6 = save;\n\t\t}\n\t} else {\n\t\trfbLog(\"http_connections: turning off http service.\\n\");\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t\tscreen->httpDir = NULL;\n\t\tif (ipv6_http_fd >= 0) {\n\t\t\tclose(ipv6_http_fd);\n\t\t\tipv6_http_fd = -1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rfb_http_init_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "473-494",
    "snippet": "static void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void http_connections(int on);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "screen->httpListenSock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbHttpInitSockets",
          "args": [
            "screen"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTP_LISTEN_LOCALHOST\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid http_connections(int on);\n\nstatic void rfb_http_init_sockets(void) {\n\tin_addr_t iface;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tiface = screen->listenInterface;\n\tif (getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\trfbLog(\"http_connections: HTTP listen on localhost only. (not HTTPS)\\n\");\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t}\n\trfbHttpInitSockets(screen);\n\tif (noipv4 || getenv(\"IPV4_FAILS\")) {\n\t\tif (getenv(\"IPV4_FAILS\")) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for rfb_http_init_sockets()\\n\");\n\t\t}\n\t\tif (screen->httpListenSock > -1) {\n\t\t\tclose(screen->httpListenSock);\n\t\t\tscreen->httpListenSock = -1;\n\t\t}\n\t}\n\tscreen->listenInterface = iface;\n}"
  },
  {
    "function_name": "check_httpdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "349-471",
    "snippet": "int check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_httpdir(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "httpdir"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: bad guess:\\n\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "use[i]"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "use[i]",
            "&sbuf"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   %s\\n\"",
            "httpdir"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: guessed directory:\\n\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "prog"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../classes\"",
            "prog"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../classes/ssl\"",
            "prog"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../classes/ssl\"",
            "prog"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../share/x11vnc/classes\"",
            "prog"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../share/x11vnc/classes/ssl\"",
            "prog"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "httpdir",
            "len",
            "\"%s/../share/x11vnc/classes/ssl\"",
            "prog"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prog"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: bad program path: %s\\n\"",
            "prog"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "prog",
            "'/'"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prog",
            "len",
            "\"%s/%s\"",
            "p",
            "base"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "base"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path",
            "\":\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "program_name",
            "'/'"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"PATH\")"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prog",
            "len",
            "\"%s/%s\"",
            "cwd",
            "program_name"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "program_name"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cwd"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcwd",
          "args": [
            "cwd",
            "1024"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "program_name"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_httpdir: trying to guess httpdir... %s\\n\"",
            "program_name"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint check_httpdir(void);\n\nint check_httpdir(void) {\n\tif (http_dir && http_dir[0] != '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *prog = NULL, *httpdir, *q;\n\t\tstruct stat sbuf;\n\t\tint len;\n\n\t\trfbLog(\"check_httpdir: trying to guess httpdir... %s\\n\", program_name);\n\t\tif (program_name[0] == '/') {\n\t\t\tprog = strdup(program_name);\n\t\t} else {\n\t\t\tchar cwd[1024];\n\t\t\tgetcwd(cwd, 1024);\n\t\t\tlen = strlen(cwd) + 1 + strlen(program_name) + 1;\n\t\t\tprog = (char *) malloc(len);\n\t\t\tsnprintf(prog, len, \"%s/%s\", cwd, program_name);\n\t\t\tif (stat(prog, &sbuf) != 0) {\n\t\t\t\tchar *path = strdup(getenv(\"PATH\"));\n\t\t\t\tchar *p, *base;\n\t\t\t\tbase = strrchr(program_name, '/');\n\t\t\t\tif (base) {\n\t\t\t\t\tbase++;\n\t\t\t\t} else {\n\t\t\t\t\tbase = program_name;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp = strtok(path, \":\");\n\t\t\t\twhile(p) {\n\t\t\t\t\tif (prog) {\n\t\t\t\t\t\tfree(prog);\n\t\t\t\t\t\tprog = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tlen = strlen(p) + 1 + strlen(base) + 1;\n\t\t\t\t\tprog = (char *) malloc(len);\n\t\t\t\t\tsnprintf(prog, len, \"%s/%s\", p, base);\n\t\t\t\t\tif (stat(prog, &sbuf) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \":\");\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * /path/to/bin/x11vnc\n\t\t * /path/to/bin/../share/x11vnc/classes\n\t\t *                    12345678901234567\n\t\t * /path/to/bin/../share/x11vnc/classes/ssl\n\t\t *                    123456789012345678901\n\t\t *                                        21\n\t\t */\n\t\tif ((q = strrchr(prog, '/')) == NULL) {\n\t\t\trfbLog(\"check_httpdir: bad program path: %s\\n\", prog);\n\t\t\tfree(prog);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen = strlen(prog) + 21 + 1;\n\t\t*q = '\\0';\n\t\thttpdir = (char *) malloc(len);\n\t\tif (use_stunnel && http_ssl) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes/ssl\", prog);\n\t\t} else {\n\t\t\tsnprintf(httpdir, len, \"%s/../share/x11vnc/classes\", prog);\n\t\t}\n\t\tif (stat(httpdir, &sbuf) != 0) {\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes/ssl\", prog);\n\t\t\t} else {\n\t\t\t\tsnprintf(httpdir, len, \"%s/../classes\", prog);\n\t\t\t}\n\t\t}\n\t\tfree(prog);\n\n\t\tif (stat(httpdir, &sbuf) == 0) {\n\t\t\t/* good enough for me */\n\t\t\trfbLog(\"check_httpdir: guessed directory:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\thttp_dir = httpdir;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t/* try some hardwires: */\n\t\t\tint i;\n\t\t\tchar **use;\n\t\t\tchar *list[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes\",\n\t\t\t\t\"/usr/share/x11vnc/classes\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tchar *ssllist[] = {\n\t\t\t\t\"/usr/local/share/x11vnc/classes/ssl\",\n\t\t\t\t\"/usr/share/x11vnc/classes/ssl\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tif (use_stunnel && http_ssl) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else if (!enc_str && (use_openssl || use_stunnel || http_ssl)) {\n\t\t\t\tuse = ssllist;\n\t\t\t} else {\n\t\t\t\tuse = list;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (use[i] != NULL) {\n\t\t\t\tif (stat(use[i], &sbuf) == 0) {\n\t\t\t\t\thttp_dir = strdup(use[i]);\t\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\trfbLog(\"check_httpdir: bad guess:\\n\");\n\t\t\trfbLog(\"   %s\\n\", httpdir);\n\t\t\trfbLog(\"check_httpdir: *HTTP disabled*  Use -httpdir path\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_black_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "337-347",
    "snippet": "void check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_black_fb(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_black_screen",
          "args": [
            "4"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "push_black_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "502-515",
          "snippet": "void push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void push_sleep(int n);",
            "void push_black_screen(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\"",
            "client_count",
            "new_fb_size_clients(screen)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_fb_size_clients",
          "args": [
            "screen"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "new_fb_size_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "232-249",
          "snippet": "int new_fb_size_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->useNewFBSize) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\n\nint new_fb_size_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->useNewFBSize) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid check_black_fb(void);\n\nvoid check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}"
  },
  {
    "function_name": "if_8bpp_do_new_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "329-335",
    "snippet": "static void if_8bpp_do_new_fb(void) {\n\tif (bpp == 8) {\n\t\tdo_new_fb(0);\n\t} else {\n\t\trfbLog(\"  bpp(%d) is not 8bpp, not resetting fb\\n\", bpp);\n\t}\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void if_8bpp_do_new_fb(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  bpp(%d) is not 8bpp, not resetting fb\\n\"",
            "bpp"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void if_8bpp_do_new_fb(void);\n\nstatic void if_8bpp_do_new_fb(void) {\n\tif (bpp == 8) {\n\t\tdo_new_fb(0);\n\t} else {\n\t\trfbLog(\"  bpp(%d) is not 8bpp, not resetting fb\\n\", bpp);\n\t}\n}"
  },
  {
    "function_name": "delete_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "301-327",
    "snippet": "static char *delete_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(\"\");\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item) || *p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\treturn str;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *add_item(char *instr, char *item);",
      "static char *delete_item(char *instr, char *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "p"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\",\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "item"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "instr",
            "\",\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "instr"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *add_item(char *instr, char *item);\nstatic char *delete_item(char *instr, char *item);\n\nstatic char *delete_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(\"\");\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item) || *p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\treturn str;\n}"
  },
  {
    "function_name": "add_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "261-299",
    "snippet": "static char *add_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len, saw_item = 0;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(item);\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1 + strlen(item) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item)) {\n\t\t\tif (saw_item) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_item = 1;\n\t\t} else if (*p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tif (! saw_item) {\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, item);\n\t}\n\treturn str;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *add_item(char *instr, char *item);",
      "static char *delete_item(char *instr, char *item);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "item"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\",\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "p"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\",\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "item"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "instr",
            "\",\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "item"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "instr"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "item"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *add_item(char *instr, char *item);\nstatic char *delete_item(char *instr, char *item);\n\nstatic char *add_item(char *instr, char *item) {\n\tchar *p, *str;\n\tint len, saw_item = 0;\n\n\tif (! instr || *instr == '\\0') {\n\t\tstr = strdup(item);\n\t\treturn str;\n\t}\n\tlen = strlen(instr) + 1 + strlen(item) + 1;\n\tstr = (char *) malloc(len);\n\tstr[0] = '\\0';\n\n\t/* n.b. instr will be modified; caller replaces with returned string */\n\tp = strtok(instr, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, item)) {\n\t\t\tif (saw_item) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_item = 1;\n\t\t} else if (*p == '\\0') {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tif (! saw_item) {\n\t\tif (str[0]) {\n\t\t\tstrcat(str, \",\");\n\t\t}\n\t\tstrcat(str, item);\n\t}\n\treturn str;\n}"
  },
  {
    "function_name": "do_remote_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "191-259",
    "snippet": "int do_remote_query(char *remote_cmd, char *query_cmd, int remote_sync,\n    int qdefault) {\n\tchar *rcmd = NULL, *qcmd = NULL;\n\tint rc = 1, direct = 0;\n\n\tif (qdefault && !query_cmd) {\n\t\tquery_cmd = remote_cmd;\n\t\tremote_cmd = NULL;\n\t}\n\tif (remote_cmd && strstr(remote_cmd, \"DIRECT:\") == remote_cmd) {\n\t\tdirect = 1;\n\t\tremote_cmd += strlen(\"DIRECT:\");\n\t}\n\tif (query_cmd && strstr(query_cmd, \"DIRECT:\") == query_cmd) {\n\t\tdirect = 1;\n\t\tquery_cmd += strlen(\"DIRECT:\");\n\t}\n\n\tif (remote_cmd) {\n\t\trcmd = (char *) malloc(strlen(remote_cmd) + 5);\n\t\tstrcpy(rcmd, \"cmd=\");\n\t\tstrcat(rcmd, remote_cmd);\n\t}\n\tif (query_cmd) {\n\t\tqcmd = (char *) malloc(strlen(query_cmd) + 5);\n\t\tstrcpy(qcmd, \"qry=\");\n\t\tstrcat(qcmd, query_cmd);\n\t}\n\tif (direct) {\n\t\tchar *res;\n\t\tif (rcmd) {\n\t\t\tres = process_remote_cmd(rcmd, 1);\n\t\t\tfprintf(stdout, \"%s\\n\", res);\n\t\t}\n\t\tif (qcmd) {\n\t\t\tres = process_remote_cmd(qcmd, 1);\n\t\t\tfprintf(stdout, \"%s\\n\", res);\n\t\t}\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tif (qdefault) {\n\t\tchar *res;\n\t\tif (!qcmd) {\n\t\t\treturn 1;\n\t\t}\n\t\tres = process_remote_cmd(qcmd, 1);\n\t\tfprintf(stdout, \"%s\\n\", res);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tif (rcmd && qcmd) {\n\t\trc = send_remote_cmd(rcmd, 0, 1);\n\t\tif (rc) {\n\t\t\tfree(rcmd);\n\t\t\tfree(qcmd);\n\t\t\treturn(rc);\n\t\t}\n\t\trc = send_remote_cmd(qcmd, 1, 1);\n\t} else if (rcmd) {\n\t\trc = send_remote_cmd(rcmd, 0, remote_sync);\n\t\tfree(rcmd);\n\t} else if (qcmd) {\n\t\trc = send_remote_cmd(qcmd, 1, 1);\n\t\tfree(qcmd);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int do_remote_query(char *remote_cmd, char *query_cmd, int remote_sync,\n    int qdefault);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "qcmd"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_remote_cmd",
          "args": [
            "qcmd",
            "1",
            "1"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "send_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "85-189",
          "snippet": "int send_remote_cmd(char *cmd, int query, int wait) {\n\tFILE *in = NULL;\n\n\tif (query_result != NULL) {\n\t\tfree(query_result);\n\t\tquery_result = NULL;\n\t}\n\n\tif (client_connect_file) {\n\t\tumask(077);\n\t\tin = fopen(client_connect_file, \"w\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not open \"\n\t\t\t    \"connect file \\\"%s\\\" for writing\\n\",\n\t\t\t    client_connect_file);\n\t\t\tperror(\"fopen\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (x11vnc_remote_prop == None) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tif (x11vnc_remote_prop == None) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not obtain \"\n\t\t\t    \"X11VNC_REMOTE X property\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\"\\n  via\"\n\t\t    \" connect file: %s\\n\", cmd, client_connect_file);\n\t\tfprintf(in, \"%s\\n\", cmd);\n\t\tfclose(in);\n\t} else {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\" via\"\n\t\t    \" X11VNC_REMOTE X property.\\n\", cmd);\n\t\tset_x11vnc_remote_prop(cmd);\n\t\tif (dpy) {\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t}\n\n\tif (query || wait) {\n\t\tchar line[X11VNC_REMOTE_MAX];\t\n\t\tint rc=1, i=0, max=140, ms_sl=25;\n\n\t\tif (!strcmp(cmd, \"cmd=stop\")) {\n\t\t\tmax = 40;\n\t\t}\n\t\tif (strstr(cmd, \"script:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (strstr(cmd, \"bcx_xattach:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (getenv(\"X11VNC_SYNC_TIMEOUT\")) {\n\t\t\tmax = (int) ((1000. * atof(getenv(\"X11VNC_SYNC_TIMEOUT\")))/ms_sl);\n\t\t}\n\t\tfor (i=0; i<max; i++) {\n\t\t\tif (i==0) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\tusleep(ms_sl * 1000);\n\t\t\t}\n\t\t\tif (client_connect_file) {\n\t\t\t\tchar *q;\n\t\t\t\tin = fopen(client_connect_file, \"r\");\n\t\t\t\tif (in == NULL) {\n\t\t\t\t\tfprintf(stderr, \"send_remote_cmd: could\"\n\t\t\t\t\t    \" not open connect file \\\"%s\\\" for\"\n\t\t\t\t\t    \" writing\\n\", client_connect_file);\n\t\t\t\t\tperror(\"fopen\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfgets(line, X11VNC_REMOTE_MAX, in);\n\t\t\t\tfclose(in);\n\t\t\t\tq = line;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '\\n') *q = '\\0';\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_x11vnc_remote_prop(1);\n\t\t\t\tstrncpy(line, x11vnc_remote_str,\n\t\t\t\t    X11VNC_REMOTE_MAX);\n\t\t\t}\n\t\t\tif (strcmp(cmd, line)) {\n\t\t\t\tif (query || wait) {\n\t\t\t\t\tquery_result = strdup(line);\n\t\t\t\t\tfprintf(stdout, \"%s\\n\", line);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t}\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"error: could not connect to \"\n\t\t\t    \"an x11vnc server at %s  (rc=%d)\\n\",\n\t\t\t    client_connect_file ? client_connect_file\n\t\t\t    : DisplayString(dpy), rc);\n\t\t}\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "char *query_result = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint send_remote_cmd(char *cmd, int query, int wait);\nchar *query_result = NULL;\n\nint send_remote_cmd(char *cmd, int query, int wait) {\n\tFILE *in = NULL;\n\n\tif (query_result != NULL) {\n\t\tfree(query_result);\n\t\tquery_result = NULL;\n\t}\n\n\tif (client_connect_file) {\n\t\tumask(077);\n\t\tin = fopen(client_connect_file, \"w\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not open \"\n\t\t\t    \"connect file \\\"%s\\\" for writing\\n\",\n\t\t\t    client_connect_file);\n\t\t\tperror(\"fopen\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (x11vnc_remote_prop == None) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tif (x11vnc_remote_prop == None) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not obtain \"\n\t\t\t    \"X11VNC_REMOTE X property\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\"\\n  via\"\n\t\t    \" connect file: %s\\n\", cmd, client_connect_file);\n\t\tfprintf(in, \"%s\\n\", cmd);\n\t\tfclose(in);\n\t} else {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\" via\"\n\t\t    \" X11VNC_REMOTE X property.\\n\", cmd);\n\t\tset_x11vnc_remote_prop(cmd);\n\t\tif (dpy) {\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t}\n\n\tif (query || wait) {\n\t\tchar line[X11VNC_REMOTE_MAX];\t\n\t\tint rc=1, i=0, max=140, ms_sl=25;\n\n\t\tif (!strcmp(cmd, \"cmd=stop\")) {\n\t\t\tmax = 40;\n\t\t}\n\t\tif (strstr(cmd, \"script:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (strstr(cmd, \"bcx_xattach:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (getenv(\"X11VNC_SYNC_TIMEOUT\")) {\n\t\t\tmax = (int) ((1000. * atof(getenv(\"X11VNC_SYNC_TIMEOUT\")))/ms_sl);\n\t\t}\n\t\tfor (i=0; i<max; i++) {\n\t\t\tif (i==0) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\tusleep(ms_sl * 1000);\n\t\t\t}\n\t\t\tif (client_connect_file) {\n\t\t\t\tchar *q;\n\t\t\t\tin = fopen(client_connect_file, \"r\");\n\t\t\t\tif (in == NULL) {\n\t\t\t\t\tfprintf(stderr, \"send_remote_cmd: could\"\n\t\t\t\t\t    \" not open connect file \\\"%s\\\" for\"\n\t\t\t\t\t    \" writing\\n\", client_connect_file);\n\t\t\t\t\tperror(\"fopen\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfgets(line, X11VNC_REMOTE_MAX, in);\n\t\t\t\tfclose(in);\n\t\t\t\tq = line;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '\\n') *q = '\\0';\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_x11vnc_remote_prop(1);\n\t\t\t\tstrncpy(line, x11vnc_remote_str,\n\t\t\t\t    X11VNC_REMOTE_MAX);\n\t\t\t}\n\t\t\tif (strcmp(cmd, line)) {\n\t\t\t\tif (query || wait) {\n\t\t\t\t\tquery_result = strdup(line);\n\t\t\t\t\tfprintf(stdout, \"%s\\n\", line);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t}\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"error: could not connect to \"\n\t\t\t    \"an x11vnc server at %s  (rc=%d)\\n\",\n\t\t\t    client_connect_file ? client_connect_file\n\t\t\t    : DisplayString(dpy), rc);\n\t\t}\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "res"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "qcmd",
            "1"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "res"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "res"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "qcmd",
            "query_cmd"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "qcmd",
            "\"qry=\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(query_cmd) + 5"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "query_cmd"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "rcmd",
            "remote_cmd"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "rcmd",
            "\"cmd=\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(remote_cmd) + 5"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote_cmd"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"DIRECT:\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "query_cmd",
            "\"DIRECT:\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"DIRECT:\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "remote_cmd",
            "\"DIRECT:\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint do_remote_query(char *remote_cmd, char *query_cmd, int remote_sync,\n    int qdefault);\n\nint do_remote_query(char *remote_cmd, char *query_cmd, int remote_sync,\n    int qdefault) {\n\tchar *rcmd = NULL, *qcmd = NULL;\n\tint rc = 1, direct = 0;\n\n\tif (qdefault && !query_cmd) {\n\t\tquery_cmd = remote_cmd;\n\t\tremote_cmd = NULL;\n\t}\n\tif (remote_cmd && strstr(remote_cmd, \"DIRECT:\") == remote_cmd) {\n\t\tdirect = 1;\n\t\tremote_cmd += strlen(\"DIRECT:\");\n\t}\n\tif (query_cmd && strstr(query_cmd, \"DIRECT:\") == query_cmd) {\n\t\tdirect = 1;\n\t\tquery_cmd += strlen(\"DIRECT:\");\n\t}\n\n\tif (remote_cmd) {\n\t\trcmd = (char *) malloc(strlen(remote_cmd) + 5);\n\t\tstrcpy(rcmd, \"cmd=\");\n\t\tstrcat(rcmd, remote_cmd);\n\t}\n\tif (query_cmd) {\n\t\tqcmd = (char *) malloc(strlen(query_cmd) + 5);\n\t\tstrcpy(qcmd, \"qry=\");\n\t\tstrcat(qcmd, query_cmd);\n\t}\n\tif (direct) {\n\t\tchar *res;\n\t\tif (rcmd) {\n\t\t\tres = process_remote_cmd(rcmd, 1);\n\t\t\tfprintf(stdout, \"%s\\n\", res);\n\t\t}\n\t\tif (qcmd) {\n\t\t\tres = process_remote_cmd(qcmd, 1);\n\t\t\tfprintf(stdout, \"%s\\n\", res);\n\t\t}\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tif (qdefault) {\n\t\tchar *res;\n\t\tif (!qcmd) {\n\t\t\treturn 1;\n\t\t}\n\t\tres = process_remote_cmd(qcmd, 1);\n\t\tfprintf(stdout, \"%s\\n\", res);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tif (rcmd && qcmd) {\n\t\trc = send_remote_cmd(rcmd, 0, 1);\n\t\tif (rc) {\n\t\t\tfree(rcmd);\n\t\t\tfree(qcmd);\n\t\t\treturn(rc);\n\t\t}\n\t\trc = send_remote_cmd(qcmd, 1, 1);\n\t} else if (rcmd) {\n\t\trc = send_remote_cmd(rcmd, 0, remote_sync);\n\t\tfree(rcmd);\n\t} else if (qcmd) {\n\t\trc = send_remote_cmd(qcmd, 1, 1);\n\t\tfree(qcmd);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "send_remote_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
    "lines": "85-189",
    "snippet": "int send_remote_cmd(char *cmd, int query, int wait) {\n\tFILE *in = NULL;\n\n\tif (query_result != NULL) {\n\t\tfree(query_result);\n\t\tquery_result = NULL;\n\t}\n\n\tif (client_connect_file) {\n\t\tumask(077);\n\t\tin = fopen(client_connect_file, \"w\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not open \"\n\t\t\t    \"connect file \\\"%s\\\" for writing\\n\",\n\t\t\t    client_connect_file);\n\t\t\tperror(\"fopen\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (x11vnc_remote_prop == None) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tif (x11vnc_remote_prop == None) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not obtain \"\n\t\t\t    \"X11VNC_REMOTE X property\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\"\\n  via\"\n\t\t    \" connect file: %s\\n\", cmd, client_connect_file);\n\t\tfprintf(in, \"%s\\n\", cmd);\n\t\tfclose(in);\n\t} else {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\" via\"\n\t\t    \" X11VNC_REMOTE X property.\\n\", cmd);\n\t\tset_x11vnc_remote_prop(cmd);\n\t\tif (dpy) {\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t}\n\n\tif (query || wait) {\n\t\tchar line[X11VNC_REMOTE_MAX];\t\n\t\tint rc=1, i=0, max=140, ms_sl=25;\n\n\t\tif (!strcmp(cmd, \"cmd=stop\")) {\n\t\t\tmax = 40;\n\t\t}\n\t\tif (strstr(cmd, \"script:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (strstr(cmd, \"bcx_xattach:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (getenv(\"X11VNC_SYNC_TIMEOUT\")) {\n\t\t\tmax = (int) ((1000. * atof(getenv(\"X11VNC_SYNC_TIMEOUT\")))/ms_sl);\n\t\t}\n\t\tfor (i=0; i<max; i++) {\n\t\t\tif (i==0) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\tusleep(ms_sl * 1000);\n\t\t\t}\n\t\t\tif (client_connect_file) {\n\t\t\t\tchar *q;\n\t\t\t\tin = fopen(client_connect_file, \"r\");\n\t\t\t\tif (in == NULL) {\n\t\t\t\t\tfprintf(stderr, \"send_remote_cmd: could\"\n\t\t\t\t\t    \" not open connect file \\\"%s\\\" for\"\n\t\t\t\t\t    \" writing\\n\", client_connect_file);\n\t\t\t\t\tperror(\"fopen\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfgets(line, X11VNC_REMOTE_MAX, in);\n\t\t\t\tfclose(in);\n\t\t\t\tq = line;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '\\n') *q = '\\0';\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_x11vnc_remote_prop(1);\n\t\t\t\tstrncpy(line, x11vnc_remote_str,\n\t\t\t\t    X11VNC_REMOTE_MAX);\n\t\t\t}\n\t\t\tif (strcmp(cmd, line)) {\n\t\t\t\tif (query || wait) {\n\t\t\t\t\tquery_result = strdup(line);\n\t\t\t\t\tfprintf(stdout, \"%s\\n\", line);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t}\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"error: could not connect to \"\n\t\t\t    \"an x11vnc server at %s  (rc=%d)\\n\",\n\t\t\t    client_connect_file ? client_connect_file\n\t\t\t    : DisplayString(dpy), rc);\n\t\t}\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sslhelper.h\"",
      "#include \"avahi.h\"",
      "#include \"userinput.h\"",
      "#include \"uinput.h\"",
      "#include \"unixpw.h\"",
      "#include \"selection.h\"",
      "#include \"keyboard.h\"",
      "#include \"userinput.h\"",
      "#include \"cursor.h\"",
      "#include \"pointer.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"screen.h\"",
      "#include \"win_utils.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xinerama.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int send_remote_cmd(char *cmd, int query, int wait);",
      "char *query_result = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"error: could not connect to \"\n\t\t\t    \"an x11vnc server at %s  (rc=%d)\\n\"",
            "client_connect_file ? client_connect_file\n\t\t\t    : DisplayString(dpy)",
            "rc"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "line"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "line"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "line",
            "x11vnc_remote_str",
            "X11VNC_REMOTE_MAX"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_x11vnc_remote_prop",
          "args": [
            "1"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "read_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3106-3174",
          "snippet": "void read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char x11vnc_remote_str[X11VNC_REMOTE_MAX+1];",
            "Atom x11vnc_remote_prop = None;",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "int cmd_ok(char *cmd);",
            "void read_x11vnc_remote_prop(int);",
            "void adjust_grabs(int grab, int quiet);",
            "int set_xprop(char *prop, Window win, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar x11vnc_remote_str[X11VNC_REMOTE_MAX+1];\nAtom x11vnc_remote_prop = None;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid read_x11vnc_remote_prop(int);\nvoid adjust_grabs(int grab, int quiet);\nint set_xprop(char *prop, Window win, char *value);\n\nvoid read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "X11VNC_REMOTE_MAX",
            "in"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"send_remote_cmd: could\"\n\t\t\t\t\t    \" not open connect file \\\"%s\\\" for\"\n\t\t\t\t\t    \" writing\\n\"",
            "client_connect_file"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"r\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms_sl * 1000"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "getenv(\"X11VNC_SYNC_TIMEOUT\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SYNC_TIMEOUT\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SYNC_TIMEOUT\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"bcx_xattach:\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"script:\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"cmd=stop\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_x11vnc_remote_prop",
          "args": [
            "cmd"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "set_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3043-3052",
          "snippet": "void set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Atom x11vnc_remote_prop = None;",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nAtom x11vnc_remote_prop = None;\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>> sending remote command: \\\"%s\\\" via\"\n\t\t    \" X11VNC_REMOTE X property.\\n\"",
            "cmd"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"%s\\n\"",
            "cmd"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>> sending remote command: \\\"%s\\\"\\n  via\"\n\t\t    \" connect file: %s\\n\"",
            "cmd",
            "client_connect_file"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"send_remote_cmd: could not obtain \"\n\t\t\t    \"X11VNC_REMOTE X property\\n\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_x11vnc_remote_prop",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "104-115",
          "snippet": "void initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_x11vnc_remote_prop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_x11vnc_remote_prop(void);\n\nvoid initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fopen\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"send_remote_cmd: could not open \"\n\t\t\t    \"connect file \\\"%s\\\" for writing\\n\"",
            "client_connect_file"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"w\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "query_result"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint send_remote_cmd(char *cmd, int query, int wait);\nchar *query_result = NULL;\n\nint send_remote_cmd(char *cmd, int query, int wait) {\n\tFILE *in = NULL;\n\n\tif (query_result != NULL) {\n\t\tfree(query_result);\n\t\tquery_result = NULL;\n\t}\n\n\tif (client_connect_file) {\n\t\tumask(077);\n\t\tin = fopen(client_connect_file, \"w\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not open \"\n\t\t\t    \"connect file \\\"%s\\\" for writing\\n\",\n\t\t\t    client_connect_file);\n\t\t\tperror(\"fopen\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (x11vnc_remote_prop == None) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tif (x11vnc_remote_prop == None) {\n\t\t\tfprintf(stderr, \"send_remote_cmd: could not obtain \"\n\t\t\t    \"X11VNC_REMOTE X property\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (in != NULL) {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\"\\n  via\"\n\t\t    \" connect file: %s\\n\", cmd, client_connect_file);\n\t\tfprintf(in, \"%s\\n\", cmd);\n\t\tfclose(in);\n\t} else {\n\t\tfprintf(stderr, \">>> sending remote command: \\\"%s\\\" via\"\n\t\t    \" X11VNC_REMOTE X property.\\n\", cmd);\n\t\tset_x11vnc_remote_prop(cmd);\n\t\tif (dpy) {\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t}\n\n\tif (query || wait) {\n\t\tchar line[X11VNC_REMOTE_MAX];\t\n\t\tint rc=1, i=0, max=140, ms_sl=25;\n\n\t\tif (!strcmp(cmd, \"cmd=stop\")) {\n\t\t\tmax = 40;\n\t\t}\n\t\tif (strstr(cmd, \"script:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (strstr(cmd, \"bcx_xattach:\")) {\n\t\t\tmax = 400;\n\t\t}\n\t\tif (getenv(\"X11VNC_SYNC_TIMEOUT\")) {\n\t\t\tmax = (int) ((1000. * atof(getenv(\"X11VNC_SYNC_TIMEOUT\")))/ms_sl);\n\t\t}\n\t\tfor (i=0; i<max; i++) {\n\t\t\tif (i==0) {\n\t\t\t\tusleep(10 * 1000);\n\t\t\t} else {\n\t\t\t\tusleep(ms_sl * 1000);\n\t\t\t}\n\t\t\tif (client_connect_file) {\n\t\t\t\tchar *q;\n\t\t\t\tin = fopen(client_connect_file, \"r\");\n\t\t\t\tif (in == NULL) {\n\t\t\t\t\tfprintf(stderr, \"send_remote_cmd: could\"\n\t\t\t\t\t    \" not open connect file \\\"%s\\\" for\"\n\t\t\t\t\t    \" writing\\n\", client_connect_file);\n\t\t\t\t\tperror(\"fopen\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfgets(line, X11VNC_REMOTE_MAX, in);\n\t\t\t\tfclose(in);\n\t\t\t\tq = line;\n\t\t\t\twhile (*q != '\\0') {\n\t\t\t\t\tif (*q == '\\n') *q = '\\0';\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_x11vnc_remote_prop(1);\n\t\t\t\tstrncpy(line, x11vnc_remote_str,\n\t\t\t\t    X11VNC_REMOTE_MAX);\n\t\t\t}\n\t\t\tif (strcmp(cmd, line)) {\n\t\t\t\tif (query || wait) {\n\t\t\t\t\tquery_result = strdup(line);\n\t\t\t\t\tfprintf(stdout, \"%s\\n\", line);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t}\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"error: could not connect to \"\n\t\t\t    \"an x11vnc server at %s  (rc=%d)\\n\",\n\t\t\t    client_connect_file ? client_connect_file\n\t\t\t    : DisplayString(dpy), rc);\n\t\t}\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
  }
]