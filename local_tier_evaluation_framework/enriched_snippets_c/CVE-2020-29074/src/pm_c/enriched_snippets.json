[
  {
    "function_name": "check_dpms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
    "lines": "207-296",
    "snippet": "static void check_dpms(void) {\n\tstatic int init_dpms = 0;\n#if HAVE_DPMS\n\tstatic int dpms_capable = 0;\n\tstatic time_t last_dpms = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_dpms) {\n\t\tif (getenv(\"DPMS_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"DPMS_DEBUG\"));\n\t\t}\n\t\tif (DPMSCapable(dpy)) {\n\t\t\tdpms_capable = 1;\n\t\t\trfbLog(\"X display is capable of DPMS.\\n\");\n\t\t\tif (watch_dpms) {\n\t\t\t\trfbLog(\"Preventing low-power DPMS modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of DPMS.\\n\");\n\t\t\t}\n\t\t\tdpms_capable = 0;\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n\n\tif (force_dpms || (client_dpms && client_count)) {\n\t\tstatic int last_enable = 0;\n\t\tif (time(NULL) > last_enable) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tlast_enable = time(NULL);\n\t\t}\n\t\tset_dpms_mode(\"off\");\n\t}\n\tif (! watch_dpms) {\n\t\treturn;\n\t}\n\tif (! dpms_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_dpms + 5) {\n\t\treturn;\n\t}\n\tlast_dpms = time(NULL);\n\n\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != DPMSModeOn) {\n\t\t\tchar *from = \"unknown-dpms-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching DPMS state from %s to DPMSModeOn\\n\", from);\n\t\t\t\n\t\t\tDPMSForceLevel(dpy, DPMSModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"DPMSInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_dpms) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X DPMS extension not supported.\\n\");\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/dpms.h>",
      "#include <X11/extensions/fbpm.h>",
      "#include <X11/Xmd.h>",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_dpms(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X DPMS extension not supported.\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DPMSInfo failed.\\n\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPMSForceLevel",
          "args": [
            "dpy",
            "DPMSModeOn"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"switching DPMS state from %s to DPMSModeOn\\n\"",
            "from"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DPMSInfo level: %d enabled: %d\\n\"",
            "level",
            "enabled"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSInfo",
          "args": [
            "dpy",
            "&level",
            "&enabled"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dpms_mode",
          "args": [
            "\"off\""
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "set_dpms_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
          "lines": "150-205",
          "snippet": "void set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}",
          "includes": [
            "#include <X11/extensions/dpms.h>",
            "#include <X11/extensions/fbpm.h>",
            "#include <X11/Xmd.h>",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_dpms_mode(char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_dpms_mode(char *mode);\n\nvoid set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X display is not capable of DPMS.\\n\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Preventing low-power DPMS modes when\"\n\t\t\t\t    \" clients are connected.\\n\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X display is capable of DPMS.\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSCapable",
          "args": [
            "dpy"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"DPMS_DEBUG\")"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DPMS_DEBUG\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DPMS_DEBUG\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void check_dpms(void);\n\nstatic void check_dpms(void) {\n\tstatic int init_dpms = 0;\n#if HAVE_DPMS\n\tstatic int dpms_capable = 0;\n\tstatic time_t last_dpms = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_dpms) {\n\t\tif (getenv(\"DPMS_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"DPMS_DEBUG\"));\n\t\t}\n\t\tif (DPMSCapable(dpy)) {\n\t\t\tdpms_capable = 1;\n\t\t\trfbLog(\"X display is capable of DPMS.\\n\");\n\t\t\tif (watch_dpms) {\n\t\t\t\trfbLog(\"Preventing low-power DPMS modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of DPMS.\\n\");\n\t\t\t}\n\t\t\tdpms_capable = 0;\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n\n\tif (force_dpms || (client_dpms && client_count)) {\n\t\tstatic int last_enable = 0;\n\t\tif (time(NULL) > last_enable) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tlast_enable = time(NULL);\n\t\t}\n\t\tset_dpms_mode(\"off\");\n\t}\n\tif (! watch_dpms) {\n\t\treturn;\n\t}\n\tif (! dpms_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_dpms + 5) {\n\t\treturn;\n\t}\n\tlast_dpms = time(NULL);\n\n\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != DPMSModeOn) {\n\t\t\tchar *from = \"unknown-dpms-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching DPMS state from %s to DPMSModeOn\\n\", from);\n\t\t\t\n\t\t\tDPMSForceLevel(dpy, DPMSModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"DPMSInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_dpms) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X DPMS extension not supported.\\n\");\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n#endif\n}"
  },
  {
    "function_name": "set_dpms_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
    "lines": "150-205",
    "snippet": "void set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}",
    "includes": [
      "#include <X11/extensions/dpms.h>",
      "#include <X11/extensions/fbpm.h>",
      "#include <X11/Xmd.h>",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_dpms_mode(char *mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPMSForceLevel",
          "args": [
            "dpy",
            "want"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"switching DPMS state from %s to %s\\n\"",
            "from",
            "mode"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"DPMSInfo level: %d enabled: %d\\n\"",
            "level",
            "enabled"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSInfo",
          "args": [
            "dpy",
            "&level",
            "&enabled"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSDisable",
          "args": [
            "dpy"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"disable\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSEnable",
          "args": [
            "dpy"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"enable\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"suspend\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"standby\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"on\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"off\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPMSCapable",
          "args": [
            "dpy"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_dpms_mode(char *mode);\n\nvoid set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}"
  },
  {
    "function_name": "check_fbpm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
    "lines": "67-148",
    "snippet": "static void check_fbpm(void) {\n\tstatic int init_fbpm = 0;\n#if HAVE_FBPM\n\tstatic int fbpm_capable = 0;\n\tstatic time_t last_fbpm = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_fbpm) {\n\t\tif (getenv(\"FBPM_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"FBPM_DEBUG\"));\n\t\t}\n\t\tif (FBPMCapable(dpy)) {\n\t\t\tfbpm_capable = 1;\n\t\t\trfbLog(\"X display is capable of FBPM.\\n\");\n\t\t\tif (watch_fbpm) {\n\t\t\t\trfbLog(\"Preventing low-power FBPM modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of FBPM.\\n\");\n\t\t\t}\n\t\t\tfbpm_capable = 0;\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n\n\tif (! watch_fbpm) {\n\t\treturn;\n\t}\n\tif (! fbpm_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_fbpm + 5) {\n\t\treturn;\n\t}\n\tlast_fbpm = time(NULL);\n\n\tif (FBPMInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"FBPMInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != FBPMModeOn) {\n\t\t\tchar *from = \"unknown-fbpm-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == FBPMModeStandby) {\n\t\t\t\tfrom = \"FBPMModeStandby\";\n\t\t\t} else if (level == FBPMModeSuspend) {\n\t\t\t\tfrom = \"FBPMModeSuspend\";\n\t\t\t} else if (level == FBPMModeOff) {\n\t\t\t\tfrom = \"FBPMModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching FBPM state from %s to FBPMModeOn\\n\", from);\n\t\t\t\n\t\t\tFBPMForceLevel(dpy, FBPMModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"FBPMInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_fbpm) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X FBPM extension not supported.\\n\");\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/dpms.h>",
      "#include <X11/extensions/fbpm.h>",
      "#include <X11/Xmd.h>",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_fbpm(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X FBPM extension not supported.\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FBPMInfo failed.\\n\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FBPMForceLevel",
          "args": [
            "dpy",
            "FBPMModeOn"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"switching FBPM state from %s to FBPMModeOn\\n\"",
            "from"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FBPMInfo level: %d enabled: %d\\n\"",
            "level",
            "enabled"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FBPMInfo",
          "args": [
            "dpy",
            "&level",
            "&enabled"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X display is not capable of FBPM.\\n\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Preventing low-power FBPM modes when\"\n\t\t\t\t    \" clients are connected.\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X display is capable of FBPM.\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FBPMCapable",
          "args": [
            "dpy"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"FBPM_DEBUG\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FBPM_DEBUG\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FBPM_DEBUG\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void check_fbpm(void);\n\nstatic void check_fbpm(void) {\n\tstatic int init_fbpm = 0;\n#if HAVE_FBPM\n\tstatic int fbpm_capable = 0;\n\tstatic time_t last_fbpm = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_fbpm) {\n\t\tif (getenv(\"FBPM_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"FBPM_DEBUG\"));\n\t\t}\n\t\tif (FBPMCapable(dpy)) {\n\t\t\tfbpm_capable = 1;\n\t\t\trfbLog(\"X display is capable of FBPM.\\n\");\n\t\t\tif (watch_fbpm) {\n\t\t\t\trfbLog(\"Preventing low-power FBPM modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of FBPM.\\n\");\n\t\t\t}\n\t\t\tfbpm_capable = 0;\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n\n\tif (! watch_fbpm) {\n\t\treturn;\n\t}\n\tif (! fbpm_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_fbpm + 5) {\n\t\treturn;\n\t}\n\tlast_fbpm = time(NULL);\n\n\tif (FBPMInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"FBPMInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != FBPMModeOn) {\n\t\t\tchar *from = \"unknown-fbpm-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == FBPMModeStandby) {\n\t\t\t\tfrom = \"FBPMModeStandby\";\n\t\t\t} else if (level == FBPMModeSuspend) {\n\t\t\t\tfrom = \"FBPMModeSuspend\";\n\t\t\t} else if (level == FBPMModeOff) {\n\t\t\t\tfrom = \"FBPMModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching FBPM state from %s to FBPMModeOn\\n\", from);\n\t\t\t\n\t\t\tFBPMForceLevel(dpy, FBPMModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"FBPMInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_fbpm) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X FBPM extension not supported.\\n\");\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n#endif\n}"
  },
  {
    "function_name": "check_pm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
    "lines": "51-65",
    "snippet": "void check_pm(void) {\n\tstatic int skip = -1;\n\tif (skip < 0) {\n\t\tskip = 0;\n\t\tif (getenv(\"X11VNC_NO_CHECK_PM\")) {\n\t\t\tskip = 1;\n\t\t}\n\t}\n\tif (skip) {\n\t\treturn;\n\t}\n\tcheck_fbpm();\n\tcheck_dpms();\n\t/* someday dpms activities? */\n}",
    "includes": [
      "#include <X11/extensions/dpms.h>",
      "#include <X11/extensions/fbpm.h>",
      "#include <X11/Xmd.h>",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_pm(void);",
      "static void check_fbpm(void);",
      "static void check_dpms(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_dpms",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "check_dpms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
          "lines": "207-296",
          "snippet": "static void check_dpms(void) {\n\tstatic int init_dpms = 0;\n#if HAVE_DPMS\n\tstatic int dpms_capable = 0;\n\tstatic time_t last_dpms = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_dpms) {\n\t\tif (getenv(\"DPMS_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"DPMS_DEBUG\"));\n\t\t}\n\t\tif (DPMSCapable(dpy)) {\n\t\t\tdpms_capable = 1;\n\t\t\trfbLog(\"X display is capable of DPMS.\\n\");\n\t\t\tif (watch_dpms) {\n\t\t\t\trfbLog(\"Preventing low-power DPMS modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of DPMS.\\n\");\n\t\t\t}\n\t\t\tdpms_capable = 0;\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n\n\tif (force_dpms || (client_dpms && client_count)) {\n\t\tstatic int last_enable = 0;\n\t\tif (time(NULL) > last_enable) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tlast_enable = time(NULL);\n\t\t}\n\t\tset_dpms_mode(\"off\");\n\t}\n\tif (! watch_dpms) {\n\t\treturn;\n\t}\n\tif (! dpms_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_dpms + 5) {\n\t\treturn;\n\t}\n\tlast_dpms = time(NULL);\n\n\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != DPMSModeOn) {\n\t\t\tchar *from = \"unknown-dpms-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching DPMS state from %s to DPMSModeOn\\n\", from);\n\t\t\t\n\t\t\tDPMSForceLevel(dpy, DPMSModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"DPMSInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_dpms) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X DPMS extension not supported.\\n\");\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n#endif\n}",
          "includes": [
            "#include <X11/extensions/dpms.h>",
            "#include <X11/extensions/fbpm.h>",
            "#include <X11/Xmd.h>",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_dpms(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void check_dpms(void);\n\nstatic void check_dpms(void) {\n\tstatic int init_dpms = 0;\n#if HAVE_DPMS\n\tstatic int dpms_capable = 0;\n\tstatic time_t last_dpms = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_dpms) {\n\t\tif (getenv(\"DPMS_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"DPMS_DEBUG\"));\n\t\t}\n\t\tif (DPMSCapable(dpy)) {\n\t\t\tdpms_capable = 1;\n\t\t\trfbLog(\"X display is capable of DPMS.\\n\");\n\t\t\tif (watch_dpms) {\n\t\t\t\trfbLog(\"Preventing low-power DPMS modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of DPMS.\\n\");\n\t\t\t}\n\t\t\tdpms_capable = 0;\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n\n\tif (force_dpms || (client_dpms && client_count)) {\n\t\tstatic int last_enable = 0;\n\t\tif (time(NULL) > last_enable) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tlast_enable = time(NULL);\n\t\t}\n\t\tset_dpms_mode(\"off\");\n\t}\n\tif (! watch_dpms) {\n\t\treturn;\n\t}\n\tif (! dpms_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_dpms + 5) {\n\t\treturn;\n\t}\n\tlast_dpms = time(NULL);\n\n\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != DPMSModeOn) {\n\t\t\tchar *from = \"unknown-dpms-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching DPMS state from %s to DPMSModeOn\\n\", from);\n\t\t\t\n\t\t\tDPMSForceLevel(dpy, DPMSModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"DPMSInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_dpms) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X DPMS extension not supported.\\n\");\n\t\t}\n\t\tinit_dpms = 1;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fbpm",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "check_fbpm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
          "lines": "67-148",
          "snippet": "static void check_fbpm(void) {\n\tstatic int init_fbpm = 0;\n#if HAVE_FBPM\n\tstatic int fbpm_capable = 0;\n\tstatic time_t last_fbpm = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_fbpm) {\n\t\tif (getenv(\"FBPM_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"FBPM_DEBUG\"));\n\t\t}\n\t\tif (FBPMCapable(dpy)) {\n\t\t\tfbpm_capable = 1;\n\t\t\trfbLog(\"X display is capable of FBPM.\\n\");\n\t\t\tif (watch_fbpm) {\n\t\t\t\trfbLog(\"Preventing low-power FBPM modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of FBPM.\\n\");\n\t\t\t}\n\t\t\tfbpm_capable = 0;\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n\n\tif (! watch_fbpm) {\n\t\treturn;\n\t}\n\tif (! fbpm_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_fbpm + 5) {\n\t\treturn;\n\t}\n\tlast_fbpm = time(NULL);\n\n\tif (FBPMInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"FBPMInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != FBPMModeOn) {\n\t\t\tchar *from = \"unknown-fbpm-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == FBPMModeStandby) {\n\t\t\t\tfrom = \"FBPMModeStandby\";\n\t\t\t} else if (level == FBPMModeSuspend) {\n\t\t\t\tfrom = \"FBPMModeSuspend\";\n\t\t\t} else if (level == FBPMModeOff) {\n\t\t\t\tfrom = \"FBPMModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching FBPM state from %s to FBPMModeOn\\n\", from);\n\t\t\t\n\t\t\tFBPMForceLevel(dpy, FBPMModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"FBPMInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_fbpm) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X FBPM extension not supported.\\n\");\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n#endif\n}",
          "includes": [
            "#include <X11/extensions/dpms.h>",
            "#include <X11/extensions/fbpm.h>",
            "#include <X11/Xmd.h>",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_fbpm(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void check_fbpm(void);\n\nstatic void check_fbpm(void) {\n\tstatic int init_fbpm = 0;\n#if HAVE_FBPM\n\tstatic int fbpm_capable = 0;\n\tstatic time_t last_fbpm = 0;\n\tint db = 0;\n\n\tCARD16 level;\n\tBOOL enabled;\n\n\tRAWFB_RET_VOID\n\n\tif (! init_fbpm) {\n\t\tif (getenv(\"FBPM_DEBUG\")) {\n\t\t\tdb = atoi(getenv(\"FBPM_DEBUG\"));\n\t\t}\n\t\tif (FBPMCapable(dpy)) {\n\t\t\tfbpm_capable = 1;\n\t\t\trfbLog(\"X display is capable of FBPM.\\n\");\n\t\t\tif (watch_fbpm) {\n\t\t\t\trfbLog(\"Preventing low-power FBPM modes when\"\n\t\t\t\t    \" clients are connected.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (! raw_fb_str) {\n\t\t\t\trfbLog(\"X display is not capable of FBPM.\\n\");\n\t\t\t}\n\t\t\tfbpm_capable = 0;\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n\n\tif (! watch_fbpm) {\n\t\treturn;\n\t}\n\tif (! fbpm_capable) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (time(NULL) < last_fbpm + 5) {\n\t\treturn;\n\t}\n\tlast_fbpm = time(NULL);\n\n\tif (FBPMInfo(dpy, &level, &enabled)) {\n\t\tif (db) fprintf(stderr, \"FBPMInfo level: %d enabled: %d\\n\", level, enabled);\n\n\t\tif (enabled && level != FBPMModeOn) {\n\t\t\tchar *from = \"unknown-fbpm-state\";\n\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\n\t\t\tif (level == FBPMModeStandby) {\n\t\t\t\tfrom = \"FBPMModeStandby\";\n\t\t\t} else if (level == FBPMModeSuspend) {\n\t\t\t\tfrom = \"FBPMModeSuspend\";\n\t\t\t} else if (level == FBPMModeOff) {\n\t\t\t\tfrom = \"FBPMModeOff\";\n\t\t\t}\n\n\t\t\trfbLog(\"switching FBPM state from %s to FBPMModeOn\\n\", from);\n\t\t\t\n\t\t\tFBPMForceLevel(dpy, FBPMModeOn);\n\t\t\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\ttrapped_xerror = 0;\n\t\t}\n\t} else {\n\t\tif (db) fprintf(stderr, \"FBPMInfo failed.\\n\");\n\t}\n#else\n\tRAWFB_RET_VOID\n\tif (! init_fbpm) {\n\t\tif (! raw_fb_str) {\n\t\t\trfbLog(\"X FBPM extension not supported.\\n\");\n\t\t}\n\t\tinit_fbpm = 1;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_CHECK_PM\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid check_pm(void);\nstatic void check_fbpm(void);\nstatic void check_dpms(void);\n\nvoid check_pm(void) {\n\tstatic int skip = -1;\n\tif (skip < 0) {\n\t\tskip = 0;\n\t\tif (getenv(\"X11VNC_NO_CHECK_PM\")) {\n\t\t\tskip = 1;\n\t\t}\n\t}\n\tif (skip) {\n\t\treturn;\n\t}\n\tcheck_fbpm();\n\tcheck_dpms();\n\t/* someday dpms activities? */\n}"
  }
]