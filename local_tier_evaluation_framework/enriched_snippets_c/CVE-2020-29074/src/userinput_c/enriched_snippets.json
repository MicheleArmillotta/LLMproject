[
  {
    "function_name": "check_ncache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8880-10195",
    "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
      "#define EV_OLD_WM_NOTMAPPED\t16",
      "#define EV_OLD_WM_OFF\t\t15",
      "#define EV_OLD_WM_UNMAP\t\t14",
      "#define EV_OLD_WM_MAP\t\t13",
      "#define EV_CONFIGURE_SIZE\t7",
      "#define EV_REPARENT\t\t5",
      "#define EV_MAP\t\t\t4",
      "#define EV_UNMAP\t\t3",
      "#define EV_DESTROY\t\t2",
      "#define EV_CREATE\t\t1",
      "#define EV_RESET\t\t0",
      "#define NSCHED 128",
      "#define NRECENT 32"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "void set_ncache_xrootpmap(void);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "void batch_push(int ncr, double delay);",
      "int clipped(int idx);",
      "void snap_old(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 10193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\"",
            "dnowx()",
            "dnow() - now",
            "n",
            "pixels"
          ],
          "line": 10192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 10192
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "missed_bs_restore_rgn"
          ],
          "line": 10190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "missed_su_restore_rgn"
          ],
          "line": 10189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 10188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snap_old",
          "args": [],
          "line": 10185
        },
        "resolved": true,
        "details": {
          "function_name": "snap_old_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6059-6072",
          "snippet": "void snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_sched",
          "args": [
            "try_batch",
            "&did_sched"
          ],
          "line": 10182
        },
        "resolved": true,
        "details": {
          "function_name": "check_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8633-8878",
          "snippet": "void check_sched(int try_batch, int *did_sched) {\n\tstatic double last_root = 0.0;\n\tstatic double last_pixmap = 0.0;\n\tdouble refresh = 60.0;\n\tint i, k, valid;\n\tWindow win;\n\tXWindowAttributes attr;\n\tdouble now = dnow();\n\n\tif (now > last_root + refresh) {\n\nif (ncdb) fprintf(stderr, \"\\n**** checking cache_list[%d]\\n\\n\", cache_list_num);\n\t\tblock_stats();\n\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tvalid = 0;\n\t\t\twin = cache_list[k].win; \n\t\t\tX_LOCK;\n\t\t\tif (win == None) {\n\t\t\t\t;\n\t\t\t} else if (cache_list[k].selectinput && cache_list[k].time > now - refresh) {\n\t\t\t\tvalid = 1;\n\t\t\t} else if (valid_window(win, &attr, 1)) {\n\t\t\t\tSTORE(k, win, attr);\n\t\t\t\tif (! cache_list[k].selectinput) {\n\t\t\t\t\txselectinput(win, win_ev, 0);\n\t\t\t\t\tCLEAR(k);\n\t\t\t\t\tcache_list[k].selectinput = 1;\n\t\t\t\t}\n\t\t\t\tvalid = 1;\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"DELETE(%d) %dx%d+%d+%d\\n\", k, cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tX_UNLOCK;\n/* XXX Y */\n\t\t\tif (valid) {\n\t\t\t\tif (cache_list[k].create_cnt && cache_list[k].map_state != IsViewable && cache_list[k].map_cnt == 0) {\n\t\t\t\t\tif (cache_list[k].bs_x >= 0) {\nif (ncdb) fprintf(stderr, \"Created window never mapped: freeing(%d) 0x%lx\\n\", k, win);\n\t\t\t\t\t\tfree_rect(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlast_root = dnow();\n\t}\n\n\tif (now > last_sched_bs + 0.30) {\n\t\tstatic double last_sched_vis = 0.0;\n\t\tint nr = 0, *bat = NULL;\n\n\t\tif (try_batch) {\n\t\t\tbat = &nr;\n\t\t}\n\t\tif (now < last_wireframe + 2.0) {\n\t\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\t\tsched_bs[i] = None;\n\t\t\t}\n\t\t}\n\t\tif (now < last_get_wm_frame_time + 1.0) {\n\t\t\tif (last_get_wm_frame != None) {\n\t\t\t\tint idx = lookup_win_index(last_get_wm_frame);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (cache_list[idx].bs_x < 0) {\n\t\t\t\t\t\tint x = cache_list[idx].x;\n\t\t\t\t\t\tint y = cache_list[idx].y;\n\t\t\t\t\t\tint w = cache_list[idx].width;\n\t\t\t\t\t\tint h = cache_list[idx].height;\n\t\t\t\t\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\t\t\t\t\tSCHED(last_get_wm_frame, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tif (sched_bs[i] != None) {\n\t\t\t\tint idx;\n\t\t\t\twin = sched_bs[i];\t\n\t\t\t\tif (now < sched_tm[i] + 0.55) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\t\t\tsched_tm[i] = now;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tint aw = cache_list[idx].width; \n\t\t\t\t\tint ah = cache_list[idx].height; \n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (cache_list[idx].vis_state != VisibilityUnobscured) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (aw * ah < 64 * 64) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SNAP BS_save: 0x%lx %d %d %d\\n\", win, aw, ah, cache_list[idx].map_state); \n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, bat, &attr, 1, 0, &valid, 0);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SCHED LOOKUP FAIL: i=%d 0x%lx\\n\", i, win);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\t*did_sched = 1;\n\n\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\tif (last_sched_vis < now) {\n\t\t\t\tlast_sched_vis += 1.0;\n\t\t\t}\n\t\t} else if (now > last_sched_vis + 3.0 && now > last_wireframe + 2.0) {\n\t\t\tstatic double last_vis = 0.0;\n\t\t\tint vis_now[32], top_now[32];\n\t\t\tstatic int vis_prev[32], freq = 0;\n\t\t\tint diff, nv = 32, vis_now_n = 0;\n\t\t\tWindow win;\n\n\t\t\tfreq++;\n\n\t\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\t\tint ok = 0;\n\t\t\t\tint top_only = 1;\n\t\t\t\tint aw = cache_list[i].width; \n\t\t\t\tint ah = cache_list[i].height; \n\t\t\t\tint map_prev = cache_list[i].map_state;\n\n\t\t\t\twin = cache_list[i].win;\n\n\t\t\t\tif (saw_desktop_change) {\n\t\t\t\t\ttop_only = 0;\n\t\t\t\t}\n\n\t\t\t\tif (win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* XXX Y resp */\n\t\t\t\tif (saw_desktop_change || freq % 5 == 0) {\n\t\t\t\t\tint vret = 0;\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tvret = valid_window(win, &attr, 1);\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (!vret) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t}\n\t\t\t\tif (!cache_list[i].valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map_prev != IsViewable) {\n\t\t\t\t\t/* we hope to catch it below in the normal event processing */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (aw * ah < 64 * 64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (top_only) {\n\t\t\t\t\tif (cache_list[i].vis_state == VisibilityUnobscured) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} else if (!clipped(i)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (vis_now_n < nv) {\n\t\t\t\t\t\tvis_now[vis_now_n] = i;\n\t\t\t\t\t\ttop_now[vis_now_n++] = top_only;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiff = 0;\n\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\tif (vis_now[k] != vis_prev[k]) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff == 0) {\n\t\t\t\tif (now > last_vis + 45.0) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff) {\nif (ncdb && vis_now_n) fprintf(stderr, \"*VIS  snapshot all %.4f\\n\", dnowx());\n\t\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\t\ti = vis_now[k];\n\t\t\t\t\twin = cache_list[i].win;\n\t\t\t\t\tvalid = 0;\nif (ncdb) fprintf(stderr, \"*VIS  BS_save: 0x%lx %d %d %d\\n\", win, cache_list[i].width, cache_list[i].height, cache_list[i].map_state); \n\t\t\t\t\tif (now < cache_list[i].vis_unobs_time + 0.75 && now < cache_list[i].vis_obs_time + 0.75) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbs_save(i, bat, &attr, !top_now[k], 0, &valid, 1);\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(i);\n\t\t\t\t\t}\n\t\t\t\t\tvis_prev[k] = vis_now[k];\n\t\t\t\t}\n\t\t\t\tlast_vis = dnow();\n\t\t\t}\n\t\t\tlast_sched_vis = dnow();\n\t\t\tif (! n_DC) {\n\t\t\t\tsaw_desktop_change = 0;\n\t\t\t}\n\t\t\t/* XXX Y */\n\t\t\ttry_to_synthesize_su(0, 0, bat);\n\t\t}\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tlast_sched_bs = dnow();\n\t}\n#if !NO_X11\n\tif (dpy && atom_XROOTPMAP_ID == None && now > last_pixmap + 5.0) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t\tlast_pixmap = now;\n\t}\n#endif\n\tif (got_XROOTPMAP_ID > 0.0) {\nif (ncdb) fprintf(stderr, \"got_XROOTPMAP_ID\\n\");\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgot_XROOTPMAP_ID = 0.0;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NSCHED 128"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NSCHED 128\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid check_sched(int try_batch, int *did_sched) {\n\tstatic double last_root = 0.0;\n\tstatic double last_pixmap = 0.0;\n\tdouble refresh = 60.0;\n\tint i, k, valid;\n\tWindow win;\n\tXWindowAttributes attr;\n\tdouble now = dnow();\n\n\tif (now > last_root + refresh) {\n\nif (ncdb) fprintf(stderr, \"\\n**** checking cache_list[%d]\\n\\n\", cache_list_num);\n\t\tblock_stats();\n\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tvalid = 0;\n\t\t\twin = cache_list[k].win; \n\t\t\tX_LOCK;\n\t\t\tif (win == None) {\n\t\t\t\t;\n\t\t\t} else if (cache_list[k].selectinput && cache_list[k].time > now - refresh) {\n\t\t\t\tvalid = 1;\n\t\t\t} else if (valid_window(win, &attr, 1)) {\n\t\t\t\tSTORE(k, win, attr);\n\t\t\t\tif (! cache_list[k].selectinput) {\n\t\t\t\t\txselectinput(win, win_ev, 0);\n\t\t\t\t\tCLEAR(k);\n\t\t\t\t\tcache_list[k].selectinput = 1;\n\t\t\t\t}\n\t\t\t\tvalid = 1;\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"DELETE(%d) %dx%d+%d+%d\\n\", k, cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tX_UNLOCK;\n/* XXX Y */\n\t\t\tif (valid) {\n\t\t\t\tif (cache_list[k].create_cnt && cache_list[k].map_state != IsViewable && cache_list[k].map_cnt == 0) {\n\t\t\t\t\tif (cache_list[k].bs_x >= 0) {\nif (ncdb) fprintf(stderr, \"Created window never mapped: freeing(%d) 0x%lx\\n\", k, win);\n\t\t\t\t\t\tfree_rect(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlast_root = dnow();\n\t}\n\n\tif (now > last_sched_bs + 0.30) {\n\t\tstatic double last_sched_vis = 0.0;\n\t\tint nr = 0, *bat = NULL;\n\n\t\tif (try_batch) {\n\t\t\tbat = &nr;\n\t\t}\n\t\tif (now < last_wireframe + 2.0) {\n\t\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\t\tsched_bs[i] = None;\n\t\t\t}\n\t\t}\n\t\tif (now < last_get_wm_frame_time + 1.0) {\n\t\t\tif (last_get_wm_frame != None) {\n\t\t\t\tint idx = lookup_win_index(last_get_wm_frame);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (cache_list[idx].bs_x < 0) {\n\t\t\t\t\t\tint x = cache_list[idx].x;\n\t\t\t\t\t\tint y = cache_list[idx].y;\n\t\t\t\t\t\tint w = cache_list[idx].width;\n\t\t\t\t\t\tint h = cache_list[idx].height;\n\t\t\t\t\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\t\t\t\t\tSCHED(last_get_wm_frame, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tif (sched_bs[i] != None) {\n\t\t\t\tint idx;\n\t\t\t\twin = sched_bs[i];\t\n\t\t\t\tif (now < sched_tm[i] + 0.55) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\t\t\tsched_tm[i] = now;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tint aw = cache_list[idx].width; \n\t\t\t\t\tint ah = cache_list[idx].height; \n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (cache_list[idx].vis_state != VisibilityUnobscured) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (aw * ah < 64 * 64) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SNAP BS_save: 0x%lx %d %d %d\\n\", win, aw, ah, cache_list[idx].map_state); \n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, bat, &attr, 1, 0, &valid, 0);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SCHED LOOKUP FAIL: i=%d 0x%lx\\n\", i, win);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\t*did_sched = 1;\n\n\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\tif (last_sched_vis < now) {\n\t\t\t\tlast_sched_vis += 1.0;\n\t\t\t}\n\t\t} else if (now > last_sched_vis + 3.0 && now > last_wireframe + 2.0) {\n\t\t\tstatic double last_vis = 0.0;\n\t\t\tint vis_now[32], top_now[32];\n\t\t\tstatic int vis_prev[32], freq = 0;\n\t\t\tint diff, nv = 32, vis_now_n = 0;\n\t\t\tWindow win;\n\n\t\t\tfreq++;\n\n\t\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\t\tint ok = 0;\n\t\t\t\tint top_only = 1;\n\t\t\t\tint aw = cache_list[i].width; \n\t\t\t\tint ah = cache_list[i].height; \n\t\t\t\tint map_prev = cache_list[i].map_state;\n\n\t\t\t\twin = cache_list[i].win;\n\n\t\t\t\tif (saw_desktop_change) {\n\t\t\t\t\ttop_only = 0;\n\t\t\t\t}\n\n\t\t\t\tif (win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* XXX Y resp */\n\t\t\t\tif (saw_desktop_change || freq % 5 == 0) {\n\t\t\t\t\tint vret = 0;\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tvret = valid_window(win, &attr, 1);\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (!vret) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t}\n\t\t\t\tif (!cache_list[i].valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map_prev != IsViewable) {\n\t\t\t\t\t/* we hope to catch it below in the normal event processing */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (aw * ah < 64 * 64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (top_only) {\n\t\t\t\t\tif (cache_list[i].vis_state == VisibilityUnobscured) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} else if (!clipped(i)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (vis_now_n < nv) {\n\t\t\t\t\t\tvis_now[vis_now_n] = i;\n\t\t\t\t\t\ttop_now[vis_now_n++] = top_only;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiff = 0;\n\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\tif (vis_now[k] != vis_prev[k]) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff == 0) {\n\t\t\t\tif (now > last_vis + 45.0) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff) {\nif (ncdb && vis_now_n) fprintf(stderr, \"*VIS  snapshot all %.4f\\n\", dnowx());\n\t\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\t\ti = vis_now[k];\n\t\t\t\t\twin = cache_list[i].win;\n\t\t\t\t\tvalid = 0;\nif (ncdb) fprintf(stderr, \"*VIS  BS_save: 0x%lx %d %d %d\\n\", win, cache_list[i].width, cache_list[i].height, cache_list[i].map_state); \n\t\t\t\t\tif (now < cache_list[i].vis_unobs_time + 0.75 && now < cache_list[i].vis_obs_time + 0.75) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbs_save(i, bat, &attr, !top_now[k], 0, &valid, 1);\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(i);\n\t\t\t\t\t}\n\t\t\t\t\tvis_prev[k] = vis_now[k];\n\t\t\t\t}\n\t\t\t\tlast_vis = dnow();\n\t\t\t}\n\t\t\tlast_sched_vis = dnow();\n\t\t\tif (! n_DC) {\n\t\t\t\tsaw_desktop_change = 0;\n\t\t\t}\n\t\t\t/* XXX Y */\n\t\t\ttry_to_synthesize_su(0, 0, bat);\n\t\t}\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tlast_sched_bs = dnow();\n\t}\n#if !NO_X11\n\tif (dpy && atom_XROOTPMAP_ID == None && now > last_pixmap + 5.0) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t\tlast_pixmap = now;\n\t}\n#endif\n\tif (got_XROOTPMAP_ID > 0.0) {\nif (ncdb) fprintf(stderr, \"got_XROOTPMAP_ID\\n\");\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgot_XROOTPMAP_ID = 0.0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_borders",
          "args": [
            "Ev_rects",
            "nrects"
          ],
          "line": 10178
        },
        "resolved": true,
        "details": {
          "function_name": "push_borders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3684-3744",
          "snippet": "void push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "nreg",
            "-1.0"
          ],
          "line": 10174
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"igno%02d: ** Ignoring      0x%lx type: %s\\n\"",
            "ik",
            "win",
            "Etype(type)"
          ],
          "line": 10166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Etype",
          "args": [
            "type"
          ],
          "line": 10166
        },
        "resolved": true,
        "details": {
          "function_name": "Etype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6146-6183",
          "snippet": "char *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 10163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: DestroyNotify    0x%lx  %3d\\n\"",
            "ik",
            "win2",
            "idx"
          ],
          "line": 10160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "win2"
          ],
          "line": 10159
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\"",
            "ik",
            "win2",
            "idx"
          ],
          "line": 10153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 10144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "unmapped_rgn",
            "r"
          ],
          "line": 10143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "r0"
          ],
          "line": 10142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 10141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idx_add_rgn",
          "args": [
            "missed_su_restore_rgn",
            "r0",
            "idx"
          ],
          "line": 10121
        },
        "resolved": true,
        "details": {
          "function_name": "idx_add_rgn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8098-8116",
          "snippet": "void idx_add_rgn(sraRegionPtr r, sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\tsraRgnOr(r, rtmp);\n\tsraRgnDestroy(rtmp);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid idx_add_rgn(sraRegionPtr r, sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\tsraRgnOr(r, rtmp);\n\tsraRgnDestroy(rtmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 10118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 10116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_fix_su",
          "args": [
            "win",
            "idx",
            "None",
            "nbatch",
            "\"unmapped\""
          ],
          "line": 10114
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_fix_su",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7912-8096",
          "snippet": "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}"
        }
      },
      {
        "call_info": {
          "callee": "su_restore",
          "args": [
            "idx",
            "nbatch",
            "NULL",
            "&attr",
            "1",
            "0",
            "&valid",
            "1"
          ],
          "line": 10113
        },
        "resolved": true,
        "details": {
          "function_name": "su_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7441-7548",
          "snippet": "int su_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2 = 0, y2 = 0, w2 = 0, h2 = 0;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"save-unders  restore:    0x%lx  %3d \\n\", win, idx);\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"SU_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tx2 = x1;\n\t\ty2 = y1;\n\t\tw2 = w1;\n\t\th2 = h1;\n\t} else {\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\nif (ncdb) fprintf(stderr, \"SU_rest: su_x/bs_x/su_time: %d %d %.3f\\n\", x, cache_list[idx].bs_x, cache_list[idx].su_time);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_restore = dnow();\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static void draw_box(int x, int y, int w, int h, int restore);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint su_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2 = 0, y2 = 0, w2 = 0, h2 = 0;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"save-unders  restore:    0x%lx  %3d \\n\", win, idx);\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"SU_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tx2 = x1;\n\t\ty2 = y1;\n\t\tw2 = w1;\n\t\th2 = h1;\n\t} else {\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\nif (ncdb) fprintf(stderr, \"SU_rest: su_x/bs_x/su_time: %d %d %.3f\\n\", x, cache_list[idx].bs_x, cache_list[idx].su_time);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_restore = dnow();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bs_save",
          "args": [
            "idx",
            "nbatch",
            "&attr",
            "1",
            "0",
            "&valid",
            "1"
          ],
          "line": 10110
        },
        "resolved": true,
        "details": {
          "function_name": "bs_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7130-7234",
          "snippet": "int bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 10102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "missed_bs_restore_rgn"
          ],
          "line": 10099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idx_create_rgn",
          "args": [
            "r0",
            "idx"
          ],
          "line": 10098
        },
        "resolved": true,
        "details": {
          "function_name": "idx_create_rgn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8118-8135",
          "snippet": "sraRegionPtr idx_create_rgn(sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn NULL;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\treturn rtmp;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nsraRegionPtr idx_create_rgn(sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn NULL;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\treturn rtmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 10095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "missed_su_restore_rgn"
          ],
          "line": 10092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: UnmapNotify      0x%lx  %3d\\n\"",
            "ik",
            "win",
            "idx"
          ],
          "line": 10067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 10059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED",
          "args": [
            "win",
            "1"
          ],
          "line": 10039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 10038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 10037
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGS_follow_animation_win",
          "args": [
            "win",
            "-1",
            "1"
          ],
          "line": 10036
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_follow_animation_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "176-238",
          "snippet": "int macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 10031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bs_restore",
          "args": [
            "idx",
            "nbatch",
            "NULL",
            "&attr",
            "0",
            "0",
            "&valid",
            "1"
          ],
          "line": 10024
        },
        "resolved": true,
        "details": {
          "function_name": "bs_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7338-7439",
          "snippet": "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static void draw_box(int x, int y, int w, int h, int restore);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ev_lookup",
          "args": [
            "win",
            "EV_CONFIGURE_SIZE"
          ],
          "line": 10018
        },
        "resolved": true,
        "details": {
          "function_name": "ev_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8282-8290",
          "snippet": "int ev_lookup(Window win, int type) {\n\tint i;\n\tfor(i=0; i < _ev_list_cnt; i++) {\n\t\tif (_ev_list[i] == win && _ev_case[i] == type) \t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint ev_lookup(Window win, int type) {\n\tint i;\n\tfor(i=0; i < _ev_list_cnt; i++) {\n\t\tif (_ev_list[i] == win && _ev_case[i] == type) \t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 10014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "su_save",
          "args": [
            "idx",
            "nbatch",
            "&attr",
            "0",
            "&valid",
            "1"
          ],
          "line": 10012
        },
        "resolved": true,
        "details": {
          "function_name": "su_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7236-7336",
          "snippet": "int su_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\nif (ncdb && verb) fprintf(stderr, \"save-unders save:        0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"su_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].su_w || h2 > cache_list[idx].su_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"SU_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"SU_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_save = cache_list[idx].su_time = dnow();\n\t\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint su_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\nif (ncdb && verb) fprintf(stderr, \"save-unders save:        0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"su_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].su_w || h2 > cache_list[idx].su_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"SU_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"SU_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_save = cache_list[idx].su_time = dnow();\n\t\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 10007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 10001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "missed_bs_restore_rgn"
          ],
          "line": 9998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 9994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "missed_su_restore_rgn"
          ],
          "line": 9991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: MapNotify        0x%lx  %3d\\n\"",
            "ik",
            "win",
            "idx"
          ],
          "line": 9970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 9957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED",
          "args": [
            "win",
            "1"
          ],
          "line": 9955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 9945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rmask"
          ],
          "line": 9942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rmask"
          ],
          "line": 9930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "rmask"
          ],
          "line": 9929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "rmask",
            "unmapped_rgn"
          ],
          "line": 9928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 9927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "unmapped_rgn"
          ],
          "line": 9922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "ro2"
          ],
          "line": 9912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "ro1"
          ],
          "line": 9911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"        skip VisibilityUnobscured for GNOME iconify.\\n\""
          ],
          "line": 9908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "ro1",
            "ro2"
          ],
          "line": 9907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\"",
            "ik",
            "win",
            "idx",
            "VState(state)",
            "n_VN_u",
            "n_VN_p"
          ],
          "line": 9867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VState",
          "args": [
            "state"
          ],
          "line": 9867
        },
        "resolved": true,
        "details": {
          "function_name": "VState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6184-6190",
          "snippet": "char *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_synthesize_su",
          "args": [
            "1",
            "1",
            "nbatch"
          ],
          "line": 9848
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_synthesize_su",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8459-8626",
          "snippet": "int try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"        skip try_to_fix_su for GNOME deiconify #2\\n\""
          ],
          "line": 9838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"        skip try_to_fix_su for GNOME deiconify #1\\n\""
          ],
          "line": 9828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\"",
            "win"
          ],
          "line": 9821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\"",
            "win",
            "w_old",
            "h_old",
            "x_old",
            "y_old",
            "w_new",
            "h_new",
            "x_new",
            "y_new",
            "old_wm"
          ],
          "line": 9796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\"",
            "win",
            "w_old",
            "h_old",
            "x_old",
            "y_old",
            "w_new",
            "h_new",
            "x_new",
            "y_new"
          ],
          "line": 9792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\"",
            "win",
            "w_old",
            "h_old",
            "x_old",
            "y_old",
            "w_new",
            "h_new",
            "x_new",
            "y_new"
          ],
          "line": 9787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\"",
            "win",
            "w_old",
            "h_old",
            "w_new",
            "h_new"
          ],
          "line": 9780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\"",
            "win",
            "x_old",
            "y_old",
            "x_new",
            "y_new"
          ],
          "line": 9775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\"",
            "ik",
            "win",
            "idx",
            "oabove",
            "ev.xconfigure.above",
            "ev.xconfigure.width",
            "ev.xconfigure.height",
            "ev.xconfigure.x",
            "ev.xconfigure.y"
          ],
          "line": 9734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\"",
            "ik",
            "win",
            "Etype(type)"
          ],
          "line": 9719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\"",
            "ik",
            "win2",
            "idx"
          ],
          "line": 9716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\"",
            "ik",
            "win2",
            "idx",
            "w",
            "h",
            "x",
            "y",
            "valid"
          ],
          "line": 9710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED",
          "args": [
            "win2",
            "1"
          ],
          "line": 9705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win2",
            "attr"
          ],
          "line": 9700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\"",
            "ik",
            "win",
            "win2",
            "Etype(type)"
          ],
          "line": 9677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skipwins[%d] 0x%lx\\n\"",
            "k",
            "skipwins[k]"
          ],
          "line": 9646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 9642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 9641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 9640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 9639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"GUESSED DESKTOP CHANGE. Skipping.\\n\""
          ],
          "line": 9630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"GUESSED DESKTOP CHANGE.\\n\""
          ],
          "line": 9627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 9616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 9614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\"",
            "ik",
            "win",
            "idx",
            "VState(state)",
            "n_VN_u",
            "n_VN_p"
          ],
          "line": 9610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"UM Ev_order[%d] = %d oku=%d okm=%d\\n\"",
            "i",
            "j",
            "oku",
            "okm"
          ],
          "line": 9484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"M Ev_tmp2[%d] = %d\\n\"",
            "add",
            "i"
          ],
          "line": 9446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"U Ev_tmp2[%d] = %d\\n\"",
            "add",
            "i"
          ],
          "line": 9431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"M Ev_tmp[%d] = %d\\n\"",
            "cnt",
            "i"
          ],
          "line": 9415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"U Ev_tmp[%d] = %d\\n\"",
            "cnt",
            "i"
          ],
          "line": 9407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DESKTOP_CHANGE_OLD_WM: %d\\n\"",
            "shifts"
          ],
          "line": 9379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\"",
            "i",
            "x_old",
            "y_old",
            "x_new",
            "y_new",
            "old_wm"
          ],
          "line": 9374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 9372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r_new"
          ],
          "line": 9371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r_old"
          ],
          "line": 9370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev_store",
          "args": [
            "win",
            "EV_OLD_WM_OFF"
          ],
          "line": 9368
        },
        "resolved": true,
        "details": {
          "function_name": "ev_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8266-8280",
          "snippet": "int ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define EV_RESET\t\t0",
            "#define EVLISTMAX 256"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define EV_RESET\t\t0\n#define EVLISTMAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r_new"
          ],
          "line": 9363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r_old"
          ],
          "line": 9363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r_new"
          ],
          "line": 9359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r_old"
          ],
          "line": 9359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r_new",
            "r0"
          ],
          "line": 9356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x_new",
            "y_new",
            "x_new+w_new",
            "y_new+h_new"
          ],
          "line": 9355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r_old",
            "r0"
          ],
          "line": 9354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x_old",
            "y_old",
            "x_old+w_old",
            "y_old+h_old"
          ],
          "line": 9353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 9352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "y_new - y_old"
          ],
          "line": 9350
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\"",
            "twin",
            "n2"
          ],
          "line": 9288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cursor_noshape_updates_clients",
          "args": [
            "screen"
          ],
          "line": 9268
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_noshape_updates_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1770-1786",
          "snippet": "int cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nint cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"IN  check_ncache() %d events.  %.4f\\n\"",
            "n",
            "now - x11vnc_start"
          ],
          "line": 9259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 9259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\"",
            "n"
          ],
          "line": 9250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***got_NET_CURRENT_DESKTOP n=%d\\n\"",
            "n"
          ],
          "line": 9246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xselectinput",
          "args": [
            "win2",
            "0",
            "1"
          ],
          "line": 9230
        },
        "resolved": true,
        "details": {
          "function_name": "xselectinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7693-7734",
          "snippet": "void xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\n\nvoid xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 9227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\"",
            "win2",
            "n1",
            "idx"
          ],
          "line": 9225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 9216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\"",
            "win2",
            "n1"
          ],
          "line": 9212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "idx"
          ],
          "line": 9209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win2",
            "attr"
          ],
          "line": 9208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\"",
            "win2",
            "n1"
          ],
          "line": 9206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "idx"
          ],
          "line": 9204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_free_index",
          "args": [],
          "line": 9200
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5976-6025",
          "snippet": "int lookup_free_index(void) {\n\tint k;\n\n\tif (rfree >= 0) {\n\t\tif (cache_list[rfree].win == None) {\nif (ncdb) fprintf(stderr, \"lookup_freeA: %d\\n\", rfree);\n\t\t\treturn rfree;\n\t\t}\n\t}\n\trfree = -1;\n\tfor(k=0; k<cache_list_num; k++) {\n\t\tif (cache_list[k].win == None) {\n\t\t\trfree = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rfree < 0) {\n\t\tif (ncdb) fprintf(stderr, \"*** LOOKUP_FREE_INDEX: incrementing cache_list_num %d/%d\\n\", cache_list_num, cache_list_len);\n\n\t\trfree = cache_list_num++;\n\t\tif (rfree >= cache_list_len)  {\n\t\t\tint i, n = 2*cache_list_len;\n\t\t\twinattr_t *cache_new;\n\n\t\t\tif (ncdb) fprintf(stderr, \"lookup_free_index: growing cache_list_len: %d -> %d\\n\", cache_list_len, n);\n\n\t\t\tcache_new = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\t\tfor (i=0; i<cache_list_num-1; i++) {\n\t\t\t\tcache_new[i] = cache_list[i]; \n\t\t\t}\n\t\t\tcache_list_len = n;\n\t\t\tfree(cache_list);\n\t\t\tcache_list = cache_new;\n\t\t}\n\t\tcache_list[rfree].win = None;\n\t\tcache_list[rfree].fetched = 0;\n\t\tcache_list[rfree].valid = 0;\n\t\tcache_list[rfree].time = 0.0;\n\t\tcache_list[rfree].selectinput = 0;\n\t\tcache_list[rfree].vis_cnt = 0;\n\t\tcache_list[rfree].map_cnt = 0;\n\t\tcache_list[rfree].unmap_cnt = 0;\n\t\tcache_list[rfree].create_cnt = 0;\n\t\tcache_list[rfree].vis_state = -1;\n\t\tcache_list[rfree].above = None;\n\t}\n\nif (ncdb) fprintf(stderr, \"lookup_freeB: %d\\n\", rfree);\n\treturn rfree;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nwinattr_t *cache_list;\n\nint lookup_free_index(void) {\n\tint k;\n\n\tif (rfree >= 0) {\n\t\tif (cache_list[rfree].win == None) {\nif (ncdb) fprintf(stderr, \"lookup_freeA: %d\\n\", rfree);\n\t\t\treturn rfree;\n\t\t}\n\t}\n\trfree = -1;\n\tfor(k=0; k<cache_list_num; k++) {\n\t\tif (cache_list[k].win == None) {\n\t\t\trfree = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rfree < 0) {\n\t\tif (ncdb) fprintf(stderr, \"*** LOOKUP_FREE_INDEX: incrementing cache_list_num %d/%d\\n\", cache_list_num, cache_list_len);\n\n\t\trfree = cache_list_num++;\n\t\tif (rfree >= cache_list_len)  {\n\t\t\tint i, n = 2*cache_list_len;\n\t\t\twinattr_t *cache_new;\n\n\t\t\tif (ncdb) fprintf(stderr, \"lookup_free_index: growing cache_list_len: %d -> %d\\n\", cache_list_len, n);\n\n\t\t\tcache_new = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\t\tfor (i=0; i<cache_list_num-1; i++) {\n\t\t\t\tcache_new[i] = cache_list[i]; \n\t\t\t}\n\t\t\tcache_list_len = n;\n\t\t\tfree(cache_list);\n\t\t\tcache_list = cache_new;\n\t\t}\n\t\tcache_list[rfree].win = None;\n\t\tcache_list[rfree].fetched = 0;\n\t\tcache_list[rfree].valid = 0;\n\t\tcache_list[rfree].time = 0.0;\n\t\tcache_list[rfree].selectinput = 0;\n\t\tcache_list[rfree].vis_cnt = 0;\n\t\tcache_list[rfree].map_cnt = 0;\n\t\tcache_list[rfree].unmap_cnt = 0;\n\t\tcache_list[rfree].create_cnt = 0;\n\t\tcache_list[rfree].vis_state = -1;\n\t\tcache_list[rfree].above = None;\n\t}\n\nif (ncdb) fprintf(stderr, \"lookup_freeB: %d\\n\", rfree);\n\treturn rfree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SKIPWINS: CreateNotify: 0x%lx %d\\n\"",
            "win2",
            "n1"
          ],
          "line": 9194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_events retry: %d -> %d\\n\"",
            "n0",
            "n"
          ],
          "line": 9174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_events",
          "args": [
            "&n"
          ],
          "line": 9173
        },
        "resolved": true,
        "details": {
          "function_name": "read_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8295-8457",
          "snippet": "void read_events(int *n_in) {\n\tint n = *n_in;\n\tWindow win, win2;\n\tXEvent ev;\n\t\n\twhile (xcheckmaskevent(dpy, all_ev, &Ev[n])) {\n\t\tint cfg_size = 0;\n\t\tint cfg_pos = 0;\n\t\tint cfg_stack = 0;\n\t\tint type = Ev[n].type; \n\t\tWindow w = None;\n\n\t\twin = Ev[n].xany.window;\n\t\tEv_done[n] = 0;\n\t\tEv_area[n] = 0;\n\t\tEv_win[n] = win;\n\t\tEv_map[n] = None;\n\t\tEv_unmap[n] = None;\n\t\tEv_order[n] = n;\n\n\t\tev = Ev[n];\n\n\t\tif (type == DestroyNotify)  w = Ev[n].xcreatewindow.window;\n\t\tif (type == CreateNotify)   w = Ev[n].xdestroywindow.window;\n\t\tif (type == ReparentNotify) w = Ev[n].xreparent.window;\n\t\tif (type == UnmapNotify)    w = Ev[n].xunmap.window;\n\t\tif (type == MapNotify)      w = Ev[n].xmap.window;\n\t\tif (type == Expose)         w = Ev[n].xexpose.window;\n\t\tif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\n\t\tif (type == VisibilityNotify) w = win;\n\t\tif (n == *n_in && ncdb) fprintf(stderr, \"\\n\");\n\t\tif (1) {\n\t\t\tchar *msg = \"\";\n\t\t\tint idx = -1, x = 0, y = 0, wd = 0, ht = 0;\n\t\t\tif (w != None) {\n\t\t\t\tidx = lookup_win_index(w);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tx = cache_list[idx].x;\n\t\t\t\t\ty = cache_list[idx].y;\n\t\t\t\t\twd = cache_list[idx].width;\n\t\t\t\t\tht = cache_list[idx].height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type == VisibilityNotify) {\n\t\t\t\tmsg = VState(Ev[n].xvisibility.state);\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tint x_new = Ev[n].xconfigure.x; \n\t\t\t\tint y_new = Ev[n].xconfigure.y; \n\t\t\t\tint w_new = Ev[n].xconfigure.width; \n\t\t\t\tint h_new = Ev[n].xconfigure.height; \n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (w_new != wd || h_new != ht) {\n\t\t\t\t\t\tmsg = \"change size\";\n\t\t\t\t\t\tcfg_size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (x_new != x || y_new != y) {\n\t\t\t\t\t\tif (!strcmp(msg, \"\")) {\n\t\t\t\t\t\t\tmsg = \"change position\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg_pos = 1;\n\t\t\t\t\t} else if (! cfg_size) {\n\t\t\t\t\t\tmsg = \"change stacking\";\n\t\t\t\t\t\tcfg_stack = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ncdb) fprintf(stderr, \"----- %02d inputev 0x%08lx w: 0x%08lx %04dx%04d+%04d+%04d %s  %s\\n\", n, win, w, wd, ht, x, y, Etype(type), msg);\n\t\t}\n\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tev_store(win2, EV_CREATE);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tev_store(win2, EV_REPARENT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == PropertyNotify) {\n\t\t\t\tset_prop_atom(Ev[n].xproperty.atom);\n\t\t\t\tn++;\n\t\t\t\tn_PN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\twin2 = ev.xmap.window;\n\t\t\t\tev_store(win2, EV_MAP);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\n#if 0\n\t\t\t\tWindow w = None;\nif (type == DestroyNotify) w = Ev[n].xdestroywindow.window;\nif (type == UnmapNotify)   w = Ev[n].xunmap.window;\nif (type == MapNotify)     w = Ev[n].xmap.window;\nif (type == Expose)        w = Ev[n].xexpose.window;\nif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\nif (type != ConfigureNotify) fprintf(stderr, \"root: skip %s  for 0x%lx\\n\", Etype(type), w);\n#endif\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ReparentNotify) {\n\t\t\t\tev_store(win, EV_REPARENT);\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\tev_store(win, EV_DESTROY);\n\t\t\t\tn++;\n\t\t\t\tn_DN++;\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tev_store(win, EV_CONFIGURE);\n\t\t\t\tif (cfg_size) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_SIZE);\n\t\t\t\t\tn_ON_sz++;\n\t\t\t\t}\n\t\t\t\tif (cfg_pos) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_POS);\n\t\t\t\t\tn_ON_po++;\n\t\t\t\t}\n\t\t\t\tif (cfg_stack) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_STACK);\n\t\t\t\t\tn_ON_st++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_ON++;\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tif (Ev[n].xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_UNOBS);\n\t\t\t\t\tn_VN_u++;\n\t\t\t\t} else {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_OBS);\n\t\t\t\t\tn_VN_p++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_VN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tev_store(win, EV_MAP);\n\t\t\t\tEv_map[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_MN++;\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tev_store(win, EV_UNMAP);\n\t\t\t\tEv_unmap[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_UN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\nif (ncdb) fprintf(stderr, \"----- skip %s\\n\", Etype(type));\n\t\t\t}\n\t\t}\n\t\tif (n >= EVMAX) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*n_in = n;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define EV_VISIBILITY_OBS\t11",
            "#define EV_VISIBILITY_UNOBS\t10",
            "#define EV_CONFIGURE_STACK\t9",
            "#define EV_CONFIGURE_POS\t8",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_CONFIGURE\t\t6",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EVMAX 2048"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define EV_VISIBILITY_OBS\t11\n#define EV_VISIBILITY_UNOBS\t10\n#define EV_CONFIGURE_STACK\t9\n#define EV_CONFIGURE_POS\t8\n#define EV_CONFIGURE_SIZE\t7\n#define EV_CONFIGURE\t\t6\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EVMAX 2048\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid read_events(int *n_in) {\n\tint n = *n_in;\n\tWindow win, win2;\n\tXEvent ev;\n\t\n\twhile (xcheckmaskevent(dpy, all_ev, &Ev[n])) {\n\t\tint cfg_size = 0;\n\t\tint cfg_pos = 0;\n\t\tint cfg_stack = 0;\n\t\tint type = Ev[n].type; \n\t\tWindow w = None;\n\n\t\twin = Ev[n].xany.window;\n\t\tEv_done[n] = 0;\n\t\tEv_area[n] = 0;\n\t\tEv_win[n] = win;\n\t\tEv_map[n] = None;\n\t\tEv_unmap[n] = None;\n\t\tEv_order[n] = n;\n\n\t\tev = Ev[n];\n\n\t\tif (type == DestroyNotify)  w = Ev[n].xcreatewindow.window;\n\t\tif (type == CreateNotify)   w = Ev[n].xdestroywindow.window;\n\t\tif (type == ReparentNotify) w = Ev[n].xreparent.window;\n\t\tif (type == UnmapNotify)    w = Ev[n].xunmap.window;\n\t\tif (type == MapNotify)      w = Ev[n].xmap.window;\n\t\tif (type == Expose)         w = Ev[n].xexpose.window;\n\t\tif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\n\t\tif (type == VisibilityNotify) w = win;\n\t\tif (n == *n_in && ncdb) fprintf(stderr, \"\\n\");\n\t\tif (1) {\n\t\t\tchar *msg = \"\";\n\t\t\tint idx = -1, x = 0, y = 0, wd = 0, ht = 0;\n\t\t\tif (w != None) {\n\t\t\t\tidx = lookup_win_index(w);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tx = cache_list[idx].x;\n\t\t\t\t\ty = cache_list[idx].y;\n\t\t\t\t\twd = cache_list[idx].width;\n\t\t\t\t\tht = cache_list[idx].height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type == VisibilityNotify) {\n\t\t\t\tmsg = VState(Ev[n].xvisibility.state);\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tint x_new = Ev[n].xconfigure.x; \n\t\t\t\tint y_new = Ev[n].xconfigure.y; \n\t\t\t\tint w_new = Ev[n].xconfigure.width; \n\t\t\t\tint h_new = Ev[n].xconfigure.height; \n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (w_new != wd || h_new != ht) {\n\t\t\t\t\t\tmsg = \"change size\";\n\t\t\t\t\t\tcfg_size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (x_new != x || y_new != y) {\n\t\t\t\t\t\tif (!strcmp(msg, \"\")) {\n\t\t\t\t\t\t\tmsg = \"change position\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg_pos = 1;\n\t\t\t\t\t} else if (! cfg_size) {\n\t\t\t\t\t\tmsg = \"change stacking\";\n\t\t\t\t\t\tcfg_stack = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ncdb) fprintf(stderr, \"----- %02d inputev 0x%08lx w: 0x%08lx %04dx%04d+%04d+%04d %s  %s\\n\", n, win, w, wd, ht, x, y, Etype(type), msg);\n\t\t}\n\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tev_store(win2, EV_CREATE);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tev_store(win2, EV_REPARENT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == PropertyNotify) {\n\t\t\t\tset_prop_atom(Ev[n].xproperty.atom);\n\t\t\t\tn++;\n\t\t\t\tn_PN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\twin2 = ev.xmap.window;\n\t\t\t\tev_store(win2, EV_MAP);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\n#if 0\n\t\t\t\tWindow w = None;\nif (type == DestroyNotify) w = Ev[n].xdestroywindow.window;\nif (type == UnmapNotify)   w = Ev[n].xunmap.window;\nif (type == MapNotify)     w = Ev[n].xmap.window;\nif (type == Expose)        w = Ev[n].xexpose.window;\nif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\nif (type != ConfigureNotify) fprintf(stderr, \"root: skip %s  for 0x%lx\\n\", Etype(type), w);\n#endif\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ReparentNotify) {\n\t\t\t\tev_store(win, EV_REPARENT);\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\tev_store(win, EV_DESTROY);\n\t\t\t\tn++;\n\t\t\t\tn_DN++;\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tev_store(win, EV_CONFIGURE);\n\t\t\t\tif (cfg_size) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_SIZE);\n\t\t\t\t\tn_ON_sz++;\n\t\t\t\t}\n\t\t\t\tif (cfg_pos) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_POS);\n\t\t\t\t\tn_ON_po++;\n\t\t\t\t}\n\t\t\t\tif (cfg_stack) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_STACK);\n\t\t\t\t\tn_ON_st++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_ON++;\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tif (Ev[n].xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_UNOBS);\n\t\t\t\t\tn_VN_u++;\n\t\t\t\t} else {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_OBS);\n\t\t\t\t\tn_VN_p++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_VN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tev_store(win, EV_MAP);\n\t\t\t\tEv_map[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_MN++;\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tev_store(win, EV_UNMAP);\n\t\t\t\tEv_unmap[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_UN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\nif (ncdb) fprintf(stderr, \"----- skip %s\\n\", Etype(type));\n\t\t\t}\n\t\t}\n\t\tif (n >= EVMAX) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*n_in = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 9172
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 9170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "30 * 1000"
          ],
          "line": 9168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_events retry: %d -> %d\\n\"",
            "n0",
            "n"
          ],
          "line": 9159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "25 * 1000"
          ],
          "line": 9156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read_events-%d\\n\"",
            "k"
          ],
          "line": 9141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kde_no_animate",
          "args": [
            "0"
          ],
          "line": 9128
        },
        "resolved": true,
        "details": {
          "function_name": "kde_no_animate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1055-1160",
          "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dt_guess",
            "\"kde\""
          ],
          "line": 9124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dt_guess",
            "\"gnome\""
          ],
          "line": 9122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dt_prev"
          ],
          "line": 9119
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ncache_xrootpmap",
          "args": [],
          "line": 9114
        },
        "resolved": true,
        "details": {
          "function_name": "set_ncache_xrootpmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8167-8238",
          "snippet": "void set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_ncache_xrootpmap(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_ncache_xrootpmap(void);\n\nvoid set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dt_prev",
            "dt_guess"
          ],
          "line": 9113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "guess_desktop()"
          ],
          "line": 9111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_desktop",
          "args": [],
          "line": 9111
        },
        "resolved": true,
        "details": {
          "function_name": "guess_desktop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1232-1292",
          "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGS_get_all_windows",
          "args": [],
          "line": 9096
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_all_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "262-521",
          "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTMAX 4",
            "#define WINHISTNUM 32768",
            "#define MAXWINDAT 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "NULL"
          ],
          "line": 9094
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_stats",
          "args": [],
          "line": 9088
        },
        "resolved": true,
        "details": {
          "function_name": "block_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7569-7664",
          "snippet": "void block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_zero_rects",
          "args": [],
          "line": 9085
        },
        "resolved": true,
        "details": {
          "function_name": "check_zero_rects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7550-7567",
          "snippet": "void check_zero_rects(void) {\n\tsraRect rt;\n\tsraRectangleIterator *iter;\n\tif (! zero_rects) {\n\t\tzero_rects = sraRgnCreate();\n\t}\n\tif (sraRgnEmpty(zero_rects)) {\n\t\treturn;\n\t}\n\t\t\n\titer = sraRgnGetIterator(zero_rects);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\tzero_fb(rt.x1, rt.y1, rt.x2, rt.y2);\n\t\tmark_rect_as_modified(rt.x1, rt.y1, rt.x2, rt.y2, 0);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnMakeEmpty(zero_rects);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_zero_rects(void) {\n\tsraRect rt;\n\tsraRectangleIterator *iter;\n\tif (! zero_rects) {\n\t\tzero_rects = sraRgnCreate();\n\t}\n\tif (sraRgnEmpty(zero_rects)) {\n\t\treturn;\n\t}\n\t\t\n\titer = sraRgnGetIterator(zero_rects);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\tzero_fb(rt.x1, rt.y1, rt.x2, rt.y2);\n\t\tmark_rect_as_modified(rt.x1, rt.y1, rt.x2, rt.y2, 0);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnMakeEmpty(zero_rects);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "i"
          ],
          "line": 9072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_cache_list",
          "args": [
            "0",
            "100.0"
          ],
          "line": 9070
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_cache_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5756-5860",
          "snippet": "void snapshot_cache_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\tint start = 512;\n\n\tif (! cache_list) {\n\t\tcache_list = (winattr_t *) calloc(start*sizeof(winattr_t), 1);\n\t\tcache_list_num = 0;\n\t\tcache_list_len = start;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (cache_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tcache_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num > cache_list_len) {\n\t\tint n = 2*num;\n\t\tn = num + 3;\n\t\tfree(cache_list);\n\t\tcache_list = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\tcache_list_len = n;\n\t}\n\tfor (i=0; i<num; i++) {\n\t\tcache_list[i].win = list[i];\n\t\tcache_list[i].fetched = 0;\n\t\tcache_list[i].valid = 0;\n\t\tcache_list[i].time = now;\n\t\tcache_list[i].selectinput = 0;\n\t\tcache_list[i].vis_cnt = 0;\n\t\tcache_list[i].map_cnt = 0;\n\t\tcache_list[i].unmap_cnt = 0;\n\t\tcache_list[i].create_cnt = 0;\n\t\tcache_list[i].vis_state = -1;\n\t\tcache_list[i].above = None;\n\t}\n\tif (num == 0) {\n\t\tcache_list[0].win = None;\n\t\tcache_list[0].fetched = 0;\n\t\tcache_list[0].valid = 0;\n\t\tcache_list[0].time = now;\n\t\tcache_list[0].selectinput = 0;\n\t\tcache_list[0].vis_cnt = 0;\n\t\tcache_list[0].map_cnt = 0;\n\t\tcache_list[0].unmap_cnt = 0;\n\t\tcache_list[0].create_cnt = 0;\n\t\tcache_list[0].vis_state = -1;\n\t\tcache_list[0].above = None;\n\t\tnum++;\n\t}\n\n\tcache_list_num = num;\n\n\tif (num) {\n\t\tX_LOCK;\n\t\tXFree_wr(list);\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;",
            "static void destroy_str_list(char **list);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\nstatic void destroy_str_list(char **list);\nwinattr_t *cache_list;\n\nvoid snapshot_cache_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\tint start = 512;\n\n\tif (! cache_list) {\n\t\tcache_list = (winattr_t *) calloc(start*sizeof(winattr_t), 1);\n\t\tcache_list_num = 0;\n\t\tcache_list_len = start;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (cache_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tcache_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num > cache_list_len) {\n\t\tint n = 2*num;\n\t\tn = num + 3;\n\t\tfree(cache_list);\n\t\tcache_list = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\tcache_list_len = n;\n\t}\n\tfor (i=0; i<num; i++) {\n\t\tcache_list[i].win = list[i];\n\t\tcache_list[i].fetched = 0;\n\t\tcache_list[i].valid = 0;\n\t\tcache_list[i].time = now;\n\t\tcache_list[i].selectinput = 0;\n\t\tcache_list[i].vis_cnt = 0;\n\t\tcache_list[i].map_cnt = 0;\n\t\tcache_list[i].unmap_cnt = 0;\n\t\tcache_list[i].create_cnt = 0;\n\t\tcache_list[i].vis_state = -1;\n\t\tcache_list[i].above = None;\n\t}\n\tif (num == 0) {\n\t\tcache_list[0].win = None;\n\t\tcache_list[0].fetched = 0;\n\t\tcache_list[0].valid = 0;\n\t\tcache_list[0].time = now;\n\t\tcache_list[0].selectinput = 0;\n\t\tcache_list[0].vis_cnt = 0;\n\t\tcache_list[0].map_cnt = 0;\n\t\tcache_list[0].unmap_cnt = 0;\n\t\tcache_list[0].create_cnt = 0;\n\t\tcache_list[0].vis_state = -1;\n\t\tcache_list[0].above = None;\n\t\tnum++;\n\t}\n\n\tcache_list_num = num;\n\n\tif (num) {\n\t\tX_LOCK;\n\t\tXFree_wr(list);\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+6*dy",
            "\"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\"",
            "white_pixel()"
          ],
          "line": 9063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 9065
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+5*dy",
            "\"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\"",
            "white_pixel()"
          ],
          "line": 9060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+4*dy",
            "\"To disable caching run the server with:  x11vnc -noncache ...\"",
            "white_pixel()"
          ],
          "line": 9057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+3*dy",
            "\"Pay no attention to the man behind the curtain...\"",
            "white_pixel()"
          ],
          "line": 9054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+2*dy",
            "\"Try resizing your VNC Viewer so you don't see it!!\"",
            "white_pixel()"
          ],
          "line": 9051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "screen",
            "&default8x16Font",
            "dx",
            "ds + Dy+1*dy",
            "\"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\"",
            "white_pixel()"
          ],
          "line": 9048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput_wr",
          "args": [
            "dpy",
            "rootwin",
            "xselectinput_rootwin"
          ],
          "line": 9034
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "dpy_y",
            "dpy_x",
            "(ncache+1)*dpy_y",
            "0"
          ],
          "line": 9009
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "0",
            "dpy_y",
            "dpy_x",
            "(ncache+1)*dpy_y"
          ],
          "line": 9008
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect_reg[n]"
          ],
          "line": 9004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_ncache: resetting cache: %d/%d %d %d\\n\"",
            "cache_list_num",
            "cache_list_len",
            "ncache",
            "first"
          ],
          "line": 8998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 8990
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 8966
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_ncache purged %d events\\n\"",
            "c"
          ],
          "line": 8961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcheckmaskevent",
          "args": [
            "dpy",
            "all_ev",
            "&ev"
          ],
          "line": 8956
        },
        "resolved": true,
        "details": {
          "function_name": "xcheckmaskevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7736-7754",
          "snippet": "Bool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nBool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "-1"
          ],
          "line": 8927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "-1"
          ],
          "line": 8921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
  },
  {
    "function_name": "check_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8633-8878",
    "snippet": "void check_sched(int try_batch, int *did_sched) {\n\tstatic double last_root = 0.0;\n\tstatic double last_pixmap = 0.0;\n\tdouble refresh = 60.0;\n\tint i, k, valid;\n\tWindow win;\n\tXWindowAttributes attr;\n\tdouble now = dnow();\n\n\tif (now > last_root + refresh) {\n\nif (ncdb) fprintf(stderr, \"\\n**** checking cache_list[%d]\\n\\n\", cache_list_num);\n\t\tblock_stats();\n\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tvalid = 0;\n\t\t\twin = cache_list[k].win; \n\t\t\tX_LOCK;\n\t\t\tif (win == None) {\n\t\t\t\t;\n\t\t\t} else if (cache_list[k].selectinput && cache_list[k].time > now - refresh) {\n\t\t\t\tvalid = 1;\n\t\t\t} else if (valid_window(win, &attr, 1)) {\n\t\t\t\tSTORE(k, win, attr);\n\t\t\t\tif (! cache_list[k].selectinput) {\n\t\t\t\t\txselectinput(win, win_ev, 0);\n\t\t\t\t\tCLEAR(k);\n\t\t\t\t\tcache_list[k].selectinput = 1;\n\t\t\t\t}\n\t\t\t\tvalid = 1;\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"DELETE(%d) %dx%d+%d+%d\\n\", k, cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tX_UNLOCK;\n/* XXX Y */\n\t\t\tif (valid) {\n\t\t\t\tif (cache_list[k].create_cnt && cache_list[k].map_state != IsViewable && cache_list[k].map_cnt == 0) {\n\t\t\t\t\tif (cache_list[k].bs_x >= 0) {\nif (ncdb) fprintf(stderr, \"Created window never mapped: freeing(%d) 0x%lx\\n\", k, win);\n\t\t\t\t\t\tfree_rect(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlast_root = dnow();\n\t}\n\n\tif (now > last_sched_bs + 0.30) {\n\t\tstatic double last_sched_vis = 0.0;\n\t\tint nr = 0, *bat = NULL;\n\n\t\tif (try_batch) {\n\t\t\tbat = &nr;\n\t\t}\n\t\tif (now < last_wireframe + 2.0) {\n\t\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\t\tsched_bs[i] = None;\n\t\t\t}\n\t\t}\n\t\tif (now < last_get_wm_frame_time + 1.0) {\n\t\t\tif (last_get_wm_frame != None) {\n\t\t\t\tint idx = lookup_win_index(last_get_wm_frame);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (cache_list[idx].bs_x < 0) {\n\t\t\t\t\t\tint x = cache_list[idx].x;\n\t\t\t\t\t\tint y = cache_list[idx].y;\n\t\t\t\t\t\tint w = cache_list[idx].width;\n\t\t\t\t\t\tint h = cache_list[idx].height;\n\t\t\t\t\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\t\t\t\t\tSCHED(last_get_wm_frame, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tif (sched_bs[i] != None) {\n\t\t\t\tint idx;\n\t\t\t\twin = sched_bs[i];\t\n\t\t\t\tif (now < sched_tm[i] + 0.55) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\t\t\tsched_tm[i] = now;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tint aw = cache_list[idx].width; \n\t\t\t\t\tint ah = cache_list[idx].height; \n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (cache_list[idx].vis_state != VisibilityUnobscured) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (aw * ah < 64 * 64) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SNAP BS_save: 0x%lx %d %d %d\\n\", win, aw, ah, cache_list[idx].map_state); \n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, bat, &attr, 1, 0, &valid, 0);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SCHED LOOKUP FAIL: i=%d 0x%lx\\n\", i, win);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\t*did_sched = 1;\n\n\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\tif (last_sched_vis < now) {\n\t\t\t\tlast_sched_vis += 1.0;\n\t\t\t}\n\t\t} else if (now > last_sched_vis + 3.0 && now > last_wireframe + 2.0) {\n\t\t\tstatic double last_vis = 0.0;\n\t\t\tint vis_now[32], top_now[32];\n\t\t\tstatic int vis_prev[32], freq = 0;\n\t\t\tint diff, nv = 32, vis_now_n = 0;\n\t\t\tWindow win;\n\n\t\t\tfreq++;\n\n\t\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\t\tint ok = 0;\n\t\t\t\tint top_only = 1;\n\t\t\t\tint aw = cache_list[i].width; \n\t\t\t\tint ah = cache_list[i].height; \n\t\t\t\tint map_prev = cache_list[i].map_state;\n\n\t\t\t\twin = cache_list[i].win;\n\n\t\t\t\tif (saw_desktop_change) {\n\t\t\t\t\ttop_only = 0;\n\t\t\t\t}\n\n\t\t\t\tif (win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* XXX Y resp */\n\t\t\t\tif (saw_desktop_change || freq % 5 == 0) {\n\t\t\t\t\tint vret = 0;\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tvret = valid_window(win, &attr, 1);\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (!vret) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t}\n\t\t\t\tif (!cache_list[i].valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map_prev != IsViewable) {\n\t\t\t\t\t/* we hope to catch it below in the normal event processing */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (aw * ah < 64 * 64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (top_only) {\n\t\t\t\t\tif (cache_list[i].vis_state == VisibilityUnobscured) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} else if (!clipped(i)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (vis_now_n < nv) {\n\t\t\t\t\t\tvis_now[vis_now_n] = i;\n\t\t\t\t\t\ttop_now[vis_now_n++] = top_only;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiff = 0;\n\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\tif (vis_now[k] != vis_prev[k]) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff == 0) {\n\t\t\t\tif (now > last_vis + 45.0) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff) {\nif (ncdb && vis_now_n) fprintf(stderr, \"*VIS  snapshot all %.4f\\n\", dnowx());\n\t\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\t\ti = vis_now[k];\n\t\t\t\t\twin = cache_list[i].win;\n\t\t\t\t\tvalid = 0;\nif (ncdb) fprintf(stderr, \"*VIS  BS_save: 0x%lx %d %d %d\\n\", win, cache_list[i].width, cache_list[i].height, cache_list[i].map_state); \n\t\t\t\t\tif (now < cache_list[i].vis_unobs_time + 0.75 && now < cache_list[i].vis_obs_time + 0.75) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbs_save(i, bat, &attr, !top_now[k], 0, &valid, 1);\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(i);\n\t\t\t\t\t}\n\t\t\t\t\tvis_prev[k] = vis_now[k];\n\t\t\t\t}\n\t\t\t\tlast_vis = dnow();\n\t\t\t}\n\t\t\tlast_sched_vis = dnow();\n\t\t\tif (! n_DC) {\n\t\t\t\tsaw_desktop_change = 0;\n\t\t\t}\n\t\t\t/* XXX Y */\n\t\t\ttry_to_synthesize_su(0, 0, bat);\n\t\t}\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tlast_sched_bs = dnow();\n\t}\n#if !NO_X11\n\tif (dpy && atom_XROOTPMAP_ID == None && now > last_pixmap + 5.0) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t\tlast_pixmap = now;\n\t}\n#endif\n\tif (got_XROOTPMAP_ID > 0.0) {\nif (ncdb) fprintf(stderr, \"got_XROOTPMAP_ID\\n\");\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgot_XROOTPMAP_ID = 0.0;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NSCHED 128"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "void set_ncache_xrootpmap(void);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ncache_xrootpmap",
          "args": [],
          "line": 8874
        },
        "resolved": true,
        "details": {
          "function_name": "set_ncache_xrootpmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8167-8238",
          "snippet": "void set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_ncache_xrootpmap(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_ncache_xrootpmap(void);\n\nvoid set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got_XROOTPMAP_ID\\n\""
          ],
          "line": 8872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_XROOTPMAP_ID\"",
            "True"
          ],
          "line": 8867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 8863
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "nr",
            "-1.0"
          ],
          "line": 8861
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_synthesize_su",
          "args": [
            "0",
            "0",
            "bat"
          ],
          "line": 8857
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_synthesize_su",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8459-8626",
          "snippet": "int try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "i"
          ],
          "line": 8846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "i",
            "win",
            "attr"
          ],
          "line": 8844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bs_save",
          "args": [
            "i",
            "bat",
            "&attr",
            "!top_now[k]",
            "0",
            "&valid",
            "1"
          ],
          "line": 8842
        },
        "resolved": true,
        "details": {
          "function_name": "bs_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7130-7234",
          "snippet": "int bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*VIS  BS_save: 0x%lx %d %d %d\\n\"",
            "win",
            "cache_list[i].width",
            "cache_list[i].height",
            "cache_list[i].map_state"
          ],
          "line": 8838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*VIS  snapshot all %.4f\\n\"",
            "dnowx()"
          ],
          "line": 8833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clipped",
          "args": [
            "i"
          ],
          "line": 8808
        },
        "resolved": true,
        "details": {
          "function_name": "clipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7031-7092",
          "snippet": "int clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "i",
            "win",
            "attr"
          ],
          "line": 8787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 8782
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*SCHED LOOKUP FAIL: i=%d 0x%lx\\n\"",
            "i",
            "win"
          ],
          "line": 8742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "idx"
          ],
          "line": 8738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 8736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*SNAP BS_save: 0x%lx %d %d %d\\n\"",
            "win",
            "aw",
            "ah",
            "cache_list[idx].map_state"
          ],
          "line": 8732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "win"
          ],
          "line": 8721
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED",
          "args": [
            "last_get_wm_frame",
            "1"
          ],
          "line": 8703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "idx",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 8702
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rect",
          "args": [
            "k"
          ],
          "line": 8673
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Created window never mapped: freeing(%d) 0x%lx\\n\"",
            "k",
            "win"
          ],
          "line": 8672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "k"
          ],
          "line": 8665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DELETE(%d) %dx%d+%d+%d\\n\"",
            "k",
            "cache_list[k].width",
            "cache_list[k].height",
            "cache_list[k].x",
            "cache_list[k].y"
          ],
          "line": 8664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "k"
          ],
          "line": 8659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xselectinput",
          "args": [
            "win",
            "win_ev",
            "0"
          ],
          "line": 8658
        },
        "resolved": true,
        "details": {
          "function_name": "xselectinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7693-7734",
          "snippet": "void xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\n\nvoid xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "k",
            "win",
            "attr"
          ],
          "line": 8656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_stats",
          "args": [],
          "line": 8645
        },
        "resolved": true,
        "details": {
          "function_name": "block_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7569-7664",
          "snippet": "void block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n**** checking cache_list[%d]\\n\\n\"",
            "cache_list_num"
          ],
          "line": 8644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NSCHED 128\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid check_sched(int try_batch, int *did_sched) {\n\tstatic double last_root = 0.0;\n\tstatic double last_pixmap = 0.0;\n\tdouble refresh = 60.0;\n\tint i, k, valid;\n\tWindow win;\n\tXWindowAttributes attr;\n\tdouble now = dnow();\n\n\tif (now > last_root + refresh) {\n\nif (ncdb) fprintf(stderr, \"\\n**** checking cache_list[%d]\\n\\n\", cache_list_num);\n\t\tblock_stats();\n\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tvalid = 0;\n\t\t\twin = cache_list[k].win; \n\t\t\tX_LOCK;\n\t\t\tif (win == None) {\n\t\t\t\t;\n\t\t\t} else if (cache_list[k].selectinput && cache_list[k].time > now - refresh) {\n\t\t\t\tvalid = 1;\n\t\t\t} else if (valid_window(win, &attr, 1)) {\n\t\t\t\tSTORE(k, win, attr);\n\t\t\t\tif (! cache_list[k].selectinput) {\n\t\t\t\t\txselectinput(win, win_ev, 0);\n\t\t\t\t\tCLEAR(k);\n\t\t\t\t\tcache_list[k].selectinput = 1;\n\t\t\t\t}\n\t\t\t\tvalid = 1;\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"DELETE(%d) %dx%d+%d+%d\\n\", k, cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tX_UNLOCK;\n/* XXX Y */\n\t\t\tif (valid) {\n\t\t\t\tif (cache_list[k].create_cnt && cache_list[k].map_state != IsViewable && cache_list[k].map_cnt == 0) {\n\t\t\t\t\tif (cache_list[k].bs_x >= 0) {\nif (ncdb) fprintf(stderr, \"Created window never mapped: freeing(%d) 0x%lx\\n\", k, win);\n\t\t\t\t\t\tfree_rect(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlast_root = dnow();\n\t}\n\n\tif (now > last_sched_bs + 0.30) {\n\t\tstatic double last_sched_vis = 0.0;\n\t\tint nr = 0, *bat = NULL;\n\n\t\tif (try_batch) {\n\t\t\tbat = &nr;\n\t\t}\n\t\tif (now < last_wireframe + 2.0) {\n\t\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\t\tsched_bs[i] = None;\n\t\t\t}\n\t\t}\n\t\tif (now < last_get_wm_frame_time + 1.0) {\n\t\t\tif (last_get_wm_frame != None) {\n\t\t\t\tint idx = lookup_win_index(last_get_wm_frame);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (cache_list[idx].bs_x < 0) {\n\t\t\t\t\t\tint x = cache_list[idx].x;\n\t\t\t\t\t\tint y = cache_list[idx].y;\n\t\t\t\t\t\tint w = cache_list[idx].width;\n\t\t\t\t\t\tint h = cache_list[idx].height;\n\t\t\t\t\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\t\t\t\t\tSCHED(last_get_wm_frame, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tif (sched_bs[i] != None) {\n\t\t\t\tint idx;\n\t\t\t\twin = sched_bs[i];\t\n\t\t\t\tif (now < sched_tm[i] + 0.55) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\t\t\tsched_tm[i] = now;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tint aw = cache_list[idx].width; \n\t\t\t\t\tint ah = cache_list[idx].height; \n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (cache_list[idx].vis_state != VisibilityUnobscured) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (aw * ah < 64 * 64) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SNAP BS_save: 0x%lx %d %d %d\\n\", win, aw, ah, cache_list[idx].map_state); \n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, bat, &attr, 1, 0, &valid, 0);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"*SCHED LOOKUP FAIL: i=%d 0x%lx\\n\", i, win);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\t*did_sched = 1;\n\n\t\tif (n_MN || n_UN || n_ST || n_DC) {\n\t\t\tif (last_sched_vis < now) {\n\t\t\t\tlast_sched_vis += 1.0;\n\t\t\t}\n\t\t} else if (now > last_sched_vis + 3.0 && now > last_wireframe + 2.0) {\n\t\t\tstatic double last_vis = 0.0;\n\t\t\tint vis_now[32], top_now[32];\n\t\t\tstatic int vis_prev[32], freq = 0;\n\t\t\tint diff, nv = 32, vis_now_n = 0;\n\t\t\tWindow win;\n\n\t\t\tfreq++;\n\n\t\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\t\tint ok = 0;\n\t\t\t\tint top_only = 1;\n\t\t\t\tint aw = cache_list[i].width; \n\t\t\t\tint ah = cache_list[i].height; \n\t\t\t\tint map_prev = cache_list[i].map_state;\n\n\t\t\t\twin = cache_list[i].win;\n\n\t\t\t\tif (saw_desktop_change) {\n\t\t\t\t\ttop_only = 0;\n\t\t\t\t}\n\n\t\t\t\tif (win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* XXX Y resp */\n\t\t\t\tif (saw_desktop_change || freq % 5 == 0) {\n\t\t\t\t\tint vret = 0;\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tvret = valid_window(win, &attr, 1);\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (!vret) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t}\n\t\t\t\tif (!cache_list[i].valid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[i].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (map_prev != IsViewable) {\n\t\t\t\t\t/* we hope to catch it below in the normal event processing */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (aw * ah < 64 * 64) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (top_only) {\n\t\t\t\t\tif (cache_list[i].vis_state == VisibilityUnobscured) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} else if (!clipped(i)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (vis_now_n < nv) {\n\t\t\t\t\t\tvis_now[vis_now_n] = i;\n\t\t\t\t\t\ttop_now[vis_now_n++] = top_only;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdiff = 0;\n\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\tif (vis_now[k] != vis_prev[k]) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff == 0) {\n\t\t\t\tif (now > last_vis + 45.0) {\n\t\t\t\t\tdiff = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diff) {\nif (ncdb && vis_now_n) fprintf(stderr, \"*VIS  snapshot all %.4f\\n\", dnowx());\n\t\t\t\tfor (k = 0; k < vis_now_n; k++) {\n\t\t\t\t\ti = vis_now[k];\n\t\t\t\t\twin = cache_list[i].win;\n\t\t\t\t\tvalid = 0;\nif (ncdb) fprintf(stderr, \"*VIS  BS_save: 0x%lx %d %d %d\\n\", win, cache_list[i].width, cache_list[i].height, cache_list[i].map_state); \n\t\t\t\t\tif (now < cache_list[i].vis_unobs_time + 0.75 && now < cache_list[i].vis_obs_time + 0.75) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbs_save(i, bat, &attr, !top_now[k], 0, &valid, 1);\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(i, win, attr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(i);\n\t\t\t\t\t}\n\t\t\t\t\tvis_prev[k] = vis_now[k];\n\t\t\t\t}\n\t\t\t\tlast_vis = dnow();\n\t\t\t}\n\t\t\tlast_sched_vis = dnow();\n\t\t\tif (! n_DC) {\n\t\t\t\tsaw_desktop_change = 0;\n\t\t\t}\n\t\t\t/* XXX Y */\n\t\t\ttry_to_synthesize_su(0, 0, bat);\n\t\t}\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tlast_sched_bs = dnow();\n\t}\n#if !NO_X11\n\tif (dpy && atom_XROOTPMAP_ID == None && now > last_pixmap + 5.0) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t\tlast_pixmap = now;\n\t}\n#endif\n\tif (got_XROOTPMAP_ID > 0.0) {\nif (ncdb) fprintf(stderr, \"got_XROOTPMAP_ID\\n\");\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgot_XROOTPMAP_ID = 0.0;\n\t}\n}"
  },
  {
    "function_name": "try_to_synthesize_su",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8459-8626",
    "snippet": "int try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "int lookup_win_index(Window);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);",
      "void snap_old(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\"",
            "win",
            "i",
            "idx",
            "cnt"
          ],
          "line": 8620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 8618
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 8615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r2",
            "dx",
            "dy",
            "save_delay0",
            "save_delay1",
            "nbatch"
          ],
          "line": 8612
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 8606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 8574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "tmp_reg[i2]"
          ],
          "line": 8573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 8569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 8559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "tmp_reg[i]"
          ],
          "line": 8555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"forcing synth: 0x%lx %d\\n\"",
            "cache_list[idx].win",
            "idx"
          ],
          "line": 8537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r1"
          ],
          "line": 8532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 8512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 8511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"win: 0x%lx %d  idx=%d\\n\"",
            "win",
            "i",
            "idx"
          ],
          "line": 8504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "win"
          ],
          "line": 8485
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STORE",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 8482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 8477
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snap_old",
          "args": [],
          "line": 8471
        },
        "resolved": true,
        "details": {
          "function_name": "snap_old_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6059-6072",
          "snippet": "void snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 8469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint try_to_synthesize_su(int force, int urgent, int *nbatch) {\n\tint i, idx, idx2, n = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win = None;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x3, y3, w3, h3;\n\tXWindowAttributes attr;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tsnap_old();\n\n\tX_LOCK;\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin = old_stack[i];\n\t\tif (urgent) {\t/* XXX Y resp */\n\t\t\tif (!valid_window(win, &attr, 1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tSTORE(idx, win, attr);\n\t\t\t}\n\t\t} else {\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx >= 0) {\n\t\t\t\tattr.map_state = cache_list[idx].map_state;\n\t\t\t\tattr.x = cache_list[idx].x;\n\t\t\t\tattr.y = cache_list[idx].y;\n\t\t\t\tattr.width = cache_list[idx].width;\n\t\t\t\tattr.height = cache_list[idx].height;\n\t\t\t} else {\n\t\t\t\tattr.map_state = IsUnmapped;\n\t\t\t\tattr.x = 0;\n\t\t\t\tattr.y = 0;\n\t\t\t\tattr.width = 0;\n\t\t\t\tattr.height = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (attr.map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\nif (0) fprintf(stderr, \"win: 0x%lx %d  idx=%d\\n\", win, i, idx);\n\n\t\tx2 = attr.x;\n\t\ty2 = attr.y;\n\t\tw2 = attr.width;\n\t\th2 = attr.height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx;\n\t}\n\tX_UNLOCK;\n\n\tif (! n) {\n\t\tr1 = NULL;\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tint i2, cnt = 0;\n\t\tidx = tmp_stack[i];\n\t\tif (idx < 0 || cache_list[idx].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tr1 = tmp_reg[i];\n\t\tif (r1 == NULL || sraRgnEmpty(r1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx].su_time > 0.0) {\n\t\t\tif (force) {\nif (ncdb) fprintf(stderr, \"forcing synth: 0x%lx %d\\n\", cache_list[idx].win, idx);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\tint dx, dy;\n\n\t\t\tx0 = cache_list[idx].x;\n\t\t\ty0 = cache_list[idx].y;\n\t\t\tw0 = cache_list[idx].width;\n\t\t\th0 = cache_list[idx].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\t\tdx = x1 - x0;\n\t\t\tdy = y1 - y0;\n\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tx2 = x0;\n\t\t\ty2 = y0 + (ncache+1) * dpy_y;\n\n\t\t\tdx = x1 - x2;\n\t\t\tdy = y1 - y2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\tcnt++;\n\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\n\t\tfor (i2 = n - 1; i2 > i; i2--) {\n\t\t\tr2 = sraRgnCreateRgn(tmp_reg[i2]);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tint dx, dy;\n\t\t\t\tint dx2, dy2;\n\n\t\t\t\tidx2 = tmp_stack[i2];\n\t\t\t\t/* XXX Y */\n\t\t\t\tif (idx2 < 0 || cache_list[idx2].bs_x < 0 || cache_list[idx2].bs_time == 0.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx0 = cache_list[idx].x;\n\t\t\t\ty0 = cache_list[idx].y;\n\t\t\t\tw0 = cache_list[idx].width;\n\t\t\t\th0 = cache_list[idx].height;\n\n\t\t\t\tx1 = cache_list[idx].su_x;\n\t\t\t\ty1 = cache_list[idx].su_y;\n\t\t\t\tw1 = cache_list[idx].su_w;\n\t\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\t\tx2 = cache_list[idx2].x;\n\t\t\t\ty2 = cache_list[idx2].y;\n\t\t\t\tw2 = cache_list[idx2].width;\n\t\t\t\th2 = cache_list[idx2].height;\n\n\t\t\t\tx3 = cache_list[idx2].bs_x;\n\t\t\t\ty3 = cache_list[idx2].bs_y;\n\t\t\t\tw3 = cache_list[idx2].bs_w;\n\t\t\t\th3 = cache_list[idx2].bs_h;\n\n\t\t\t\tdx = x1 - x0;\n\t\t\t\tdy = y1 - y0;\n\t\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\t\tdx2 = x3 - x2;\n\t\t\t\tdy2 = y3 - y2;\n\t\t\t\tdx = dx - dx2;\n\t\t\t\tdy = dy - dy2;\n\t\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\tif (cnt) {\n\t\t\tcache_list[idx].su_time = dnow();\n\t\t}\nif (ncdb) fprintf(stderr, \"  try_to_synth_su: 0x%lx %d  idx=%d cnt=%d\\n\", win, i, idx, cnt);\n\t}\n\n\tr1 = NULL;\n\tCLEAN_OUT\n\treturn 1;\n}"
  },
  {
    "function_name": "read_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8295-8457",
    "snippet": "void read_events(int *n_in) {\n\tint n = *n_in;\n\tWindow win, win2;\n\tXEvent ev;\n\t\n\twhile (xcheckmaskevent(dpy, all_ev, &Ev[n])) {\n\t\tint cfg_size = 0;\n\t\tint cfg_pos = 0;\n\t\tint cfg_stack = 0;\n\t\tint type = Ev[n].type; \n\t\tWindow w = None;\n\n\t\twin = Ev[n].xany.window;\n\t\tEv_done[n] = 0;\n\t\tEv_area[n] = 0;\n\t\tEv_win[n] = win;\n\t\tEv_map[n] = None;\n\t\tEv_unmap[n] = None;\n\t\tEv_order[n] = n;\n\n\t\tev = Ev[n];\n\n\t\tif (type == DestroyNotify)  w = Ev[n].xcreatewindow.window;\n\t\tif (type == CreateNotify)   w = Ev[n].xdestroywindow.window;\n\t\tif (type == ReparentNotify) w = Ev[n].xreparent.window;\n\t\tif (type == UnmapNotify)    w = Ev[n].xunmap.window;\n\t\tif (type == MapNotify)      w = Ev[n].xmap.window;\n\t\tif (type == Expose)         w = Ev[n].xexpose.window;\n\t\tif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\n\t\tif (type == VisibilityNotify) w = win;\n\t\tif (n == *n_in && ncdb) fprintf(stderr, \"\\n\");\n\t\tif (1) {\n\t\t\tchar *msg = \"\";\n\t\t\tint idx = -1, x = 0, y = 0, wd = 0, ht = 0;\n\t\t\tif (w != None) {\n\t\t\t\tidx = lookup_win_index(w);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tx = cache_list[idx].x;\n\t\t\t\t\ty = cache_list[idx].y;\n\t\t\t\t\twd = cache_list[idx].width;\n\t\t\t\t\tht = cache_list[idx].height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type == VisibilityNotify) {\n\t\t\t\tmsg = VState(Ev[n].xvisibility.state);\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tint x_new = Ev[n].xconfigure.x; \n\t\t\t\tint y_new = Ev[n].xconfigure.y; \n\t\t\t\tint w_new = Ev[n].xconfigure.width; \n\t\t\t\tint h_new = Ev[n].xconfigure.height; \n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (w_new != wd || h_new != ht) {\n\t\t\t\t\t\tmsg = \"change size\";\n\t\t\t\t\t\tcfg_size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (x_new != x || y_new != y) {\n\t\t\t\t\t\tif (!strcmp(msg, \"\")) {\n\t\t\t\t\t\t\tmsg = \"change position\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg_pos = 1;\n\t\t\t\t\t} else if (! cfg_size) {\n\t\t\t\t\t\tmsg = \"change stacking\";\n\t\t\t\t\t\tcfg_stack = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ncdb) fprintf(stderr, \"----- %02d inputev 0x%08lx w: 0x%08lx %04dx%04d+%04d+%04d %s  %s\\n\", n, win, w, wd, ht, x, y, Etype(type), msg);\n\t\t}\n\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tev_store(win2, EV_CREATE);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tev_store(win2, EV_REPARENT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == PropertyNotify) {\n\t\t\t\tset_prop_atom(Ev[n].xproperty.atom);\n\t\t\t\tn++;\n\t\t\t\tn_PN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\twin2 = ev.xmap.window;\n\t\t\t\tev_store(win2, EV_MAP);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\n#if 0\n\t\t\t\tWindow w = None;\nif (type == DestroyNotify) w = Ev[n].xdestroywindow.window;\nif (type == UnmapNotify)   w = Ev[n].xunmap.window;\nif (type == MapNotify)     w = Ev[n].xmap.window;\nif (type == Expose)        w = Ev[n].xexpose.window;\nif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\nif (type != ConfigureNotify) fprintf(stderr, \"root: skip %s  for 0x%lx\\n\", Etype(type), w);\n#endif\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ReparentNotify) {\n\t\t\t\tev_store(win, EV_REPARENT);\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\tev_store(win, EV_DESTROY);\n\t\t\t\tn++;\n\t\t\t\tn_DN++;\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tev_store(win, EV_CONFIGURE);\n\t\t\t\tif (cfg_size) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_SIZE);\n\t\t\t\t\tn_ON_sz++;\n\t\t\t\t}\n\t\t\t\tif (cfg_pos) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_POS);\n\t\t\t\t\tn_ON_po++;\n\t\t\t\t}\n\t\t\t\tif (cfg_stack) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_STACK);\n\t\t\t\t\tn_ON_st++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_ON++;\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tif (Ev[n].xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_UNOBS);\n\t\t\t\t\tn_VN_u++;\n\t\t\t\t} else {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_OBS);\n\t\t\t\t\tn_VN_p++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_VN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tev_store(win, EV_MAP);\n\t\t\t\tEv_map[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_MN++;\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tev_store(win, EV_UNMAP);\n\t\t\t\tEv_unmap[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_UN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\nif (ncdb) fprintf(stderr, \"----- skip %s\\n\", Etype(type));\n\t\t\t}\n\t\t}\n\t\tif (n >= EVMAX) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*n_in = n;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define EV_VISIBILITY_OBS\t11",
      "#define EV_VISIBILITY_UNOBS\t10",
      "#define EV_CONFIGURE_STACK\t9",
      "#define EV_CONFIGURE_POS\t8",
      "#define EV_CONFIGURE_SIZE\t7",
      "#define EV_CONFIGURE\t\t6",
      "#define EV_REPARENT\t\t5",
      "#define EV_MAP\t\t\t4",
      "#define EV_UNMAP\t\t3",
      "#define EV_DESTROY\t\t2",
      "#define EV_CREATE\t\t1",
      "#define EVMAX 2048"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----- skip %s\\n\"",
            "Etype(type)"
          ],
          "line": 8449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Etype",
          "args": [
            "type"
          ],
          "line": 8449
        },
        "resolved": true,
        "details": {
          "function_name": "Etype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6146-6183",
          "snippet": "char *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ev_store",
          "args": [
            "win",
            "EV_UNMAP"
          ],
          "line": 8443
        },
        "resolved": true,
        "details": {
          "function_name": "ev_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8266-8280",
          "snippet": "int ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define EV_RESET\t\t0",
            "#define EVLISTMAX 256"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define EV_RESET\t\t0\n#define EVLISTMAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"root: skip %s  for 0x%lx\\n\"",
            "Etype(type)",
            "w"
          ],
          "line": 8398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_prop_atom",
          "args": [
            "Ev[n].xproperty.atom"
          ],
          "line": 8381
        },
        "resolved": true,
        "details": {
          "function_name": "set_prop_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1191-1197",
          "snippet": "void set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_prop_atom(Atom atom);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_prop_atom(Atom atom);\n\nvoid set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----- %02d inputev 0x%08lx w: 0x%08lx %04dx%04d+%04d+%04d %s  %s\\n\"",
            "n",
            "win",
            "w",
            "wd",
            "ht",
            "x",
            "y",
            "Etype(type)",
            "msg"
          ],
          "line": 8362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "msg",
            "\"\""
          ],
          "line": 8351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VState",
          "args": [
            "Ev[n].xvisibility.state"
          ],
          "line": 8339
        },
        "resolved": true,
        "details": {
          "function_name": "VState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6184-6190",
          "snippet": "char *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "w"
          ],
          "line": 8330
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 8325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcheckmaskevent",
          "args": [
            "dpy",
            "all_ev",
            "&Ev[n]"
          ],
          "line": 8300
        },
        "resolved": true,
        "details": {
          "function_name": "xcheckmaskevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7736-7754",
          "snippet": "Bool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nBool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define EV_VISIBILITY_OBS\t11\n#define EV_VISIBILITY_UNOBS\t10\n#define EV_CONFIGURE_STACK\t9\n#define EV_CONFIGURE_POS\t8\n#define EV_CONFIGURE_SIZE\t7\n#define EV_CONFIGURE\t\t6\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EVMAX 2048\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid read_events(int *n_in) {\n\tint n = *n_in;\n\tWindow win, win2;\n\tXEvent ev;\n\t\n\twhile (xcheckmaskevent(dpy, all_ev, &Ev[n])) {\n\t\tint cfg_size = 0;\n\t\tint cfg_pos = 0;\n\t\tint cfg_stack = 0;\n\t\tint type = Ev[n].type; \n\t\tWindow w = None;\n\n\t\twin = Ev[n].xany.window;\n\t\tEv_done[n] = 0;\n\t\tEv_area[n] = 0;\n\t\tEv_win[n] = win;\n\t\tEv_map[n] = None;\n\t\tEv_unmap[n] = None;\n\t\tEv_order[n] = n;\n\n\t\tev = Ev[n];\n\n\t\tif (type == DestroyNotify)  w = Ev[n].xcreatewindow.window;\n\t\tif (type == CreateNotify)   w = Ev[n].xdestroywindow.window;\n\t\tif (type == ReparentNotify) w = Ev[n].xreparent.window;\n\t\tif (type == UnmapNotify)    w = Ev[n].xunmap.window;\n\t\tif (type == MapNotify)      w = Ev[n].xmap.window;\n\t\tif (type == Expose)         w = Ev[n].xexpose.window;\n\t\tif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\n\t\tif (type == VisibilityNotify) w = win;\n\t\tif (n == *n_in && ncdb) fprintf(stderr, \"\\n\");\n\t\tif (1) {\n\t\t\tchar *msg = \"\";\n\t\t\tint idx = -1, x = 0, y = 0, wd = 0, ht = 0;\n\t\t\tif (w != None) {\n\t\t\t\tidx = lookup_win_index(w);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tx = cache_list[idx].x;\n\t\t\t\t\ty = cache_list[idx].y;\n\t\t\t\t\twd = cache_list[idx].width;\n\t\t\t\t\tht = cache_list[idx].height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type == VisibilityNotify) {\n\t\t\t\tmsg = VState(Ev[n].xvisibility.state);\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tint x_new = Ev[n].xconfigure.x; \n\t\t\t\tint y_new = Ev[n].xconfigure.y; \n\t\t\t\tint w_new = Ev[n].xconfigure.width; \n\t\t\t\tint h_new = Ev[n].xconfigure.height; \n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tif (w_new != wd || h_new != ht) {\n\t\t\t\t\t\tmsg = \"change size\";\n\t\t\t\t\t\tcfg_size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (x_new != x || y_new != y) {\n\t\t\t\t\t\tif (!strcmp(msg, \"\")) {\n\t\t\t\t\t\t\tmsg = \"change position\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcfg_pos = 1;\n\t\t\t\t\t} else if (! cfg_size) {\n\t\t\t\t\t\tmsg = \"change stacking\";\n\t\t\t\t\t\tcfg_stack = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ncdb) fprintf(stderr, \"----- %02d inputev 0x%08lx w: 0x%08lx %04dx%04d+%04d+%04d %s  %s\\n\", n, win, w, wd, ht, x, y, Etype(type), msg);\n\t\t}\n\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tev_store(win2, EV_CREATE);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tev_store(win2, EV_REPARENT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == PropertyNotify) {\n\t\t\t\tset_prop_atom(Ev[n].xproperty.atom);\n\t\t\t\tn++;\n\t\t\t\tn_PN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\twin2 = ev.xmap.window;\n\t\t\t\tev_store(win2, EV_MAP);\n\t\t\t\tn++;\n\t\t\t\tn_CN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\n#if 0\n\t\t\t\tWindow w = None;\nif (type == DestroyNotify) w = Ev[n].xdestroywindow.window;\nif (type == UnmapNotify)   w = Ev[n].xunmap.window;\nif (type == MapNotify)     w = Ev[n].xmap.window;\nif (type == Expose)        w = Ev[n].xexpose.window;\nif (type == ConfigureNotify) w = Ev[n].xconfigure.window;\nif (type != ConfigureNotify) fprintf(stderr, \"root: skip %s  for 0x%lx\\n\", Etype(type), w);\n#endif\n\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ReparentNotify) {\n\t\t\t\tev_store(win, EV_REPARENT);\n\t\t\t\tn++;\n\t\t\t\tn_RN++;\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\tev_store(win, EV_DESTROY);\n\t\t\t\tn++;\n\t\t\t\tn_DN++;\n\t\t\t} else if (type == ConfigureNotify) {\n\t\t\t\tev_store(win, EV_CONFIGURE);\n\t\t\t\tif (cfg_size) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_SIZE);\n\t\t\t\t\tn_ON_sz++;\n\t\t\t\t}\n\t\t\t\tif (cfg_pos) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_POS);\n\t\t\t\t\tn_ON_po++;\n\t\t\t\t}\n\t\t\t\tif (cfg_stack) {\n\t\t\t\t\tev_store(win, EV_CONFIGURE_STACK);\n\t\t\t\t\tn_ON_st++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_ON++;\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tif (Ev[n].xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_UNOBS);\n\t\t\t\t\tn_VN_u++;\n\t\t\t\t} else {\n\t\t\t\t\tev_store(win, EV_VISIBILITY_OBS);\n\t\t\t\t\tn_VN_p++;\n\t\t\t\t}\n\t\t\t\tn++;\n\t\t\t\tn_VN++;\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tev_store(win, EV_MAP);\n\t\t\t\tEv_map[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_MN++;\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tev_store(win, EV_UNMAP);\n\t\t\t\tEv_unmap[n] = win;\n\t\t\t\tn++;\n\t\t\t\tn_UN++;\n\t\t\t} else {\n\t\t\t\t/* skip rest */\nif (ncdb) fprintf(stderr, \"----- skip %s\\n\", Etype(type));\n\t\t\t}\n\t\t}\n\t\tif (n >= EVMAX) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*n_in = n;\n}"
  },
  {
    "function_name": "ev_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8282-8290",
    "snippet": "int ev_lookup(Window win, int type) {\n\tint i;\n\tfor(i=0; i < _ev_list_cnt; i++) {\n\t\tif (_ev_list[i] == win && _ev_case[i] == type) \t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint ev_lookup(Window win, int type) {\n\tint i;\n\tfor(i=0; i < _ev_list_cnt; i++) {\n\t\tif (_ev_list[i] == win && _ev_case[i] == type) \t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ev_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8266-8280",
    "snippet": "int ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define EV_RESET\t\t0",
      "#define EVLISTMAX 256"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define EV_RESET\t\t0\n#define EVLISTMAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint ev_store(Window win, int type) {\n\tif (type == EV_RESET)  {\n\t\tn_CN = 0; n_RN = 0; n_DN = 0; n_ON = 0; n_MN = 0; n_UN = 0;\n\t\tn_VN = 0; n_VN_p = 0; n_VN_u = 0; n_ST = 0; n_PN = 0; n_DC = 0;\n\t\tn_ON_sz = 0; n_ON_po = 0; n_ON_st = 0;\n\t\t_ev_list_cnt = 0;\n\t\treturn 1;\n\t}\n\tif (_ev_list_cnt >= EVLISTMAX) {\n\t\treturn 0;\n\t}\n\t_ev_list[_ev_list_cnt] = win;\n\t_ev_case[_ev_list_cnt++] = type;\n\treturn 1;\n}"
  },
  {
    "function_name": "set_ncache_xrootpmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8167-8238",
    "snippet": "void set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_ncache_xrootpmap(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 8235
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "0",
            "yn",
            "dpy_x",
            "yn + dpy_y"
          ],
          "line": 8233
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_mark_xrootpmap",
          "args": [],
          "line": 8229
        },
        "resolved": true,
        "details": {
          "function_name": "scale_mark_xrootpmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8137-8165",
          "snippet": "void scale_mark_xrootpmap(void) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\tint yn = (ncache+1) * dpy_y;\n\tint yfac = (ncache+2);\n\tint mark = 1;\n\n\tif (!scaling || !rfb_fb || rfb_fb == main_fb) {\n\t\tmark_rect_as_modified(0, yn, dpy_x, yn + dpy_y, 0);\n\t\treturn;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, yfac * dpy_y,\n\t    scaled_x, yfac * scaled_y, 0, yn, dpy_x, yn + dpy_y, mark);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\n\nvoid scale_mark_xrootpmap(void) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\tint yn = (ncache+1) * dpy_y;\n\tint yfac = (ncache+2);\n\tint mark = 1;\n\n\tif (!scaling || !rfb_fb || rfb_fb == main_fb) {\n\t\tmark_rect_as_modified(0, yn, dpy_x, yn + dpy_y, 0);\n\t\treturn;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, yfac * dpy_y,\n\t    scaled_x, yfac * scaled_y, 0, yn, dpy_x, yn + dpy_y, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "image"
          ],
          "line": 8227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "dpy_x * pixelsize"
          ],
          "line": 8223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_root",
          "args": [
            "(char *) 0x1"
          ],
          "line": 8211
        },
        "resolved": true,
        "details": {
          "function_name": "solid_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "177-285",
          "snippet": "XImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\n\nXImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_ncache_xrootpmap: trying root background\\n\""
          ],
          "line": 8207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\"",
            "pixmap"
          ],
          "line": 8203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetImage",
          "args": [
            "dpy",
            "pixmap",
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 8199
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "rootwin",
            "pmap",
            "0L",
            "1L",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&length",
            "&after",
            "&d_pmap"
          ],
          "line": 8193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_ncache_xrootpmap: solid_image\\n\""
          ],
          "line": 8187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_image",
          "args": [
            "NULL"
          ],
          "line": 8185
        },
        "resolved": true,
        "details": {
          "function_name": "solid_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1294-1328",
          "snippet": "XImage *solid_image(char *color) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\treturn NULL;\n#else\n\tXImage *image = NULL;\n\tunsigned long pixel = 0;\n\tint x, y;\n\n\tRAWFB_RET(NULL)\n\n\tif (!color) {\n\t\tcolor = last_color;\n\t}\n\n\tif (!color) {\n\t\treturn NULL;\n\t}\n\n\timage = XGetImage(dpy, rootwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t    ZPixmap);\n\n\tif (!image) {\n\t\treturn NULL;\n\t}\n\tpixel = get_pixel(color);\n\n\tfor (y=0; y<wdpy_y; y++) {\n\t\tfor (x=0; x<wdpy_x; x++) {\n\t\t\tXPutPixel(image, x, y, pixel);\n\t\t}\n\t}\n\treturn image;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic char *last_color = NULL;\n\nXImage *solid_image(char *color) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\treturn NULL;\n#else\n\tXImage *image = NULL;\n\tunsigned long pixel = 0;\n\tint x, y;\n\n\tRAWFB_RET(NULL)\n\n\tif (!color) {\n\t\tcolor = last_color;\n\t}\n\n\tif (!color) {\n\t\treturn NULL;\n\t}\n\n\timage = XGetImage(dpy, rootwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t    ZPixmap);\n\n\tif (!image) {\n\t\treturn NULL;\n\t}\n\tpixel = get_pixel(color);\n\n\tfor (y=0; y<wdpy_y; y++) {\n\t\tfor (x=0; x<wdpy_x; x++) {\n\t\t\tXPutPixel(image, x, y, pixel);\n\t\t}\n\t}\n\treturn image;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_XROOTPMAP_ID\"",
            "True"
          ],
          "line": 8182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_ncache_xrootpmap(void);\n\nvoid set_ncache_xrootpmap(void) {\n\tAtom pmap, type;\n\tint format;\n\tunsigned long length, after;\n\tXImage *image = NULL;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (!ncache) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tpmap = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\n\tif (use_solid_bg) {\n\t\timage = solid_image(NULL);\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: solid_image\\n\");\n\t\t}\n\t} else if (pmap != None) {\n\t\tPixmap pixmap = None;\n\t\tunsigned char *d_pmap;\n\n\t\tXGetWindowProperty(dpy, rootwin, pmap, 0L, 1L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &d_pmap);\n\n\t\tif (length != 0) {\n\t\t\tpixmap = *((Pixmap *) d_pmap);\n\t\t\tif (pixmap != None) {\n\t\t\t\timage = XGetImage(dpy, pixmap, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t\t}\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: loading background pixmap: 0x%lx\\n\", pixmap);\n\t\t}\n\t} else {\n\t\tif (!quiet) {\n\t\t\trfbLog(\"set_ncache_xrootpmap: trying root background\\n\");\n\t\t}\n\t}\n\tif (image == NULL) {\n\t\timage = solid_root((char *) 0x1);\n\t}\n\tif (image != NULL) {\n\t\tchar *src, *dst;\n\t\tint line;\n\t\tint pixelsize = bpp/8;\n\t\tint y1 = dpy_y * (ncache+1);\n\n\t\tsrc = image->data;\n\t\tdst = main_fb + y1 * main_bytes_per_line;\n\t\tline = 0;\n\t\twhile (line++ < dpy_y) {\n\t\t\tmemcpy(dst, src, dpy_x * pixelsize);\n\t\t\tsrc += image->bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t\tXDestroyImage(image);\n\t\tX_UNLOCK;\n\t\tscale_mark_xrootpmap();\n\t\tX_LOCK;\n\t} else {\n\t\tint yn = (ncache+1) * dpy_y;\n\t\tzero_fb(0, yn, dpy_x, yn + dpy_y);\n\t}\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n#endif\n}"
  },
  {
    "function_name": "scale_mark_xrootpmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8137-8165",
    "snippet": "void scale_mark_xrootpmap(void) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\tint yn = (ncache+1) * dpy_y;\n\tint yfac = (ncache+2);\n\tint mark = 1;\n\n\tif (!scaling || !rfb_fb || rfb_fb == main_fb) {\n\t\tmark_rect_as_modified(0, yn, dpy_x, yn + dpy_y, 0);\n\t\treturn;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, yfac * dpy_y,\n\t    scaled_x, yfac * scaled_y, 0, yn, dpy_x, yn + dpy_y, mark);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
      "static void scale_mark(int x1, int y1, int x2, int y2, int mark);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scale_rect",
          "args": [
            "scale_fac_x",
            "scale_fac_y",
            "scaling_blend",
            "scaling_interpolate",
            "fac * Bpp",
            "src_fb",
            "fac * main_bytes_per_line",
            "dst_fb",
            "dst_bpl",
            "dpy_x",
            "yfac * dpy_y",
            "scaled_x",
            "yfac * scaled_y",
            "0",
            "yn",
            "dpy_x",
            "yn + dpy_y",
            "mark"
          ],
          "line": 8162
        },
        "resolved": true,
        "details": {
          "function_name": "scale_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "777-1229",
          "snippet": "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);",
            "void nap_sleep(int ms, int split);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nvoid nap_sleep(int ms, int split);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "yn",
            "dpy_x",
            "yn + dpy_y",
            "0"
          ],
          "line": 8145
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\n\nvoid scale_mark_xrootpmap(void) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\tint yn = (ncache+1) * dpy_y;\n\tint yfac = (ncache+2);\n\tint mark = 1;\n\n\tif (!scaling || !rfb_fb || rfb_fb == main_fb) {\n\t\tmark_rect_as_modified(0, yn, dpy_x, yn + dpy_y, 0);\n\t\treturn;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, yfac * dpy_y,\n\t    scaled_x, yfac * scaled_y, 0, yn, dpy_x, yn + dpy_y, mark);\n}"
  },
  {
    "function_name": "idx_create_rgn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8118-8135",
    "snippet": "sraRegionPtr idx_create_rgn(sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn NULL;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\treturn rtmp;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "rtmp",
            "r0"
          ],
          "line": 8132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 8130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nsraRegionPtr idx_create_rgn(sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn NULL;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\treturn rtmp;\n}"
  },
  {
    "function_name": "idx_add_rgn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "8098-8116",
    "snippet": "void idx_add_rgn(sraRegionPtr r, sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\tsraRgnOr(r, rtmp);\n\tsraRgnDestroy(rtmp);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rtmp"
          ],
          "line": 8115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r",
            "rtmp"
          ],
          "line": 8114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "rtmp",
            "r0"
          ],
          "line": 8112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 8110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid idx_add_rgn(sraRegionPtr r, sraRegionPtr r0, int idx) {\n\tint x, y, w, h;\n\tsraRegionPtr rtmp;\n\t\n\tif (idx < 0) {\n\t\treturn;\n\t}\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\trtmp = sraRgnCreateRect(x, y, w, h);\n\tif (r0) {\n\t\tsraRgnAnd(rtmp, r0);\n\t}\n\tsraRgnOr(r, rtmp);\n\tsraRgnDestroy(rtmp);\n}"
  },
  {
    "function_name": "try_to_fix_su",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7912-8096",
    "snippet": "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "int lookup_win_index(Window);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 8091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r2",
            "dx",
            "dy",
            "save_delay0",
            "save_delay1",
            "nbatch"
          ],
          "line": 8089
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 8083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r2"
          ],
          "line": 8062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "tmp_reg[i]"
          ],
          "line": 8060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 8051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 8043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r2"
          ],
          "line": 8022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r2",
            "tmp_reg[i2]"
          ],
          "line": 8019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "tmp_reg[i]"
          ],
          "line": 8017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 8002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 8001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 8000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 7999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "win2"
          ],
          "line": 7982
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"0x%lx turn off: 0x%lx  i=%d\\n\"",
            "win",
            "win2",
            "i"
          ],
          "line": 7974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"0x%lx turn on:  0x%lx  i=%d\\n\"",
            "win",
            "win2",
            "i"
          ],
          "line": 7969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r1"
          ],
          "line": 7955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 7953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 7951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\"",
            "idx",
            "win",
            "above",
            "unmapped",
            "MState(cache_list[idx].map_state)"
          ],
          "line": 7932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MState",
          "args": [
            "cache_list[idx].map_state"
          ],
          "line": 7932
        },
        "resolved": true,
        "details": {
          "function_name": "MState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6191-6196",
          "snippet": "char *MState(int state) {\n\tif (state == IsViewable)\treturn \"IsViewable\";\n\tif (state == IsUnmapped)\treturn \"IsUnmapped\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *MState(int state) {\n\tif (state == IsViewable)\treturn \"IsViewable\";\n\tif (state == IsUnmapped)\treturn \"IsUnmapped\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"moved\""
          ],
          "line": 7926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"unmapped\""
          ],
          "line": 7924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}"
  },
  {
    "function_name": "try_to_fix_resize_su",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7781-7910",
    "snippet": "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\n\tint idx = lookup_win_index(orig_frame);\n\tsraRegionPtr r0, r1, r2, r3;\n\tint sx1, sy1, sw1, sh1, dx, dy;\n\tint bx1, by1, bw1, bh1;\n\tint nr = 0, *nbat = NULL;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x+orig_w, orig_y+orig_h);\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\tsraRgnAnd(r2, r0);\n\n\tif (try_batch) {\n\t\tnbat = &nr;\n\t}\n\t\n\tif (orig_w >= w && orig_h >= h) {\n\nif (0) fprintf(stderr, \"Shrinking resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnSubtract(r3, r2);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tdx = orig_x - sx1;\n\t\tdy = orig_y - sy1;\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnAnd(r3, r2);\n\n\t\tdx = sx1 - orig_x;\n\t\tdy = sy1 - orig_y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tdx = orig_x - x;\n\t\tdy = orig_y - y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\n\t\tcache_list[idx].x = x;\n\t\tcache_list[idx].y = y;\n\t\tcache_list[idx].width = w;\n\t\tcache_list[idx].height = h;\n\n\t\tcache_list[idx].bs_w = w;\n\t\tcache_list[idx].bs_h = h;\n\t\tcache_list[idx].su_w = w;\n\t\tcache_list[idx].su_h = h;\n\n\t\tcache_list[idx].bs_time = 0.0;\n\t\t/* XXX Y */\n\t\tif (0) cache_list[idx].su_time = dnow();\n\t} else {\nif (0) fprintf(stderr, \"Growing resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tbx1 = cache_list[idx].bs_x;\n\t\tby1 = cache_list[idx].bs_y;\n\t\tbw1 = cache_list[idx].bs_w;\n\t\tbh1 = cache_list[idx].bs_h;\n\t\t\n\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnAnd(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tdx = dx - (sx1 - orig_x);\n\t\t\tdy = dy - (sy1 - orig_y);\n\t\t\t\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnSubtract(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tif (nr) {\n\t\t\t\tbatch_push(nr, -1.0);\n\t\t\t}\n\n\t\t\tcache_list[idx].bs_time = 0.0;\n\t\t\t/* XXX Y */\n\t\t\tif (0) cache_list[idx].su_time = dnow();\n\t\t}\n\t}\n\t\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\tsraRgnDestroy(r2);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 7907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 7906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7901
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "nr",
            "-1.0"
          ],
          "line": 7896
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r3"
          ],
          "line": 7893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r3",
            "dx",
            "dy",
            "0.075",
            "0.05",
            "nbat"
          ],
          "line": 7892
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r3",
            "dx",
            "dy"
          ],
          "line": 7890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r3",
            "r1"
          ],
          "line": 7885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r2"
          ],
          "line": 7884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r3"
          ],
          "line": 7882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r3",
            "dx",
            "dy"
          ],
          "line": 7876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r3",
            "r1"
          ],
          "line": 7871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r2"
          ],
          "line": 7870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "idx",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 7869
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Growing resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\"",
            "idx",
            "orig_w",
            "orig_h",
            "orig_x",
            "orig_y",
            "w",
            "h",
            "x",
            "y"
          ],
          "line": 7857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r3"
          ],
          "line": 7837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r3",
            "dx",
            "dy"
          ],
          "line": 7834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r3",
            "dx",
            "dy"
          ],
          "line": 7830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r3",
            "r2"
          ],
          "line": 7826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 7825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r3"
          ],
          "line": 7823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r3",
            "r2"
          ],
          "line": 7812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 7811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Shrinking resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\"",
            "idx",
            "orig_w",
            "orig_h",
            "orig_x",
            "orig_y",
            "w",
            "h",
            "x",
            "y"
          ],
          "line": 7810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 7802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 7801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 7799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "orig_x",
            "orig_y",
            "orig_x+orig_w",
            "orig_y+orig_h"
          ],
          "line": 7798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "orig_frame"
          ],
          "line": 7784
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\n\tint idx = lookup_win_index(orig_frame);\n\tsraRegionPtr r0, r1, r2, r3;\n\tint sx1, sy1, sw1, sh1, dx, dy;\n\tint bx1, by1, bw1, bh1;\n\tint nr = 0, *nbat = NULL;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x+orig_w, orig_y+orig_h);\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\tsraRgnAnd(r2, r0);\n\n\tif (try_batch) {\n\t\tnbat = &nr;\n\t}\n\t\n\tif (orig_w >= w && orig_h >= h) {\n\nif (0) fprintf(stderr, \"Shrinking resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnSubtract(r3, r2);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tdx = orig_x - sx1;\n\t\tdy = orig_y - sy1;\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnAnd(r3, r2);\n\n\t\tdx = sx1 - orig_x;\n\t\tdy = sy1 - orig_y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tdx = orig_x - x;\n\t\tdy = orig_y - y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\n\t\tcache_list[idx].x = x;\n\t\tcache_list[idx].y = y;\n\t\tcache_list[idx].width = w;\n\t\tcache_list[idx].height = h;\n\n\t\tcache_list[idx].bs_w = w;\n\t\tcache_list[idx].bs_h = h;\n\t\tcache_list[idx].su_w = w;\n\t\tcache_list[idx].su_h = h;\n\n\t\tcache_list[idx].bs_time = 0.0;\n\t\t/* XXX Y */\n\t\tif (0) cache_list[idx].su_time = dnow();\n\t} else {\nif (0) fprintf(stderr, \"Growing resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tbx1 = cache_list[idx].bs_x;\n\t\tby1 = cache_list[idx].bs_y;\n\t\tbw1 = cache_list[idx].bs_w;\n\t\tbh1 = cache_list[idx].bs_h;\n\t\t\n\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnAnd(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tdx = dx - (sx1 - orig_x);\n\t\t\tdy = dy - (sy1 - orig_y);\n\t\t\t\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnSubtract(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tif (nr) {\n\t\t\t\tbatch_push(nr, -1.0);\n\t\t\t}\n\n\t\t\tcache_list[idx].bs_time = 0.0;\n\t\t\t/* XXX Y */\n\t\t\tif (0) cache_list[idx].su_time = dnow();\n\t\t}\n\t}\n\t\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\tsraRgnDestroy(r2);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "xcheckmaskevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7736-7754",
    "snippet": "Bool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XCheckMaskEvent",
          "args": [
            "d",
            "mask",
            "ev"
          ],
          "line": 7752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "False"
          ],
          "line": 7746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "ev"
          ],
          "line": 7739
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nBool xcheckmaskevent(Display *d, long mask, XEvent *ev) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tif (macosx_checkevent(ev)) {\n\t\t\treturn True;\n\t\t} else {\n\t\t\treturn False;\n\t\t}\n\t}\n#endif\n\tRAWFB_RET(False);\n\n#if NO_X11\n\tif (!d || !mask) {}\n\treturn False;\n#else\n\treturn XCheckMaskEvent(d, mask, ev);\n#endif\n}"
  },
  {
    "function_name": "xselectinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7693-7734",
    "snippet": "void xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int lookup_win_index(Window);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\"",
            "w",
            "sync",
            "trapped_xerror",
            "trapped_xioerror"
          ],
          "line": 7733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XSELECTINPUT: trapped XIO Error.\""
          ],
          "line": 7731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XSELECTINPUT: trapped X Error.\""
          ],
          "line": 7728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetIOErrorHandler",
          "args": [
            "old_handler2"
          ],
          "line": 7724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler1"
          ],
          "line": 7723
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 7720
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 7718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput",
          "args": [
            "dpy",
            "w",
            "evmask"
          ],
          "line": 7711
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetIOErrorHandler",
          "args": [
            "trap_xioerror"
          ],
          "line": 7707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\n\nvoid xselectinput(Window w, unsigned long evmask, int sync) {\n#if NO_X11\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\tif (!evmask) {}\n#else\n\tXErrorHandler   old_handler1;\n\tXIOErrorHandler old_handler2;\n\n\tif (macosx_console || !dpy) {\n\t\treturn;\n\t}\n\n\told_handler1 = XSetErrorHandler(trap_xerror);\n\told_handler2 = XSetIOErrorHandler(trap_xioerror);\n\ttrapped_xerror = 0;\n\ttrapped_xioerror = 0;\n\n\tXSelectInput(dpy, w, evmask);\n\n\t/*\n\t * We seem to need to synchronize right away since the window\n\t * might go away quickly.\n\t */\n\tif (sync) {\n\t\tXSync(dpy, False);\n\t} else {\n\t\tXFlush_wr(dpy);\n\t}\n\n\tXSetErrorHandler(old_handler1);\n\tXSetIOErrorHandler(old_handler2);\n#endif\n\n\tif (trapped_xerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped X Error.\");\n\t}\n\tif (trapped_xioerror) {\n\t\tif (ncdb) fprintf(stderr, \"XSELECTINPUT: trapped XIO Error.\");\n\t}\nif (sync && ncdb) fprintf(stderr, \"XSELECTINPUT: 0x%lx  sync=%d err=%d/%d\\n\", w, sync, trapped_xerror, trapped_xioerror);\n}"
  },
  {
    "function_name": "block_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7569-7664",
    "snippet": "void block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 7663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\"",
            "fr_REGIONt",
            "fr_GRIDt",
            "fr_EXPIREt",
            "fr_FORCEt",
            "fr_BIG1t",
            "fr_BIG2t",
            "fr_FAILt",
            "s2"
          ],
          "line": 7653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\"",
            "fr_REGION",
            "fr_GRID",
            "fr_EXPIRE",
            "fr_FORCE",
            "fr_BIG1",
            "fr_BIG2",
            "fr_FAIL",
            "s1"
          ],
          "line": 7651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 7650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"block: trak/val/inval %d/%d/%d of %d\\n\"",
            "ttot",
            "vtot",
            "itot",
            "vtot+itot"
          ],
          "line": 7646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 7645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\"",
            "n",
            "frac",
            "(int) area",
            "tcnt",
            "vcnt",
            "icnt",
            "vcnt+icnt"
          ],
          "line": 7642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\"",
            "n",
            "k",
            "win",
            "w",
            "h",
            "x",
            "y",
            "attr.width",
            "attr.height",
            "attr.x",
            "attr.y",
            "cache_list[k].width",
            "cache_list[k].height",
            "cache_list[k].x",
            "cache_list[k].y",
            "attr.map_state == IsViewable",
            "t1",
            "t2",
            "cache_list[k].create_cnt",
            "cache_list[k].map_cnt"
          ],
          "line": 7635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7634
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE",
          "args": [
            "k"
          ],
          "line": 7628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\"",
            "win",
            "w",
            "h",
            "x",
            "y"
          ],
          "line": 7627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\a\""
          ],
          "line": 7626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "u",
            "\"runge\""
          ],
          "line": 7626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"USER\""
          ],
          "line": 7625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 7609
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid block_stats(void) {\n\tint n, k, s1, s2;\n\tstatic int t = -1;\n\tint vcnt, icnt, tcnt, vtot = 0, itot = 0, ttot = 0;\n\tt++;\n\tfor (n = 1; n < ncache+1; n += 2) {\n\t\tdouble area = 0.0, frac;\n\t\tvcnt = 0;\n\t\ticnt = 0;\n\t\ttcnt = 0;\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint x = cache_list[k].bs_x;\n\t\t\tint y = cache_list[k].bs_y;\n\t\t\tint w = cache_list[k].bs_w;\n\t\t\tint h = cache_list[k].bs_h;\n\t\t\tint rc = 0;\n\t\t\tWindow win = cache_list[k].win;\n\n\t\t\tif (win == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tif (rc) {\n\t\t\t\t\tvtot++;\n\t\t\t\t} else {\n\t\t\t\t\titot++;\n\t\t\t\t}\n\t\t\t\tif (x >= 0) {\n\t\t\t\t\tttot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < n*dpy_y || y > (n+1)*dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (n != 1) {\n\t\t\t\tX_LOCK;\n\t\t\t\trc = valid_window(win, &attr, 1);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tvcnt++;\n\t\t\t} else {\n\t\t\t\ticnt++;\n\t\t\t}\n\t\t\tif (x >= 0) {\n\t\t\t\ttcnt++;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarea += cache_list[k].width * cache_list[k].height;\n\t\t\tif (! rc && ! macosx_console) {\n\t\t\t\tchar *u = getenv(\"USER\");\n\t\t\t\tif (u && !strcmp(u, \"runge\"))\tfprintf(stderr, \"\\a\");\n\t\t\t\tif (ncdb) fprintf(stderr, \"\\n   *** UNRECLAIMED WINDOW: 0x%lx  %dx%d+%d+%d\\n\\n\", win, w, h, x, y);\n\t\t\t\tDELETE(k);\n\t\t\t}\n\t\t\tif (t < 3 || (t % 4) == 0 || hack_val || macosx_console) {\n\t\t\t\tdouble t1 = cache_list[k].su_time;\n\t\t\t\tdouble t2 = cache_list[k].bs_time;\n\t\t\t\tif (t1 > 0.0) {t1 = dnow() - t1;} else {t1 = -1.0;}\n\t\t\t\tif (t2 > 0.0) {t2 = dnow() - t2;} else {t2 = -1.0;}\n\t\t\t\tif (ncdb) fprintf(stderr, \"     [%02d] %04d 0x%08lx bs: %04dx%04d+%04d+%05d vw: %04dx%04d+%04d+%04d cl: %04dx%04d+%04d+%04d map=%d su=%9.3f bs=%9.3f cnt=%d/%d\\n\",\n\t\t\t\t    n, k, win, w, h, x, y, attr.width, attr.height, attr.x, attr.y,\n\t\t\t\t    cache_list[k].width, cache_list[k].height, cache_list[k].x, cache_list[k].y,\n\t\t\t\t    attr.map_state == IsViewable, t1, t2, cache_list[k].create_cnt, cache_list[k].map_cnt); \n\t\t\t}\n\t\t}\n\t\tfrac = area /(dpy_x * dpy_y);\n\t\tif (ncdb) fprintf(stderr, \"block[%02d]  %.3f  %8d  trak/val/inval: %d/%d/%d of %d\\n\", n, frac, (int) area, tcnt, vcnt, icnt, vcnt+icnt);\n\t}\n\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"block: trak/val/inval %d/%d/%d of %d\\n\", ttot, vtot, itot, vtot+itot);\n\n\ts1 = fr_REGION  + fr_GRID  + fr_EXPIRE  + fr_FORCE  + fr_BIG1  + fr_BIG2  + fr_FAIL;\n\ts2 = fr_REGIONt + fr_GRIDt + fr_EXPIREt + fr_FORCEt + fr_BIG1t + fr_BIG2t + fr_FAILt;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n\tif (ncdb) fprintf(stderr, \"find_rect:  REGION/GRID/EXPIRE/FORCE - BIG1/BIG2/FAIL  %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGION,  fr_GRID,  fr_EXPIRE,  fr_FORCE,  fr_BIG1,  fr_BIG2,  fr_FAIL, s1);\n\tif (ncdb) fprintf(stderr, \"                                       totals:         %d/%d/%d/%d - %d/%d/%d  of %d\\n\",\n\t    fr_REGIONt, fr_GRIDt, fr_EXPIREt, fr_FORCEt, fr_BIG1t, fr_BIG2t, fr_FAILt, s2);\n\n\tfr_BIG1 = 0;\n\tfr_BIG2 = 0;\n\tfr_REGION = 0;\n\tfr_GRID = 0;\n\tfr_EXPIRE = 0;\n\tfr_FORCE = 0;\n\tfr_FAIL = 0;\n\tif (ncdb) fprintf(stderr, \"\\n\");\n}"
  },
  {
    "function_name": "check_zero_rects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7550-7567",
    "snippet": "void check_zero_rects(void) {\n\tsraRect rt;\n\tsraRectangleIterator *iter;\n\tif (! zero_rects) {\n\t\tzero_rects = sraRgnCreate();\n\t}\n\tif (sraRgnEmpty(zero_rects)) {\n\t\treturn;\n\t}\n\t\t\n\titer = sraRgnGetIterator(zero_rects);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\tzero_fb(rt.x1, rt.y1, rt.x2, rt.y2);\n\t\tmark_rect_as_modified(rt.x1, rt.y1, rt.x2, rt.y2, 0);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnMakeEmpty(zero_rects);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnMakeEmpty",
          "args": [
            "zero_rects"
          ],
          "line": 7566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 7565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "rt.x1",
            "rt.y1",
            "rt.x2",
            "rt.y2",
            "0"
          ],
          "line": 7563
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "rt.x1",
            "rt.y1",
            "rt.x2",
            "rt.y2"
          ],
          "line": 7562
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rt"
          ],
          "line": 7561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "zero_rects"
          ],
          "line": 7560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "zero_rects"
          ],
          "line": 7556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 7554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_zero_rects(void) {\n\tsraRect rt;\n\tsraRectangleIterator *iter;\n\tif (! zero_rects) {\n\t\tzero_rects = sraRgnCreate();\n\t}\n\tif (sraRgnEmpty(zero_rects)) {\n\t\treturn;\n\t}\n\t\t\n\titer = sraRgnGetIterator(zero_rects);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\tzero_fb(rt.x1, rt.y1, rt.x2, rt.y2);\n\t\tmark_rect_as_modified(rt.x1, rt.y1, rt.x2, rt.y2, 0);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnMakeEmpty(zero_rects);\n}"
  },
  {
    "function_name": "su_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7441-7548",
    "snippet": "int su_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2 = 0, y2 = 0, w2 = 0, h2 = 0;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"save-unders  restore:    0x%lx  %3d \\n\", win, idx);\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"SU_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tx2 = x1;\n\t\ty2 = y1;\n\t\tw2 = w1;\n\t\th2 = h1;\n\t} else {\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\nif (ncdb) fprintf(stderr, \"SU_rest: su_x/bs_x/su_time: %d %d %.3f\\n\", x, cache_list[idx].bs_x, cache_list[idx].su_time);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_restore = dnow();\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
      "int lookup_win_index(Window);",
      "static void draw_box(int x, int y, int w, int h, int restore);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7545
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\"",
            "dtB",
            "dtB-dtA",
            "idx",
            "w1",
            "h1",
            "x1",
            "y1",
            "w2",
            "h2",
            "x2",
            "y2",
            "cache_list[idx].su_time - x11vnc_start",
            "dnowx()"
          ],
          "line": 7540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r",
            "dx",
            "dy",
            "restore_delay0",
            "restore_delay1",
            "nbatch"
          ],
          "line": 7537
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_rest: %.4f      %d dx=%d dy=%d\\n\"",
            "dtA",
            "idx",
            "dx",
            "dy"
          ],
          "line": 7535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "rmask"
          ],
          "line": 7531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clip_region",
          "args": [
            "r",
            "win"
          ],
          "line": 7528
        },
        "resolved": true,
        "details": {
          "function_name": "clip_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7094-7128",
          "snippet": "void clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "r0"
          ],
          "line": 7525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r",
            "dx",
            "dy"
          ],
          "line": 7524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w2",
            "y+h2"
          ],
          "line": 7519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_rest: su_x/bs_x/su_time: %d %d %.3f\\n\"",
            "x",
            "cache_list[idx].bs_x",
            "cache_list[idx].su_time"
          ],
          "line": 7488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_restore: not a valid X window: 0x%lx\\n\"",
            "win"
          ],
          "line": 7467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_wr",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 7466
        },
        "resolved": true,
        "details": {
          "function_name": "valid_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7010-7029",
          "snippet": "int valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"save-unders  restore:    0x%lx  %3d \\n\"",
            "win",
            "idx"
          ],
          "line": 7449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint su_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2 = 0, y2 = 0, w2 = 0, h2 = 0;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"save-unders  restore:    0x%lx  %3d \\n\", win, idx);\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"SU_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tx2 = x1;\n\t\ty2 = y1;\n\t\tw2 = w1;\n\t\th2 = h1;\n\t} else {\n\t\tx2 = attr->x;\n\t\ty2 = attr->y;\n\t\tw2 = attr->width;\n\t\th2 = attr->height;\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\nif (ncdb) fprintf(stderr, \"SU_rest: su_x/bs_x/su_time: %d %d %.3f\\n\", x, cache_list[idx].bs_x, cache_list[idx].su_time);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_restore = dnow();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "bs_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7338-7439",
    "snippet": "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
      "int lookup_win_index(Window);",
      "static void draw_box(int x, int y, int w, int h, int restore);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7436
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\"",
            "dtB",
            "dtB-dtA",
            "idx",
            "w1",
            "h1",
            "x1",
            "y1",
            "w2",
            "h2",
            "x2",
            "y2",
            "cache_list[idx].bs_time - x11vnc_start",
            "dnowx()"
          ],
          "line": 7431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r",
            "dx",
            "dy",
            "restore_delay0",
            "restore_delay1",
            "nbatch"
          ],
          "line": 7428
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_rest: %.4f      %d dx=%d dy=%d\\n\"",
            "dtA",
            "idx",
            "dx",
            "dy"
          ],
          "line": 7426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "rmask"
          ],
          "line": 7422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clip_region",
          "args": [
            "r",
            "win"
          ],
          "line": 7419
        },
        "resolved": true,
        "details": {
          "function_name": "clip_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7094-7128",
          "snippet": "void clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "r0"
          ],
          "line": 7416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r",
            "dx",
            "dy"
          ],
          "line": 7415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w2",
            "y+h2"
          ],
          "line": 7410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_restore: not a valid X window: 0x%lx\\n\"",
            "win"
          ],
          "line": 7360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_wr",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 7359
        },
        "resolved": true,
        "details": {
          "function_name": "valid_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7010-7029",
          "snippet": "int valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"backingstore restore:    0x%lx  %3d \\n\"",
            "win",
            "idx"
          ],
          "line": 7346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}"
  },
  {
    "function_name": "su_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7236-7336",
    "snippet": "int su_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\nif (ncdb && verb) fprintf(stderr, \"save-unders save:        0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"su_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].su_w || h2 > cache_list[idx].su_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"SU_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"SU_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_save = cache_list[idx].su_time = dnow();\n\t\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
      "int lookup_win_index(Window);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7333
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\"",
            "dtB",
            "dtB-dtA",
            "idx",
            "w1",
            "h1",
            "x1",
            "y1",
            "w2",
            "h2",
            "x2",
            "y2",
            "cache_list[idx].su_time - x11vnc_start",
            "dnowx()"
          ],
          "line": 7328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r",
            "dx",
            "dy",
            "save_delay0",
            "save_delay1",
            "nbatch"
          ],
          "line": 7325
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_save: %.4f      %d dx=%d dy=%d\\n\"",
            "dtA",
            "idx",
            "dx",
            "dy"
          ],
          "line": 7323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r",
            "dx",
            "dy"
          ],
          "line": 7320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_save: Region Empty: %d\\n\"",
            "idx"
          ],
          "line": 7310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r"
          ],
          "line": 7309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clip_region",
          "args": [
            "r",
            "win"
          ],
          "line": 7306
        },
        "resolved": true,
        "details": {
          "function_name": "clip_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7094-7128",
          "snippet": "void clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "r0"
          ],
          "line": 7303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 7302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SU_save: FAIL FOR: %d\\n\"",
            "idx"
          ],
          "line": 7285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "idx",
            "x2",
            "y2",
            "w2",
            "h2"
          ],
          "line": 7277
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rect",
          "args": [
            "idx"
          ],
          "line": 7276
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"su_save:    not a valid X window: 0x%lx\\n\"",
            "win"
          ],
          "line": 7258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_wr",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 7257
        },
        "resolved": true,
        "details": {
          "function_name": "valid_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7010-7029",
          "snippet": "int valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"save-unders save:        0x%lx  %3d \\n\"",
            "win",
            "idx"
          ],
          "line": 7244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint su_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\nif (ncdb && verb) fprintf(stderr, \"save-unders save:        0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"su_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].su_w || h2 > cache_list[idx].su_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\tx = cache_list[idx].su_x;\n\ty = cache_list[idx].su_y;\n\tw = cache_list[idx].su_w;\n\th = cache_list[idx].su_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"SU_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"SU_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"SU_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].su_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_su_save = cache_list[idx].su_time = dnow();\n\t\n\treturn 1;\n}"
  },
  {
    "function_name": "bs_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7130-7234",
    "snippet": "int bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
      "int lookup_win_index(Window);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 7231
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\"",
            "dtB",
            "dtB-dtA",
            "idx",
            "w1",
            "h1",
            "x1",
            "y1",
            "w2",
            "h2",
            "x2",
            "y2",
            "cache_list[idx].bs_time - x11vnc_start",
            "dnowx()"
          ],
          "line": 7226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_cr",
          "args": [
            "r",
            "dx",
            "dy",
            "save_delay0",
            "save_delay1",
            "nbatch"
          ],
          "line": 7223
        },
        "resolved": true,
        "details": {
          "function_name": "cache_cr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6984-7002",
          "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_save: %.4f      %d dx=%d dy=%d\\n\"",
            "dtA",
            "idx",
            "dx",
            "dy"
          ],
          "line": 7221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r",
            "dx",
            "dy"
          ],
          "line": 7218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 7211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_save: Region Empty: %d\\n\"",
            "idx"
          ],
          "line": 7209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clip_region",
          "args": [
            "r",
            "win"
          ],
          "line": 7205
        },
        "resolved": true,
        "details": {
          "function_name": "clip_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7094-7128",
          "snippet": "void clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "r0"
          ],
          "line": 7202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x2",
            "y2",
            "x2+w2",
            "y2+h2"
          ],
          "line": 7201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BS_save: FAIL FOR: %d\\n\"",
            "idx"
          ],
          "line": 7184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "idx",
            "x2",
            "y2",
            "w2",
            "h2"
          ],
          "line": 7175
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rect",
          "args": [
            "idx"
          ],
          "line": 7174
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bs_save:    not a valid X window: 0x%lx\\n\"",
            "win"
          ],
          "line": 7152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_wr",
          "args": [
            "idx",
            "win",
            "attr"
          ],
          "line": 7151
        },
        "resolved": true,
        "details": {
          "function_name": "valid_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7010-7029",
          "snippet": "int valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"backingstore save:       0x%lx  %3d clip=%d\\n\"",
            "win",
            "idx",
            "clip"
          ],
          "line": 7143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_save(int idx, int *nbatch, XWindowAttributes *attr, int clip, int only_if_tracking, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy, rc = 1;\n\tsraRegionPtr r, r0;\n\t\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore save:       0x%lx  %3d clip=%d\\n\", win, idx, clip);\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"bs_save:    not a valid X window: 0x%lx\\n\", win);\n\t\tX_UNLOCK;\n\t\t*valid = 0;\n\t\tcache_list[idx].valid = 0;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tif (only_if_tracking && cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tif (cache_list[idx].bs_x < 0) {\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t} else if (w2 > cache_list[idx].bs_w || h2 > cache_list[idx].bs_h) {\n\t\tfree_rect(idx);\n\t\trc = find_rect(idx, x2, y2, w2, h2);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || ! rc) {\nif (ncdb) fprintf(stderr, \"BS_save: FAIL FOR: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tx2 -= ncache_pad;\t\n\t\ty2 -= ncache_pad;\t\n\t\tw2 += 2 * ncache_pad;\t\n\t\th2 += 2 * ncache_pad;\t\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\n\tif (sraRgnEmpty(r)) {\nif (ncdb && verb) fprintf(stderr, \"BS_save: Region Empty: %d\\n\", idx);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r);\n\t\treturn 0;\n\t}\n\n\tdx = x - x2; \n\tdy = y - y2; \n\n\tsraRgnOffset(r, dx, dy);\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, save_delay0, save_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_save: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_save = cache_list[idx].bs_time = dnow();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "clip_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7094-7128",
    "snippet": "void clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 7126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clip[0x%lx]: 0x%lx, %d/%d\\n\"",
            "win",
            "cache_list[idx2].win",
            "ic",
            "idx2"
          ],
          "line": 7124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r",
            "r1"
          ],
          "line": 7123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r"
          ],
          "line": 7122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xc",
            "yc",
            "xc+wc",
            "yc+hc"
          ],
          "line": 7121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_old_stack_index",
          "args": [
            "ic"
          ],
          "line": 7107
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_old_stack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6074-6093",
          "snippet": "int lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"----[0x%lx]: 0x%lx, %d  %d\\n\"",
            "win",
            "old_stack[ic]",
            "ic",
            "old_stack_mapped[ic]"
          ],
          "line": 7100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\n\nvoid clip_region(sraRegionPtr r, Window win) {\n\tint ic, idx2;\t\n\tsraRegionPtr r1;\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc;\n\nif (0) fprintf(stderr, \"----[0x%lx]: 0x%lx, %d  %d\\n\", win, old_stack[ic], ic, old_stack_mapped[ic]);\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\t\tr1 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tif (sraRgnAnd(r1, r)) {\n\t\t\tsraRgnSubtract(r, r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t}\n}"
  },
  {
    "function_name": "clipped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7031-7092",
    "snippet": "int clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clip[0x%lx]: %s\\n\"",
            "win",
            "clip ? \"clipped\" : \"no-clipped\""
          ],
          "line": 7090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 7089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 7088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 7083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clip[0x%lx]: 0x%lx, %d/%d\\n\"",
            "win",
            "cache_list[idx2].win",
            "ic",
            "idx2"
          ],
          "line": 7080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 7079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 7078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xc",
            "yc",
            "xc+wc",
            "yc+hc"
          ],
          "line": 7077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_old_stack_index",
          "args": [
            "ic"
          ],
          "line": 7062
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_old_stack_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6074-6093",
          "snippet": "int lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 7051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x1+w1",
            "y1+h1"
          ],
          "line": 7050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 7041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}"
  },
  {
    "function_name": "valid_wr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "7010-7029",
    "snippet": "int valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "attr",
            "1"
          ],
          "line": 7028
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint valid_wr(int idx, Window win, XWindowAttributes *attr) {\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t/* this is all to avoid animation changing WxH+X+Y... */\n\t\tif (idx >= 0) {\n\t\t\tint rc = valid_window(win, attr, 1);\n\t\t\tattr->x = cache_list[idx].x;\n\t\t\tattr->y = cache_list[idx].y;\n\t\t\tattr->width = cache_list[idx].width;\n\t\t\tattr->height = cache_list[idx].height;\n\t\t\treturn rc;\n\t\t} else {\n\t\t\treturn valid_window(win, attr, 1);\n\t\t}\n\t}\n#else\n\tif (!idx) {}\n#endif\n\treturn valid_window(win, attr, 1);\n}"
  },
  {
    "function_name": "cache_cr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6984-7002",
    "snippet": "static void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r"
          ],
          "line": 6999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "d1/2",
            "FB_COPY"
          ],
          "line": 6994
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "r",
            "dx",
            "dy",
            "0"
          ],
          "line": 6992
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r"
          ],
          "line": 6985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic void cache_cr(sraRegionPtr r, int dx, int dy, double d0, double d1, int *nbatch) {\n\tif (sraRgnEmpty(r)) {\n\t\treturn;\n\t}\n\tif (nbatch == NULL) {\n\t\tif (!fb_push_wait(d0, FB_COPY)) {\n\t\t\tfb_push_wait(d0/2, FB_COPY);\n\t\t}\n\t\tdo_copyregion(r, dx, dy, 0);\n\t\tif (!fb_push_wait(d1, FB_COPY)) {\n\t\t\tfb_push_wait(d1/2, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[*nbatch] = dx;\n\t\tbatch_dys[*nbatch] = dy;\n\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(r);\n\t\t(*nbatch)++;\n\t}\n}"
  },
  {
    "function_name": "find_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6724-6982",
    "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "zero_rects",
            "r1"
          ],
          "line": 6977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x_hit",
            "y_hit+dpy_y",
            "x_hit+w",
            "y_hit+dpy_y+h"
          ],
          "line": 6976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "zero_rects",
            "r1"
          ],
          "line": 6974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x_hit",
            "y_hit",
            "x_hit+w",
            "y_hit+h"
          ],
          "line": 6973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expire_rects",
          "args": [
            "idx",
            "w",
            "h",
            "&x_hit",
            "&y_hit",
            "big1",
            "big2",
            "cram"
          ],
          "line": 6949
        },
        "resolved": true,
        "details": {
          "function_name": "expire_rects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6715-6722",
          "snippet": "void expire_rects(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tint method = 2;\n\tif (method == 1) {\n\t\texpire_rects1(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t} else if (method == 2) {\n\t\texpire_rects2(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint clipped(int idx);\n\nvoid expire_rects(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tint method = 2;\n\tif (method == 1) {\n\t\texpire_rects1(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t} else if (method == 2) {\n\t\texpire_rects2(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "rect_reg[n]",
            "r2"
          ],
          "line": 6936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "rx",
            "ry+ny",
            "rx + w",
            "ry+ny + h"
          ],
          "line": 6924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 6919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "rx",
            "ry+ny",
            "rx + w",
            "ry+ny + h"
          ],
          "line": 6918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "rect_reg[n]"
          ],
          "line": 6907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "n * dpy_y",
            "dpy_x",
            "(n+1) * dpy_y"
          ],
          "line": 6906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 6882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x_hit",
            "y_hit",
            "x_hit + w",
            "y_hit + h"
          ],
          "line": 6878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rt"
          ],
          "line": 6866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "r1"
          ],
          "line": 6865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "x_hit",
            "y_hit"
          ],
          "line": 6837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"NOBIGS\""
          ],
          "line": 6826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 6787
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"free_rect: bad index: %d\\n\"",
            "idx"
          ],
          "line": 6786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "su_x",
            "su_y",
            "su_x+su_w",
            "su_y+su_h"
          ],
          "line": 6778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bs_n",
          "args": [
            "su_y"
          ],
          "line": 6775
        },
        "resolved": true,
        "details": {
          "function_name": "get_bs_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5912-5920",
          "snippet": "int get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "n2 * dpy_y",
            "dpy_x",
            "(n2+1) * dpy_y"
          ],
          "line": 6765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect_reg[n2]"
          ],
          "line": 6764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "bs_x",
            "bs_y",
            "bs_x+bs_w",
            "bs_y+bs_h"
          ],
          "line": 6758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "n * dpy_y",
            "dpy_x",
            "(n+1) * dpy_y"
          ],
          "line": 6746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect_reg[n]"
          ],
          "line": 6745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "n * dpy_y",
            "dpy_x",
            "(n+1) * dpy_y"
          ],
          "line": 6737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 6732
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "expire_rects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6715-6722",
    "snippet": "void expire_rects(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tint method = 2;\n\tif (method == 1) {\n\t\texpire_rects1(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t} else if (method == 2) {\n\t\texpire_rects2(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_rects2",
          "args": [
            "idx",
            "w",
            "h",
            "x_hit",
            "y_hit",
            "big1",
            "big2",
            "cram"
          ],
          "line": 6720
        },
        "resolved": true,
        "details": {
          "function_name": "expire_rects2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6416-6713",
          "snippet": "void expire_rects2(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n, i, j, k;\n\tint nwgt_max = 128, nwgt = 0;\n\tint type[128];\n\tint val[4][128];\n\tdouble wgt[128], norm;\n\tint Expire = 1, Force = 2;\n\tint do_expire = 1;\n\tint do_force = 1;\n\tdouble now = dnow(), r;\n\tdouble newest = -1.0, oldest = -1.0, basetime;\n\tdouble map_factor = 0.25;\n\n\tfor (i=0; i<cache_list_num; i++) {\n\t\tdouble d, d1, d2;\n\n\t\td1 = cache_list[i].bs_time;\n\t\td2 = cache_list[i].su_time;\n\n\t\td = d1;\n\t\tif (d2 > d) d = d2;\n\n\t\tif (d == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oldest == -1.0 || d < oldest) {\n\t\t\toldest = d;\n\t\t}\n\t\tif (newest == -1.0 || d > newest) {\n\t\t\tnewest = d;\n\t\t}\n\t}\n\tif (newest == -1.0) {\n\t\tnewest = now;\n\t}\n\tif (oldest == -1.0) {\n\t\toldest = newest - 1800;\n\t}\n\n\tbasetime = newest + 0.1 * (newest - oldest);\n\n\tif (do_expire) {\n\t\tint old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].bs_time;\n\t\t\td2 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\n\t\t\t\twgt[nwgt] =  (basetime - dold[k]) / (k_w * k_h);\n\t\t\t\tif (cache_list[ik].map_state == IsViewable) {\n\t\t\t\t\twgt[nwgt] *= map_factor;\n\t\t\t\t}\n\t\t\t\ttype[nwgt] = Expire;\n\t\t\t\tval[0][nwgt] = ik;\nif (ncdb) fprintf(stderr, \"Expire[%02d]   %9.5f  age=%9.4f  area=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], basetime - dold[k], k_w * k_h, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many rect */\n\tif (do_force) {\n\t\tint corner_x, corner_y;\n\t\tint x0, y0;\n\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t    if (big1 && ncache > 2 && n == 1) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (big2 && ncache > 4 && n <= 3) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    for (corner_x = 0; corner_x < 2; corner_x++) {\n\t\t\tif (cram && big1 && corner_x == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (corner_y = 0; corner_y < 2; corner_y++) {\n\t\t\t\tdouble age = 0.0, area = 0.0, amap = 0.0, a;\n\t\t\t\tdouble d, d1, d2, score;\n\t\t\t\tint nc = 0;\n\n\t\t\t\tx0 = 0;\n\t\t\t\ty0 = 0;\n\t\t\t\ty0 += n * dpy_y; \n\n\t\t\t\tif (corner_y) {\n\t\t\t\t\ty0 += dpy_y - h; \n\t\t\t\t}\n\t\t\t\tif (corner_x) {\n\t\t\t\t\tx0 += dpy_x - w; \n\t\t\t\t}\n\t\t\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\t\tint xb = cache_list[i].bs_x;\n\t\t\t\t\tint yb = cache_list[i].bs_y;\n\t\t\t\t\tint wb = cache_list[i].bs_w;\n\t\t\t\t\tint hb = cache_list[i].bs_h;\n\n\t\t\t\t\tif (xb < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\t\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\t\ta = wb * hb;\n\n\t\t\t\t\td1 = cache_list[i].bs_time;\n\t\t\t\t\td2 = cache_list[i].su_time;\n\n\t\t\t\t\td = d1;\n\t\t\t\t\tif (d2 > d) d = d2;\n\t\t\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\t\t\tif (cache_list[i].map_state == IsViewable) {\n\t\t\t\t\t\tamap += a;\n\t\t\t\t\t}\n\t\t\t\t\tarea += a;\n\t\t\t\t\tage += (basetime - d) * a;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t\tif (nc == 0) {\n\t\t\t\t\tscore = 999999.9;\n\t\t\t\t} else {\n\t\t\t\t\tdouble fac;\n\t\t\t\t\tage = age / area;\n\t\t\t\t\tscore = age / area;\n\t\t\t\t\tfac = 1.0 * (1.0 - amap/area) + map_factor * (amap/area);\n\t\t\t\t\tscore *= fac;\n\t\t\t\t}\n\n\t\t\t\twgt[nwgt] =  score;\n\t\t\t\ttype[nwgt] = Force;\n\t\t\t\tval[0][nwgt] = n;\n\t\t\t\tval[1][nwgt] = x0;\n\t\t\t\tval[2][nwgt] = y0;\nif (ncdb) fprintf(stderr, \"Force [%02d]   %9.5f  age=%9.4f  area=%8d  amap=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], age, (int) area, (int) amap, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) break;\n\t\t\t\tsraRgnDestroy(r1);\n\t\t\t}\n\t\t\tif (nwgt >= nwgt_max) break;\n\t\t    }\n\t\t    if (nwgt >= nwgt_max) break;\n\t\t}\n\t}\n\n\tif (nwgt == 0) {\nif (ncdb) fprintf(stderr, \"nwgt=0\\n\");\n\t\t*x_hit = -1;\n\t\treturn;\n\t}\n\n\tnorm = 0.0;\n\tfor (i=0; i < nwgt; i++) {\n\t\tnorm += wgt[i];\n\t}\n\tfor (i=0; i < nwgt; i++) {\n\t\twgt[i] /= norm; \n\t}\n\n\tr = rfac();\n\n\tnorm = 0.0;\n\tfor (j=0; j < nwgt; j++) {\n\t\tnorm += wgt[j];\nif (ncdb) fprintf(stderr, \"j=%2d  acc=%.6f r=%.6f\\n\", j, norm, r); \n\t\tif (r < norm) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j >= nwgt) {\n\t\tj = nwgt - 1;\n\t}\n\n\tif (type[j] == Expire) {\n\t\tint ik = val[0][j];\n\t\tint k_x = cache_list[ik].bs_x;\n\t\tint k_y = cache_list[ik].bs_y;\n\t\tint k_w = cache_list[ik].bs_w;\n\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n\tget_bs_n(*y_hit), ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\tfree_rect(ik);\n\t\tfr_EXPIRE++;\n\t\tfr_EXPIREt++;\n\t\t*x_hit = k_x;\n\t\t*y_hit = k_y;\n\t\tn = get_bs_n(*y_hit);\n\t\tif (n >= 0) {\n\t\t\tr1 = rect_reg[n];\n\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t} else {\n\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t\n\t} else if (type[j] == Force) {\n\n\t\tint x0 = val[1][j];\n\t\tint y0 = val[2][j];\n\t\tn = val[0][j];\n\t\t\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*n-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN FORCE: %dx%d+%d+%d -- %d %d\\n\", n, w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid expire_rects2(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n, i, j, k;\n\tint nwgt_max = 128, nwgt = 0;\n\tint type[128];\n\tint val[4][128];\n\tdouble wgt[128], norm;\n\tint Expire = 1, Force = 2;\n\tint do_expire = 1;\n\tint do_force = 1;\n\tdouble now = dnow(), r;\n\tdouble newest = -1.0, oldest = -1.0, basetime;\n\tdouble map_factor = 0.25;\n\n\tfor (i=0; i<cache_list_num; i++) {\n\t\tdouble d, d1, d2;\n\n\t\td1 = cache_list[i].bs_time;\n\t\td2 = cache_list[i].su_time;\n\n\t\td = d1;\n\t\tif (d2 > d) d = d2;\n\n\t\tif (d == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oldest == -1.0 || d < oldest) {\n\t\t\toldest = d;\n\t\t}\n\t\tif (newest == -1.0 || d > newest) {\n\t\t\tnewest = d;\n\t\t}\n\t}\n\tif (newest == -1.0) {\n\t\tnewest = now;\n\t}\n\tif (oldest == -1.0) {\n\t\toldest = newest - 1800;\n\t}\n\n\tbasetime = newest + 0.1 * (newest - oldest);\n\n\tif (do_expire) {\n\t\tint old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].bs_time;\n\t\t\td2 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\n\t\t\t\twgt[nwgt] =  (basetime - dold[k]) / (k_w * k_h);\n\t\t\t\tif (cache_list[ik].map_state == IsViewable) {\n\t\t\t\t\twgt[nwgt] *= map_factor;\n\t\t\t\t}\n\t\t\t\ttype[nwgt] = Expire;\n\t\t\t\tval[0][nwgt] = ik;\nif (ncdb) fprintf(stderr, \"Expire[%02d]   %9.5f  age=%9.4f  area=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], basetime - dold[k], k_w * k_h, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many rect */\n\tif (do_force) {\n\t\tint corner_x, corner_y;\n\t\tint x0, y0;\n\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t    if (big1 && ncache > 2 && n == 1) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (big2 && ncache > 4 && n <= 3) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    for (corner_x = 0; corner_x < 2; corner_x++) {\n\t\t\tif (cram && big1 && corner_x == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (corner_y = 0; corner_y < 2; corner_y++) {\n\t\t\t\tdouble age = 0.0, area = 0.0, amap = 0.0, a;\n\t\t\t\tdouble d, d1, d2, score;\n\t\t\t\tint nc = 0;\n\n\t\t\t\tx0 = 0;\n\t\t\t\ty0 = 0;\n\t\t\t\ty0 += n * dpy_y; \n\n\t\t\t\tif (corner_y) {\n\t\t\t\t\ty0 += dpy_y - h; \n\t\t\t\t}\n\t\t\t\tif (corner_x) {\n\t\t\t\t\tx0 += dpy_x - w; \n\t\t\t\t}\n\t\t\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\t\tint xb = cache_list[i].bs_x;\n\t\t\t\t\tint yb = cache_list[i].bs_y;\n\t\t\t\t\tint wb = cache_list[i].bs_w;\n\t\t\t\t\tint hb = cache_list[i].bs_h;\n\n\t\t\t\t\tif (xb < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\t\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\t\ta = wb * hb;\n\n\t\t\t\t\td1 = cache_list[i].bs_time;\n\t\t\t\t\td2 = cache_list[i].su_time;\n\n\t\t\t\t\td = d1;\n\t\t\t\t\tif (d2 > d) d = d2;\n\t\t\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\t\t\tif (cache_list[i].map_state == IsViewable) {\n\t\t\t\t\t\tamap += a;\n\t\t\t\t\t}\n\t\t\t\t\tarea += a;\n\t\t\t\t\tage += (basetime - d) * a;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t\tif (nc == 0) {\n\t\t\t\t\tscore = 999999.9;\n\t\t\t\t} else {\n\t\t\t\t\tdouble fac;\n\t\t\t\t\tage = age / area;\n\t\t\t\t\tscore = age / area;\n\t\t\t\t\tfac = 1.0 * (1.0 - amap/area) + map_factor * (amap/area);\n\t\t\t\t\tscore *= fac;\n\t\t\t\t}\n\n\t\t\t\twgt[nwgt] =  score;\n\t\t\t\ttype[nwgt] = Force;\n\t\t\t\tval[0][nwgt] = n;\n\t\t\t\tval[1][nwgt] = x0;\n\t\t\t\tval[2][nwgt] = y0;\nif (ncdb) fprintf(stderr, \"Force [%02d]   %9.5f  age=%9.4f  area=%8d  amap=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], age, (int) area, (int) amap, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) break;\n\t\t\t\tsraRgnDestroy(r1);\n\t\t\t}\n\t\t\tif (nwgt >= nwgt_max) break;\n\t\t    }\n\t\t    if (nwgt >= nwgt_max) break;\n\t\t}\n\t}\n\n\tif (nwgt == 0) {\nif (ncdb) fprintf(stderr, \"nwgt=0\\n\");\n\t\t*x_hit = -1;\n\t\treturn;\n\t}\n\n\tnorm = 0.0;\n\tfor (i=0; i < nwgt; i++) {\n\t\tnorm += wgt[i];\n\t}\n\tfor (i=0; i < nwgt; i++) {\n\t\twgt[i] /= norm; \n\t}\n\n\tr = rfac();\n\n\tnorm = 0.0;\n\tfor (j=0; j < nwgt; j++) {\n\t\tnorm += wgt[j];\nif (ncdb) fprintf(stderr, \"j=%2d  acc=%.6f r=%.6f\\n\", j, norm, r); \n\t\tif (r < norm) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j >= nwgt) {\n\t\tj = nwgt - 1;\n\t}\n\n\tif (type[j] == Expire) {\n\t\tint ik = val[0][j];\n\t\tint k_x = cache_list[ik].bs_x;\n\t\tint k_y = cache_list[ik].bs_y;\n\t\tint k_w = cache_list[ik].bs_w;\n\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n\tget_bs_n(*y_hit), ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\tfree_rect(ik);\n\t\tfr_EXPIRE++;\n\t\tfr_EXPIREt++;\n\t\t*x_hit = k_x;\n\t\t*y_hit = k_y;\n\t\tn = get_bs_n(*y_hit);\n\t\tif (n >= 0) {\n\t\t\tr1 = rect_reg[n];\n\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t} else {\n\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t\n\t} else if (type[j] == Force) {\n\n\t\tint x0 = val[1][j];\n\t\tint y0 = val[2][j];\n\t\tn = val[0][j];\n\t\t\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*n-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN FORCE: %dx%d+%d+%d -- %d %d\\n\", n, w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "expire_rects1",
          "args": [
            "idx",
            "w",
            "h",
            "x_hit",
            "y_hit",
            "big1",
            "big2",
            "cram"
          ],
          "line": 6718
        },
        "resolved": true,
        "details": {
          "function_name": "expire_rects1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6264-6414",
          "snippet": "void expire_rects1(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n;\n\n\tif (*x_hit < 0) {\n\t\tint i, k, old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2, d3;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].time;\n\t\t\td2 = cache_list[i].bs_time;\n\t\t\td3 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d3 > d) d = d3;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_x = cache_list[ik].bs_x;\n\t\t\t\tint k_y = cache_list[ik].bs_y;\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n    ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\t\t\tfree_rect(ik);\n\t\t\t\tfr_EXPIRE++;\n\t\t\t\tfr_EXPIREt++;\n\t\t\t\t*x_hit = k_x;\n\t\t\t\t*y_hit = k_y;\n\t\t\t\tn = get_bs_n(*y_hit);\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\tr1 = rect_reg[n];\n\t\t\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many */\n\tif (*x_hit < 0) {\n\t\tint corner_x = (int) (2 * rfac());\n\t\tint corner_y = (int) (2 * rfac());\n\t\tint x0 = 0, y0 = 0, i, nrand, nr = ncache/2;\n\t\tif (nr == 1) {\n\t\t\tnrand = 1;\n\t\t} else {\n\t\t\tif (! big1) {\n\t\t\t\tnrand = 1;\n\t\t\t} else {\n\t\t\t\tif (big2 && nr > 2) {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 2) * rfac());\n\t\t\t\t\tnrand += 2; \n\t\t\t\t} else {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 1) * rfac());\n\t\t\t\t\tnrand += 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nrand < 0 || nrand > nr) {\n\t\t\tnrand = nr;\n\t\t}\n\t\tif (cram && big1) {\n\t\t\tcorner_x = 1;\n\t\t}\n\n\t\ty0 += dpy_y; \n\t\tif (nrand > 1) {\n\t\t\ty0 += 2 * (nrand - 1) * dpy_y; \n\t\t}\n\t\tif (corner_y) {\n\t\t\ty0 += dpy_y - h; \n\t\t}\n\t\tif (corner_x) {\n\t\t\tx0 += dpy_x - w; \n\t\t}\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*nrand-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via FORCE: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid expire_rects1(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n;\n\n\tif (*x_hit < 0) {\n\t\tint i, k, old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2, d3;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].time;\n\t\t\td2 = cache_list[i].bs_time;\n\t\t\td3 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d3 > d) d = d3;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_x = cache_list[ik].bs_x;\n\t\t\t\tint k_y = cache_list[ik].bs_y;\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n    ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\t\t\tfree_rect(ik);\n\t\t\t\tfr_EXPIRE++;\n\t\t\t\tfr_EXPIREt++;\n\t\t\t\t*x_hit = k_x;\n\t\t\t\t*y_hit = k_y;\n\t\t\t\tn = get_bs_n(*y_hit);\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\tr1 = rect_reg[n];\n\t\t\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many */\n\tif (*x_hit < 0) {\n\t\tint corner_x = (int) (2 * rfac());\n\t\tint corner_y = (int) (2 * rfac());\n\t\tint x0 = 0, y0 = 0, i, nrand, nr = ncache/2;\n\t\tif (nr == 1) {\n\t\t\tnrand = 1;\n\t\t} else {\n\t\t\tif (! big1) {\n\t\t\t\tnrand = 1;\n\t\t\t} else {\n\t\t\t\tif (big2 && nr > 2) {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 2) * rfac());\n\t\t\t\t\tnrand += 2; \n\t\t\t\t} else {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 1) * rfac());\n\t\t\t\t\tnrand += 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nrand < 0 || nrand > nr) {\n\t\t\tnrand = nr;\n\t\t}\n\t\tif (cram && big1) {\n\t\t\tcorner_x = 1;\n\t\t}\n\n\t\ty0 += dpy_y; \n\t\tif (nrand > 1) {\n\t\t\ty0 += 2 * (nrand - 1) * dpy_y; \n\t\t}\n\t\tif (corner_y) {\n\t\t\ty0 += dpy_y - h; \n\t\t}\n\t\tif (corner_x) {\n\t\t\tx0 += dpy_x - w; \n\t\t}\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*nrand-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via FORCE: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint clipped(int idx);\n\nvoid expire_rects(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tint method = 2;\n\tif (method == 1) {\n\t\texpire_rects1(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t} else if (method == 2) {\n\t\texpire_rects2(idx, w, h, x_hit, y_hit, big1, big2, cram);\n\t}\n}"
  },
  {
    "function_name": "expire_rects2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6416-6713",
    "snippet": "void expire_rects2(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n, i, j, k;\n\tint nwgt_max = 128, nwgt = 0;\n\tint type[128];\n\tint val[4][128];\n\tdouble wgt[128], norm;\n\tint Expire = 1, Force = 2;\n\tint do_expire = 1;\n\tint do_force = 1;\n\tdouble now = dnow(), r;\n\tdouble newest = -1.0, oldest = -1.0, basetime;\n\tdouble map_factor = 0.25;\n\n\tfor (i=0; i<cache_list_num; i++) {\n\t\tdouble d, d1, d2;\n\n\t\td1 = cache_list[i].bs_time;\n\t\td2 = cache_list[i].su_time;\n\n\t\td = d1;\n\t\tif (d2 > d) d = d2;\n\n\t\tif (d == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oldest == -1.0 || d < oldest) {\n\t\t\toldest = d;\n\t\t}\n\t\tif (newest == -1.0 || d > newest) {\n\t\t\tnewest = d;\n\t\t}\n\t}\n\tif (newest == -1.0) {\n\t\tnewest = now;\n\t}\n\tif (oldest == -1.0) {\n\t\toldest = newest - 1800;\n\t}\n\n\tbasetime = newest + 0.1 * (newest - oldest);\n\n\tif (do_expire) {\n\t\tint old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].bs_time;\n\t\t\td2 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\n\t\t\t\twgt[nwgt] =  (basetime - dold[k]) / (k_w * k_h);\n\t\t\t\tif (cache_list[ik].map_state == IsViewable) {\n\t\t\t\t\twgt[nwgt] *= map_factor;\n\t\t\t\t}\n\t\t\t\ttype[nwgt] = Expire;\n\t\t\t\tval[0][nwgt] = ik;\nif (ncdb) fprintf(stderr, \"Expire[%02d]   %9.5f  age=%9.4f  area=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], basetime - dold[k], k_w * k_h, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many rect */\n\tif (do_force) {\n\t\tint corner_x, corner_y;\n\t\tint x0, y0;\n\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t    if (big1 && ncache > 2 && n == 1) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (big2 && ncache > 4 && n <= 3) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    for (corner_x = 0; corner_x < 2; corner_x++) {\n\t\t\tif (cram && big1 && corner_x == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (corner_y = 0; corner_y < 2; corner_y++) {\n\t\t\t\tdouble age = 0.0, area = 0.0, amap = 0.0, a;\n\t\t\t\tdouble d, d1, d2, score;\n\t\t\t\tint nc = 0;\n\n\t\t\t\tx0 = 0;\n\t\t\t\ty0 = 0;\n\t\t\t\ty0 += n * dpy_y; \n\n\t\t\t\tif (corner_y) {\n\t\t\t\t\ty0 += dpy_y - h; \n\t\t\t\t}\n\t\t\t\tif (corner_x) {\n\t\t\t\t\tx0 += dpy_x - w; \n\t\t\t\t}\n\t\t\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\t\tint xb = cache_list[i].bs_x;\n\t\t\t\t\tint yb = cache_list[i].bs_y;\n\t\t\t\t\tint wb = cache_list[i].bs_w;\n\t\t\t\t\tint hb = cache_list[i].bs_h;\n\n\t\t\t\t\tif (xb < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\t\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\t\ta = wb * hb;\n\n\t\t\t\t\td1 = cache_list[i].bs_time;\n\t\t\t\t\td2 = cache_list[i].su_time;\n\n\t\t\t\t\td = d1;\n\t\t\t\t\tif (d2 > d) d = d2;\n\t\t\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\t\t\tif (cache_list[i].map_state == IsViewable) {\n\t\t\t\t\t\tamap += a;\n\t\t\t\t\t}\n\t\t\t\t\tarea += a;\n\t\t\t\t\tage += (basetime - d) * a;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t\tif (nc == 0) {\n\t\t\t\t\tscore = 999999.9;\n\t\t\t\t} else {\n\t\t\t\t\tdouble fac;\n\t\t\t\t\tage = age / area;\n\t\t\t\t\tscore = age / area;\n\t\t\t\t\tfac = 1.0 * (1.0 - amap/area) + map_factor * (amap/area);\n\t\t\t\t\tscore *= fac;\n\t\t\t\t}\n\n\t\t\t\twgt[nwgt] =  score;\n\t\t\t\ttype[nwgt] = Force;\n\t\t\t\tval[0][nwgt] = n;\n\t\t\t\tval[1][nwgt] = x0;\n\t\t\t\tval[2][nwgt] = y0;\nif (ncdb) fprintf(stderr, \"Force [%02d]   %9.5f  age=%9.4f  area=%8d  amap=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], age, (int) area, (int) amap, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) break;\n\t\t\t\tsraRgnDestroy(r1);\n\t\t\t}\n\t\t\tif (nwgt >= nwgt_max) break;\n\t\t    }\n\t\t    if (nwgt >= nwgt_max) break;\n\t\t}\n\t}\n\n\tif (nwgt == 0) {\nif (ncdb) fprintf(stderr, \"nwgt=0\\n\");\n\t\t*x_hit = -1;\n\t\treturn;\n\t}\n\n\tnorm = 0.0;\n\tfor (i=0; i < nwgt; i++) {\n\t\tnorm += wgt[i];\n\t}\n\tfor (i=0; i < nwgt; i++) {\n\t\twgt[i] /= norm; \n\t}\n\n\tr = rfac();\n\n\tnorm = 0.0;\n\tfor (j=0; j < nwgt; j++) {\n\t\tnorm += wgt[j];\nif (ncdb) fprintf(stderr, \"j=%2d  acc=%.6f r=%.6f\\n\", j, norm, r); \n\t\tif (r < norm) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j >= nwgt) {\n\t\tj = nwgt - 1;\n\t}\n\n\tif (type[j] == Expire) {\n\t\tint ik = val[0][j];\n\t\tint k_x = cache_list[ik].bs_x;\n\t\tint k_y = cache_list[ik].bs_y;\n\t\tint k_w = cache_list[ik].bs_w;\n\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n\tget_bs_n(*y_hit), ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\tfree_rect(ik);\n\t\tfr_EXPIRE++;\n\t\tfr_EXPIREt++;\n\t\t*x_hit = k_x;\n\t\t*y_hit = k_y;\n\t\tn = get_bs_n(*y_hit);\n\t\tif (n >= 0) {\n\t\t\tr1 = rect_reg[n];\n\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t} else {\n\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t\n\t} else if (type[j] == Force) {\n\n\t\tint x0 = val[1][j];\n\t\tint y0 = val[2][j];\n\t\tn = val[0][j];\n\t\t\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*n-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN FORCE: %dx%d+%d+%d -- %d %d\\n\", n, w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect [%d] via RAN FORCE: %dx%d+%d+%d -- %d %d\\n\"",
            "n",
            "w",
            "h",
            "x",
            "y",
            "*x_hit",
            "*y_hit"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r3",
            "r1"
          ],
          "line": 6705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rect",
          "args": [
            "i"
          ],
          "line": 6698
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 6697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xb",
            "yb",
            "xb+wb",
            "yb+hb"
          ],
          "line": 6696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "yb - y0"
          ],
          "line": 6693
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x0",
            "y0",
            "x0+w",
            "y0+h"
          ],
          "line": 6683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 6674
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failure to find y n in find_rect\\n\""
          ],
          "line": 6673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "*x_hit",
            "*y_hit",
            "*x_hit + w",
            "*y_hit + h"
          ],
          "line": 6669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bs_n",
          "args": [
            "*y_hit"
          ],
          "line": 6666
        },
        "resolved": true,
        "details": {
          "function_name": "get_bs_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5912-5920",
          "snippet": "int get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect [%d] via RAN EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\"",
            "get_bs_n(*y_hit)",
            "ik",
            "cache_list[ik].win",
            "w",
            "h",
            "x",
            "y",
            "*x_hit",
            "*y_hit",
            "k_w",
            "k_h",
            "k_x",
            "k_y",
            "k_w * k_h",
            "w * h"
          ],
          "line": 6658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"j=%2d  acc=%.6f r=%.6f\\n\"",
            "j",
            "norm",
            "r"
          ],
          "line": 6642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfac",
          "args": [],
          "line": 6637
        },
        "resolved": true,
        "details": {
          "function_name": "rfac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "454-473",
          "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double rnow(void);",
            "double rfac(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nwgt=0\\n\""
          ],
          "line": 6624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Force [%02d]   %9.5f  age=%9.4f  area=%8d  amap=%8d  need=%8d\\n\"",
            "nwgt",
            "10000 * wgt[nwgt]",
            "age",
            "(int) area",
            "(int) amap",
            "w*h"
          ],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 6575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xb",
            "yb",
            "xb+wb",
            "yb+hb"
          ],
          "line": 6574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x0",
            "y0",
            "x0+w",
            "y0+h"
          ],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Expire[%02d]   %9.5f  age=%9.4f  area=%8d  need=%8d\\n\"",
            "nwgt",
            "10000 * wgt[nwgt]",
            "basetime - dold[k]",
            "k_w * k_h",
            "w*h"
          ],
          "line": 6519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 6426
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid expire_rects2(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n, i, j, k;\n\tint nwgt_max = 128, nwgt = 0;\n\tint type[128];\n\tint val[4][128];\n\tdouble wgt[128], norm;\n\tint Expire = 1, Force = 2;\n\tint do_expire = 1;\n\tint do_force = 1;\n\tdouble now = dnow(), r;\n\tdouble newest = -1.0, oldest = -1.0, basetime;\n\tdouble map_factor = 0.25;\n\n\tfor (i=0; i<cache_list_num; i++) {\n\t\tdouble d, d1, d2;\n\n\t\td1 = cache_list[i].bs_time;\n\t\td2 = cache_list[i].su_time;\n\n\t\td = d1;\n\t\tif (d2 > d) d = d2;\n\n\t\tif (d == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (oldest == -1.0 || d < oldest) {\n\t\t\toldest = d;\n\t\t}\n\t\tif (newest == -1.0 || d > newest) {\n\t\t\tnewest = d;\n\t\t}\n\t}\n\tif (newest == -1.0) {\n\t\tnewest = now;\n\t}\n\tif (oldest == -1.0) {\n\t\toldest = newest - 1800;\n\t}\n\n\tbasetime = newest + 0.1 * (newest - oldest);\n\n\tif (do_expire) {\n\t\tint old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].bs_time;\n\t\t\td2 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\n\t\t\t\twgt[nwgt] =  (basetime - dold[k]) / (k_w * k_h);\n\t\t\t\tif (cache_list[ik].map_state == IsViewable) {\n\t\t\t\t\twgt[nwgt] *= map_factor;\n\t\t\t\t}\n\t\t\t\ttype[nwgt] = Expire;\n\t\t\t\tval[0][nwgt] = ik;\nif (ncdb) fprintf(stderr, \"Expire[%02d]   %9.5f  age=%9.4f  area=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], basetime - dold[k], k_w * k_h, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many rect */\n\tif (do_force) {\n\t\tint corner_x, corner_y;\n\t\tint x0, y0;\n\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t    if (big1 && ncache > 2 && n == 1) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (big2 && ncache > 4 && n <= 3) {\n\t\t\tcontinue;\n\t\t    }\n\t\t    for (corner_x = 0; corner_x < 2; corner_x++) {\n\t\t\tif (cram && big1 && corner_x == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (corner_y = 0; corner_y < 2; corner_y++) {\n\t\t\t\tdouble age = 0.0, area = 0.0, amap = 0.0, a;\n\t\t\t\tdouble d, d1, d2, score;\n\t\t\t\tint nc = 0;\n\n\t\t\t\tx0 = 0;\n\t\t\t\ty0 = 0;\n\t\t\t\ty0 += n * dpy_y; \n\n\t\t\t\tif (corner_y) {\n\t\t\t\t\ty0 += dpy_y - h; \n\t\t\t\t}\n\t\t\t\tif (corner_x) {\n\t\t\t\t\tx0 += dpy_x - w; \n\t\t\t\t}\n\t\t\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\t\tint xb = cache_list[i].bs_x;\n\t\t\t\t\tint yb = cache_list[i].bs_y;\n\t\t\t\t\tint wb = cache_list[i].bs_w;\n\t\t\t\t\tint hb = cache_list[i].bs_h;\n\n\t\t\t\t\tif (xb < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\t\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\t\ta = wb * hb;\n\n\t\t\t\t\td1 = cache_list[i].bs_time;\n\t\t\t\t\td2 = cache_list[i].su_time;\n\n\t\t\t\t\td = d1;\n\t\t\t\t\tif (d2 > d) d = d2;\n\t\t\t\t\tif (d == 0.0) d = oldest;\n\n\t\t\t\t\tif (cache_list[i].map_state == IsViewable) {\n\t\t\t\t\t\tamap += a;\n\t\t\t\t\t}\n\t\t\t\t\tarea += a;\n\t\t\t\t\tage += (basetime - d) * a;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t\tif (nc == 0) {\n\t\t\t\t\tscore = 999999.9;\n\t\t\t\t} else {\n\t\t\t\t\tdouble fac;\n\t\t\t\t\tage = age / area;\n\t\t\t\t\tscore = age / area;\n\t\t\t\t\tfac = 1.0 * (1.0 - amap/area) + map_factor * (amap/area);\n\t\t\t\t\tscore *= fac;\n\t\t\t\t}\n\n\t\t\t\twgt[nwgt] =  score;\n\t\t\t\ttype[nwgt] = Force;\n\t\t\t\tval[0][nwgt] = n;\n\t\t\t\tval[1][nwgt] = x0;\n\t\t\t\tval[2][nwgt] = y0;\nif (ncdb) fprintf(stderr, \"Force [%02d]   %9.5f  age=%9.4f  area=%8d  amap=%8d  need=%8d\\n\", nwgt, 10000 * wgt[nwgt], age, (int) area, (int) amap, w*h);\n\t\t\t\tnwgt++;\n\t\t\t\tif (nwgt >= nwgt_max) break;\n\t\t\t\tsraRgnDestroy(r1);\n\t\t\t}\n\t\t\tif (nwgt >= nwgt_max) break;\n\t\t    }\n\t\t    if (nwgt >= nwgt_max) break;\n\t\t}\n\t}\n\n\tif (nwgt == 0) {\nif (ncdb) fprintf(stderr, \"nwgt=0\\n\");\n\t\t*x_hit = -1;\n\t\treturn;\n\t}\n\n\tnorm = 0.0;\n\tfor (i=0; i < nwgt; i++) {\n\t\tnorm += wgt[i];\n\t}\n\tfor (i=0; i < nwgt; i++) {\n\t\twgt[i] /= norm; \n\t}\n\n\tr = rfac();\n\n\tnorm = 0.0;\n\tfor (j=0; j < nwgt; j++) {\n\t\tnorm += wgt[j];\nif (ncdb) fprintf(stderr, \"j=%2d  acc=%.6f r=%.6f\\n\", j, norm, r); \n\t\tif (r < norm) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (j >= nwgt) {\n\t\tj = nwgt - 1;\n\t}\n\n\tif (type[j] == Expire) {\n\t\tint ik = val[0][j];\n\t\tint k_x = cache_list[ik].bs_x;\n\t\tint k_y = cache_list[ik].bs_y;\n\t\tint k_w = cache_list[ik].bs_w;\n\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n\tget_bs_n(*y_hit), ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\tfree_rect(ik);\n\t\tfr_EXPIRE++;\n\t\tfr_EXPIREt++;\n\t\t*x_hit = k_x;\n\t\t*y_hit = k_y;\n\t\tn = get_bs_n(*y_hit);\n\t\tif (n >= 0) {\n\t\t\tr1 = rect_reg[n];\n\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t} else {\n\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t\n\t} else if (type[j] == Force) {\n\n\t\tint x0 = val[1][j];\n\t\tint y0 = val[2][j];\n\t\tn = val[0][j];\n\t\t\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*n-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect [%d] via RAN FORCE: %dx%d+%d+%d -- %d %d\\n\", n, w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}"
  },
  {
    "function_name": "expire_rects1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6264-6414",
    "snippet": "void expire_rects1(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n;\n\n\tif (*x_hit < 0) {\n\t\tint i, k, old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2, d3;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].time;\n\t\t\td2 = cache_list[i].bs_time;\n\t\t\td3 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d3 > d) d = d3;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_x = cache_list[ik].bs_x;\n\t\t\t\tint k_y = cache_list[ik].bs_y;\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n    ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\t\t\tfree_rect(ik);\n\t\t\t\tfr_EXPIRE++;\n\t\t\t\tfr_EXPIREt++;\n\t\t\t\t*x_hit = k_x;\n\t\t\t\t*y_hit = k_y;\n\t\t\t\tn = get_bs_n(*y_hit);\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\tr1 = rect_reg[n];\n\t\t\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many */\n\tif (*x_hit < 0) {\n\t\tint corner_x = (int) (2 * rfac());\n\t\tint corner_y = (int) (2 * rfac());\n\t\tint x0 = 0, y0 = 0, i, nrand, nr = ncache/2;\n\t\tif (nr == 1) {\n\t\t\tnrand = 1;\n\t\t} else {\n\t\t\tif (! big1) {\n\t\t\t\tnrand = 1;\n\t\t\t} else {\n\t\t\t\tif (big2 && nr > 2) {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 2) * rfac());\n\t\t\t\t\tnrand += 2; \n\t\t\t\t} else {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 1) * rfac());\n\t\t\t\t\tnrand += 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nrand < 0 || nrand > nr) {\n\t\t\tnrand = nr;\n\t\t}\n\t\tif (cram && big1) {\n\t\t\tcorner_x = 1;\n\t\t}\n\n\t\ty0 += dpy_y; \n\t\tif (nrand > 1) {\n\t\t\ty0 += 2 * (nrand - 1) * dpy_y; \n\t\t}\n\t\tif (corner_y) {\n\t\t\ty0 += dpy_y - h; \n\t\t}\n\t\tif (corner_x) {\n\t\t\tx0 += dpy_x - w; \n\t\t}\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*nrand-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via FORCE: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect via FORCE: %dx%d+%d+%d -- %d %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "*x_hit",
            "*y_hit"
          ],
          "line": 6409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 6407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r3",
            "r1"
          ],
          "line": 6406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rect",
          "args": [
            "i"
          ],
          "line": 6399
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 6398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xb",
            "yb",
            "xb+wb",
            "yb+hb"
          ],
          "line": 6397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "yb - y0"
          ],
          "line": 6394
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x0",
            "y0",
            "x0+w",
            "y0+h"
          ],
          "line": 6384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfac",
          "args": [],
          "line": 6362
        },
        "resolved": true,
        "details": {
          "function_name": "rfac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "454-473",
          "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double rnow(void);",
            "double rfac(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 6340
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"failure to find y n in find_rect\\n\""
          ],
          "line": 6339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "*x_hit",
            "*y_hit",
            "*x_hit + w",
            "*y_hit + h"
          ],
          "line": 6335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bs_n",
          "args": [
            "*y_hit"
          ],
          "line": 6332
        },
        "resolved": true,
        "details": {
          "function_name": "get_bs_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5912-5920",
          "snippet": "int get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>**--**>> found rect via EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\"",
            "ik",
            "cache_list[ik].win",
            "w",
            "h",
            "x",
            "y",
            "*x_hit",
            "*y_hit",
            "k_w",
            "k_h",
            "k_x",
            "k_y",
            "k_w * k_h",
            "w * h"
          ],
          "line": 6324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid expire_rects1(int idx, int w, int h, int *x_hit, int *y_hit, int big1, int big2, int cram) {\n\tsraRegionPtr r1, r2, r3;\n\tint x = -1, y = -1, n;\n\n\tif (*x_hit < 0) {\n\t\tint i, k, old[10], N = 4;\n\t\tdouble dold[10], fa, d, d1, d2, d3;\n\t\tint a0 = w * h, a1;\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\told[k] = -1;\n\t\t\tdold[k] = -1.0;\n\t\t}\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (cache_list[i].bs_x < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (w > wb || h > hb) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (wb == 0 || hb == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a0 == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta1 = wb * hb;\n\t\t\tfa = ((double) a1) / a0;\n\t\t\tk = (int) fa;\n\n\t\t\tif (k < 1) k = 1;\n\t\t\tif (k > N) continue;\n\n\t\t\td1 = cache_list[i].time;\n\t\t\td2 = cache_list[i].bs_time;\n\t\t\td3 = cache_list[i].su_time;\n\n\t\t\td = d1;\n\t\t\tif (d2 > d) d = d2;\n\t\t\tif (d3 > d) d = d3;\n\n\t\t\tif (dold[k] == -1.0 || d < dold[k]) {\n\t\t\t\told[k] = i;\n\t\t\t\tdold[k] = d;\n\t\t\t}\n\t\t}\n\n\t\tfor (k=1; k<=N; k++) {\n\t\t\tif (old[k] >= 0) {\n\t\t\t\tint ik = old[k];\n\t\t\t\tint k_x = cache_list[ik].bs_x;\n\t\t\t\tint k_y = cache_list[ik].bs_y;\n\t\t\t\tint k_w = cache_list[ik].bs_w;\n\t\t\t\tint k_h = cache_list[ik].bs_h;\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via EXPIRE: %d 0x%lx -- %dx%d+%d+%d %d %d --  %dx%d+%d+%d  A: %d/%d\\n\",\n    ik, cache_list[ik].win, w, h, x, y, *x_hit, *y_hit, k_w, k_h, k_x, k_y, k_w * k_h, w * h);\n\n\t\t\t\tfree_rect(ik);\n\t\t\t\tfr_EXPIRE++;\n\t\t\t\tfr_EXPIREt++;\n\t\t\t\t*x_hit = k_x;\n\t\t\t\t*y_hit = k_y;\n\t\t\t\tn = get_bs_n(*y_hit);\n\t\t\t\tif (n >= 0) {\n\t\t\t\t\tr1 = rect_reg[n];\n\t\t\t\t\tr2 = sraRgnCreateRect(*x_hit, *y_hit, *x_hit + w, *y_hit + h);\n\t\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"failure to find y n in find_rect\\n\");\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* next, force ourselves into some corner, expiring many */\n\tif (*x_hit < 0) {\n\t\tint corner_x = (int) (2 * rfac());\n\t\tint corner_y = (int) (2 * rfac());\n\t\tint x0 = 0, y0 = 0, i, nrand, nr = ncache/2;\n\t\tif (nr == 1) {\n\t\t\tnrand = 1;\n\t\t} else {\n\t\t\tif (! big1) {\n\t\t\t\tnrand = 1;\n\t\t\t} else {\n\t\t\t\tif (big2 && nr > 2) {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 2) * rfac());\n\t\t\t\t\tnrand += 2; \n\t\t\t\t} else {\n\t\t\t\t\tnrand =  1 + (int) ((nr - 1) * rfac());\n\t\t\t\t\tnrand += 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nrand < 0 || nrand > nr) {\n\t\t\tnrand = nr;\n\t\t}\n\t\tif (cram && big1) {\n\t\t\tcorner_x = 1;\n\t\t}\n\n\t\ty0 += dpy_y; \n\t\tif (nrand > 1) {\n\t\t\ty0 += 2 * (nrand - 1) * dpy_y; \n\t\t}\n\t\tif (corner_y) {\n\t\t\ty0 += dpy_y - h; \n\t\t}\n\t\tif (corner_x) {\n\t\t\tx0 += dpy_x - w; \n\t\t}\n\t\tr1 = sraRgnCreateRect(x0, y0, x0+w, y0+h);\n\n\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\tint xb = cache_list[i].bs_x;\n\t\t\tint yb = cache_list[i].bs_y;\n\t\t\tint wb = cache_list[i].bs_w;\n\t\t\tint hb = cache_list[i].bs_h;\n\t\t\tif (xb < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nabs(yb - y0) > dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr2 = sraRgnCreateRect(xb, yb, xb+wb, yb+hb);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tfree_rect(i);\n\t\t\t}\n\t\t\tsraRgnDestroy(r2);\n\t\t}\n\t\t*x_hit = x0;\n\t\t*y_hit = y0;\n\t\tr3 = rect_reg[2*nrand-1];\n\t\tsraRgnSubtract(r3, r1);\n\t\tsraRgnDestroy(r1);\n\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via FORCE: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, *x_hit, *y_hit);\n\n\t\tfr_FORCE++;\n\t\tfr_FORCEt++;\n\t}\n}"
  },
  {
    "function_name": "free_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6200-6247",
    "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**** free_rect: not-found %d\\n\"",
            "idx"
          ],
          "line": 6245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "idx"
          ],
          "line": 6244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "zero_rects",
            "r2"
          ],
          "line": 6239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 6238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 6237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "zero_rects",
            "r2"
          ],
          "line": 6231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r1",
            "r2"
          ],
          "line": 6226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bs_n",
          "args": [
            "y"
          ],
          "line": 6223
        },
        "resolved": true,
        "details": {
          "function_name": "get_bs_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5912-5920",
          "snippet": "int get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"free_rect: already bs_x invalidated: %d bs_x: %d\\n\"",
            "idx",
            "x"
          ],
          "line": 6217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 6217
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLEAR",
          "args": [
            "idx"
          ],
          "line": 6216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"free_rect: bad index: %d\\n\"",
            "idx"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
  },
  {
    "function_name": "MState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6191-6196",
    "snippet": "char *MState(int state) {\n\tif (state == IsViewable)\treturn \"IsViewable\";\n\tif (state == IsUnmapped)\treturn \"IsUnmapped\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "unk",
            "\"Unknown %d\"",
            "state"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *MState(int state) {\n\tif (state == IsViewable)\treturn \"IsViewable\";\n\tif (state == IsUnmapped)\treturn \"IsUnmapped\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}"
  },
  {
    "function_name": "VState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6184-6190",
    "snippet": "char *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "unk",
            "\"Unknown %d\"",
            "state"
          ],
          "line": 6188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *VState(int state) {\n\tif (state == VisibilityFullyObscured)\t\treturn \"VisibilityFullyObscured\";\n\tif (state == VisibilityPartiallyObscured)\treturn \"VisibilityPartiallyObscured\";\n\tif (state == VisibilityUnobscured)\t\treturn \"VisibilityUnobscured\";\n\tsprintf(unk, \"Unknown %d\", state);\n\treturn unk;\n}"
  },
  {
    "function_name": "Etype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6146-6183",
    "snippet": "char *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "unk",
            "\"Unknown %d\"",
            "type"
          ],
          "line": 6181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *Etype(int type) {\n\tif (type == KeyPress)\t\treturn \"KeyPress\";\n\tif (type == KeyRelease)\t\treturn \"KeyRelease\";\n\tif (type == ButtonPress)\treturn \"ButtonPress\";\n\tif (type == ButtonRelease)\treturn \"ButtonRelease\";\n\tif (type == MotionNotify)\treturn \"MotionNotify\";\n\tif (type == EnterNotify)\treturn \"EnterNotify\";\n\tif (type == LeaveNotify)\treturn \"LeaveNotify\";\n\tif (type == FocusIn)\t\treturn \"FocusIn\";\n\tif (type == FocusOut)\t\treturn \"FocusOut\";\n\tif (type == KeymapNotify)\treturn \"KeymapNotify\";\n\tif (type == Expose)\t\treturn \"Expose\";\n\tif (type == GraphicsExpose)\treturn \"GraphicsExpose\";\n\tif (type == NoExpose)\t\treturn \"NoExpose\";\n\tif (type == VisibilityNotify)\treturn \"VisibilityNotify\";\n\tif (type == CreateNotify)\treturn \"CreateNotify\";\n\tif (type == DestroyNotify)\treturn \"DestroyNotify\";\n\tif (type == UnmapNotify)\treturn \"UnmapNotify\";\n\tif (type == MapNotify)\t\treturn \"MapNotify\";\n\tif (type == MapRequest)\t\treturn \"MapRequest\";\n\tif (type == ReparentNotify)\treturn \"ReparentNotify\";\n\tif (type == ConfigureNotify)\treturn \"ConfigureNotify\";\n\tif (type == ConfigureRequest)\treturn \"ConfigureRequest\";\n\tif (type == GravityNotify)\treturn \"GravityNotify\";\n\tif (type == ResizeRequest)\treturn \"ResizeRequest\";\n\tif (type == CirculateNotify)\treturn \"CirculateNotify\";\n\tif (type == CirculateRequest)\treturn \"CirculateRequest\";\n\tif (type == PropertyNotify)\treturn \"PropertyNotify\";\n\tif (type == SelectionClear)\treturn \"SelectionClear\";\n\tif (type == SelectionRequest)\treturn \"SelectionRequest\";\n\tif (type == SelectionNotify)\treturn \"SelectionNotify\";\n\tif (type == ColormapNotify)\treturn \"ColormapNotify\";\n\tif (type == ClientMessage)\treturn \"ClientMessage\";\n\tif (type == MappingNotify)\treturn \"MappingNotify\";\n\tif (type == LASTEvent)\t\treturn \"LASTEvent\";\n\tsprintf(unk, \"Unknown %d\", type);\n\treturn unk;\n}"
  },
  {
    "function_name": "lookup_old_stack_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6074-6093",
    "snippet": "int lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snap_old_index",
          "args": [],
          "line": 6081
        },
        "resolved": true,
        "details": {
          "function_name": "snap_old_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6059-6072",
          "snippet": "void snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_old_stack_index(int ic) {\n\tint idx = old_stack_index[ic];\n\n\tif (idx < 0) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].win != old_stack[ic]) {\n\t\tsnap_old_index();\n\t}\n\tidx = old_stack_index[ic];\n\tif (idx < 0 || cache_list[idx].win != old_stack[ic]) {\n\t\treturn -1;\n\t}\n\tif (cache_list[idx].map_state == IsViewable) {\n\t\told_stack_mapped[ic] = 1;\n\t} else {\n\t\told_stack_mapped[ic] = 0;\n\t}\n\treturn idx;\n}"
  },
  {
    "function_name": "snap_old_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6059-6072",
    "snippet": "void snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "old_stack[i]"
          ],
          "line": 6062
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "snap_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "6039-6057",
    "snippet": "void snap_old(void) {\n\tint i;\n\told_stack_n = STACKMAX;\n\tquick_snap(old_stack, &old_stack_n);\nif (0) fprintf(stderr, \"snap_old: %d  %.4f\\n\", old_stack_n, dnowx());\n#if 0\n\tfor (i= old_stack_n - 1; i >= 0; i--) {\n\t\tint idx = lookup_win_index(old_stack[i]);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"   %03d  0x%x\\n\", i, old_stack[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tfor (i=0; i < old_stack_n; i++) {\n\t\told_stack_mapped[i] = -1;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define STACKMAX 4096"
    ],
    "globals_used": [
      "winattr_t *cache_list;",
      "int clipped(int idx);",
      "void snap_old(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   %03d  0x%x\\n\"",
            "i",
            "old_stack[i]"
          ],
          "line": 6049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "old_stack[i]"
          ],
          "line": 6046
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"snap_old: %d  %.4f\\n\"",
            "old_stack_n",
            "dnowx()"
          ],
          "line": 6043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quick_snap",
          "args": [
            "old_stack",
            "&old_stack_n"
          ],
          "line": 6042
        },
        "resolved": true,
        "details": {
          "function_name": "quick_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5862-5910",
          "snippet": "void quick_snap(Window *wins, int *size) {\n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n#ifdef MACOSX\n\tif (1 || ! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc || num == 0) {\n\t\t*size = 0;\n\t\treturn;\n\t} else {\n\t\tint m = *size;\n\t\tif (num < m) {\n\t\t\tm = num;\n\t\t}\n\t\tfor (i=0; i < m; i++) {\n\t\t\twins[i] = list[i];\n\t\t}\n\t\tif (num) {\n\t\t\tX_LOCK;\n\t\t\tXFree_wr(list);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\t*size = m;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);",
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;",
            "static void destroy_str_list(char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\nstatic void destroy_str_list(char **list);\n\nvoid quick_snap(Window *wins, int *size) {\n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n#ifdef MACOSX\n\tif (1 || ! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc || num == 0) {\n\t\t*size = 0;\n\t\treturn;\n\t} else {\n\t\tint m = *size;\n\t\tif (num < m) {\n\t\t\tm = num;\n\t\t}\n\t\tfor (i=0; i < m; i++) {\n\t\t\twins[i] = list[i];\n\t\t}\n\t\tif (num) {\n\t\t\tX_LOCK;\n\t\t\tXFree_wr(list);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\t*size = m;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define STACKMAX 4096\n\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nvoid snap_old(void) {\n\tint i;\n\told_stack_n = STACKMAX;\n\tquick_snap(old_stack, &old_stack_n);\nif (0) fprintf(stderr, \"snap_old: %d  %.4f\\n\", old_stack_n, dnowx());\n#if 0\n\tfor (i= old_stack_n - 1; i >= 0; i--) {\n\t\tint idx = lookup_win_index(old_stack[i]);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"   %03d  0x%x\\n\", i, old_stack[i]);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tfor (i=0; i < old_stack_n; i++) {\n\t\told_stack_mapped[i] = -1;\n\t}\n}"
  },
  {
    "function_name": "lookup_free_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5976-6025",
    "snippet": "int lookup_free_index(void) {\n\tint k;\n\n\tif (rfree >= 0) {\n\t\tif (cache_list[rfree].win == None) {\nif (ncdb) fprintf(stderr, \"lookup_freeA: %d\\n\", rfree);\n\t\t\treturn rfree;\n\t\t}\n\t}\n\trfree = -1;\n\tfor(k=0; k<cache_list_num; k++) {\n\t\tif (cache_list[k].win == None) {\n\t\t\trfree = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rfree < 0) {\n\t\tif (ncdb) fprintf(stderr, \"*** LOOKUP_FREE_INDEX: incrementing cache_list_num %d/%d\\n\", cache_list_num, cache_list_len);\n\n\t\trfree = cache_list_num++;\n\t\tif (rfree >= cache_list_len)  {\n\t\t\tint i, n = 2*cache_list_len;\n\t\t\twinattr_t *cache_new;\n\n\t\t\tif (ncdb) fprintf(stderr, \"lookup_free_index: growing cache_list_len: %d -> %d\\n\", cache_list_len, n);\n\n\t\t\tcache_new = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\t\tfor (i=0; i<cache_list_num-1; i++) {\n\t\t\t\tcache_new[i] = cache_list[i]; \n\t\t\t}\n\t\t\tcache_list_len = n;\n\t\t\tfree(cache_list);\n\t\t\tcache_list = cache_new;\n\t\t}\n\t\tcache_list[rfree].win = None;\n\t\tcache_list[rfree].fetched = 0;\n\t\tcache_list[rfree].valid = 0;\n\t\tcache_list[rfree].time = 0.0;\n\t\tcache_list[rfree].selectinput = 0;\n\t\tcache_list[rfree].vis_cnt = 0;\n\t\tcache_list[rfree].map_cnt = 0;\n\t\tcache_list[rfree].unmap_cnt = 0;\n\t\tcache_list[rfree].create_cnt = 0;\n\t\tcache_list[rfree].vis_state = -1;\n\t\tcache_list[rfree].above = None;\n\t}\n\nif (ncdb) fprintf(stderr, \"lookup_freeB: %d\\n\", rfree);\n\treturn rfree;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "winattr_t *cache_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_freeB: %d\\n\"",
            "rfree"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cache_list"
          ],
          "line": 6007
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "n*sizeof(winattr_t)",
            "1"
          ],
          "line": 6002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_free_index: growing cache_list_len: %d -> %d\\n\"",
            "cache_list_len",
            "n"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** LOOKUP_FREE_INDEX: incrementing cache_list_num %d/%d\\n\"",
            "cache_list_num",
            "cache_list_len"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_freeA: %d\\n\"",
            "rfree"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nwinattr_t *cache_list;\n\nint lookup_free_index(void) {\n\tint k;\n\n\tif (rfree >= 0) {\n\t\tif (cache_list[rfree].win == None) {\nif (ncdb) fprintf(stderr, \"lookup_freeA: %d\\n\", rfree);\n\t\t\treturn rfree;\n\t\t}\n\t}\n\trfree = -1;\n\tfor(k=0; k<cache_list_num; k++) {\n\t\tif (cache_list[k].win == None) {\n\t\t\trfree = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rfree < 0) {\n\t\tif (ncdb) fprintf(stderr, \"*** LOOKUP_FREE_INDEX: incrementing cache_list_num %d/%d\\n\", cache_list_num, cache_list_len);\n\n\t\trfree = cache_list_num++;\n\t\tif (rfree >= cache_list_len)  {\n\t\t\tint i, n = 2*cache_list_len;\n\t\t\twinattr_t *cache_new;\n\n\t\t\tif (ncdb) fprintf(stderr, \"lookup_free_index: growing cache_list_len: %d -> %d\\n\", cache_list_len, n);\n\n\t\t\tcache_new = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\t\tfor (i=0; i<cache_list_num-1; i++) {\n\t\t\t\tcache_new[i] = cache_list[i]; \n\t\t\t}\n\t\t\tcache_list_len = n;\n\t\t\tfree(cache_list);\n\t\t\tcache_list = cache_new;\n\t\t}\n\t\tcache_list[rfree].win = None;\n\t\tcache_list[rfree].fetched = 0;\n\t\tcache_list[rfree].valid = 0;\n\t\tcache_list[rfree].time = 0.0;\n\t\tcache_list[rfree].selectinput = 0;\n\t\tcache_list[rfree].vis_cnt = 0;\n\t\tcache_list[rfree].map_cnt = 0;\n\t\tcache_list[rfree].unmap_cnt = 0;\n\t\tcache_list[rfree].create_cnt = 0;\n\t\tcache_list[rfree].vis_state = -1;\n\t\tcache_list[rfree].above = None;\n\t}\n\nif (ncdb) fprintf(stderr, \"lookup_freeB: %d\\n\", rfree);\n\treturn rfree;\n}"
  },
  {
    "function_name": "lookup_win_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5927-5974",
    "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NRECENT 32"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_win_index recent hit stats: %d/%d/%d\\n\"",
            "s1",
            "s2",
            "s3"
          ],
          "line": 5970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recentC(fail): %d  0x%lx\\n\"",
            "idx",
            "win"
          ],
          "line": 5966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recentB(normal): %d  0x%lx\\n\"",
            "idx",
            "win"
          ],
          "line": 5954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recentA(shortcut): %d  0x%lx\\n\"",
            "idx",
            "win"
          ],
          "line": 5940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
  },
  {
    "function_name": "get_bs_n",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5912-5920",
    "snippet": "int get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_bs_n(int y) {\n\tint n;\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tif (n*dpy_y <= y && y < (n+1)*dpy_y) {\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "quick_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5862-5910",
    "snippet": "void quick_snap(Window *wins, int *size) {\n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n#ifdef MACOSX\n\tif (1 || ! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc || num == 0) {\n\t\t*size = 0;\n\t\treturn;\n\t} else {\n\t\tint m = *size;\n\t\tif (num < m) {\n\t\t\tm = num;\n\t\t}\n\t\tfor (i=0; i < m; i++) {\n\t\t\twins[i] = list[i];\n\t\t}\n\t\tif (num) {\n\t\t\tX_LOCK;\n\t\t\tXFree_wr(list);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\t*size = m;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int lookup_win_index(Window);",
      "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;",
      "static void destroy_str_list(char **list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "list"
          ],
          "line": 5904
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&w",
            "&list",
            "&ui"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\nstatic void destroy_str_list(char **list);\n\nvoid quick_snap(Window *wins, int *size) {\n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n#ifdef MACOSX\n\tif (1 || ! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc || num == 0) {\n\t\t*size = 0;\n\t\treturn;\n\t} else {\n\t\tint m = *size;\n\t\tif (num < m) {\n\t\t\tm = num;\n\t\t}\n\t\tfor (i=0; i < m; i++) {\n\t\t\twins[i] = list[i];\n\t\t}\n\t\tif (num) {\n\t\t\tX_LOCK;\n\t\t\tXFree_wr(list);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\t*size = m;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "snapshot_cache_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5756-5860",
    "snippet": "void snapshot_cache_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\tint start = 512;\n\n\tif (! cache_list) {\n\t\tcache_list = (winattr_t *) calloc(start*sizeof(winattr_t), 1);\n\t\tcache_list_num = 0;\n\t\tcache_list_len = start;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (cache_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tcache_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num > cache_list_len) {\n\t\tint n = 2*num;\n\t\tn = num + 3;\n\t\tfree(cache_list);\n\t\tcache_list = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\tcache_list_len = n;\n\t}\n\tfor (i=0; i<num; i++) {\n\t\tcache_list[i].win = list[i];\n\t\tcache_list[i].fetched = 0;\n\t\tcache_list[i].valid = 0;\n\t\tcache_list[i].time = now;\n\t\tcache_list[i].selectinput = 0;\n\t\tcache_list[i].vis_cnt = 0;\n\t\tcache_list[i].map_cnt = 0;\n\t\tcache_list[i].unmap_cnt = 0;\n\t\tcache_list[i].create_cnt = 0;\n\t\tcache_list[i].vis_state = -1;\n\t\tcache_list[i].above = None;\n\t}\n\tif (num == 0) {\n\t\tcache_list[0].win = None;\n\t\tcache_list[0].fetched = 0;\n\t\tcache_list[0].valid = 0;\n\t\tcache_list[0].time = now;\n\t\tcache_list[0].selectinput = 0;\n\t\tcache_list[0].vis_cnt = 0;\n\t\tcache_list[0].map_cnt = 0;\n\t\tcache_list[0].unmap_cnt = 0;\n\t\tcache_list[0].create_cnt = 0;\n\t\tcache_list[0].vis_state = -1;\n\t\tcache_list[0].above = None;\n\t\tnum++;\n\t}\n\n\tcache_list_num = num;\n\n\tif (num) {\n\t\tX_LOCK;\n\t\tXFree_wr(list);\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;",
      "static void destroy_str_list(char **list);",
      "winattr_t *cache_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "list"
          ],
          "line": 5856
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "n*sizeof(winattr_t)",
            "1"
          ],
          "line": 5821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cache_list"
          ],
          "line": 5820
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&w",
            "&list",
            "&ui"
          ],
          "line": 5805
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&now"
          ],
          "line": 5771
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "start*sizeof(winattr_t)",
            "1"
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\nstatic void destroy_str_list(char **list);\nwinattr_t *cache_list;\n\nvoid snapshot_cache_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\tint start = 512;\n\n\tif (! cache_list) {\n\t\tcache_list = (winattr_t *) calloc(start*sizeof(winattr_t), 1);\n\t\tcache_list_num = 0;\n\t\tcache_list_len = start;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (cache_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tcache_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tX_UNLOCK;\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tcache_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num > cache_list_len) {\n\t\tint n = 2*num;\n\t\tn = num + 3;\n\t\tfree(cache_list);\n\t\tcache_list = (winattr_t *) calloc(n*sizeof(winattr_t), 1);\n\t\tcache_list_len = n;\n\t}\n\tfor (i=0; i<num; i++) {\n\t\tcache_list[i].win = list[i];\n\t\tcache_list[i].fetched = 0;\n\t\tcache_list[i].valid = 0;\n\t\tcache_list[i].time = now;\n\t\tcache_list[i].selectinput = 0;\n\t\tcache_list[i].vis_cnt = 0;\n\t\tcache_list[i].map_cnt = 0;\n\t\tcache_list[i].unmap_cnt = 0;\n\t\tcache_list[i].create_cnt = 0;\n\t\tcache_list[i].vis_state = -1;\n\t\tcache_list[i].above = None;\n\t}\n\tif (num == 0) {\n\t\tcache_list[0].win = None;\n\t\tcache_list[0].fetched = 0;\n\t\tcache_list[0].valid = 0;\n\t\tcache_list[0].time = now;\n\t\tcache_list[0].selectinput = 0;\n\t\tcache_list[0].vis_cnt = 0;\n\t\tcache_list[0].map_cnt = 0;\n\t\tcache_list[0].unmap_cnt = 0;\n\t\tcache_list[0].create_cnt = 0;\n\t\tcache_list[0].vis_state = -1;\n\t\tcache_list[0].above = None;\n\t\tnum++;\n\t}\n\n\tcache_list_num = num;\n\n\tif (num) {\n\t\tX_LOCK;\n\t\tXFree_wr(list);\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_ncache_xrootpmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5746-5748",
    "snippet": "void set_ncache_xrootpmap(void) {\n\treturn;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_ncache_xrootpmap(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_ncache_xrootpmap(void);\n\nvoid set_ncache_xrootpmap(void) {\n\treturn;\n}"
  },
  {
    "function_name": "try_to_fix_resize_su",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5741-5745",
    "snippet": "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\tif (!orig_frame || !orig_x || !orig_y || !orig_w || !orig_h || !x || !y || !w || !h || !try_batch) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\n\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\tif (!orig_frame || !orig_x || !orig_y || !orig_w || !orig_h || !x || !y || !w || !h || !try_batch) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "try_to_fix_su",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5737-5740",
    "snippet": "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tif (!win || !idx || !above || !nbatch || !mode) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "int lookup_win_index(Window);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "int clipped(int idx);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint clipped(int idx);\n\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tif (!win || !idx || !above || !nbatch || !mode) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "bs_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5733-5736",
    "snippet": "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tif (!idx || !nbatch || !rmask || !attr || !clip || !nopad || !valid || !verb) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "int clipped(int idx);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nint clipped(int idx);\n\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tif (!idx || !nbatch || !rmask || !attr || !clip || !nopad || !valid || !verb) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "clipped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5729-5732",
    "snippet": "int clipped(int idx) {\n\tif (!idx) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int clipped(int idx);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint clipped(int idx);\n\nint clipped(int idx) {\n\tif (!idx) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "snap_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5726-5728",
    "snippet": "void snap_old(void) {\n\treturn;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void snap_old(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid snap_old(void);\n\nvoid snap_old(void) {\n\treturn;\n}"
  },
  {
    "function_name": "find_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5722-5725",
    "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tif (!idx || !x || !y || !w || !h) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int clipped(int idx);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tif (!idx || !x || !y || !w || !h) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_win_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5718-5721",
    "snippet": "int lookup_win_index(Window win) {\n\tif (!win) {}\n\treturn -1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nint lookup_win_index(Window win) {\n\tif (!win) {}\n\treturn -1;\n}"
  },
  {
    "function_name": "check_ncache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5713-5717",
    "snippet": "int check_ncache(int a, int b) {\n\tif (!a || !b) {}\n\tncache = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_ncache(int a, int b) {\n\tif (!a || !b) {}\n\tncache = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "check_user_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5631-5710",
    "snippet": "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt) {\n\n\tif (rawfb_vnc_reflect) {\n\t\tif (got_user_input) {\n\t\t\tif (0) vnc_reflect_process_client();\n\t\t}\n\t\tif (got_user_input && *cnt % ui_skip != 0) {\n\t\t\t/* every n-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t}\n\t}\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (use_xrecord) {\n\t\tint rc = check_xrecord();\n\t\t/*\n\t\t * 0: nothing found, proceed to other user input schemes.\n\t\t * 1: events found, want to do a screen update now.\n\t\t * 2: events found, want to loop back for some more.\n\t\t * 3: events found, want to loop back for some more,\n\t\t *    and not have rfbPE() called.\n\t\t *\n\t\t * For 0, we precede below, otherwise return rc-1.\n\t\t */\nif (debug_scroll && rc > 1) fprintf(stderr, \"  CXR: check_user_input ret %d\\n\", rc - 1);\n\t\tif (rc == 0) {\n\t\t\t;\t/* proceed below. */\n\t\t} else {\n\t\t\treturn rc - 1;\n\t\t}\n\t}\n\n\tif (wireframe) {\n\t\tif (check_wireframe()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pointer_mode == 1) {\n\t\tif ((got_user_input || ui_skip < 0) && *cnt % ui_skip != 0) {\n\t\t\t/* every ui_skip-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (pointer_mode >= 2 && pointer_mode <= 4) {\n\t\tif (got_keyboard_input) {\n\t\t\t/*\n\t\t\t * for these modes, short circuit watch_loop on\n\t\t\t * *keyboard* input.\n\t\t\t */\n\t\t\tif (*cnt % ui_skip != 0) {\n\t\t\t\t*cnt = *cnt + 1; \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* otherwise continue below with pointer input method */\n\t}\n\n\tif (pointer_mode == 2) {\n\t\tcheck_user_input2(dt);\n\t} else if (pointer_mode == 3) {\n\t\tcheck_user_input3(dt, dtr, tile_diffs);\n\t} else if (pointer_mode == 4) {\n\t\tcheck_user_input4(dt, dtr, tile_diffs);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_xrecord(void);",
      "int check_wireframe(void);",
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "static void check_user_input2(double dt);",
      "static void check_user_input3(double dt, double dtr, int tile_diffs);",
      "static void check_user_input4(double dt, double dtr, int tile_diffs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_user_input4",
          "args": [
            "dt",
            "dtr",
            "tile_diffs"
          ],
          "line": 5707
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_input4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5421-5629",
          "snippet": "static void check_user_input4(double dt, double dtr, int tile_diffs) {\n\n\tint g, g_in, i, ginput, gcnt, tmp;\n\tint last_was_miss, consecutive_misses;\n\tint min_frame_size = 10;\t/* 10 tiles */\n\tdouble spin, tm, to, tc, dtm, rpe_last;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.050;\n\tstatic int first = 1;\n\n\tint Btile = tile_x * tile_y * bpp/8; \t/* Bytes per tile */\n\tdouble Ttile, dt_use;\n\tdouble screen_rate = 6000000.;    /* 5 MB/sec */\n\tdouble vnccpu_rate = 80 * 100000.; /* 20 KB/sec @ 80X compression */\n\tdouble net_rate = 50000.;\n\tstatic double Tfac_r = 1.0, Tfac_v = 1.0, Tfac_n = 1.0, Tdelay = 0.001;\n\tstatic double dt_min = -1.0, dt_max = -1.0;\n\tdouble dt_min_fallback = 0.050;\n\tstatic int ssec = 0, total_calls = 0;\n\tstatic int push_frame = 0, update_count = 0;\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tsscanf(p, \"%lf,%lf,%lf,%lf\", &dt_cut, &Tfac_r, &Tfac_v, &Tfac_n);\n\t\t}\n\t\tfirst = 0;\n\t\tssec = time(NULL);\n\n\t\tif (dtr) {}\t/* unused vars warning: */\n\t}\n\n\ttotal_calls++;\n\n\tif (dt_min < 0.0 || dt < dt_min) {\n\t\tif (dt > 0.0) {\n\t\t\tdt_min = dt;\n\t\t}\n\t}\n\tif (dt_min < 0.0) {\n\t\t/* sensible value for the very 1st call if dt = 0.0 */\n\t\tdt_min = dt_min_fallback;\n\t}\n\tif (dt_max < 0.0 || dt > dt_max) {\n\t\tdt_max = dt;\n\t}\n\n\tif (total_calls > 30 && dt_min > 0.0) {\n\t\tstatic int first = 1;\n\t\t/*\n\t\t * dt_min will soon be the quickest time to do\n\t\t * one scan_for_updates with no tiles copied.\n\t\t * use this (instead of copy_tiles) to estimate\n\t\t * screen read rate.\n\t\t */\n\t\tscreen_rate = (main_bytes_per_line * ntiles_y) / dt_min;\n\t\tif (first) {\n\t\t\trfbLog(\"measured screen read rate: %.2f Bytes/sec\\n\",\n\t\t\t    screen_rate);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tdtime0(&tm);\n\n\tif (dt < dt_cut) {\n\t\tdt_use = dt_cut;\n\t} else {\n\t\tdt_use = dt;\n\t}\n\n\tif (push_frame) {\n\t\tint cnt, iter = 0;\n\t\tdouble tp, push_spin = 0.0;\n\t\tdtime0(&tp);\n\t\twhile (push_spin < dt_use * 0.5) {\n\t\t\tfb_update_sent(&cnt);\n\t\t\tif (cnt != update_count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* damn, they didn't push our frame! */\n\t\t\titer++;\n\t\t\trfbPE(rfb_wait_ms * 1000);\n\t\t\t\n\t\t\tpush_spin += dtime(&tp);\n\t\t}\n\t\tif (iter) {\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tpush_frame = 0;\n\t\tupdate_count = 0;\n\t}\n\n\t/*\n\t * when we first enter we require some pointer input\n\t */\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\tvnccpu_rate = get_raw_rate();\n\n\tif ((tmp = get_read_rate()) != 0) {\n\t\tscreen_rate = (double) tmp;\n\t}\n\tif ((tmp = get_net_rate()) != 0) {\n\t\tnet_rate = (double) tmp;\n\t}\n\tnet_rate = (vnccpu_rate/get_cmp_rate()) * net_rate;\n\n\tif ((tmp = get_net_latency()) != 0) {\n\t\tTdelay = 0.5 * ((double) tmp)/1000.;\n\t}\n\n\tTtile = Btile * (Tfac_r/screen_rate + Tfac_v/vnccpu_rate + Tfac_n/net_rate);\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\trpe_last = to = tc = tm;\t/* last time we did rfbPE() */\n\tg = g_in = got_pointer_input;\n\n\ttile_diffs = 0;\t/* reset our knowlegde of tile_diffs to zero */\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\t/* this varible is used by our pointer handler */\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\t/* turn libvncserver crank to process events: */\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif ( (gcnt == 1 && got_pointer_input > g) || tm-tc > 2*dt_min) {\n\t\t\ttile_diffs = scan_for_updates(1);\n\t\t\ttc = tm;\n\t\t}\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (tile_diffs > min_frame_size && spin > Ttile * tile_diffs + Tdelay) {\n\t\t\t/* we think we can push the frame */\n\t\t\tpush_frame = 1;\n\t\t\tfb_update_sent(&update_count);\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush it to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t} else if (consecutive_misses >= 2) {\n\t\t\t/* too many misses in a row */\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t/* these are pointer input misses */\n\t\t\tint wms;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait for\n\t\t\t\t * a defer time. (e.g. on slow link)\n\t\t\t\t * hopefully client will batch many\n\t\t\t\t * of them for the next read.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t\twms = 0;\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\tdrag_in_progress = 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "static void check_user_input2(double dt);",
            "static void check_user_input3(double dt, double dtr, int tile_diffs);",
            "static void check_user_input4(double dt, double dtr, int tile_diffs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nstatic void check_user_input4(double dt, double dtr, int tile_diffs) {\n\n\tint g, g_in, i, ginput, gcnt, tmp;\n\tint last_was_miss, consecutive_misses;\n\tint min_frame_size = 10;\t/* 10 tiles */\n\tdouble spin, tm, to, tc, dtm, rpe_last;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.050;\n\tstatic int first = 1;\n\n\tint Btile = tile_x * tile_y * bpp/8; \t/* Bytes per tile */\n\tdouble Ttile, dt_use;\n\tdouble screen_rate = 6000000.;    /* 5 MB/sec */\n\tdouble vnccpu_rate = 80 * 100000.; /* 20 KB/sec @ 80X compression */\n\tdouble net_rate = 50000.;\n\tstatic double Tfac_r = 1.0, Tfac_v = 1.0, Tfac_n = 1.0, Tdelay = 0.001;\n\tstatic double dt_min = -1.0, dt_max = -1.0;\n\tdouble dt_min_fallback = 0.050;\n\tstatic int ssec = 0, total_calls = 0;\n\tstatic int push_frame = 0, update_count = 0;\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tsscanf(p, \"%lf,%lf,%lf,%lf\", &dt_cut, &Tfac_r, &Tfac_v, &Tfac_n);\n\t\t}\n\t\tfirst = 0;\n\t\tssec = time(NULL);\n\n\t\tif (dtr) {}\t/* unused vars warning: */\n\t}\n\n\ttotal_calls++;\n\n\tif (dt_min < 0.0 || dt < dt_min) {\n\t\tif (dt > 0.0) {\n\t\t\tdt_min = dt;\n\t\t}\n\t}\n\tif (dt_min < 0.0) {\n\t\t/* sensible value for the very 1st call if dt = 0.0 */\n\t\tdt_min = dt_min_fallback;\n\t}\n\tif (dt_max < 0.0 || dt > dt_max) {\n\t\tdt_max = dt;\n\t}\n\n\tif (total_calls > 30 && dt_min > 0.0) {\n\t\tstatic int first = 1;\n\t\t/*\n\t\t * dt_min will soon be the quickest time to do\n\t\t * one scan_for_updates with no tiles copied.\n\t\t * use this (instead of copy_tiles) to estimate\n\t\t * screen read rate.\n\t\t */\n\t\tscreen_rate = (main_bytes_per_line * ntiles_y) / dt_min;\n\t\tif (first) {\n\t\t\trfbLog(\"measured screen read rate: %.2f Bytes/sec\\n\",\n\t\t\t    screen_rate);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tdtime0(&tm);\n\n\tif (dt < dt_cut) {\n\t\tdt_use = dt_cut;\n\t} else {\n\t\tdt_use = dt;\n\t}\n\n\tif (push_frame) {\n\t\tint cnt, iter = 0;\n\t\tdouble tp, push_spin = 0.0;\n\t\tdtime0(&tp);\n\t\twhile (push_spin < dt_use * 0.5) {\n\t\t\tfb_update_sent(&cnt);\n\t\t\tif (cnt != update_count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* damn, they didn't push our frame! */\n\t\t\titer++;\n\t\t\trfbPE(rfb_wait_ms * 1000);\n\t\t\t\n\t\t\tpush_spin += dtime(&tp);\n\t\t}\n\t\tif (iter) {\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tpush_frame = 0;\n\t\tupdate_count = 0;\n\t}\n\n\t/*\n\t * when we first enter we require some pointer input\n\t */\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\tvnccpu_rate = get_raw_rate();\n\n\tif ((tmp = get_read_rate()) != 0) {\n\t\tscreen_rate = (double) tmp;\n\t}\n\tif ((tmp = get_net_rate()) != 0) {\n\t\tnet_rate = (double) tmp;\n\t}\n\tnet_rate = (vnccpu_rate/get_cmp_rate()) * net_rate;\n\n\tif ((tmp = get_net_latency()) != 0) {\n\t\tTdelay = 0.5 * ((double) tmp)/1000.;\n\t}\n\n\tTtile = Btile * (Tfac_r/screen_rate + Tfac_v/vnccpu_rate + Tfac_n/net_rate);\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\trpe_last = to = tc = tm;\t/* last time we did rfbPE() */\n\tg = g_in = got_pointer_input;\n\n\ttile_diffs = 0;\t/* reset our knowlegde of tile_diffs to zero */\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\t/* this varible is used by our pointer handler */\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\t/* turn libvncserver crank to process events: */\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif ( (gcnt == 1 && got_pointer_input > g) || tm-tc > 2*dt_min) {\n\t\t\ttile_diffs = scan_for_updates(1);\n\t\t\ttc = tm;\n\t\t}\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (tile_diffs > min_frame_size && spin > Ttile * tile_diffs + Tdelay) {\n\t\t\t/* we think we can push the frame */\n\t\t\tpush_frame = 1;\n\t\t\tfb_update_sent(&update_count);\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush it to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t} else if (consecutive_misses >= 2) {\n\t\t\t/* too many misses in a row */\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t/* these are pointer input misses */\n\t\t\tint wms;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait for\n\t\t\t\t * a defer time. (e.g. on slow link)\n\t\t\t\t * hopefully client will batch many\n\t\t\t\t * of them for the next read.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t\twms = 0;\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\tdrag_in_progress = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_user_input3",
          "args": [
            "dt",
            "dtr",
            "tile_diffs"
          ],
          "line": 5705
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_input3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5270-5388",
          "snippet": "static void check_user_input3(double dt, double dtr, int tile_diffs) {\n\n\tint allowed_misses, miss_tweak, i, g, g_in;\n\tint last_was_miss, consecutive_misses;\n\tdouble spin, spin_max, tm, to, dtm;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.075;\n\tint gcnt, ginput;\n\tstatic int first = 1;\n\n\tif (dtr || tile_diffs) {} /* unused vars warning: */\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tdouble junk;\n\t\t\tsscanf(p, \"%lf,%lf\", &dt_cut, &junk);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\n\tif (dt < dt_cut) {\n\t\tdt = dt_cut;\t/* this is to try to avoid early exit */\n\t}\n\tspin_max = 0.5;\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tallowed_misses = 10;\t/* number of ptr inputs we can miss */\n\tmiss_tweak = 8;\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\tdtime0(&tm);\n\tto = tm;\t/* last time we did rfbPE() */\n\n\tg = g_in = got_pointer_input;\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tif (ginput % miss_tweak == 0) {\n\t\t\t\tallowed_misses++;\n\t\t\t}\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (spin > spin_max) {\n\t\t\t/* get out if spin time over limit */\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t} else if (--allowed_misses <= 0) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else if (consecutive_misses >=3) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* these are misses */\n\t\t\tint wms = 0;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait\n\t\t\t\t * for a defer time. (e.g. on\n\t\t\t\t * slow link) hopefully client\n\t\t\t\t * will batch them.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\n\tdrag_in_progress = 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_user_input2(double dt);",
            "static void check_user_input3(double dt, double dtr, int tile_diffs);",
            "static void check_user_input4(double dt, double dtr, int tile_diffs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nstatic void check_user_input3(double dt, double dtr, int tile_diffs) {\n\n\tint allowed_misses, miss_tweak, i, g, g_in;\n\tint last_was_miss, consecutive_misses;\n\tdouble spin, spin_max, tm, to, dtm;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.075;\n\tint gcnt, ginput;\n\tstatic int first = 1;\n\n\tif (dtr || tile_diffs) {} /* unused vars warning: */\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tdouble junk;\n\t\t\tsscanf(p, \"%lf,%lf\", &dt_cut, &junk);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\n\tif (dt < dt_cut) {\n\t\tdt = dt_cut;\t/* this is to try to avoid early exit */\n\t}\n\tspin_max = 0.5;\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tallowed_misses = 10;\t/* number of ptr inputs we can miss */\n\tmiss_tweak = 8;\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\tdtime0(&tm);\n\tto = tm;\t/* last time we did rfbPE() */\n\n\tg = g_in = got_pointer_input;\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tif (ginput % miss_tweak == 0) {\n\t\t\t\tallowed_misses++;\n\t\t\t}\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (spin > spin_max) {\n\t\t\t/* get out if spin time over limit */\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t} else if (--allowed_misses <= 0) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else if (consecutive_misses >=3) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* these are misses */\n\t\t\tint wms = 0;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait\n\t\t\t\t * for a defer time. (e.g. on\n\t\t\t\t * slow link) hopefully client\n\t\t\t\t * will batch them.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\n\tdrag_in_progress = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_user_input2",
          "args": [
            "dt"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_input2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5124-5268",
          "snippet": "static void check_user_input2(double dt) {\n\n\tint eaten = 0, miss = 0, max_eat = 50, do_flush = 1;\n\tint g, g_in;\n\tdouble spin = 0.0, tm;\n\tdouble quick_spin_fac  = 0.40;\n\tdouble grind_spin_time = 0.175;\n\n\tdtime0(&tm);\n\tg = g_in = got_pointer_input;\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\t/*\n\t * Try for some \"quick\" pointer input processing.\n\t *\n\t * About as fast as we can, we try to process user input calling\n\t * rfbProcessEvents or rfbCheckFds.  We do this for a time on\n\t * order of the last scan_for_updates() time, dt, but if we stop\n\t * getting user input we break out.  We will also break out if\n\t * we have processed max_eat inputs.\n\t *\n\t * Note that rfbCheckFds() does not send any framebuffer updates,\n\t * so is more what we want here, although it is likely they have\n\t * all be sent already.\n\t */\n\twhile (1) {\n\t\tif (show_multiple_cursors) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\trfbCFD(0);\n\n\t\tspin += dtime(&tm);\n\n\t\tif (spin > quick_spin_fac * dt) {\n\t\t\t/* get out if spin time comparable to last scan time */\n\t\t\tbreak;\n\t\t}\n\t\tif (got_pointer_input > g) {\n\t\t\tint i, max_extra = max_eat / 2;\n\t\t\tg = got_pointer_input;\n\t\t\teaten++;\n\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\trfbCFD(0);\n\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\teaten++;\n\t\t\t\t} else if (i > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_LOCK;\n\t\t\tdo_flush = 0;\nif (0) fprintf(stderr, \"check_user_input2-A: XFlush %.4f\\n\", tm);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tif (eaten < max_eat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tmiss++;\n\t\t}\n\t\tif (miss > 1) {\t/* 1 means out on 2nd miss */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_flush) {\n\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-B: XFlush %.4f\\n\", tm);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t}\n\n\n\t/*\n\t * Probably grinding with a lot of fb I/O if dt is this large.\n\t * (need to do this more elegantly)\n\t *\n\t * Current idea is to spin our wheels here *not* processing any\n\t * fb I/O, but still processing the user input.  This user input\n\t * goes to the X display and changes it, but we don't poll it\n\t * while we \"rest\" here for a time on order of dt, the previous\n\t * scan_for_updates() time.  We also break out if we miss enough\n\t * user input.\n\t */\n\tif (dt > grind_spin_time) {\n\t\tint i, ms, split = 30;\n\t\tdouble shim;\n\n\t\t/*\n\t\t * Break up our pause into 'split' steps.  We get at\n\t\t * most one input per step.\n\t\t */\n\t\tshim = 0.75 * dt / split;\n\n\t\tms = (int) (1000 * shim);\n\n\t\t/* cutoff how long the pause can be */\n\t\tif (split * ms > 300) {\n\t\t\tms = 300 / split;\n\t\t}\n\n\t\tspin = 0.0;\n\t\tdtime0(&tm);\n\n\t\tg = got_pointer_input;\n\t\tmiss = 0;\n\t\tfor (i=0; i<split; i++) {\n\t\t\tusleep(ms * 1000);\n\t\t\tif (show_multiple_cursors) {\n\t\t\t\trfbPE(1000);\n\t\t\t} else {\n\t\t\t\trfbCFD(1000);\n\t\t\t}\n\t\t\tspin += dtime(&tm);\n\t\t\tif (got_pointer_input > g) {\n\t\t\t\tint i, max_extra = max_eat / 2;\n\t\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\t\trfbCFD(0);\n\t\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\t} else if (i > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-C: XFlush %.4f\\n\", tm);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tmiss = 0;\n\t\t\t} else {\n\t\t\t\tmiss++;\n\t\t\t}\n\t\t\tg = got_pointer_input;\n\t\t\tif (miss > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (1000 * spin > ms * split)  {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_user_input2(double dt);\n\nstatic void check_user_input2(double dt) {\n\n\tint eaten = 0, miss = 0, max_eat = 50, do_flush = 1;\n\tint g, g_in;\n\tdouble spin = 0.0, tm;\n\tdouble quick_spin_fac  = 0.40;\n\tdouble grind_spin_time = 0.175;\n\n\tdtime0(&tm);\n\tg = g_in = got_pointer_input;\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\t/*\n\t * Try for some \"quick\" pointer input processing.\n\t *\n\t * About as fast as we can, we try to process user input calling\n\t * rfbProcessEvents or rfbCheckFds.  We do this for a time on\n\t * order of the last scan_for_updates() time, dt, but if we stop\n\t * getting user input we break out.  We will also break out if\n\t * we have processed max_eat inputs.\n\t *\n\t * Note that rfbCheckFds() does not send any framebuffer updates,\n\t * so is more what we want here, although it is likely they have\n\t * all be sent already.\n\t */\n\twhile (1) {\n\t\tif (show_multiple_cursors) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\trfbCFD(0);\n\n\t\tspin += dtime(&tm);\n\n\t\tif (spin > quick_spin_fac * dt) {\n\t\t\t/* get out if spin time comparable to last scan time */\n\t\t\tbreak;\n\t\t}\n\t\tif (got_pointer_input > g) {\n\t\t\tint i, max_extra = max_eat / 2;\n\t\t\tg = got_pointer_input;\n\t\t\teaten++;\n\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\trfbCFD(0);\n\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\teaten++;\n\t\t\t\t} else if (i > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_LOCK;\n\t\t\tdo_flush = 0;\nif (0) fprintf(stderr, \"check_user_input2-A: XFlush %.4f\\n\", tm);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tif (eaten < max_eat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tmiss++;\n\t\t}\n\t\tif (miss > 1) {\t/* 1 means out on 2nd miss */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_flush) {\n\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-B: XFlush %.4f\\n\", tm);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t}\n\n\n\t/*\n\t * Probably grinding with a lot of fb I/O if dt is this large.\n\t * (need to do this more elegantly)\n\t *\n\t * Current idea is to spin our wheels here *not* processing any\n\t * fb I/O, but still processing the user input.  This user input\n\t * goes to the X display and changes it, but we don't poll it\n\t * while we \"rest\" here for a time on order of dt, the previous\n\t * scan_for_updates() time.  We also break out if we miss enough\n\t * user input.\n\t */\n\tif (dt > grind_spin_time) {\n\t\tint i, ms, split = 30;\n\t\tdouble shim;\n\n\t\t/*\n\t\t * Break up our pause into 'split' steps.  We get at\n\t\t * most one input per step.\n\t\t */\n\t\tshim = 0.75 * dt / split;\n\n\t\tms = (int) (1000 * shim);\n\n\t\t/* cutoff how long the pause can be */\n\t\tif (split * ms > 300) {\n\t\t\tms = 300 / split;\n\t\t}\n\n\t\tspin = 0.0;\n\t\tdtime0(&tm);\n\n\t\tg = got_pointer_input;\n\t\tmiss = 0;\n\t\tfor (i=0; i<split; i++) {\n\t\t\tusleep(ms * 1000);\n\t\t\tif (show_multiple_cursors) {\n\t\t\t\trfbPE(1000);\n\t\t\t} else {\n\t\t\t\trfbCFD(1000);\n\t\t\t}\n\t\t\tspin += dtime(&tm);\n\t\t\tif (got_pointer_input > g) {\n\t\t\t\tint i, max_extra = max_eat / 2;\n\t\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\t\trfbCFD(0);\n\t\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\t} else if (i > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-C: XFlush %.4f\\n\", tm);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tmiss = 0;\n\t\t\t} else {\n\t\t\t\tmiss++;\n\t\t\t}\n\t\t\tg = got_pointer_input;\n\t\t\tif (miss > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (1000 * spin > ms * split)  {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 5681
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_wireframe",
          "args": [],
          "line": 5671
        },
        "resolved": true,
        "details": {
          "function_name": "check_wireframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4336-5102",
          "snippet": "int check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "void fb_push(void);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
            "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
            "int check_wireframe(void);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "static void parse_wireframe_str(char *wf);",
            "static void destroy_str_list(char **list);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static int scrollability(Window win, int set);",
            "static int wireframe_mod_state();",
            "static void check_user_input2(double dt);",
            "static double wireframe_frac;",
            "static double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;",
            "void batch_push(int ncr, double delay);",
            "static int NPP_nreg = 0;",
            "static Window NPP_nwin = None;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint check_wireframe(void);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nstatic void parse_wireframe_str(char *wf);\nstatic void destroy_str_list(char **list);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\nstatic int wireframe_mod_state();\nstatic void check_user_input2(double dt);\nstatic double wireframe_frac;\nstatic double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;\nvoid batch_push(int ncr, double delay);\nstatic int NPP_nreg = 0;\nstatic Window NPP_nwin = None;\nint clipped(int idx);\n\nint check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  CXR: check_user_input ret %d\\n\"",
            "rc - 1"
          ],
          "line": 5662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xrecord",
          "args": [],
          "line": 5652
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3066-3118",
          "snippet": "int check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_xrecord(void);",
            "static int check_xrecord_keys(void);",
            "static int check_xrecord_mouse(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nstatic int check_xrecord_keys(void);\nstatic int check_xrecord_mouse(void);\n\nint check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 5645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_reflect_process_client",
          "args": [],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_reflect_process_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1604-1616",
          "snippet": "void vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vnc_reflect_process_client(void);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid vnc_reflect_process_client(void);\nstatic rfbClient* client = NULL;\n\nvoid vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nint check_wireframe(void);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt) {\n\n\tif (rawfb_vnc_reflect) {\n\t\tif (got_user_input) {\n\t\t\tif (0) vnc_reflect_process_client();\n\t\t}\n\t\tif (got_user_input && *cnt % ui_skip != 0) {\n\t\t\t/* every n-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t}\n\t}\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (use_xrecord) {\n\t\tint rc = check_xrecord();\n\t\t/*\n\t\t * 0: nothing found, proceed to other user input schemes.\n\t\t * 1: events found, want to do a screen update now.\n\t\t * 2: events found, want to loop back for some more.\n\t\t * 3: events found, want to loop back for some more,\n\t\t *    and not have rfbPE() called.\n\t\t *\n\t\t * For 0, we precede below, otherwise return rc-1.\n\t\t */\nif (debug_scroll && rc > 1) fprintf(stderr, \"  CXR: check_user_input ret %d\\n\", rc - 1);\n\t\tif (rc == 0) {\n\t\t\t;\t/* proceed below. */\n\t\t} else {\n\t\t\treturn rc - 1;\n\t\t}\n\t}\n\n\tif (wireframe) {\n\t\tif (check_wireframe()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pointer_mode == 1) {\n\t\tif ((got_user_input || ui_skip < 0) && *cnt % ui_skip != 0) {\n\t\t\t/* every ui_skip-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (pointer_mode >= 2 && pointer_mode <= 4) {\n\t\tif (got_keyboard_input) {\n\t\t\t/*\n\t\t\t * for these modes, short circuit watch_loop on\n\t\t\t * *keyboard* input.\n\t\t\t */\n\t\t\tif (*cnt % ui_skip != 0) {\n\t\t\t\t*cnt = *cnt + 1; \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* otherwise continue below with pointer input method */\n\t}\n\n\tif (pointer_mode == 2) {\n\t\tcheck_user_input2(dt);\n\t} else if (pointer_mode == 3) {\n\t\tcheck_user_input3(dt, dtr, tile_diffs);\n\t} else if (pointer_mode == 4) {\n\t\tcheck_user_input4(dt, dtr, tile_diffs);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_user_input4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5421-5629",
    "snippet": "static void check_user_input4(double dt, double dtr, int tile_diffs) {\n\n\tint g, g_in, i, ginput, gcnt, tmp;\n\tint last_was_miss, consecutive_misses;\n\tint min_frame_size = 10;\t/* 10 tiles */\n\tdouble spin, tm, to, tc, dtm, rpe_last;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.050;\n\tstatic int first = 1;\n\n\tint Btile = tile_x * tile_y * bpp/8; \t/* Bytes per tile */\n\tdouble Ttile, dt_use;\n\tdouble screen_rate = 6000000.;    /* 5 MB/sec */\n\tdouble vnccpu_rate = 80 * 100000.; /* 20 KB/sec @ 80X compression */\n\tdouble net_rate = 50000.;\n\tstatic double Tfac_r = 1.0, Tfac_v = 1.0, Tfac_n = 1.0, Tdelay = 0.001;\n\tstatic double dt_min = -1.0, dt_max = -1.0;\n\tdouble dt_min_fallback = 0.050;\n\tstatic int ssec = 0, total_calls = 0;\n\tstatic int push_frame = 0, update_count = 0;\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tsscanf(p, \"%lf,%lf,%lf,%lf\", &dt_cut, &Tfac_r, &Tfac_v, &Tfac_n);\n\t\t}\n\t\tfirst = 0;\n\t\tssec = time(NULL);\n\n\t\tif (dtr) {}\t/* unused vars warning: */\n\t}\n\n\ttotal_calls++;\n\n\tif (dt_min < 0.0 || dt < dt_min) {\n\t\tif (dt > 0.0) {\n\t\t\tdt_min = dt;\n\t\t}\n\t}\n\tif (dt_min < 0.0) {\n\t\t/* sensible value for the very 1st call if dt = 0.0 */\n\t\tdt_min = dt_min_fallback;\n\t}\n\tif (dt_max < 0.0 || dt > dt_max) {\n\t\tdt_max = dt;\n\t}\n\n\tif (total_calls > 30 && dt_min > 0.0) {\n\t\tstatic int first = 1;\n\t\t/*\n\t\t * dt_min will soon be the quickest time to do\n\t\t * one scan_for_updates with no tiles copied.\n\t\t * use this (instead of copy_tiles) to estimate\n\t\t * screen read rate.\n\t\t */\n\t\tscreen_rate = (main_bytes_per_line * ntiles_y) / dt_min;\n\t\tif (first) {\n\t\t\trfbLog(\"measured screen read rate: %.2f Bytes/sec\\n\",\n\t\t\t    screen_rate);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tdtime0(&tm);\n\n\tif (dt < dt_cut) {\n\t\tdt_use = dt_cut;\n\t} else {\n\t\tdt_use = dt;\n\t}\n\n\tif (push_frame) {\n\t\tint cnt, iter = 0;\n\t\tdouble tp, push_spin = 0.0;\n\t\tdtime0(&tp);\n\t\twhile (push_spin < dt_use * 0.5) {\n\t\t\tfb_update_sent(&cnt);\n\t\t\tif (cnt != update_count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* damn, they didn't push our frame! */\n\t\t\titer++;\n\t\t\trfbPE(rfb_wait_ms * 1000);\n\t\t\t\n\t\t\tpush_spin += dtime(&tp);\n\t\t}\n\t\tif (iter) {\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tpush_frame = 0;\n\t\tupdate_count = 0;\n\t}\n\n\t/*\n\t * when we first enter we require some pointer input\n\t */\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\tvnccpu_rate = get_raw_rate();\n\n\tif ((tmp = get_read_rate()) != 0) {\n\t\tscreen_rate = (double) tmp;\n\t}\n\tif ((tmp = get_net_rate()) != 0) {\n\t\tnet_rate = (double) tmp;\n\t}\n\tnet_rate = (vnccpu_rate/get_cmp_rate()) * net_rate;\n\n\tif ((tmp = get_net_latency()) != 0) {\n\t\tTdelay = 0.5 * ((double) tmp)/1000.;\n\t}\n\n\tTtile = Btile * (Tfac_r/screen_rate + Tfac_v/vnccpu_rate + Tfac_n/net_rate);\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\trpe_last = to = tc = tm;\t/* last time we did rfbPE() */\n\tg = g_in = got_pointer_input;\n\n\ttile_diffs = 0;\t/* reset our knowlegde of tile_diffs to zero */\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\t/* this varible is used by our pointer handler */\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\t/* turn libvncserver crank to process events: */\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif ( (gcnt == 1 && got_pointer_input > g) || tm-tc > 2*dt_min) {\n\t\t\ttile_diffs = scan_for_updates(1);\n\t\t\ttc = tm;\n\t\t}\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (tile_diffs > min_frame_size && spin > Ttile * tile_diffs + Tdelay) {\n\t\t\t/* we think we can push the frame */\n\t\t\tpush_frame = 1;\n\t\t\tfb_update_sent(&update_count);\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush it to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t} else if (consecutive_misses >= 2) {\n\t\t\t/* too many misses in a row */\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t/* these are pointer input misses */\n\t\t\tint wms;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait for\n\t\t\t\t * a defer time. (e.g. on slow link)\n\t\t\t\t * hopefully client will batch many\n\t\t\t\t * of them for the next read.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t\twms = 0;\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\tdrag_in_progress = 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "static void check_user_input2(double dt);",
      "static void check_user_input3(double dt, double dtr, int tile_diffs);",
      "static void check_user_input4(double dt, double dtr, int tile_diffs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "rfb_wait_ms * 1000"
          ],
          "line": 5625
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "wms * 1000"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 5593
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_update_sent",
          "args": [
            "&update_count"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "fb_update_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5390-5419",
          "snippet": "int fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int fb_update_sent(int *count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint fb_update_sent(int *count);\n\nint fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_for_updates",
          "args": [
            "1"
          ],
          "line": 5567
        },
        "resolved": true,
        "details": {
          "function_name": "scan_for_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3356-3674",
          "snippet": "int scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int copy_screen(void);",
            "void set_offset(void);",
            "int scan_for_updates(int count_only);",
            "static void hint_updates(void);",
            "static int copy_all_tiles(void);",
            "static int copy_all_tile_runs(void);",
            "static int copy_tiles_backward_pass(void);",
            "static int copy_tiles_additional_pass(void);",
            "static int fill_tile_gaps(void);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int grow_islands(void);",
            "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
            "static int scan_display(int ystart, int rescan);",
            "static int scan_count = 0;",
            "static int scan_in_progress = 0;",
            "static int fs_factor = 0;",
            "static int xd_samples = 0, xd_misses = 0, xd_do_check = 0;",
            "int scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint copy_screen(void);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nstatic void hint_updates(void);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int scan_display(int ystart, int rescan);\nstatic int scan_count = 0;\nstatic int scan_in_progress = 0;\nstatic int fs_factor = 0;\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\nint scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};\n\nint scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 5563
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net_latency",
          "args": [],
          "line": 5533
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "323-335",
          "snippet": "int get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_latency = 0;",
            "int speeds_net_latency_measured = 0;",
            "int get_net_latency(void);",
            "static int get_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_latency = 0;\nint speeds_net_latency_measured = 0;\nint get_net_latency(void);\nstatic int get_latency(void);\n\nint get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cmp_rate",
          "args": [],
          "line": 5531
        },
        "resolved": true,
        "details": {
          "function_name": "get_cmp_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "189-191",
          "snippet": "int get_cmp_rate(void) {\n\treturn get_rate(0);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_cmp_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_cmp_rate(void);\n\nint get_cmp_rate(void) {\n\treturn get_rate(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net_rate",
          "args": [],
          "line": 5528
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "309-321",
          "snippet": "int get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_rate = 0;",
            "int speeds_net_rate_measured = 0;",
            "int get_cmp_rate(void);",
            "int get_net_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_rate_measured = 0;\nint get_cmp_rate(void);\nint get_net_rate(void);\n\nint get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_read_rate",
          "args": [],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "get_read_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "272-280",
          "snippet": "int get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_read_rate = 0;",
            "int speeds_read_rate_measured = 0;",
            "int get_read_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nint get_read_rate(void);\n\nint get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_raw_rate",
          "args": [],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "get_raw_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "193-195",
          "snippet": "int get_raw_rate(void) {\n\treturn get_rate(1);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_raw_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_raw_rate(void);\n\nint get_raw_rate(void) {\n\treturn get_rate(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "rfb_wait_ms * 1000"
          ],
          "line": 5503
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"measured screen read rate: %.2f Bytes/sec\\n\"",
            "screen_rate"
          ],
          "line": 5478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 5448
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%lf,%lf,%lf,%lf\"",
            "&dt_cut",
            "&Tfac_r",
            "&Tfac_v",
            "&Tfac_n"
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SPIN\""
          ],
          "line": 5443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nstatic void check_user_input4(double dt, double dtr, int tile_diffs) {\n\n\tint g, g_in, i, ginput, gcnt, tmp;\n\tint last_was_miss, consecutive_misses;\n\tint min_frame_size = 10;\t/* 10 tiles */\n\tdouble spin, tm, to, tc, dtm, rpe_last;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.050;\n\tstatic int first = 1;\n\n\tint Btile = tile_x * tile_y * bpp/8; \t/* Bytes per tile */\n\tdouble Ttile, dt_use;\n\tdouble screen_rate = 6000000.;    /* 5 MB/sec */\n\tdouble vnccpu_rate = 80 * 100000.; /* 20 KB/sec @ 80X compression */\n\tdouble net_rate = 50000.;\n\tstatic double Tfac_r = 1.0, Tfac_v = 1.0, Tfac_n = 1.0, Tdelay = 0.001;\n\tstatic double dt_min = -1.0, dt_max = -1.0;\n\tdouble dt_min_fallback = 0.050;\n\tstatic int ssec = 0, total_calls = 0;\n\tstatic int push_frame = 0, update_count = 0;\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tsscanf(p, \"%lf,%lf,%lf,%lf\", &dt_cut, &Tfac_r, &Tfac_v, &Tfac_n);\n\t\t}\n\t\tfirst = 0;\n\t\tssec = time(NULL);\n\n\t\tif (dtr) {}\t/* unused vars warning: */\n\t}\n\n\ttotal_calls++;\n\n\tif (dt_min < 0.0 || dt < dt_min) {\n\t\tif (dt > 0.0) {\n\t\t\tdt_min = dt;\n\t\t}\n\t}\n\tif (dt_min < 0.0) {\n\t\t/* sensible value for the very 1st call if dt = 0.0 */\n\t\tdt_min = dt_min_fallback;\n\t}\n\tif (dt_max < 0.0 || dt > dt_max) {\n\t\tdt_max = dt;\n\t}\n\n\tif (total_calls > 30 && dt_min > 0.0) {\n\t\tstatic int first = 1;\n\t\t/*\n\t\t * dt_min will soon be the quickest time to do\n\t\t * one scan_for_updates with no tiles copied.\n\t\t * use this (instead of copy_tiles) to estimate\n\t\t * screen read rate.\n\t\t */\n\t\tscreen_rate = (main_bytes_per_line * ntiles_y) / dt_min;\n\t\tif (first) {\n\t\t\trfbLog(\"measured screen read rate: %.2f Bytes/sec\\n\",\n\t\t\t    screen_rate);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tdtime0(&tm);\n\n\tif (dt < dt_cut) {\n\t\tdt_use = dt_cut;\n\t} else {\n\t\tdt_use = dt;\n\t}\n\n\tif (push_frame) {\n\t\tint cnt, iter = 0;\n\t\tdouble tp, push_spin = 0.0;\n\t\tdtime0(&tp);\n\t\twhile (push_spin < dt_use * 0.5) {\n\t\t\tfb_update_sent(&cnt);\n\t\t\tif (cnt != update_count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* damn, they didn't push our frame! */\n\t\t\titer++;\n\t\t\trfbPE(rfb_wait_ms * 1000);\n\t\t\t\n\t\t\tpush_spin += dtime(&tp);\n\t\t}\n\t\tif (iter) {\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tpush_frame = 0;\n\t\tupdate_count = 0;\n\t}\n\n\t/*\n\t * when we first enter we require some pointer input\n\t */\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\tvnccpu_rate = get_raw_rate();\n\n\tif ((tmp = get_read_rate()) != 0) {\n\t\tscreen_rate = (double) tmp;\n\t}\n\tif ((tmp = get_net_rate()) != 0) {\n\t\tnet_rate = (double) tmp;\n\t}\n\tnet_rate = (vnccpu_rate/get_cmp_rate()) * net_rate;\n\n\tif ((tmp = get_net_latency()) != 0) {\n\t\tTdelay = 0.5 * ((double) tmp)/1000.;\n\t}\n\n\tTtile = Btile * (Tfac_r/screen_rate + Tfac_v/vnccpu_rate + Tfac_n/net_rate);\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\trpe_last = to = tc = tm;\t/* last time we did rfbPE() */\n\tg = g_in = got_pointer_input;\n\n\ttile_diffs = 0;\t/* reset our knowlegde of tile_diffs to zero */\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\t/* this varible is used by our pointer handler */\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\t/* turn libvncserver crank to process events: */\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif ( (gcnt == 1 && got_pointer_input > g) || tm-tc > 2*dt_min) {\n\t\t\ttile_diffs = scan_for_updates(1);\n\t\t\ttc = tm;\n\t\t}\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (tile_diffs > min_frame_size && spin > Ttile * tile_diffs + Tdelay) {\n\t\t\t/* we think we can push the frame */\n\t\t\tpush_frame = 1;\n\t\t\tfb_update_sent(&update_count);\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush it to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t} else if (consecutive_misses >= 2) {\n\t\t\t/* too many misses in a row */\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t/* these are pointer input misses */\n\t\t\tint wms;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait for\n\t\t\t\t * a defer time. (e.g. on slow link)\n\t\t\t\t * hopefully client will batch many\n\t\t\t\t * of them for the next read.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t\twms = 0;\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\tdrag_in_progress = 0;\n}"
  },
  {
    "function_name": "fb_update_sent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5390-5419",
    "snippet": "int fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fb_update_sent(int *count);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetMessageCountSent",
          "args": [
            "cl",
            "rfbFramebufferUpdate"
          ],
          "line": 5406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 5400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint fb_update_sent(int *count);\n\nint fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}"
  },
  {
    "function_name": "check_user_input3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5270-5388",
    "snippet": "static void check_user_input3(double dt, double dtr, int tile_diffs) {\n\n\tint allowed_misses, miss_tweak, i, g, g_in;\n\tint last_was_miss, consecutive_misses;\n\tdouble spin, spin_max, tm, to, dtm;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.075;\n\tint gcnt, ginput;\n\tstatic int first = 1;\n\n\tif (dtr || tile_diffs) {} /* unused vars warning: */\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tdouble junk;\n\t\t\tsscanf(p, \"%lf,%lf\", &dt_cut, &junk);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\n\tif (dt < dt_cut) {\n\t\tdt = dt_cut;\t/* this is to try to avoid early exit */\n\t}\n\tspin_max = 0.5;\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tallowed_misses = 10;\t/* number of ptr inputs we can miss */\n\tmiss_tweak = 8;\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\tdtime0(&tm);\n\tto = tm;\t/* last time we did rfbPE() */\n\n\tg = g_in = got_pointer_input;\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tif (ginput % miss_tweak == 0) {\n\t\t\t\tallowed_misses++;\n\t\t\t}\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (spin > spin_max) {\n\t\t\t/* get out if spin time over limit */\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t} else if (--allowed_misses <= 0) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else if (consecutive_misses >=3) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* these are misses */\n\t\t\tint wms = 0;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait\n\t\t\t\t * for a defer time. (e.g. on\n\t\t\t\t * slow link) hopefully client\n\t\t\t\t * will batch them.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\n\tdrag_in_progress = 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_user_input2(double dt);",
      "static void check_user_input3(double dt, double dtr, int tile_diffs);",
      "static void check_user_input4(double dt, double dtr, int tile_diffs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "rfb_wait_ms * 1000"
          ],
          "line": 5383
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "wms * 1000"
          ],
          "line": 5375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 5351
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%lf,%lf\"",
            "&dt_cut",
            "&junk"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SPIN\""
          ],
          "line": 5283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nstatic void check_user_input3(double dt, double dtr, int tile_diffs) {\n\n\tint allowed_misses, miss_tweak, i, g, g_in;\n\tint last_was_miss, consecutive_misses;\n\tdouble spin, spin_max, tm, to, dtm;\n\tint rfb_wait_ms = 2;\n\tstatic double dt_cut = 0.075;\n\tint gcnt, ginput;\n\tstatic int first = 1;\n\n\tif (dtr || tile_diffs) {} /* unused vars warning: */\n\n\tif (first) {\n\t\tchar *p = getenv(\"SPIN\");\n\t\tif (p) {\n\t\t\tdouble junk;\n\t\t\tsscanf(p, \"%lf,%lf\", &dt_cut, &junk);\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\n\n\tif (dt < dt_cut) {\n\t\tdt = dt_cut;\t/* this is to try to avoid early exit */\n\t}\n\tspin_max = 0.5;\n\n\tspin = 0.0;\t\t/* amount of time spinning */\n\tallowed_misses = 10;\t/* number of ptr inputs we can miss */\n\tmiss_tweak = 8;\n\tlast_was_miss = 0;\n\tconsecutive_misses = 1;\n\tgcnt = 0;\n\tginput = 0;\n\n\tdtime0(&tm);\n\tto = tm;\t/* last time we did rfbPE() */\n\n\tg = g_in = got_pointer_input;\n\n\twhile (1) {\n\t\tint got_input = 0;\n\n\t\tgcnt++;\n\n\t\tif (button_mask) {\n\t\t\tdrag_in_progress = 1;\n\t\t}\n\n\t\trfbCFD(rfb_wait_ms * 1000);\n\n\t\tdtm = dtime(&tm);\n\t\tspin += dtm;\n\n\t\tif (got_pointer_input == g) {\n\t\t\tif (last_was_miss) {\n\t\t\t\tconsecutive_misses++;\n\t\t\t}\n\t\t\tlast_was_miss = 1;\n\t\t} else {\n\t\t\tginput++;\n\t\t\tif (ginput % miss_tweak == 0) {\n\t\t\t\tallowed_misses++;\n\t\t\t}\n\t\t\tconsecutive_misses = 1;\n\t\t\tlast_was_miss = 0;\n\t\t}\n\n\t\tif (spin > spin_max) {\n\t\t\t/* get out if spin time over limit */\n\t\t\tbreak;\n\n\t\t} else if (got_pointer_input > g) {\n\t\t\t/* received some input, flush to display. */\n\t\t\tgot_input = 1;\n\t\t\tg = got_pointer_input;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t} else if (--allowed_misses <= 0) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else if (consecutive_misses >=3) {\n\t\t\t/* too many misses */\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* these are misses */\n\t\t\tint wms = 0;\n\t\t\tif (gcnt == 1 && button_mask) {\n\t\t\t\t/*\n\t\t\t\t * missed our first input, wait\n\t\t\t\t * for a defer time. (e.g. on\n\t\t\t\t * slow link) hopefully client\n\t\t\t\t * will batch them.\n\t\t\t\t */\n\t\t\t\twms = 50;\n\t\t\t} else if (button_mask) {\n\t\t\t\twms = 10;\n\t\t\t} else {\n\t\t\t}\n\t\t\tif (wms) {\n\t\t\t\tusleep(wms * 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ginput >= 2) {\n\t\t/* try for a couple more quick ones */\n\t\tfor (i=0; i<2; i++) {\n\t\t\trfbCFD(rfb_wait_ms * 1000);\n\t\t}\n\t}\n\n\tdrag_in_progress = 0;\n}"
  },
  {
    "function_name": "check_user_input2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "5124-5268",
    "snippet": "static void check_user_input2(double dt) {\n\n\tint eaten = 0, miss = 0, max_eat = 50, do_flush = 1;\n\tint g, g_in;\n\tdouble spin = 0.0, tm;\n\tdouble quick_spin_fac  = 0.40;\n\tdouble grind_spin_time = 0.175;\n\n\tdtime0(&tm);\n\tg = g_in = got_pointer_input;\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\t/*\n\t * Try for some \"quick\" pointer input processing.\n\t *\n\t * About as fast as we can, we try to process user input calling\n\t * rfbProcessEvents or rfbCheckFds.  We do this for a time on\n\t * order of the last scan_for_updates() time, dt, but if we stop\n\t * getting user input we break out.  We will also break out if\n\t * we have processed max_eat inputs.\n\t *\n\t * Note that rfbCheckFds() does not send any framebuffer updates,\n\t * so is more what we want here, although it is likely they have\n\t * all be sent already.\n\t */\n\twhile (1) {\n\t\tif (show_multiple_cursors) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\trfbCFD(0);\n\n\t\tspin += dtime(&tm);\n\n\t\tif (spin > quick_spin_fac * dt) {\n\t\t\t/* get out if spin time comparable to last scan time */\n\t\t\tbreak;\n\t\t}\n\t\tif (got_pointer_input > g) {\n\t\t\tint i, max_extra = max_eat / 2;\n\t\t\tg = got_pointer_input;\n\t\t\teaten++;\n\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\trfbCFD(0);\n\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\teaten++;\n\t\t\t\t} else if (i > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_LOCK;\n\t\t\tdo_flush = 0;\nif (0) fprintf(stderr, \"check_user_input2-A: XFlush %.4f\\n\", tm);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tif (eaten < max_eat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tmiss++;\n\t\t}\n\t\tif (miss > 1) {\t/* 1 means out on 2nd miss */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_flush) {\n\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-B: XFlush %.4f\\n\", tm);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t}\n\n\n\t/*\n\t * Probably grinding with a lot of fb I/O if dt is this large.\n\t * (need to do this more elegantly)\n\t *\n\t * Current idea is to spin our wheels here *not* processing any\n\t * fb I/O, but still processing the user input.  This user input\n\t * goes to the X display and changes it, but we don't poll it\n\t * while we \"rest\" here for a time on order of dt, the previous\n\t * scan_for_updates() time.  We also break out if we miss enough\n\t * user input.\n\t */\n\tif (dt > grind_spin_time) {\n\t\tint i, ms, split = 30;\n\t\tdouble shim;\n\n\t\t/*\n\t\t * Break up our pause into 'split' steps.  We get at\n\t\t * most one input per step.\n\t\t */\n\t\tshim = 0.75 * dt / split;\n\n\t\tms = (int) (1000 * shim);\n\n\t\t/* cutoff how long the pause can be */\n\t\tif (split * ms > 300) {\n\t\t\tms = 300 / split;\n\t\t}\n\n\t\tspin = 0.0;\n\t\tdtime0(&tm);\n\n\t\tg = got_pointer_input;\n\t\tmiss = 0;\n\t\tfor (i=0; i<split; i++) {\n\t\t\tusleep(ms * 1000);\n\t\t\tif (show_multiple_cursors) {\n\t\t\t\trfbPE(1000);\n\t\t\t} else {\n\t\t\t\trfbCFD(1000);\n\t\t\t}\n\t\t\tspin += dtime(&tm);\n\t\t\tif (got_pointer_input > g) {\n\t\t\t\tint i, max_extra = max_eat / 2;\n\t\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\t\trfbCFD(0);\n\t\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\t} else if (i > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-C: XFlush %.4f\\n\", tm);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tmiss = 0;\n\t\t\t} else {\n\t\t\t\tmiss++;\n\t\t\t}\n\t\t\tg = got_pointer_input;\n\t\t\tif (miss > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (1000 * spin > ms * split)  {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_user_input2(double dt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 5253
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_user_input2-C: XFlush %.4f\\n\"",
            "tm"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 5244
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "1000"
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 5234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_user_input2-B: XFlush %.4f\\n\"",
            "tm"
          ],
          "line": 5194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_user_input2-A: XFlush %.4f\\n\"",
            "tm"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_user_input2(double dt);\n\nstatic void check_user_input2(double dt) {\n\n\tint eaten = 0, miss = 0, max_eat = 50, do_flush = 1;\n\tint g, g_in;\n\tdouble spin = 0.0, tm;\n\tdouble quick_spin_fac  = 0.40;\n\tdouble grind_spin_time = 0.175;\n\n\tdtime0(&tm);\n\tg = g_in = got_pointer_input;\n\tif (!got_pointer_input) {\n\t\treturn;\n\t}\n\t/*\n\t * Try for some \"quick\" pointer input processing.\n\t *\n\t * About as fast as we can, we try to process user input calling\n\t * rfbProcessEvents or rfbCheckFds.  We do this for a time on\n\t * order of the last scan_for_updates() time, dt, but if we stop\n\t * getting user input we break out.  We will also break out if\n\t * we have processed max_eat inputs.\n\t *\n\t * Note that rfbCheckFds() does not send any framebuffer updates,\n\t * so is more what we want here, although it is likely they have\n\t * all be sent already.\n\t */\n\twhile (1) {\n\t\tif (show_multiple_cursors) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\trfbCFD(0);\n\n\t\tspin += dtime(&tm);\n\n\t\tif (spin > quick_spin_fac * dt) {\n\t\t\t/* get out if spin time comparable to last scan time */\n\t\t\tbreak;\n\t\t}\n\t\tif (got_pointer_input > g) {\n\t\t\tint i, max_extra = max_eat / 2;\n\t\t\tg = got_pointer_input;\n\t\t\teaten++;\n\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\trfbCFD(0);\n\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\teaten++;\n\t\t\t\t} else if (i > 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_LOCK;\n\t\t\tdo_flush = 0;\nif (0) fprintf(stderr, \"check_user_input2-A: XFlush %.4f\\n\", tm);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tif (eaten < max_eat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tmiss++;\n\t\t}\n\t\tif (miss > 1) {\t/* 1 means out on 2nd miss */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (do_flush) {\n\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-B: XFlush %.4f\\n\", tm);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t}\n\n\n\t/*\n\t * Probably grinding with a lot of fb I/O if dt is this large.\n\t * (need to do this more elegantly)\n\t *\n\t * Current idea is to spin our wheels here *not* processing any\n\t * fb I/O, but still processing the user input.  This user input\n\t * goes to the X display and changes it, but we don't poll it\n\t * while we \"rest\" here for a time on order of dt, the previous\n\t * scan_for_updates() time.  We also break out if we miss enough\n\t * user input.\n\t */\n\tif (dt > grind_spin_time) {\n\t\tint i, ms, split = 30;\n\t\tdouble shim;\n\n\t\t/*\n\t\t * Break up our pause into 'split' steps.  We get at\n\t\t * most one input per step.\n\t\t */\n\t\tshim = 0.75 * dt / split;\n\n\t\tms = (int) (1000 * shim);\n\n\t\t/* cutoff how long the pause can be */\n\t\tif (split * ms > 300) {\n\t\t\tms = 300 / split;\n\t\t}\n\n\t\tspin = 0.0;\n\t\tdtime0(&tm);\n\n\t\tg = got_pointer_input;\n\t\tmiss = 0;\n\t\tfor (i=0; i<split; i++) {\n\t\t\tusleep(ms * 1000);\n\t\t\tif (show_multiple_cursors) {\n\t\t\t\trfbPE(1000);\n\t\t\t} else {\n\t\t\t\trfbCFD(1000);\n\t\t\t}\n\t\t\tspin += dtime(&tm);\n\t\t\tif (got_pointer_input > g) {\n\t\t\t\tint i, max_extra = max_eat / 2;\n\t\t\t\tfor (i=0; i<max_extra; i++)  {\n\t\t\t\t\trfbCFD(0);\n\t\t\t\t\tif (got_pointer_input > g) {\n\t\t\t\t\t\tg = got_pointer_input;\n\t\t\t\t\t} else if (i > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tX_LOCK;\nif (0) fprintf(stderr, \"check_user_input2-C: XFlush %.4f\\n\", tm);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tmiss = 0;\n\t\t\t} else {\n\t\t\t\tmiss++;\n\t\t\t}\n\t\t\tg = got_pointer_input;\n\t\t\tif (miss > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (1000 * spin > ms * split)  {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_wireframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4336-5102",
    "snippet": "int check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
      "void fb_push(void);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
      "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
      "int check_wireframe(void);",
      "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "static void parse_wireframe_str(char *wf);",
      "static void destroy_str_list(char **list);",
      "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
      "static int scrollability(Window win, int set);",
      "static int wireframe_mod_state();",
      "static void check_user_input2(double dt);",
      "static double wireframe_frac;",
      "static double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;",
      "void batch_push(int ncr, double delay);",
      "static int NPP_nreg = 0;",
      "static Window NPP_nwin = None;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_macosx_iconify",
          "args": [
            "orig_frame",
            "frame",
            "drew_box"
          ],
          "line": 5098
        },
        "resolved": true,
        "details": {
          "function_name": "check_macosx_iconify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4184-4240",
          "snippet": "void check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_xdamage_mark_region",
          "args": [
            "NULL",
            "1"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "clear_xdamage_mark_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "212-258",
          "snippet": "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush);\n\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpp8to24",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 5084
        },
        "resolved": true,
        "details": {
          "function_name": "bpp8to24",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1809-2054",
          "snippet": "void bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "void bpp8to24(int, int, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nvoid bpp8to24(int, int, int, int);\n\nvoid bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "0"
          ],
          "line": 5079
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_multivis",
          "args": [],
          "line": 5078
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_multivis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "304-600",
          "snippet": "void check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "int multivis_count = 0;",
            "int multivis_24count = 0;",
            "void check_for_multivis(void);",
            "void mark_8bpp(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\nvoid check_for_multivis(void);\nvoid mark_8bpp(int);\n\nvoid check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nmax",
          "args": [
            "box_y + box_h",
            "orig_y + orig_h"
          ],
          "line": 5072
        },
        "resolved": true,
        "details": {
          "function_name": "nmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "112-118",
          "snippet": "int nmax(int n, int m) {\n\tif (n > m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nmin(int n, int m);",
            "int nmax(int n, int m);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\n\nint nmax(int n, int m) {\n\tif (n > m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nmin",
          "args": [
            "box_y",
            "orig_y"
          ],
          "line": 5070
        },
        "resolved": true,
        "details": {
          "function_name": "nmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "104-110",
          "snippet": "int nmin(int n, int m) {\n\tif (n < m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nmin(int n, int m);",
            "int nmax(int n, int m);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\n\nint nmin(int n, int m) {\n\tif (n < m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "1000"
          ],
          "line": 5061
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 5054
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_mark",
          "args": [
            "xt",
            "yt",
            "xt+w",
            "yt+h",
            "1"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "scale_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1408-1415",
          "snippet": "static void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\n\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_COPY"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_win_events",
          "args": [
            "NPP_nwin",
            "0"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "clear_win_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3654-3682",
          "snippet": "void clear_win_events(Window win, int vis) {\n#if !NO_X11\n\tif (dpy && win != None && ncache) {\n\t\tXEvent ev;\n\t\tXErrorHandler old_handler;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\twhile (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &ev)) {\n\t\t\tif (ncdb) fprintf(stderr, \".\");\n\t\t\tif (trapped_xerror) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\t\t}\n/* XXX Y */\n\t\tif (vis) {\n\t\t\twhile (XCheckTypedWindowEvent(dpy, win, VisibilityNotify, &ev)) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"+\");\n\t\t\t\tif (trapped_xerror) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t\tXSetErrorHandler(old_handler);\n\t\tif (ncdb) fprintf(stderr, \" 0x%lx\\n\", win);\n\t}\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nvoid clear_win_events(Window win, int vis) {\n#if !NO_X11\n\tif (dpy && win != None && ncache) {\n\t\tXEvent ev;\n\t\tXErrorHandler old_handler;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\twhile (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &ev)) {\n\t\t\tif (ncdb) fprintf(stderr, \".\");\n\t\t\tif (trapped_xerror) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\t\t}\n/* XXX Y */\n\t\tif (vis) {\n\t\t\twhile (XCheckTypedWindowEvent(dpy, win, VisibilityNotify, &ev)) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"+\");\n\t\t\t\tif (trapped_xerror) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t\tXSetErrorHandler(old_handler);\n\t\tif (ncdb) fprintf(stderr, \" 0x%lx\\n\", win);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncache_post_portions",
          "args": [
            "nidx",
            "use_batch",
            "orig_x",
            "orig_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "-1.0",
            "ntim"
          ],
          "line": 5015
        },
        "resolved": true,
        "details": {
          "function_name": "ncache_post_portions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3879-4109",
          "snippet": "void ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];",
            "static int NPP_nreg = 0;",
            "static sraRegionPtr NPP_roffscreen = NULL;",
            "static sraRegionPtr NPP_r_bs_tmp = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\n\nvoid ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\"",
            "sent_copyrect",
            "obscured",
            "frame"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_copyrect",
          "args": [
            "orig_frame",
            "frame",
            "x",
            "y",
            "w",
            "h",
            "dx",
            "dy",
            "&obscured",
            "NULL",
            "0.15",
            "&NPP_nreg"
          ],
          "line": 4998
        },
        "resolved": true,
        "details": {
          "function_name": "try_copyrect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3138-3469",
          "snippet": "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "static int scrollability(Window win, int set);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "static void check_user_input2(double dt);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncache_pre_portions",
          "args": [
            "orig_frame",
            "frame",
            "&nidx",
            "try_batch",
            "&use_batch",
            "orig_x",
            "orig_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "ntim"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "ncache_pre_portions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3746-3877",
          "snippet": "void ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];",
            "static int NPP_nreg = 0;",
            "static sraRegionPtr NPP_roffscreen = NULL;",
            "static sraRegionPtr NPP_r_bs_tmp = NULL;",
            "static Window NPP_nwin = None;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\nstatic Window NPP_nwin = None;\n\nvoid ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY *FAILED* again! %.4f\"",
            "dnow() - ntim"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY *FAILED*, try one more... %.4f\"",
            "dnow() - ntim"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nSEND_COPYRECT  %.4f %.4f\\n\"",
            "dnowx()",
            "dnow() - ntim"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_fix_resize_su",
          "args": [
            "orig_frame",
            "orig_x",
            "orig_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "try_batch"
          ],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_fix_resize_su",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7781-7910",
          "snippet": "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\n\tint idx = lookup_win_index(orig_frame);\n\tsraRegionPtr r0, r1, r2, r3;\n\tint sx1, sy1, sw1, sh1, dx, dy;\n\tint bx1, by1, bw1, bh1;\n\tint nr = 0, *nbat = NULL;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x+orig_w, orig_y+orig_h);\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\tsraRgnAnd(r2, r0);\n\n\tif (try_batch) {\n\t\tnbat = &nr;\n\t}\n\t\n\tif (orig_w >= w && orig_h >= h) {\n\nif (0) fprintf(stderr, \"Shrinking resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnSubtract(r3, r2);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tdx = orig_x - sx1;\n\t\tdy = orig_y - sy1;\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnAnd(r3, r2);\n\n\t\tdx = sx1 - orig_x;\n\t\tdy = sy1 - orig_y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tdx = orig_x - x;\n\t\tdy = orig_y - y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\n\t\tcache_list[idx].x = x;\n\t\tcache_list[idx].y = y;\n\t\tcache_list[idx].width = w;\n\t\tcache_list[idx].height = h;\n\n\t\tcache_list[idx].bs_w = w;\n\t\tcache_list[idx].bs_h = h;\n\t\tcache_list[idx].su_w = w;\n\t\tcache_list[idx].su_h = h;\n\n\t\tcache_list[idx].bs_time = 0.0;\n\t\t/* XXX Y */\n\t\tif (0) cache_list[idx].su_time = dnow();\n\t} else {\nif (0) fprintf(stderr, \"Growing resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tbx1 = cache_list[idx].bs_x;\n\t\tby1 = cache_list[idx].bs_y;\n\t\tbw1 = cache_list[idx].bs_w;\n\t\tbh1 = cache_list[idx].bs_h;\n\t\t\n\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnAnd(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tdx = dx - (sx1 - orig_x);\n\t\t\tdy = dy - (sy1 - orig_y);\n\t\t\t\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnSubtract(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tif (nr) {\n\t\t\t\tbatch_push(nr, -1.0);\n\t\t\t}\n\n\t\t\tcache_list[idx].bs_time = 0.0;\n\t\t\t/* XXX Y */\n\t\t\tif (0) cache_list[idx].su_time = dnow();\n\t\t}\n\t}\n\t\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\tsraRgnDestroy(r2);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch) {\n\n\tint idx = lookup_win_index(orig_frame);\n\tsraRegionPtr r0, r1, r2, r3;\n\tint sx1, sy1, sw1, sh1, dx, dy;\n\tint bx1, by1, bw1, bh1;\n\tint nr = 0, *nbat = NULL;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0 || cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x+orig_w, orig_y+orig_h);\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\tsraRgnAnd(r2, r0);\n\n\tif (try_batch) {\n\t\tnbat = &nr;\n\t}\n\t\n\tif (orig_w >= w && orig_h >= h) {\n\nif (0) fprintf(stderr, \"Shrinking resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnSubtract(r3, r2);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tdx = orig_x - sx1;\n\t\tdy = orig_y - sy1;\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tr3 = sraRgnCreateRgn(r1);\n\t\tsraRgnAnd(r3, r2);\n\n\t\tdx = sx1 - orig_x;\n\t\tdy = sy1 - orig_y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tdx = orig_x - x;\n\t\tdy = orig_y - y;\n\t\tsraRgnOffset(r3, dx, dy);\n\n\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\tsraRgnDestroy(r3);\n\n\t\tif (nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\n\t\tcache_list[idx].x = x;\n\t\tcache_list[idx].y = y;\n\t\tcache_list[idx].width = w;\n\t\tcache_list[idx].height = h;\n\n\t\tcache_list[idx].bs_w = w;\n\t\tcache_list[idx].bs_h = h;\n\t\tcache_list[idx].su_w = w;\n\t\tcache_list[idx].su_h = h;\n\n\t\tcache_list[idx].bs_time = 0.0;\n\t\t/* XXX Y */\n\t\tif (0) cache_list[idx].su_time = dnow();\n\t} else {\nif (0) fprintf(stderr, \"Growing resize %d  %dx%d+%d+%d -> %dx%d+%d+%d\\n\", idx, orig_w, orig_h, orig_x, orig_y, w, h, x, y);\n\n\t\tsx1 = cache_list[idx].su_x;\n\t\tsy1 = cache_list[idx].su_y;\n\t\tsw1 = cache_list[idx].su_w;\n\t\tsh1 = cache_list[idx].su_h;\n\n\t\tbx1 = cache_list[idx].bs_x;\n\t\tby1 = cache_list[idx].bs_y;\n\t\tbw1 = cache_list[idx].bs_w;\n\t\tbh1 = cache_list[idx].bs_h;\n\t\t\n\t\tif (find_rect(idx, x, y, w, h)) {\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnAnd(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tdx = dx - (sx1 - orig_x);\n\t\t\tdy = dy - (sy1 - orig_y);\n\t\t\t\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnSubtract(r3, r1);\n\n\t\t\tdx = cache_list[idx].su_x - x;\n\t\t\tdy = cache_list[idx].su_y - y;\n\t\n\t\t\tsraRgnOffset(r3, dx, dy);\n\n\t\t\tcache_cr(r3, dx, dy, 0.075, 0.05, nbat);\n\t\t\tsraRgnDestroy(r3);\n\n\t\t\tif (nr) {\n\t\t\t\tbatch_push(nr, -1.0);\n\t\t\t}\n\n\t\t\tcache_list[idx].bs_time = 0.0;\n\t\t\t/* XXX Y */\n\t\t\tif (0) cache_list[idx].su_time = dnow();\n\t\t}\n\t}\n\t\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\tsraRgnDestroy(r2);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_cr_when_scaling",
          "args": [
            "\"wireframe\""
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "skip_cr_when_scaling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "3023-3057",
          "snippet": "int skip_cr_when_scaling(char *mode) {\n\tint got = 0;\n\t\n\tif (!scaling) {\n\t\treturn 0;\n\t}\n\n\tif (scaling_copyrect != scaling_copyrect0) {\n\t\t/* user override via -scale: */\n\t\tif (! scaling_copyrect) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (*mode == 's') {\n\t\tgot = got_scrollcopyrect;\n\t} else if (*mode == 'w') {\n\t\tgot = got_wirecopyrect;\n\t}\n\tif (scaling_copyrect || got) {\n\t\tint lat, rate;\n\t\tint link = link_rate(&lat, &rate);\n\t\tif (link == LR_DIALUP) {\n\t\t\treturn 1;\n\t\t} else if (rate < 25) {\n\t\t\t/* the fill-in of the repair may be too slow */\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int skip_cr_when_scaling(char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint skip_cr_when_scaling(char *mode);\n\nint skip_cr_when_scaling(char *mode) {\n\tint got = 0;\n\t\n\tif (!scaling) {\n\t\treturn 0;\n\t}\n\n\tif (scaling_copyrect != scaling_copyrect0) {\n\t\t/* user override via -scale: */\n\t\tif (! scaling_copyrect) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (*mode == 's') {\n\t\tgot = got_scrollcopyrect;\n\t} else if (*mode == 'w') {\n\t\tgot = got_wirecopyrect;\n\t}\n\tif (scaling_copyrect || got) {\n\t\tint lat, rate;\n\t\tint link = link_rate(&lat, &rate);\n\t\tif (link == LR_DIALUP) {\n\t\t\treturn 1;\n\t\t} else if (rate < 25) {\n\t\t\t/* the fill-in of the repair may be too slow */\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_copyrect",
            "\"never\""
          ],
          "line": 4934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyrect_drag_move",
          "args": [
            "orig_frame",
            "frame",
            "&nidx",
            "tb",
            "now_x",
            "now_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "-1.0"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyrect_drag_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4111-4182",
          "snippet": "void do_copyrect_drag_move(Window orig_frame, Window frame, int *nidx, int try_batch,\n    int now_x, int now_y, int orig_w, int orig_h, int x, int y, int w, int h, double batch_delay) {\n\n\tint sent_copyrect = 1, obscured = 0;\n\tint dx, dy;\n\tint use_batch = 0;\n\tdouble ntim = dnow();\n\tstatic int nob = -1;\n\tsraRegionPtr r0, r1;\n\n\tif (nob < 0) {\n\t\tif (getenv(\"NOCRBATCH\")) {\n\t\t\tnob = 1;\n\t\t} else {\n\t\t\tnob = 0;\n\t\t}\n\t}\n\tif (nob) {\n\t\ttry_batch = 0;\n\t}\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\tif (dx == 0 && dy == 0) {\n\t\treturn;\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: now_xy: %d %d, orig_wh: %d %d, xy: %d %d, wh: %d %d\\n\",now_x, now_y, orig_w, orig_h, x, y, w, h);\n\t\n\tncache_pre_portions(orig_frame, frame, nidx, try_batch, &use_batch,\n\t    now_x, now_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\tsraRgnAnd(r1, r0);\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\n\t/* make sure the source is on-screen too */\n\tsraRgnOffset(r1, -dx, -dy);\n\tsraRgnAnd(r1, r0);\n\tsraRgnOffset(r1, +dx, +dy);\n\tsraRgnAnd(r1, r0);\t/* just to be sure, problably not needed */\n\n\tif (! use_batch) {\n\t\tdo_copyregion(r1, dx, dy, 0);\n\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) *FAILED*\\n\", dnow() - ntim);\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[NPP_nreg] = dx;\n\t\tbatch_dys[NPP_nreg] = dy;\n\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\tif (sent_copyrect) {\n\t\tif (use_batch) {\n\t\t\t;\n\t\t} else if (! obscured) {\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t} else {\n\t\t\t/* no diff for now... */\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t\tncache_post_portions(*nidx, use_batch,\n\t\t    now_x, now_y, orig_w, orig_h, x, y, w, h, batch_delay, ntim);\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: %.4f -- post_portion done.\\n\", dnow() - ntim);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];",
            "static int NPP_nreg = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\n\nvoid do_copyrect_drag_move(Window orig_frame, Window frame, int *nidx, int try_batch,\n    int now_x, int now_y, int orig_w, int orig_h, int x, int y, int w, int h, double batch_delay) {\n\n\tint sent_copyrect = 1, obscured = 0;\n\tint dx, dy;\n\tint use_batch = 0;\n\tdouble ntim = dnow();\n\tstatic int nob = -1;\n\tsraRegionPtr r0, r1;\n\n\tif (nob < 0) {\n\t\tif (getenv(\"NOCRBATCH\")) {\n\t\t\tnob = 1;\n\t\t} else {\n\t\t\tnob = 0;\n\t\t}\n\t}\n\tif (nob) {\n\t\ttry_batch = 0;\n\t}\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\tif (dx == 0 && dy == 0) {\n\t\treturn;\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: now_xy: %d %d, orig_wh: %d %d, xy: %d %d, wh: %d %d\\n\",now_x, now_y, orig_w, orig_h, x, y, w, h);\n\t\n\tncache_pre_portions(orig_frame, frame, nidx, try_batch, &use_batch,\n\t    now_x, now_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\tsraRgnAnd(r1, r0);\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\n\t/* make sure the source is on-screen too */\n\tsraRgnOffset(r1, -dx, -dy);\n\tsraRgnAnd(r1, r0);\n\tsraRgnOffset(r1, +dx, +dy);\n\tsraRgnAnd(r1, r0);\t/* just to be sure, problably not needed */\n\n\tif (! use_batch) {\n\t\tdo_copyregion(r1, dx, dy, 0);\n\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) *FAILED*\\n\", dnow() - ntim);\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[NPP_nreg] = dx;\n\t\tbatch_dys[NPP_nreg] = dy;\n\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\tif (sent_copyrect) {\n\t\tif (use_batch) {\n\t\t\t;\n\t\t} else if (! obscured) {\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t} else {\n\t\t\t/* no diff for now... */\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t\tncache_post_portions(*nidx, use_batch,\n\t\t    now_x, now_y, orig_w, orig_h, x, y, w, h, batch_delay, ntim);\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: %.4f -- post_portion done.\\n\", dnow() - ntim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "draw_box",
          "args": [
            "0",
            "0",
            "0",
            "0",
            "1"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "draw_box",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "803-1064",
          "snippet": "static void draw_box(int x, int y, int w, int h, int restore) {\n\tint x0, y0, x1, y1, i, pixelsize = bpp/8;\n\tchar *dst, *src, *use_fb;\n\tstatic saveline_t *save[4];\n\tstatic int first = 1, len = 0;\n\tint max = dpy_x > dpy_y ? dpy_x : dpy_y;\n\tint use_Bpl, lw = wireframe_lw;\n\tunsigned long shade = wireframe_shade;\n\tint color = 0;\n\tunsigned short us = 0;\n\tunsigned long ul = 0;\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\n\t/* handle -8to24 mode: use 2nd fb only */\n\tuse_fb  = main_fb;\n\tuse_Bpl = main_bytes_per_line; \n\t\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tuse_fb = cmap8to24_fb;\n\t\tpixelsize = 4;\n\t\tif (depth <= 8) {\n\t\t\tuse_Bpl *= 4;\n\t\t} else if (depth <= 16) {\n\t\t\tuse_Bpl *= 2;\n\t\t}\n\t}\n\n\tif (max > len) {\n\t\t/* create/resize storage lines: */\n\t\tfor (i=0; i<4; i++) {\n\t\t\tlen = max;\n\t\t\tif (! first && save[i]) {\n\t\t\t\tif (save[i]->data) {\n\t\t\t\t\tfree(save[i]->data);\n\t\t\t\t\tsave[i]->data = NULL;\n\t\t\t\t}\n\t\t\t\tfree(save[i]);\n\t\t\t}\n\t\t\tsave[i] = (saveline_t *) malloc(sizeof(saveline_t));\n\t\t\tsave[i]->saved = 0;\n\t\t\tsave[i]->data = (char *) malloc( (LW_MAX+1)*len*4 );\n\n\t\t\t/* \n\t\t\t * Four types of lines:\n\t\t\t *\t0) top horizontal\n\t\t\t *\t1) bottom horizontal\n\t\t\t *\t2) left vertical\n\t\t\t *\t3) right vertical\n\t\t\t *\n\t\t\t * shift means shifted by width or height.\n\t\t\t */\n\t\t\tif (i == 0) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t} else if (i == 2) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 3) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\t/*\n\t * restore any saved lines. see below for algorithm and\n\t * how x0, etc. are used.  we just reverse those steps.\n\t */\n\tfor (i=0; i<4; i++) {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (! save[i]->saved) {\n\t\t\tcontinue;\n\t\t}\n\t\tx0 = save[i]->x0;\n\t\ty0 = save[i]->y0;\n\t\tx1 = save[i]->x1;\n\t\ty1 = save[i]->y1;\n\t\tif (save[i]->vert) {\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\t\t} else {\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\t\t}\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\t\t\tsrc = save[i]->data + (yu-y_start)*y_step;\n\t\t\tdst = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\t\t}\n\t\tif (y_min >= 0) {\nif (0) fprintf(stderr, \"Mark-1 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t\tsave[i]->saved = 0;\n\t}\n\nif (0) fprintf(stderr, \"  DrawBox: %04dx%04d+%04d+%04d B=%d rest=%d lw=%d %.4f\\n\", w, h, x, y, 2*(w+h)*(2-restore)*pixelsize*lw, restore, lw, dnowx());\n\n\tif (restore) {\n\t\treturn;\n\t}\n\n\n\t/*\n\t * work out shade/color for the wireframe line, could be a color\n\t * for 16bpp or 24bpp.\n\t */\n\tif (shade > 255) {\n\t\tif (pixelsize == 2) {\n\t\t\tus = (unsigned short) (shade & 0xffff);\n\t\t\tcolor = 1;\n\t\t} else if (pixelsize == 4) {\n\t\t\tul = (unsigned long) shade;\n\t\t\tcolor = 1;\n\t\t} else {\n\t\t\tshade = shade % 256;\n\t\t}\n\t}\n\n\tfor (i=0; i<4; i++)  {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint yblack = -1, xblack1 = -1, xblack2 = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (save[i]->vert) {\n\t\t\t/*\n\t\t\t * make the narrow x's be on the screen, let\n\t\t\t * the y's hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x + s*w - s*lw, dpy_x);\n\t\t\tsave[i]->y0 = y0 = y;\n\t\t\tsave[i]->x1 = x1 = nfix(x + s*w - s*lw + lw, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y + h;\n\n\t\t\t/*\n\t\t\t * start and stop a linewidth away from true edge,\n\t\t\t * to avoid interfering with horizontal lines.\n\t\t\t */\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\n\t\t\t/* draw a black pixel for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\txblack1 = x1-1;\n\t\t\t} else {\n\t\t\t\txblack1 = x0;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * make the wide x's be on the screen, let the y's\n\t\t\t * hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x,     dpy_x);\n\t\t\tsave[i]->y0 = y0 = y + s*h;\n\t\t\tsave[i]->x1 = x1 = nfix(x + w, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y0 + lw;\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\n\t\t\t/* draw a black pixels for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\tyblack = y_stop - 1;\n\t\t\t} else {\n\t\t\t\tyblack = y_start;\n\t\t\t}\n\t\t\txblack1 = x0;\n\t\t\txblack2 = x1-1;\n\t\t}\n\n\t\t/* now loop over the allowed y's for either case */\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* record min and max y's for marking rectangle: */\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\n\t\t\t/* save fb data for this line: */\n\t\t\tsave[i]->saved = 1;\n\t\t\tsrc = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tdst = save[i]->data + (yu-y_start)*y_step;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\n\t\t\t/* apply the shade/color to make the wireframe line: */\n\t\t\tif (! color) {\n\t\t\t\tmemset(src, shade, (x1-x0)*pixelsize);\n\t\t\t} else {\n\t\t\t\tchar *csrc = src;\n\t\t\t\tunsigned short *usp;\n\t\t\t\tunsigned long *ulp;\n\t\t\t\tint k;\n\t\t\t\tfor (k=0; k < x1 - x0; k++) {\n\t\t\t\t\tif (pixelsize == 4) {\n\t\t\t\t\t\tulp = (unsigned long *)csrc;\n\t\t\t\t\t\t*ulp = ul;\n\t\t\t\t\t} else if (pixelsize == 2) {\n\t\t\t\t\t\tusp = (unsigned short *)csrc;\n\t\t\t\t\t\t*usp = us;\n\t\t\t\t\t}\n\t\t\t\t\tcsrc += pixelsize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* apply black border for lw >= 2 */\n\t\t\tif (lw > 1) {\n\t\t\t\tif (yu == yblack) {\n\t\t\t\t\tmemset(src, 0, (x1-x0)*pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack1 >= 0) {\n\t\t\t\t\tsrc = src + (xblack1 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack2 >= 0) {\n\t\t\t\t\tsrc = src + (xblack2 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* mark it for sending: */\n\t\tif (save[i]->saved) {\nif (0) fprintf(stderr, \"Mark-2 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define LW_MAX 8"
          ],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "static void draw_box(int x, int y, int w, int h, int restore);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static unsigned long wireframe_shade = 0xff;",
            "static int wireframe_lw;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define LW_MAX 8\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic unsigned long wireframe_shade = 0xff;\nstatic int wireframe_lw;\n\nstatic void draw_box(int x, int y, int w, int h, int restore) {\n\tint x0, y0, x1, y1, i, pixelsize = bpp/8;\n\tchar *dst, *src, *use_fb;\n\tstatic saveline_t *save[4];\n\tstatic int first = 1, len = 0;\n\tint max = dpy_x > dpy_y ? dpy_x : dpy_y;\n\tint use_Bpl, lw = wireframe_lw;\n\tunsigned long shade = wireframe_shade;\n\tint color = 0;\n\tunsigned short us = 0;\n\tunsigned long ul = 0;\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\n\t/* handle -8to24 mode: use 2nd fb only */\n\tuse_fb  = main_fb;\n\tuse_Bpl = main_bytes_per_line; \n\t\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tuse_fb = cmap8to24_fb;\n\t\tpixelsize = 4;\n\t\tif (depth <= 8) {\n\t\t\tuse_Bpl *= 4;\n\t\t} else if (depth <= 16) {\n\t\t\tuse_Bpl *= 2;\n\t\t}\n\t}\n\n\tif (max > len) {\n\t\t/* create/resize storage lines: */\n\t\tfor (i=0; i<4; i++) {\n\t\t\tlen = max;\n\t\t\tif (! first && save[i]) {\n\t\t\t\tif (save[i]->data) {\n\t\t\t\t\tfree(save[i]->data);\n\t\t\t\t\tsave[i]->data = NULL;\n\t\t\t\t}\n\t\t\t\tfree(save[i]);\n\t\t\t}\n\t\t\tsave[i] = (saveline_t *) malloc(sizeof(saveline_t));\n\t\t\tsave[i]->saved = 0;\n\t\t\tsave[i]->data = (char *) malloc( (LW_MAX+1)*len*4 );\n\n\t\t\t/* \n\t\t\t * Four types of lines:\n\t\t\t *\t0) top horizontal\n\t\t\t *\t1) bottom horizontal\n\t\t\t *\t2) left vertical\n\t\t\t *\t3) right vertical\n\t\t\t *\n\t\t\t * shift means shifted by width or height.\n\t\t\t */\n\t\t\tif (i == 0) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t} else if (i == 2) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 3) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\t/*\n\t * restore any saved lines. see below for algorithm and\n\t * how x0, etc. are used.  we just reverse those steps.\n\t */\n\tfor (i=0; i<4; i++) {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (! save[i]->saved) {\n\t\t\tcontinue;\n\t\t}\n\t\tx0 = save[i]->x0;\n\t\ty0 = save[i]->y0;\n\t\tx1 = save[i]->x1;\n\t\ty1 = save[i]->y1;\n\t\tif (save[i]->vert) {\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\t\t} else {\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\t\t}\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\t\t\tsrc = save[i]->data + (yu-y_start)*y_step;\n\t\t\tdst = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\t\t}\n\t\tif (y_min >= 0) {\nif (0) fprintf(stderr, \"Mark-1 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t\tsave[i]->saved = 0;\n\t}\n\nif (0) fprintf(stderr, \"  DrawBox: %04dx%04d+%04d+%04d B=%d rest=%d lw=%d %.4f\\n\", w, h, x, y, 2*(w+h)*(2-restore)*pixelsize*lw, restore, lw, dnowx());\n\n\tif (restore) {\n\t\treturn;\n\t}\n\n\n\t/*\n\t * work out shade/color for the wireframe line, could be a color\n\t * for 16bpp or 24bpp.\n\t */\n\tif (shade > 255) {\n\t\tif (pixelsize == 2) {\n\t\t\tus = (unsigned short) (shade & 0xffff);\n\t\t\tcolor = 1;\n\t\t} else if (pixelsize == 4) {\n\t\t\tul = (unsigned long) shade;\n\t\t\tcolor = 1;\n\t\t} else {\n\t\t\tshade = shade % 256;\n\t\t}\n\t}\n\n\tfor (i=0; i<4; i++)  {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint yblack = -1, xblack1 = -1, xblack2 = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (save[i]->vert) {\n\t\t\t/*\n\t\t\t * make the narrow x's be on the screen, let\n\t\t\t * the y's hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x + s*w - s*lw, dpy_x);\n\t\t\tsave[i]->y0 = y0 = y;\n\t\t\tsave[i]->x1 = x1 = nfix(x + s*w - s*lw + lw, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y + h;\n\n\t\t\t/*\n\t\t\t * start and stop a linewidth away from true edge,\n\t\t\t * to avoid interfering with horizontal lines.\n\t\t\t */\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\n\t\t\t/* draw a black pixel for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\txblack1 = x1-1;\n\t\t\t} else {\n\t\t\t\txblack1 = x0;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * make the wide x's be on the screen, let the y's\n\t\t\t * hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x,     dpy_x);\n\t\t\tsave[i]->y0 = y0 = y + s*h;\n\t\t\tsave[i]->x1 = x1 = nfix(x + w, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y0 + lw;\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\n\t\t\t/* draw a black pixels for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\tyblack = y_stop - 1;\n\t\t\t} else {\n\t\t\t\tyblack = y_start;\n\t\t\t}\n\t\t\txblack1 = x0;\n\t\t\txblack2 = x1-1;\n\t\t}\n\n\t\t/* now loop over the allowed y's for either case */\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* record min and max y's for marking rectangle: */\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\n\t\t\t/* save fb data for this line: */\n\t\t\tsave[i]->saved = 1;\n\t\t\tsrc = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tdst = save[i]->data + (yu-y_start)*y_step;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\n\t\t\t/* apply the shade/color to make the wireframe line: */\n\t\t\tif (! color) {\n\t\t\t\tmemset(src, shade, (x1-x0)*pixelsize);\n\t\t\t} else {\n\t\t\t\tchar *csrc = src;\n\t\t\t\tunsigned short *usp;\n\t\t\t\tunsigned long *ulp;\n\t\t\t\tint k;\n\t\t\t\tfor (k=0; k < x1 - x0; k++) {\n\t\t\t\t\tif (pixelsize == 4) {\n\t\t\t\t\t\tulp = (unsigned long *)csrc;\n\t\t\t\t\t\t*ulp = ul;\n\t\t\t\t\t} else if (pixelsize == 2) {\n\t\t\t\t\t\tusp = (unsigned short *)csrc;\n\t\t\t\t\t\t*usp = us;\n\t\t\t\t\t}\n\t\t\t\t\tcsrc += pixelsize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* apply black border for lw >= 2 */\n\t\t\tif (lw > 1) {\n\t\t\t\tif (yu == yblack) {\n\t\t\t\t\tmemset(src, 0, (x1-x0)*pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack1 >= 0) {\n\t\t\t\t\tsrc = src + (xblack1 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack2 >= 0) {\n\t\t\t\t\tsrc = src + (xblack2 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* mark it for sending: */\n\t\tif (save[i]->saved) {\nif (0) fprintf(stderr, \"Mark-2 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"NO button_mask\\n\""
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_copyrect_raise",
          "args": [
            "idx",
            "fr",
            "try_batch"
          ],
          "line": 4855
        },
        "resolved": true,
        "details": {
          "function_name": "check_copyrect_raise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4258-4298",
          "snippet": "int check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "fr"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_copyrect_drag",
          "args": [
            "idx",
            "fr",
            "try_batch"
          ],
          "line": 4826
        },
        "resolved": true,
        "details": {
          "function_name": "set_copyrect_drag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4300-4309",
          "snippet": "int set_copyrect_drag(int idx, Window orig_frame, int try_batch) {\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time > 0.0) {\n\t\tcheck_copyrect_raise(idx, orig_frame, try_batch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint set_copyrect_drag(int idx, Window orig_frame, int try_batch) {\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time > 0.0) {\n\t\tcheck_copyrect_raise(idx, orig_frame, try_batch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** NO GPI DRAW_BOX\\n\""
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DRAW1 %d %d\\n\"",
            "x - box_x",
            "y - box_y"
          ],
          "line": 4780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FRAME MOVE  1st-dt: %.3f\\n\"",
            "first_dt_ave/n"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"WIN RESIZE  1st-dt: %.3f\\n\"",
            "first_dt_ave/n"
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MOVED and diff DY\\n\""
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MOVED and diff DX\\n\""
          ],
          "line": 4740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CHANGED and window switch: 0x%lx\\n\"",
            "frame"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\"",
            "cursor_x - orig_cursor_x",
            "cursor_y - orig_cursor_y",
            "px - orig_px",
            "py - orig_py",
            "x - orig_x",
            "y - orig_y"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\"",
            "x",
            "y",
            "w",
            "h",
            "px",
            "py",
            "frame"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\"",
            "x",
            "y",
            "px",
            "py",
            "frame"
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FRAME-UNMAPPED: 0x%lx\\n\"",
            "orig_frame"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FRAME-GONE: 0x%lx\\n\"",
            "orig_frame"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "orig_frame",
            "&attr",
            "1"
          ],
          "line": 4706
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"NO get_wm_frame_pos-2: 0x%lx\\n\"",
            "frame"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_wm_frame_pos",
          "args": [
            "&px",
            "&py",
            "&x",
            "&y",
            "&w",
            "&h",
            "&frame",
            "NULL"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "get_wm_frame_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "138-200",
          "snippet": "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n#if !NO_X11\n\tWindow r, c;\n\tXWindowAttributes attr;\n\tBool ret;\n\tint rootx, rooty, wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_wm_frame_pos(px, py, x, y, w, h, frame, win);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tif (!px || !py || !x || !y || !w || !h || !frame || !win) {}\n\treturn 0;\n#else\n\n\n\tret = XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty, &wx, &wy,\n\t    &mask);\n\n\t*frame = c;\n\n\t/* current pointer position is returned too */\n\t*px = rootx;\n\t*py = rooty;\n\n\tif (!ret || ! c || c == rootwin) {\n\t\t/* no immediate child */\n\t\treturn 0;\n\t}\n\n\t/* child window position and size */\n\tif (! valid_window(c, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\t*x = attr.x;\n\t*y = attr.y;\n\t*w = attr.width;\n\t*h = attr.height;\n\n#if 0\n\t/* more accurate, but the animation is bogus anyway */\n\tif (attr.border_width > 0) {\n\t\t*w += 2 * attr.border_width;\n\t\t*h += 2 * attr.border_width;\n\t}\n#endif\n\n\tif (win != NULL) {\n\t\t*win = descend_pointer(5, c, NULL, 0);\n\t}\n\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
            "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n#if !NO_X11\n\tWindow r, c;\n\tXWindowAttributes attr;\n\tBool ret;\n\tint rootx, rooty, wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_wm_frame_pos(px, py, x, y, w, h, frame, win);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tif (!px || !py || !x || !y || !w || !h || !frame || !win) {}\n\treturn 0;\n#else\n\n\n\tret = XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty, &wx, &wy,\n\t    &mask);\n\n\t*frame = c;\n\n\t/* current pointer position is returned too */\n\t*px = rootx;\n\t*py = rooty;\n\n\tif (!ret || ! c || c == rootwin) {\n\t\t/* no immediate child */\n\t\treturn 0;\n\t}\n\n\t/* child window position and size */\n\tif (! valid_window(c, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\t*x = attr.x;\n\t*y = attr.y;\n\t*w = attr.width;\n\t*h = attr.height;\n\n#if 0\n\t/* more accurate, but the animation is bogus anyway */\n\tif (attr.border_width > 0) {\n\t\t*w += 2 * attr.border_width;\n\t\t*h += 2 * attr.border_width;\n\t}\n#endif\n\n\tif (win != NULL) {\n\t\t*win = descend_pointer(5, c, NULL, 0);\n\t}\n\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "25 * 1000"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 4676
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\"",
            "got_2nd_pointer+1",
            "spin",
            "cursor_x",
            "cursor_y",
            "button_mask"
          ],
          "line": 4668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" SPIN-OUT-NO2ND_PTR: %.3f\\n\"",
            "spin"
          ],
          "line": 4657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\"",
            "spin"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" SPIN-OUT-NOT-FAST: %.3f\\n\"",
            "spin"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" SPIN-OUT-MAX: %.3f\\n\"",
            "spin"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"wf-spin: %.3f\\n\"",
            "spin"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 4617
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_get_cursor_pos",
          "args": [
            "&x",
            "&y"
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "361-368",
          "snippet": "int macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_cursor_pos(int *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor_pos(int *, int *);\n\nint macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_x11_pointer",
          "args": [],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "check_x11_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1985-2112",
          "snippet": "int check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_which_cursor(void);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "int check_x11_pointer(void);",
            "unsigned long get_cursor_serial(int mode);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_which_cursor(void);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nint check_x11_pointer(void);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nint check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "1000"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cursor_noshape_updates_clients",
          "args": [
            "screen"
          ],
          "line": 4569
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_noshape_updates_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1770-1786",
          "snippet": "int cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nint cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pointer_event",
          "args": [
            "-1",
            "0",
            "0",
            "NULL"
          ],
          "line": 4566
        },
        "resolved": true,
        "details": {
          "function_name": "pointer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "700-1005",
          "snippet": "void pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int pointer_queued_sent = 0;",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint pointer_queued_sent = 0;\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_stack_list",
          "args": [
            "0",
            "0.0"
          ],
          "line": 4536
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "192-293",
          "snippet": "void snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_len = 0;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_len = 0;\nint stack_list_num = 0;\n\nvoid snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_copyrect",
            "\"never\""
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"netrate: %d KB/sec, latency: %d ms\\n\"",
            "netrate",
            "latency"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\""
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_str",
            "WIREFRAME_PARMS"
          ],
          "line": 4484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_macosx_click_frame",
          "args": [],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "check_macosx_click_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4242-4253",
          "snippet": "void check_macosx_click_frame(void) {\n#ifdef MACOSX\n\tif (macosx_console) {\nif (0) fprintf(stderr, \"macosx_click_frame: 0x%x\\n\", macosx_click_frame);\n\t\tcheck_macosx_iconify(macosx_click_frame, None, 0);\n\t\tmacosx_click_frame = None;\n\t\tif (button_mask && !macosx_checkevent(NULL)) {\n\t\t\tcheck_macosx_iconify(None, None, 0);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_macosx_click_frame(void) {\n#ifdef MACOSX\n\tif (macosx_console) {\nif (0) fprintf(stderr, \"macosx_click_frame: 0x%x\\n\", macosx_click_frame);\n\t\tcheck_macosx_iconify(macosx_click_frame, None, 0);\n\t\tmacosx_click_frame = None;\n\t\tif (button_mask && !macosx_checkevent(NULL)) {\n\t\t\tcheck_macosx_iconify(None, None, 0);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"INTERIOR\\n\""
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 4468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"OUTSIDE CLIPSHIFT\\n\""
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r2"
          ],
          "line": 4463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "xc",
            "yc",
            "xc+dpy_x",
            "yc+dpy_y"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x+w",
            "y+h"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wireframe_mod_state",
          "args": [],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "wireframe_mod_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3598-3647",
          "snippet": "static int wireframe_mod_state() {\n\tif (! wireframe_mods) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(wireframe_mods, \"all\")) {\n\t\tif (track_mod_state(NoSymbol, FALSE, FALSE)) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(wireframe_mods, \"Alt\")) {\n\t\tif (track_mod_state(XK_Alt_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Alt_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Shift\")) {\n\t\tif (track_mod_state(XK_Shift_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Shift_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Control\")) {\n\t\tif (track_mod_state(XK_Control_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Control_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Meta\")) {\n\t\tif (track_mod_state(XK_Meta_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Meta_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Super\")) {\n\t\tif (track_mod_state(XK_Super_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Super_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Hyper\")) {\n\t\tif (track_mod_state(XK_Hyper_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Hyper_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wireframe_mod_state();",
            "static char *wireframe_mods = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wireframe_mod_state();\nstatic char *wireframe_mods = NULL;\n\nstatic int wireframe_mod_state() {\n\tif (! wireframe_mods) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(wireframe_mods, \"all\")) {\n\t\tif (track_mod_state(NoSymbol, FALSE, FALSE)) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(wireframe_mods, \"Alt\")) {\n\t\tif (track_mod_state(XK_Alt_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Alt_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Shift\")) {\n\t\tif (track_mod_state(XK_Shift_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Shift_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Control\")) {\n\t\tif (track_mod_state(XK_Control_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Control_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Meta\")) {\n\t\tif (track_mod_state(XK_Meta_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Meta_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Super\")) {\n\t\tif (track_mod_state(XK_Super_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Super_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Hyper\")) {\n\t\tif (track_mod_state(XK_Hyper_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Hyper_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "near_wm_edge",
          "args": [
            "x",
            "y",
            "w",
            "h",
            "px",
            "py"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "near_wm_edge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3471-3498",
          "snippet": "int near_wm_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint wf_t = wireframe_top;\n\tint wf_b = wireframe_bot;\n\tint wf_l = wireframe_left;\n\tint wf_r = wireframe_right;\n\n\tint near_edge = 0;\n\t\n\tif (wf_t || wf_b || wf_l || wf_r) {\n\t\tif (nabs(y - py) < wf_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < wf_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < wf_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < wf_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
            "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "static int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint find_rect(int idx, int x, int y, int w, int h);\nstatic int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;\n\nint near_wm_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint wf_t = wireframe_top;\n\tint wf_b = wireframe_bot;\n\tint wf_l = wireframe_left;\n\tint wf_r = wireframe_right;\n\n\tint near_edge = 0;\n\t\n\tif (wf_t || wf_b || wf_l || wf_r) {\n\t\tif (nabs(y - py) < wf_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < wf_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < wf_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < wf_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\"",
            "x",
            "y",
            "w",
            "h",
            "px",
            "py",
            "frame"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"small window %.3f\\n\"",
            "((double) w*h)/(dpy_x * dpy_y)"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\"",
            "w*h",
            "wireframe_frac",
            "(dpy_x*dpy_y)",
            "frame"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"NO get_wm_frame_pos-1: 0x%lx\\n\"",
            "frame"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n*** button down!!  x: %d  y: %d\\n\"",
            "cursor_x",
            "cursor_y"
          ],
          "line": 4413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_wireframe: %d\\n\"",
            "db"
          ],
          "line": 4411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_wireframe: bm: %d  gpi: %d\\n\"",
            "button_mask",
            "got_pointer_input"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 4379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint check_wireframe(void);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nstatic void parse_wireframe_str(char *wf);\nstatic void destroy_str_list(char **list);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\nstatic int wireframe_mod_state();\nstatic void check_user_input2(double dt);\nstatic double wireframe_frac;\nstatic double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;\nvoid batch_push(int ncr, double delay);\nstatic int NPP_nreg = 0;\nstatic Window NPP_nwin = None;\nint clipped(int idx);\n\nint check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "set_copyrect_drag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4300-4309",
    "snippet": "int set_copyrect_drag(int idx, Window orig_frame, int try_batch) {\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time > 0.0) {\n\t\tcheck_copyrect_raise(idx, orig_frame, try_batch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_copyrect_raise",
          "args": [
            "idx",
            "orig_frame",
            "try_batch"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "check_copyrect_raise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4258-4298",
          "snippet": "int check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint set_copyrect_drag(int idx, Window orig_frame, int try_batch) {\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time > 0.0) {\n\t\tcheck_copyrect_raise(idx, orig_frame, try_batch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_copyrect_raise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4258-4298",
    "snippet": "int check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fb_push(void);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);",
      "void snap_old(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snap_old",
          "args": [],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "snap_old_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6059-6072",
          "snippet": "void snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid snap_old_index(void) {\n\tint i, idx;\n\tfor (i=0; i < old_stack_n; i++) {\n\t\tidx = lookup_win_index(old_stack[i]);\n\t\told_stack_index[i] = idx;\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsViewable) {\n\t\t\t\told_stack_mapped[i] = 1;\n\t\t\t} else {\n\t\t\t\told_stack_mapped[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_stack_list",
          "args": [
            "0",
            "0.0"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "192-293",
          "snippet": "void snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_len = 0;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_len = 0;\nint stack_list_num = 0;\n\nvoid snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--NO,  wf_raise: %s\\n\"",
            "no"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "nr",
            "-1.0"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_fix_su",
          "args": [
            "orig_frame",
            "idx",
            "0x1",
            "nb",
            "NULL"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_fix_su",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7912-8096",
          "snippet": "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int lookup_win_index(Window);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CLEAN_OUT \\\n\tfor (i=0; i < n; i++) { \\\n\t\tsraRgnDestroy(tmp_reg[i]); \\\n\t} \\\n\tif (r1) sraRgnDestroy(r1); \\\n\tif (r0) sraRgnDestroy(r0);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint lookup_win_index(Window);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode) {\n\tint i, idx2, n = 0, found = 0, found_above = 0; \t\n\tsraRegionPtr r0, r1, r2;\n\tWindow win2;\n\tint x, y, w, h, on = 0;\n\tint x0, y0, w0, h0;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint unmapped = 0;\n\tint moved = 0;\n\n\n\tif (mode && !strcmp(mode, \"unmapped\")) {\n\t\tunmapped = 1;\n\t} else if (mode && !strcmp(mode, \"moved\")) {\n\t\tmoved = 1;\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"TRY_TO_FIX_SU(%d)  0x%lx  0x%lx was_unmapped=%d map_state=%s\\n\", idx, win, above, unmapped, MState(cache_list[idx].map_state));\n\n\tif (cache_list[idx].map_state != IsViewable && !unmapped) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].su_time == 0.0) {\n\t\treturn 0;\n\t}\n\tif (cache_list[idx].bs_x < 0) {\n\t\treturn 0;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx = cache_list[idx].x;\n\ty = cache_list[idx].y;\n\tw = cache_list[idx].width;\n\th = cache_list[idx].height;\n\n\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tsraRgnAnd(r1, r0);\n\n\tif (sraRgnEmpty(r1)) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tif (unmapped) {\n\t\ton = 1;\n\t}\n\tif (above == 0x1) {\n\t\ton = 1;\n\t}\n\tfor (i = old_stack_n - 1; i >= 0; i--) {\n\t\twin2 = old_stack[i];\n\t\tif (win2 == above) {\nif (0) fprintf(stderr, \"0x%lx turn on:  0x%lx  i=%d\\n\", win, win2, i);\n\t\t\ton = 1;\n\t\t\tfound_above = 1;\n\t\t}\n\t\tif (win2 == win) {\nif (0) fprintf(stderr, \"0x%lx turn off: 0x%lx  i=%d\\n\", win, win2, i);\n\t\t\tfound = 1;\n\t\t\ton = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (! on) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_win_index(win2);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].bs_x < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* XXX Invalidate? */\n\n\t\tx2 = cache_list[idx2].x;\n\t\ty2 = cache_list[idx2].y;\n\t\tw2 = cache_list[idx2].width;\n\t\th2 = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (! sraRgnAnd(r2, r1)) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_reg[n] = r2;\n\t\ttmp_stack[n++] = idx2;\n\t}\n\n\tif (! found) {\n\t\tCLEAN_OUT\n\t\treturn 0;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint i2;\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tfor (i2 = i + 1; i2 < n; i2++)  {\n\t\t\tsraRgnSubtract(r2, tmp_reg[i2]);\n\t\t}\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* SU -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].su_x;\n\t\t\ty2 = cache_list[idx2].su_y;\n\t\t\tw2 = cache_list[idx2].su_w;\n\t\t\th2 = cache_list[idx2].su_h;\n\n\t\t\tdx = x2 - x0;\n\t\t\tdy = y2 - y0;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x1 - x;\n\t\t\tdy2 = y1 - y;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tif (unmapped) {\n\t\tCLEAN_OUT\n\t\treturn found_above;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tr2 = sraRgnCreateRgn(tmp_reg[i]);\n\t\tidx2 = tmp_stack[i];\n\t\tif (!sraRgnEmpty(r2)) {\n\t\t\tint dx, dy;\n\t\t\tint dx2, dy2;\n\n\t\t\tx0 = cache_list[idx2].x;\n\t\t\ty0 = cache_list[idx2].y;\n\t\t\tw0 = cache_list[idx2].width;\n\t\t\th0 = cache_list[idx2].height;\n\n\t\t\tx1 = cache_list[idx].su_x;\t/* BS -> SU */\n\t\t\ty1 = cache_list[idx].su_y;\n\t\t\tw1 = cache_list[idx].su_w;\n\t\t\th1 = cache_list[idx].su_h;\n\n\t\t\tx2 = cache_list[idx2].bs_x;\n\t\t\ty2 = cache_list[idx2].bs_y;\n\t\t\tw2 = cache_list[idx2].bs_w;\n\t\t\th2 = cache_list[idx2].bs_h;\n\n\t\t\tdx = x1 - x;\n\t\t\tdy = y1 - y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\n\t\t\tdx2 = x2 - x0;\n\t\t\tdy2 = y2 - y0;\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\t\t\tcache_cr(r2, dx, dy, save_delay0, save_delay1, nbatch);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\n\tCLEAN_OUT\n\treturn found_above;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bs_restore",
          "args": [
            "idx",
            "nb",
            "NULL",
            "&attr",
            "0",
            "1",
            "&valid",
            "1"
          ],
          "line": 4284
        },
        "resolved": true,
        "details": {
          "function_name": "bs_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7338-7439",
          "snippet": "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);",
            "int lookup_win_index(Window);",
            "static void draw_box(int x, int y, int w, int h, int restore);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb);\nint lookup_win_index(Window);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint bs_restore(int idx, int *nbatch, sraRegionPtr rmask, XWindowAttributes *attr, int clip, int nopad, int *valid, int verb) {\n\tWindow win = cache_list[idx].win;\n\tint x1, y1, w1, h1;\n\tint x2, y2, w2, h2;\n\tint x, y, w, h;\n\tint dx, dy;\n\tsraRegionPtr r, r0;\n\nif (ncdb && verb) fprintf(stderr, \"backingstore restore:    0x%lx  %3d \\n\", win, idx);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\t\n\tX_LOCK;\n\tif (*valid) {\n\t\tattr->x = x1;\n\t\tattr->y = y1;\n\t\tattr->width = w1;\n\t\tattr->height = h1;\n\t} else if (! valid_wr(idx, win, attr)) {\nif (ncdb) fprintf(stderr, \"BS_restore: not a valid X window: 0x%lx\\n\", win);\n\t\t*valid = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t} else {\n\t\t*valid = 1;\n\t}\n\tX_UNLOCK;\n\n\tx2 = attr->x;\n\ty2 = attr->y;\n\tw2 = attr->width;\n\th2 = attr->height;\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0 || cache_list[idx].bs_time == 0.0) {\n\t\treturn 0;\n\t}\n\n\tif (ncache_pad) {\n\t\tif (nopad) {\n\t\t\tx += ncache_pad;\t\n\t\t\ty += ncache_pad;\t\n\t\t\tw -= 2 * ncache_pad;\t\n\t\t\th -= 2 * ncache_pad;\t\n\t\t} else {\n\t\t\tx2 -= ncache_pad;\t\n\t\t\ty2 -= ncache_pad;\t\n\t\t\tw2 += 2 * ncache_pad;\t\n\t\t\th2 += 2 * ncache_pad;\t\n\t\t}\n\t}\n\n\tif (clipshift) {\n\t\tx2 -= coff_x;\n\t\ty2 -= coff_y;\n\t}\n\n\tif (w2 > w) {\n\t\tw2 = w;\n\t}\n\tif (h2 > h) {\n\t\th2 = h;\n\t}\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr = sraRgnCreateRect(x, y, x+w2, y+h2);\n\n\tdx = x2 - x; \n\tdy = y2 - y; \n\n\tsraRgnOffset(r, dx, dy);\n\tsraRgnAnd(r, r0);\n\n\tif (clip) {\n\t\tclip_region(r, win);\n\t}\n\tif (rmask != NULL) {\n\t\tsraRgnAnd(r, rmask);\n\t}\n\n\tdtA =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f      %d dx=%d dy=%d\\n\", dtA, idx, dx, dy);\n\tif (w2 > 0 && h2 > 0) {\n\t\tcache_cr(r, dx, dy, restore_delay0, restore_delay1, nbatch);\n\t}\n\tdtB =  dnowx();\nif (ncdb && verb) fprintf(stderr, \"BS_rest: %.4f %.2f %d done.  %dx%d+%d+%d %dx%d+%d+%d  %.2f %.2f\\n\", dtB, dtB-dtA, idx, w1, h1, x1, y1, w2, h2, x2, y2, cache_list[idx].bs_time - x11vnc_start, dnowx());\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r);\n\n\tlast_bs_restore = dnow();\n\t\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--YES, wf_raise\\n\""
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clipped",
          "args": [
            "idx"
          ],
          "line": 4273
        },
        "resolved": true,
        "details": {
          "function_name": "clipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "7031-7092",
          "snippet": "int clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint clipped(int idx) {\n\tint ic;\t\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, w1, h1;\n\tWindow win;\n\tint clip = 0;\n\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tx1 = cache_list[idx].x;\n\ty1 = cache_list[idx].y;\n\tw1 = cache_list[idx].width;\n\th1 = cache_list[idx].height;\n\n\twin = cache_list[idx].win;\n\n\tr1 = sraRgnCreateRect(x1, y1, x1+w1, y1+h1);\n\tsraRgnAnd(r1, r0);\n\n\tfor (ic = old_stack_n - 1; ic >= 0; ic--) {\n\t\tint xc, yc, wc, hc, idx2;\n\n\t\tif (old_stack[ic] == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (old_stack_mapped[ic] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tidx2 = lookup_old_stack_index(ic);\n\t\tif (idx2 < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cache_list[idx2].win == win) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cache_list[idx2].map_state != IsViewable) {\n\t\t\tcontinue;\n\t\t}\n\t\txc = cache_list[idx2].x;\n\t\tyc = cache_list[idx2].y;\n\t\twc = cache_list[idx2].width;\n\t\thc = cache_list[idx2].height;\n\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+wc, yc+hc);\n\t\tsraRgnAnd(r2, r0);\n\t\tif (sraRgnAnd(r2, r1)) {\nif (0) fprintf(stderr, \"clip[0x%lx]: 0x%lx, %d/%d\\n\", win, cache_list[idx2].win, ic, idx2);\n\t\t\tclip = 1;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t\tif (clip) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\nif (0) fprintf(stderr, \"clip[0x%lx]: %s\\n\", win, clip ? \"clipped\" : \"no-clipped\");\n\treturn clip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_copyrect_raise(int idx, Window orig_frame, int try_batch) {\n\tchar *no = \"none\";\n\tint doraise = 1;\n\tint valid;\n\tXWindowAttributes attr;\n\n\tif (! ncache_wf_raises) {\n\t\tdoraise = 0;\n\t\tno = \"ncache_wf_raises\";\n\t} else if (cache_list[idx].bs_time == 0.0) {\n\t\tdoraise = 0;\n\t\tno = \"bs_time\";\n\t} else if (0 && cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\tdoraise = 0;\n\t\tno = \"VisibilityUnobscured\";\n\t} else if (!clipped(idx)) {\n\t\tdoraise = 0;\n\t\tno = \"!clipped()\";\n\t}\n\tif (doraise) {\n\t\tint nr = 0, *nb = NULL;\nif (ncdb) fprintf(stderr, \"--YES, wf_raise\\n\");\n\t\tif (try_batch) {\n\t\t\tnb = &nr;\n\t\t}\n\t\tvalid = 1;\n\t\tbs_restore(idx, nb, NULL, &attr, 0, 1, &valid, 1);\n\t\ttry_to_fix_su(orig_frame, idx, 0x1, nb, NULL);\t\n\t\tif (nb && nr) {\n\t\t\tbatch_push(nr, -1.0);\n\t\t}\n\t\tfb_push(); /* XXX Y */\n\t} else {\nif (ncdb && no) fprintf(stderr, \"--NO,  wf_raise: %s\\n\", no);\n\t}\n\tif (ncache_wf_raises) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tsnap_old();\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "check_macosx_click_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4242-4253",
    "snippet": "void check_macosx_click_frame(void) {\n#ifdef MACOSX\n\tif (macosx_console) {\nif (0) fprintf(stderr, \"macosx_click_frame: 0x%x\\n\", macosx_click_frame);\n\t\tcheck_macosx_iconify(macosx_click_frame, None, 0);\n\t\tmacosx_click_frame = None;\n\t\tif (button_mask && !macosx_checkevent(NULL)) {\n\t\t\tcheck_macosx_iconify(None, None, 0);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_macosx_iconify",
          "args": [
            "None",
            "None",
            "0"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "check_macosx_iconify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4184-4240",
          "snippet": "void check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "NULL"
          ],
          "line": 4248
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosx_click_frame: 0x%x\\n\"",
            "macosx_click_frame"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_macosx_click_frame(void) {\n#ifdef MACOSX\n\tif (macosx_console) {\nif (0) fprintf(stderr, \"macosx_click_frame: 0x%x\\n\", macosx_click_frame);\n\t\tcheck_macosx_iconify(macosx_click_frame, None, 0);\n\t\tmacosx_click_frame = None;\n\t\tif (button_mask && !macosx_checkevent(NULL)) {\n\t\t\tcheck_macosx_iconify(None, None, 0);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "check_macosx_iconify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4184-4240",
    "snippet": "void check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int clipped(int idx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "0",
            "2"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_COPY|FB_MOD"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Check Event    0\\n\""
          ],
          "line": 4224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Check Event    1\\n\""
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "NULL"
          ],
          "line": 4220
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGS_get_all_windows",
          "args": [],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_all_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "262-521",
          "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTMAX 4",
            "#define WINHISTNUM 32768",
            "#define MAXWINDAT 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FAW frame      %d\\n\"",
            "(int) frame"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_follow_animation_win",
          "args": [
            "frame",
            "-1",
            "0"
          ],
          "line": 4215
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_follow_animation_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "176-238",
          "snippet": "int macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FAW orig_frame %d\\n\"",
            "(int) orig_frame"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FAW orig_frame unmapped.\\n\""
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "orig_frame"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nvoid check_macosx_iconify(Window orig_frame, Window frame, int flush) {\n#ifdef MACOSX\n\tstatic double last = 0.0;\n\tdouble now;\n\tint j, m = 5, idx = -1, ok = 0, unmapped = 0;\n\n\tif (! macosx_console) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last + 0.3) {\n\t\treturn;\n\t}\n\tlast = now;\n\n\tif (ncache > 0 && orig_frame != None) {\n\t\tidx = lookup_win_index(orig_frame);\n\t\tif (idx >= 0) {\n\t\t\tif (cache_list[idx].map_state == IsUnmapped) {\nif (0) fprintf(stderr, \"FAW orig_frame unmapped.\\n\");\n\t\t\t\tunmapped = 1;\n\t\t\t\tm = 3;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unmapped) {\n\t\t;\n\t} else if (orig_frame && macosxCGS_follow_animation_win(orig_frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW orig_frame %d\\n\", (int) orig_frame);\n\t} else if (0 && frame && macosxCGS_follow_animation_win(frame, -1, 0)) {\n\t\tif (0) fprintf(stderr, \"FAW frame      %d\\n\", (int) frame);\n\t}\n\tfor (j=0; j<m; j++) {\n\t\tmacosxCGS_get_all_windows();\n\t\tif (macosx_checkevent(NULL)) {\n\t\t\tok = 1;\n\t\t\tif (0) fprintf(stderr, \"Check Event    1\\n\");\n\t\t} else {\n\t\t\tif (0) fprintf(stderr, \"Check Event    0\\n\");\n\t\t}\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\tif (ok) {\n\t\tif (flush) {\n\t\t\tfb_push_wait(0.1, FB_COPY|FB_MOD);\n\t\t}\n\t\tcheck_ncache(0, 2);\n\t}\n#else\n\tif (!orig_frame || !frame || !flush) {}\n#endif\n}"
  },
  {
    "function_name": "do_copyrect_drag_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "4111-4182",
    "snippet": "void do_copyrect_drag_move(Window orig_frame, Window frame, int *nidx, int try_batch,\n    int now_x, int now_y, int orig_w, int orig_h, int x, int y, int w, int h, double batch_delay) {\n\n\tint sent_copyrect = 1, obscured = 0;\n\tint dx, dy;\n\tint use_batch = 0;\n\tdouble ntim = dnow();\n\tstatic int nob = -1;\n\tsraRegionPtr r0, r1;\n\n\tif (nob < 0) {\n\t\tif (getenv(\"NOCRBATCH\")) {\n\t\t\tnob = 1;\n\t\t} else {\n\t\t\tnob = 0;\n\t\t}\n\t}\n\tif (nob) {\n\t\ttry_batch = 0;\n\t}\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\tif (dx == 0 && dy == 0) {\n\t\treturn;\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: now_xy: %d %d, orig_wh: %d %d, xy: %d %d, wh: %d %d\\n\",now_x, now_y, orig_w, orig_h, x, y, w, h);\n\t\n\tncache_pre_portions(orig_frame, frame, nidx, try_batch, &use_batch,\n\t    now_x, now_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\tsraRgnAnd(r1, r0);\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\n\t/* make sure the source is on-screen too */\n\tsraRgnOffset(r1, -dx, -dy);\n\tsraRgnAnd(r1, r0);\n\tsraRgnOffset(r1, +dx, +dy);\n\tsraRgnAnd(r1, r0);\t/* just to be sure, problably not needed */\n\n\tif (! use_batch) {\n\t\tdo_copyregion(r1, dx, dy, 0);\n\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) *FAILED*\\n\", dnow() - ntim);\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[NPP_nreg] = dx;\n\t\tbatch_dys[NPP_nreg] = dy;\n\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\tif (sent_copyrect) {\n\t\tif (use_batch) {\n\t\t\t;\n\t\t} else if (! obscured) {\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t} else {\n\t\t\t/* no diff for now... */\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t\tncache_post_portions(*nidx, use_batch,\n\t\t    now_x, now_y, orig_w, orig_h, x, y, w, h, batch_delay, ntim);\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: %.4f -- post_portion done.\\n\", dnow() - ntim);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];",
      "static int NPP_nreg = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"do_COPY: %.4f -- post_portion done.\\n\"",
            "dnow() - ntim"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncache_post_portions",
          "args": [
            "*nidx",
            "use_batch",
            "now_x",
            "now_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "batch_delay",
            "ntim"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "ncache_post_portions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3879-4109",
          "snippet": "void ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];",
            "static int NPP_nreg = 0;",
            "static sraRegionPtr NPP_roffscreen = NULL;",
            "static sraRegionPtr NPP_r_bs_tmp = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\n\nvoid ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_COPY"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 4167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 3) *FAILED*\\n\"",
            "dnow() - ntim"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "r1",
            "dx",
            "dy",
            "0"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r1",
            "+dx",
            "+dy"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r1",
            "-dx",
            "-dy"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncache_pre_portions",
          "args": [
            "orig_frame",
            "frame",
            "nidx",
            "try_batch",
            "&use_batch",
            "now_x",
            "now_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h",
            "ntim"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "ncache_pre_portions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3746-3877",
          "snippet": "void ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];",
            "static int NPP_nreg = 0;",
            "static sraRegionPtr NPP_roffscreen = NULL;",
            "static sraRegionPtr NPP_r_bs_tmp = NULL;",
            "static Window NPP_nwin = None;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\nstatic Window NPP_nwin = None;\n\nvoid ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"do_COPY: now_xy: %d %d, orig_wh: %d %d, xy: %d %d, wh: %d %d\\n\"",
            "now_x",
            "now_y",
            "orig_w",
            "orig_h",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"NOCRBATCH\""
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\n\nvoid do_copyrect_drag_move(Window orig_frame, Window frame, int *nidx, int try_batch,\n    int now_x, int now_y, int orig_w, int orig_h, int x, int y, int w, int h, double batch_delay) {\n\n\tint sent_copyrect = 1, obscured = 0;\n\tint dx, dy;\n\tint use_batch = 0;\n\tdouble ntim = dnow();\n\tstatic int nob = -1;\n\tsraRegionPtr r0, r1;\n\n\tif (nob < 0) {\n\t\tif (getenv(\"NOCRBATCH\")) {\n\t\t\tnob = 1;\n\t\t} else {\n\t\t\tnob = 0;\n\t\t}\n\t}\n\tif (nob) {\n\t\ttry_batch = 0;\n\t}\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\tif (dx == 0 && dy == 0) {\n\t\treturn;\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: now_xy: %d %d, orig_wh: %d %d, xy: %d %d, wh: %d %d\\n\",now_x, now_y, orig_w, orig_h, x, y, w, h);\n\t\n\tncache_pre_portions(orig_frame, frame, nidx, try_batch, &use_batch,\n\t    now_x, now_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\tsraRgnAnd(r1, r0);\n\n\tdx = x - now_x;\n\tdy = y - now_y;\n\n\t/* make sure the source is on-screen too */\n\tsraRgnOffset(r1, -dx, -dy);\n\tsraRgnAnd(r1, r0);\n\tsraRgnOffset(r1, +dx, +dy);\n\tsraRgnAnd(r1, r0);\t/* just to be sure, problably not needed */\n\n\tif (! use_batch) {\n\t\tdo_copyregion(r1, dx, dy, 0);\n\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) *FAILED*\\n\", dnow() - ntim);\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t} else {\n\t\tbatch_dxs[NPP_nreg] = dx;\n\t\tbatch_dys[NPP_nreg] = dy;\n\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\tif (sent_copyrect) {\n\t\tif (use_batch) {\n\t\t\t;\n\t\t} else if (! obscured) {\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t} else {\n\t\t\t/* no diff for now... */\n\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t}\n\t\tncache_post_portions(*nidx, use_batch,\n\t\t    now_x, now_y, orig_w, orig_h, x, y, w, h, batch_delay, ntim);\n\t}\nif (ncdb) fprintf(stderr, \"do_COPY: %.4f -- post_portion done.\\n\", dnow() - ntim);\n}"
  },
  {
    "function_name": "ncache_post_portions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3879-4109",
    "snippet": "void ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "winattr_t *cache_list;",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];",
      "static int NPP_nreg = 0;",
      "static sraRegionPtr NPP_roffscreen = NULL;",
      "static sraRegionPtr NPP_r_bs_tmp = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_borders",
          "args": [
            "rects",
            "2"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "push_borders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3684-3744",
          "snippet": "void push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "NPP_nreg",
            "batch_delay"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4087
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\"",
            "dnow() - ntim",
            "(unsigned int) cache_list[nidx].win",
            "nidx",
            "su_w",
            "su_h",
            "su_x",
            "su_y",
            "bs_w",
            "bs_h",
            "bs_x",
            "bs_y"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_COPY"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 6) FAILED.\\n\"",
            "dnow() - ntim"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "r1",
            "dx",
            "dy",
            "0"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 6) snapshot bs:\\n\"",
            "dnow() - ntim"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r1",
            "dx",
            "dy"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r1"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 5) FAILED.\\n\"",
            "dnow() - ntim"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 5) move tmp bs to su:\\n\"",
            "dnow() - ntim"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r3"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r3"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "NPP_r_bs_tmp"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r1",
            "dx",
            "dy"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "NPP_r_bs_tmp"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "su_x",
            "su_y",
            "su_x + su_w",
            "su_y + su_h"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r3"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 4) FAILED.\\n\"",
            "dnow() - ntim"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 4) move overlap inside su:\\n\"",
            "dnow() - ntim"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r3",
            "dx",
            "dy"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx2",
            "dy2"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r2"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "orig_x",
            "orig_y",
            "orig_x + orig_w",
            "orig_y + orig_h"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sent_copyrect: %.4f su_restore: done.\\n\"",
            "dnow() - ntim"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 3) FAILED.\\n\"",
            "dnow() - ntim"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\"",
            "dnow() - ntim",
            "dx",
            "dy"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r1",
            "r2"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r0"
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x+np",
            "y+np",
            "x + w-np",
            "y + h-np"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "orig_x",
            "orig_y",
            "orig_x + orig_w",
            "orig_y + orig_h"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "NPP_roffscreen"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "NPP_roffscreen"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "NPP_roffscreen",
            "r0"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "NPP_roffscreen",
            "dx",
            "dy"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "nidx",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\"",
            "su_w",
            "su_h",
            "su_x",
            "su_y",
            "bs_w",
            "bs_h",
            "bs_x",
            "bs_y"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\n\nvoid ncache_post_portions(int nidx, int use_batch, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, double batch_delay, double ntim) {\n\tint np = ncache_pad;\n\tint db = 0;\n\n\tif (ncache > 0 && nidx >= 0) {\n\t\tsraRegionPtr r0, r1, r2, r3;\n\t\tint dx, dy;\n\t\tint su_x = cache_list[nidx].su_x;\n\t\tint su_y = cache_list[nidx].su_y;\n\t\tint su_w = cache_list[nidx].su_w;\n\t\tint su_h = cache_list[nidx].su_h;\n\t\tint bs_x = cache_list[nidx].bs_x;\n\t\tint bs_y = cache_list[nidx].bs_y;\n\t\tint bs_w = cache_list[nidx].bs_w;\n\t\tint bs_h = cache_list[nidx].bs_h;\n\t\tint some_su = 0;\n\nif (db) fprintf(stderr, \"su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsu_x = cache_list[nidx].su_x;\n\t\t\tsu_y = cache_list[nidx].su_y;\n\t\t\tsu_w = cache_list[nidx].su_w;\n\t\t\tsu_h = cache_list[nidx].su_h;\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\t/* 0b) copy this bs part stored in saveunder */\n\t\tif (NPP_roffscreen != NULL) {\n\t\t\tdx = x - su_x;\n\t\t\tdy = y - su_y;\n\t\t\tsraRgnOffset(NPP_roffscreen, dx, dy);\n\t\t\tsraRgnAnd(NPP_roffscreen, r0);\n\t\t\t\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(NPP_roffscreen, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(NPP_roffscreen);\n\t\t\t}\n\t\t\tsraRgnDestroy(NPP_roffscreen);\n\t\t}\n\n\t\t/* 3) copy from the saveunder to where orig win was */\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x+np, y+np, x + w-np, y + h-np);\n\t\tsraRgnAnd(r2, r0);\n\t\tsraRgnSubtract(r1, r2);\n\n\t\tdx = orig_x - su_x;\n\t\tdy = orig_y - su_y;\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) sent_copyrect: su_restore: %d %d\\n\", dnow() - ntim, dx, dy);\n\t\tif (cache_list[nidx].su_time == 0.0) {\n\t\t\t;\n\t\t} else if (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 3) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\nif (db && ncdb) fprintf(stderr, \"sent_copyrect: %.4f su_restore: done.\\n\", dnow() - ntim);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 4) if overlap between orig and displaced, move the corner that will still be su: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr1 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnAnd(r1, r0);\n\t\tr2 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r2, r0);\n\t\tr3 = NULL;\n\t\tif (sraRgnAnd(r2, r1) && cache_list[nidx].su_time > 0.0) {\n\t\t\tint dx2 = su_x - orig_x;\n\t\t\tint dy2 = su_y - orig_y;\n\n\t\t\tr3 = sraRgnCreateRgn(r2);\n\t\t\tsraRgnOffset(r2, dx2, dy2); \n\n\t\t\tdx = su_x - x;\n\t\t\tdy = su_y - y;\n\t\t\tsraRgnOffset(r3, dx, dy); \n\n\t\t\tdx = dx - dx2;\n\t\t\tdy = dy - dy2;\n\nif (db && ncdb) fprintf(stderr, \"FB_COPY: %.4f 4) move overlap inside su:\\n\", dnow() - ntim);\n\t\t\tif (! use_batch) {\n\t\t\t\tdo_copyregion(r3, dx, dy, 0);\n\t\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 4) FAILED.\\n\", dnow() - ntim);\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r3);\n\t\t\t}\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 5) copy our temporary stuff from bs to su: */\n\t\tdx = su_x - bs_x;\n\t\tdy = su_y - bs_y;\n\t\tif (NPP_r_bs_tmp == NULL) {\n\t\t\tr1 = sraRgnCreateRect(su_x, su_y, su_x + su_w, su_y + su_h); \n\t\t} else {\n\t\t\tr1 = sraRgnCreateRgn(NPP_r_bs_tmp);\n\t\t\tsraRgnOffset(r1, dx, dy);\n\t\t\tsraRgnDestroy(NPP_r_bs_tmp);\n\t\t}\n\t\tif (r3 != NULL) {\n\t\t\tsraRgnSubtract(r1, r3);\n\t\t\tsraRgnDestroy(r3);\n\t\t}\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) move tmp bs to su:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 5) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tif (! sraRgnEmpty(r1)) {\n\t\t\tsome_su = 1;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\n\t\t/* 6) not really necessary, update bs with current view: */\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) snapshot bs:\\n\", dnow() - ntim);\n\t\tif (! use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (!fb_push_wait(0.2, FB_COPY)) {\nif (db) fprintf(stderr, \"FB_COPY: %.4f 6) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f XX did batch 0x%x %3d su: %dx%d+%d+%d  bs: %dx%d+%d+%d\\n\", dnow() - ntim,\n\t(unsigned int) cache_list[nidx].win, nidx, su_w, su_h, su_x, su_y, bs_w, bs_h, bs_x, bs_y);\n\t\t}\n\t\tcache_list[nidx].x = x + np;\n\t\tcache_list[nidx].y = y + np;\n\n\t\t/* XXX Y */\n\t\tcache_list[nidx].bs_time = dnow();\n\t\tif (some_su) {\n\t\t\tcache_list[nidx].su_time = dnow();\n\t\t}\n\t} else {\n\t\tif (use_batch) {\n\t\t\tbatch_push(NPP_nreg, batch_delay);\n\t\t}\n\t}\n\n\tif (scaling) {\n\t\tsraRect rects[2];\t\n\n\t\trects[0].x1 = orig_x;\n\t\trects[0].y1 = orig_y;\n\t\trects[0].x2 = orig_w;\n\t\trects[0].y2 = orig_h;\n\n\t\trects[1].x1 = x;\n\t\trects[1].y1 = y;\n\t\trects[1].x2 = w;\n\t\trects[1].y2 = h;\n\t\tpush_borders(rects, 2);\n\t}\n}"
  },
  {
    "function_name": "ncache_pre_portions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3746-3877",
    "snippet": "void ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
      "int lookup_win_index(Window);",
      "winattr_t *cache_list;",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];",
      "static int NPP_nreg = 0;",
      "static sraRegionPtr NPP_roffscreen = NULL;",
      "static sraRegionPtr NPP_r_bs_tmp = NULL;",
      "static Window NPP_nwin = None;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r1"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_COPY"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 1) FAILED.\\n\"",
            "dnow() - ntim"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "r1",
            "dx",
            "dy",
            "0"
          ],
          "line": 3863
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 1) use tmp bs:\\n\"",
            "dnow() - ntim"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r1",
            "dx",
            "dy"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r2"
          ],
          "line": 3849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "r2"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\"",
            "dnow() - ntim",
            "bs_x - orig_x",
            "bs_y - orig_y",
            "dx",
            "dy",
            "orig_w",
            "orig_h",
            "orig_x",
            "orig_y",
            "bs_x",
            "bs_y"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "r2",
            "dx",
            "dy"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r2"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "r2",
            "r0"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "orig_x",
            "orig_y",
            "orig_x + orig_w",
            "orig_y + orig_h"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_rect",
          "args": [
            "nidx",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "find_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6724-6982",
          "snippet": "int find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint find_rect(int idx, int x, int y, int w, int h) {\n\tsraRegionPtr r1, r2;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\tint n, x_hit = -1, y_hit = -1;\n\tint big1 = 0, big2 = 0, cram = 0;\n\tdouble fac1 = 0.1, fac2 = 0.25;\n\tdouble last_clean = 0.0;\n\tdouble now = dnow();\n\tstatic int nobigs = -1;\n\n\tif (rect_reg[1] == NULL) {\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t}\n\t} else if (now > last_clean + 60) {\n\t\tlast_clean = now;\n\t\tfor (n = 1; n < ncache; n += 2) {\n\t\t\tint i, n2 = n+1;\n\n\t\t\t/* n */\n\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint bs_y = cache_list[i].bs_y;\n\t\t\t\tint bs_w = cache_list[i].bs_w;\n\t\t\t\tint bs_h = cache_list[i].bs_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(bs_y) != n) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(bs_x, bs_y, bs_x+bs_w, bs_y+bs_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n] = r1;\n\n\t\t\t/* n+1 */\n\t\t\tsraRgnDestroy(rect_reg[n2]);\n\t\t\tr1 = sraRgnCreateRect(0, n2 * dpy_y, dpy_x, (n2+1) * dpy_y);\n\t\t\tfor (i=0; i<cache_list_num; i++) {\n\t\t\t\tint bs_x = cache_list[i].bs_x;\n\t\t\t\tint su_x = cache_list[i].su_x;\n\t\t\t\tint su_y = cache_list[i].su_y;\n\t\t\t\tint su_w = cache_list[i].su_w;\n\t\t\t\tint su_h = cache_list[i].su_h;\n\t\t\t\tif (bs_x < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (get_bs_n(su_y) != n2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(su_x, su_y, su_x+su_w, su_y+su_h);\n\t\t\t\tsraRgnSubtract(r1, r2);\n\t\t\t}\n\t\t\trect_reg[n2] = r1;\n\t\t}\n\t}\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (ncdb) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tcache_list[idx].bs_x = -1;\n\tcache_list[idx].su_x = -1;\n\tcache_list[idx].bs_time = 0.0;\n\tcache_list[idx].su_time = 0.0;\n\n\tif (ncache_pad) {\n\t\tx -= ncache_pad;\t\n\t\ty -= ncache_pad;\t\n\t\tw += 2 * ncache_pad;\t\n\t\th += 2 * ncache_pad;\t\n\t}\n\n\tif (ncache <= 2) {\n\t\tcram = 1;\n\t\tfac2 = 0.45;\n\t} else if (ncache <= 4) {\n\t\tfac1 = 0.18;\n\t\tfac2 = 0.35;\n\t}\n\tif (macosx_console && !macosx_ncache_macmenu) {\n\t\tif (cram) {\n\t\t\tfac1 *= 1.5;\t\n\t\t\tfac2 *= 1.5;\t\n\t\t} else {\n\t\t\tfac1 *= 2.5;\t\n\t\t\tfac2 *= 2.5;\t\n\t\t}\n\t}\n\tif (w * h > fac1 * (dpy_x * dpy_y)) {\n\t\tbig1 = 1;\n\t}\n\tif (w * h > fac2 * (dpy_x * dpy_y)) {\n\t\tbig2 = 1;\n\t}\n\n\tif (nobigs < 0) {\n\t\tif (getenv(\"NOBIGS\")) {\n\t\t\tnobigs = 1;\n\t\t} else {\n\t\t\tnobigs = 0;\n\t\t}\n\t}\n\tif (nobigs) {\n\t\tbig1 = big2 = 0;\n\t}\n\n\tif (w > dpy_x || h > dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (w == dpy_x && h == dpy_y) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG1 rect: %dx%d+%d+%d -- %d %d (FULL DISPLAY)\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG1++;\n\t\tfr_BIG1t++;\n\t\treturn 0;\n\t}\n\tif (cram && big2) {\nif (ncdb) fprintf(stderr, \">>**--**>> BIG2 rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_BIG2++;\n\t\tfr_BIG2t++;\n\t\treturn 0;\n\t}\n\n\t/* first try individual rects of unused region */\n\tfor (n = 1; n < ncache; n += 2) {\n\t\tr1 = rect_reg[n];\n\t\tr2 = NULL;\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n <= 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\t\titer = sraRgnGetIterator(r1);\n\t\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\t\tint rw = rt.x2 - rt.x1;\n\t\t\tint rh = rt.y2 - rt.y1;\n\t\t\tif (cram && big1 && rt.x1 < dpy_x/4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rw >= w && rh >= h) {\n\t\t\t\tx_hit = rt.x1;\n\t\t\t\ty_hit = rt.y1;\n\t\t\t\tif (cram && big1) {\n\t\t\t\t\tx_hit = rt.x2 - w;\n\t\t\t\t}\n\t\t\t\tr2 = sraRgnCreateRect(x_hit, y_hit, x_hit + w, y_hit + h);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tif (r2 != NULL) {\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via REGION: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_REGION++;\n\t\t\tfr_REGIONt++;\n\t\t\tsraRgnSubtract(r1, r2);\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\t/* next try moving corner to grid points */\n\tif (x_hit < 0) {\n\t    for (n = 1; n < ncache; n += 2) {\n\t\tint rx, ry, Nx = 48, Ny = 24, ny = n * dpy_y;\n\n\t\tif (big1 && n == 1 && ncache > 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (big2 && n == 3 && ncache > 4) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tr1 = sraRgnCreateRect(0, n * dpy_y, dpy_x, (n+1) * dpy_y);\n\t\tsraRgnSubtract(r1, rect_reg[n]);\n\t\tr2 = NULL;\n\n\t\trx = 0;\n\t\twhile (rx + w <= dpy_x) {\n\t\t    ry = 0;\n\t\t    if (cram && big1 && rx < dpy_x/4) {\n\t\t\trx += dpy_x/Nx;\n\t\t    \tcontinue;\n\t\t    }\n\t\t    while (ry + h <= dpy_y) {\n\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = NULL;\n\t\t\t} else {\n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\tr2 = sraRgnCreateRect(rx, ry+ny, rx + w, ry+ny + h);\n\t\t\t\tx_hit = rx;\n\t\t\t\ty_hit = ry+ny;\n\t\t\t}\n\t\t\try += dpy_y/Ny;\n\t\t\tif (r2) break;\n\t\t    }\n\t\t    rx += dpy_x/Nx;\n\t\t    if (r2) break;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tif (r2 != NULL) {\n\t\t\tsraRgnSubtract(rect_reg[n], r2);\n\t\t\tsraRgnDestroy(r2);\nif (ncdb) fprintf(stderr, \">>**--**>> found rect via GRID: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\t\tfr_GRID++;\n\t\t\tfr_GRIDt++;\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n\n\t/* next, try expiring the oldest/smallest used bs/su rectangle we fit in */\n\n\tif (x_hit < 0) {\n\t\texpire_rects(idx, w, h, &x_hit, &y_hit, big1, big2, cram);\n\t}\n\n\tcache_list[idx].bs_x = x_hit;\n\tcache_list[idx].bs_y = y_hit;\n\tcache_list[idx].bs_w = w;\n\tcache_list[idx].bs_h = h;\n\n\tcache_list[idx].su_x = x_hit;\n\tcache_list[idx].su_y = y_hit + dpy_y;\n\tcache_list[idx].su_w = w;\n\tcache_list[idx].su_h = h;\n\n\tif (x_hit < 0) {\n\t\t/* bad news, can it still happen? */\n\t\tif (ncdb) fprintf(stderr, \">>**--**>> *FAIL rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t\tfr_FAIL++;\n\t\tfr_FAILt++;\n\t\treturn 0;\n\t} else {\n\t\tif (0) fprintf(stderr, \">>**--**>> found rect: %dx%d+%d+%d -- %d %d\\n\", w, h, x, y, x_hit, y_hit);\n\t}\n\n\tif (zero_rects) {\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit, x_hit+w, y_hit+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t\tr1 = sraRgnCreateRect(x_hit, y_hit+dpy_y, x_hit+w, y_hit+dpy_y+h);\n\t\tsraRgnSubtract(zero_rects, r1);\n\t\tsraRgnDestroy(r1);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_win_index",
          "args": [
            "frame"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_win_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5927-5974",
          "snippet": "int lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint lookup_win_index(Window win) {\n\tint k, idx = -1;\n\tint foundfree = 0;\n\tstatic int s1 = 0, s2 = 0, s3 = 0;\n\n\tif (win == rootwin || win == None) {\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NRECENT; k++) {\n\t\tif (recent[k] == win) {\n\t\t\tint k2 = recidx[k];\n\t\t\tif (cache_list[k2].win == win) {\n\t\t\t\tidx = k2;\nif (0) fprintf(stderr, \"recentA(shortcut): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts1++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tfor(k=0; k<cache_list_num; k++) {\n\t\t\tif (!foundfree && cache_list[k].win == None) {\n\t\t\t\trfree = k;\n\t\t\t\tfoundfree = 1;\n\t\t\t}\n\t\t\tif (cache_list[k].win == win) {\n\t\t\t\tidx = k;\nif (0) fprintf(stderr, \"recentB(normal): %d  0x%lx\\n\", idx, win);\n\t\t\t\ts2++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\trecent[rlast] = win;\n\t\t\trecidx[rlast++] = idx;\n\t\t\trlast = rlast % NRECENT;\n\t\t}\n\t}\n\tif (idx < 0) {\nif (ncdb) fprintf(stderr, \"recentC(fail): %d  0x%lx\\n\", idx, win);\n\t\ts3++;\n\t}\n\tif (s1 + s2 + s3 >= 1000) {\nif (ncdb) fprintf(stderr, \"lookup_win_index recent hit stats: %d/%d/%d\\n\", s1, s2, s3);\n\t\ts1 = s2 = s3 = 0;\n\t}\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nwinattr_t *cache_list;\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\nstatic int NPP_nreg = 0;\nstatic sraRegionPtr NPP_roffscreen = NULL;\nstatic sraRegionPtr NPP_r_bs_tmp = NULL;\nstatic Window NPP_nwin = None;\n\nvoid ncache_pre_portions(Window orig_frame, Window frame, int *nidx_in, int try_batch, int *use_batch,\n    int orig_x, int orig_y, int orig_w, int orig_h, int x, int y, int w, int h, double ntim) {\n\tint nidx, np = ncache_pad;\n\n\tif (!ntim) {}\n\t*use_batch = 0;\n\t*nidx_in = -1;\n\tNPP_nreg = 0;\n\tNPP_roffscreen = NULL;\n\tNPP_r_bs_tmp = NULL;\n\tNPP_nwin = None;\n\t\n\tif (ncache <= 0) {\n\t\treturn;\n\t}\n\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (*nidx_in == -1) {\n\t\tnidx = lookup_win_index(orig_frame);\n\t\tNPP_nwin = orig_frame;\n\t\tif (nidx < 0) {\n\t\t\tnidx = lookup_win_index(frame);\n\t\t\tNPP_nwin = frame;\n\t\t}\n\t} else {\n\t\tnidx = *nidx_in;\n\t}\n\tif (nidx > 0) {\n\t\tsraRegionPtr r0, r1, r2;\n\t\tint dx, dy;\n\t\tint bs_x = cache_list[nidx].bs_x;\t\n\t\tint bs_y = cache_list[nidx].bs_y;\t\n\t\tint bs_w = cache_list[nidx].bs_w;\t\n\t\tint bs_h = cache_list[nidx].bs_h;\t\n\n\t\t*nidx_in = nidx;\n\n\t\tif (bs_x < 0) {\n\t\t\tif (!find_rect(nidx, x, y, w, h)) {\n\t\t\t\tnidx = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbs_x = cache_list[nidx].bs_x;\n\t\t\tbs_y = cache_list[nidx].bs_y;\n\t\t\tbs_w = cache_list[nidx].bs_w;\n\t\t\tbs_h = cache_list[nidx].bs_h;\n\t\t}\n\t\tif (bs_x < 0) {\n\t\t\tnidx = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (try_batch) {\n\t\t\t*use_batch = 1;\n\t\t}\n\n\t\tif (ncache_pad) {\n\t\t\torig_x -= np;\t\n\t\t\torig_y -= np;\t\n\t\t\torig_w += 2 * np;\t\n\t\t\torig_h += 2 * np;\t\n\t\t\tx -= np;\t\n\t\t\ty -= np;\t\n\t\t\tw += 2 * np;\t\n\t\t\th += 2 * np;\t\n\t\t}\n\n\t\tif (clipshift) {\n\t\t\torig_x -= coff_x;\n\t\t\torig_y -= coff_y;\n\t\t\tx -= coff_x;\n\t\t\ty -= coff_y;\n\t\t}\n\n\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tr2 = sraRgnCreateRect(orig_x, orig_y, orig_x + orig_w, orig_y + orig_h);\n\t\tsraRgnSubtract(r2, r0);\n\t\tif (! sraRgnEmpty(r2) && cache_list[nidx].bs_time > 0.0) {\n\t\t\t/* some is initially offscreen */\n\t\t\tdx = bs_x - orig_x;\n\t\t\tdy = bs_y - orig_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\n\t\t\tdx = 0;\n\t\t\tdy = dpy_y;\n\t\t\tsraRgnOffset(r2, dx, dy);\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) offscreen:  dx, dy: %d, %d -> %d, %d orig %dx%d+%d+%d bs_xy: %d %d\\n\",\n    dnow() - ntim, bs_x - orig_x, bs_y - orig_y, dx, dy, orig_w, orig_h, orig_x, orig_y, bs_x, bs_y);\n\n\t\t\t/* 0) save it in the invalid (offscreen) SU portion */\n\t\t\tif (! *use_batch) {\n\t\t\t\tdo_copyregion(r2, dx, dy, 0);\n\t\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\n\t\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r2);\n\t\t\t}\n\t\t\tNPP_roffscreen = sraRgnCreateRgn(r2);\n\t\t}\n\t\tsraRgnDestroy(r2);\n\n\t\t/* 1) use bs for temp storage of the new save under. */\n\t\tr1 = sraRgnCreateRect(x, y, x + w, y + h);\n\t\tsraRgnAnd(r1, r0);\n\n\t\tdx = bs_x - x;\n\t\tdy = bs_y - y;\n\t\tsraRgnOffset(r1, dx, dy);\n\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) use tmp bs:\\n\", dnow() - ntim);\n\t\tif (! *use_batch) {\n\t\t\tdo_copyregion(r1, dx, dy, 0);\n\t\t\tif (! fb_push_wait(0.2, FB_COPY)) {\nif (ncdb) fprintf(stderr, \"FB_COPY: %.4f 1) FAILED.\\n\", dnow() - ntim);\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t} else {\n\t\t\tbatch_dxs[NPP_nreg] = dx;\n\t\t\tbatch_dys[NPP_nreg] = dy;\n\t\t\tbatch_reg[NPP_nreg++] = sraRgnCreateRgn(r1);\n\t\t}\n\t\tNPP_r_bs_tmp = sraRgnCreateRgn(r1);\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n\t}\n}"
  },
  {
    "function_name": "push_borders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3684-3744",
    "snippet": "void push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SCALE_BORDER %.4f\\n\"",
            "dnow() - d"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.1",
            "FB_MOD|FB_COPY"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SCALE_BORDER %.4f\\n\"",
            "dnow() - d"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_and_mark_rect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "1"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "scale_and_mark_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1300-1342",
          "snippet": "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "r0"
          ],
          "line": 3727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SCALE_BORDER\\n\""
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "r0"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r0",
            "r1"
          ],
          "line": 3716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r0",
            "r2"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x - s",
            "y",
            "x + w + s",
            "y + h + s"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r0",
            "r2"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x - s",
            "y - s",
            "x + w + s",
            "y + s"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r0",
            "r2"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x + w",
            "y",
            "x + w + s",
            "y + h"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "r0",
            "r2"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x - s",
            "y",
            "x",
            "y + h"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid push_borders(sraRect *rects, int nrect) {\n\t\tint i, s = 2;\n\t\tsraRegionPtr r0, r1, r2;\n\n\t\tr0 = sraRgnCreate(); \n\t\tr1 = sraRgnCreateRect(0, 0, dpy_x, dpy_y); \n\n\t\tfor (i=0; i<nrect; i++) {\n\t\t\tint x = rects[i].x1;\n\t\t\tint y = rects[i].y1;\n\t\t\tint w = rects[i].x2;\n\t\t\tint h = rects[i].y2;\n\n\t\t\tif (w > 0 && h > 0 && w * h > 64 * 64) {\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x , y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x + w, y , x + w + s, y + h); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y - s, x + w + s, y + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t\t\n\t\t\t\tr2 = sraRgnCreateRect(x - s, y , x + w + s, y + h + s); \n\t\t\t\tsraRgnOr(r0, r2); \n\t\t\t\tsraRgnDestroy(r2);\n\t\t\t}\n\t\t}\n\n\t\tsraRgnAnd(r0, r1); \n\n\t\tif (!sraRgnEmpty(r0)) {\n\t\t\tdouble d = dnow();\n\t\t\tsraRectangleIterator *iter;\n\t\t\tsraRect rect;\n\t\t\tint db = 0;\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER\\n\");\n\t\t\tfb_push_wait(0.05, FB_MOD|FB_COPY);\n\n\t\t\titer = sraRgnGetIterator(r0);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t/* clip the window to the visible screen: */\n\t\t\t\tint tx1 = rect.x1;\n\t\t\t\tint ty1 = rect.y1;\n\t\t\t\tint tx2 = rect.x2;\n\t\t\t\tint ty2 = rect.y2;\n\t\t\t\tscale_and_mark_rect(tx1, ty1, tx2, ty2, 1);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t\tfb_push_wait(0.1, FB_MOD|FB_COPY);\n\t\t\tif (db) fprintf(stderr, \"SCALE_BORDER %.4f\\n\", dnow() - d);\n\t\t}\n\t\tsraRgnDestroy(r0);\n\t\tsraRgnDestroy(r1);\n}"
  },
  {
    "function_name": "clear_win_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3654-3682",
    "snippet": "void clear_win_events(Window win, int vis) {\n#if !NO_X11\n\tif (dpy && win != None && ncache) {\n\t\tXEvent ev;\n\t\tXErrorHandler old_handler;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\twhile (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &ev)) {\n\t\t\tif (ncdb) fprintf(stderr, \".\");\n\t\t\tif (trapped_xerror) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\t\t}\n/* XXX Y */\n\t\tif (vis) {\n\t\t\twhile (XCheckTypedWindowEvent(dpy, win, VisibilityNotify, &ev)) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"+\");\n\t\t\t\tif (trapped_xerror) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t\tXSetErrorHandler(old_handler);\n\t\tif (ncdb) fprintf(stderr, \" 0x%lx\\n\", win);\n\t}\n#endif\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" 0x%lx\\n\"",
            "win"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 3678
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"+\""
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedWindowEvent",
          "args": [
            "dpy",
            "win",
            "VisibilityNotify",
            "&ev"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\".\""
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedWindowEvent",
          "args": [
            "dpy",
            "win",
            "ConfigureNotify",
            "&ev"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\n\nvoid clear_win_events(Window win, int vis) {\n#if !NO_X11\n\tif (dpy && win != None && ncache) {\n\t\tXEvent ev;\n\t\tXErrorHandler old_handler;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\twhile (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &ev)) {\n\t\t\tif (ncdb) fprintf(stderr, \".\");\n\t\t\tif (trapped_xerror) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\t\t}\n/* XXX Y */\n\t\tif (vis) {\n\t\t\twhile (XCheckTypedWindowEvent(dpy, win, VisibilityNotify, &ev)) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"+\");\n\t\t\t\tif (trapped_xerror) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t\tXSetErrorHandler(old_handler);\n\t\tif (ncdb) fprintf(stderr, \" 0x%lx\\n\", win);\n\t}\n#endif\n}"
  },
  {
    "function_name": "wireframe_mod_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3598-3647",
    "snippet": "static int wireframe_mod_state() {\n\tif (! wireframe_mods) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(wireframe_mods, \"all\")) {\n\t\tif (track_mod_state(NoSymbol, FALSE, FALSE)) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(wireframe_mods, \"Alt\")) {\n\t\tif (track_mod_state(XK_Alt_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Alt_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Shift\")) {\n\t\tif (track_mod_state(XK_Shift_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Shift_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Control\")) {\n\t\tif (track_mod_state(XK_Control_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Control_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Meta\")) {\n\t\tif (track_mod_state(XK_Meta_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Meta_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Super\")) {\n\t\tif (track_mod_state(XK_Super_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Super_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Hyper\")) {\n\t\tif (track_mod_state(XK_Hyper_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Hyper_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wireframe_mod_state();",
      "static char *wireframe_mods = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "track_mod_state",
          "args": [
            "XK_Hyper_R",
            "FALSE",
            "FALSE"
          ],
          "line": 3642
        },
        "resolved": true,
        "details": {
          "function_name": "track_mod_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "211-265",
          "snippet": "int track_mod_state(rfbKeySym keysym, rfbBool down, rfbBool set) {\n\tKeySym sym = (KeySym) keysym;\t\n\tstatic rfbBool isdown[NSIMPLE_MODS];\n\tstatic int first = 1;\n\tint i, cnt = 0;\n\n\t/*\n\t * simple tracking method for the modifier state without\n\t * contacting the Xserver.  Ignores, of course what keys are\n\t * pressed on the physical display.\n\t *\n\t * This is unrelated to our mod_tweak and xkb stuff.\n\t * Just a simple thing for wireframe/scroll heuristics, \n\t * sloppy keys etc.\n\t */\n\n\tif (first) {\n\t\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\t\tisdown[i] = FALSE;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (sym != NoSymbol) {\n\t\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\t\tif (sym == simple_mods[i]) {\n\t\t\t\tif (set) {\n\t\t\t\t\tisdown[i] = down;\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (isdown[i]) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* not a modifier */\n\t\tif (set) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* called with NoSymbol: return number currently pressed: */\n\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\tif (isdown[i]) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NSIMPLE_MODS 13"
          ],
          "globals_used": [
            "int track_mod_state(rfbKeySym keysym, rfbBool down, rfbBool set);",
            "int add_keysym(KeySym keysym);",
            "static KeySym simple_mods[] = {\n\tXK_Shift_L, XK_Shift_R,\n\tXK_Control_L, XK_Control_R,\n\tXK_Meta_L, XK_Meta_R,\n\tXK_Alt_L, XK_Alt_R,\n\tXK_Super_L, XK_Super_R,\n\tXK_Hyper_L, XK_Hyper_R,\n\tXK_Mode_switch,\n\tNoSymbol\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NSIMPLE_MODS 13\n\nint track_mod_state(rfbKeySym keysym, rfbBool down, rfbBool set);\nint add_keysym(KeySym keysym);\nstatic KeySym simple_mods[] = {\n\tXK_Shift_L, XK_Shift_R,\n\tXK_Control_L, XK_Control_R,\n\tXK_Meta_L, XK_Meta_R,\n\tXK_Alt_L, XK_Alt_R,\n\tXK_Super_L, XK_Super_R,\n\tXK_Hyper_L, XK_Hyper_R,\n\tXK_Mode_switch,\n\tNoSymbol\n};\n\nint track_mod_state(rfbKeySym keysym, rfbBool down, rfbBool set) {\n\tKeySym sym = (KeySym) keysym;\t\n\tstatic rfbBool isdown[NSIMPLE_MODS];\n\tstatic int first = 1;\n\tint i, cnt = 0;\n\n\t/*\n\t * simple tracking method for the modifier state without\n\t * contacting the Xserver.  Ignores, of course what keys are\n\t * pressed on the physical display.\n\t *\n\t * This is unrelated to our mod_tweak and xkb stuff.\n\t * Just a simple thing for wireframe/scroll heuristics, \n\t * sloppy keys etc.\n\t */\n\n\tif (first) {\n\t\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\t\tisdown[i] = FALSE;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (sym != NoSymbol) {\n\t\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\t\tif (sym == simple_mods[i]) {\n\t\t\t\tif (set) {\n\t\t\t\t\tisdown[i] = down;\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (isdown[i]) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* not a modifier */\n\t\tif (set) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* called with NoSymbol: return number currently pressed: */\n\tfor (i=0; i<NSIMPLE_MODS; i++) {\n\t\tif (isdown[i]) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Hyper\""
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Super\""
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Meta\""
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Control\""
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Shift\""
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"Alt\""
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_mods",
            "\"all\""
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wireframe_mod_state();\nstatic char *wireframe_mods = NULL;\n\nstatic int wireframe_mod_state() {\n\tif (! wireframe_mods) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(wireframe_mods, \"all\")) {\n\t\tif (track_mod_state(NoSymbol, FALSE, FALSE)) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(wireframe_mods, \"Alt\")) {\n\t\tif (track_mod_state(XK_Alt_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Alt_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Shift\")) {\n\t\tif (track_mod_state(XK_Shift_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Shift_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Control\")) {\n\t\tif (track_mod_state(XK_Control_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Control_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Meta\")) {\n\t\tif (track_mod_state(XK_Meta_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Meta_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Super\")) {\n\t\tif (track_mod_state(XK_Super_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Super_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (!strcmp(wireframe_mods, \"Hyper\")) {\n\t\tif (track_mod_state(XK_Hyper_L, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t} else if (track_mod_state(XK_Hyper_R, FALSE, FALSE) == 1) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_fixscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3529-3596",
    "snippet": "void check_fixscreen(void) {\n\tdouble now = dnow();\n\tint didfull = 0, db = 0;\n\n\tif (!client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (screen_fixup_X > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_X) {\n\t\t\tif (db) rfbLog(\"doing screen_fixup_X\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t\t\n\t}\n\tif (screen_fixup_V > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_V) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_V\\n\");\n\t\t\t}\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (screen_fixup_C > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (last_copyrect_fix < last_copyrect &&\n\t\t    now > last_copyrect + screen_fixup_C) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_C\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (scaling && last_copyrect_fix < last_copyrect) {\n\t\tstatic double last = 0.0;\n\t\tdouble delay = 3.0;\n\t\tif (now > last + delay) {\n\t\t\tif (! didfull) {\n\t\t\t\tscale_and_mark_rect(0, 0, dpy_x, dpy_y, 1);\n\t\t\t\tif (db) rfbLog(\"doing scale screen_fixup\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (advertise_truecolor && advertise_truecolor_reset && indexed_color) {\n\t\t/* this will reset framebuffer to correct colors, if needed */\n\t\tstatic double dlast = 0.0;\n\t\tnow = dnow();\n\t\tif (now > last_client + 1.0 && now < last_client + 3.0 && now > dlast + 5.0) {\n\t\t\trfbLog(\"advertise truecolor reset framebuffer\\n\");\n\t\t\tdo_new_fb(1);\n\t\t\tdlast = dnow();\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_fixscreen(void);",
      "void batch_push(int ncr, double delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"advertise truecolor reset framebuffer\\n\""
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing scale screen_fixup\\n\""
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_and_mark_rect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "1"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "scale_and_mark_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1300-1342",
          "snippet": "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing screen_fixup_C\\n\""
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_screen",
          "args": [
            "0"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "517-526",
          "snippet": "void refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void refresh_screen(int push);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid refresh_screen(int push);\n\nvoid refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing screen_fixup_V\\n\""
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing screen_fixup_X\\n\""
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_fixscreen(void);\nvoid batch_push(int ncr, double delay);\n\nvoid check_fixscreen(void) {\n\tdouble now = dnow();\n\tint didfull = 0, db = 0;\n\n\tif (!client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (screen_fixup_X > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_X) {\n\t\t\tif (db) rfbLog(\"doing screen_fixup_X\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t\t\n\t}\n\tif (screen_fixup_V > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_V) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_V\\n\");\n\t\t\t}\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (screen_fixup_C > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (last_copyrect_fix < last_copyrect &&\n\t\t    now > last_copyrect + screen_fixup_C) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_C\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (scaling && last_copyrect_fix < last_copyrect) {\n\t\tstatic double last = 0.0;\n\t\tdouble delay = 3.0;\n\t\tif (now > last + delay) {\n\t\t\tif (! didfull) {\n\t\t\t\tscale_and_mark_rect(0, 0, dpy_x, dpy_y, 1);\n\t\t\t\tif (db) rfbLog(\"doing scale screen_fixup\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (advertise_truecolor && advertise_truecolor_reset && indexed_color) {\n\t\t/* this will reset framebuffer to correct colors, if needed */\n\t\tstatic double dlast = 0.0;\n\t\tnow = dnow();\n\t\tif (now > last_client + 1.0 && now < last_client + 3.0 && now > dlast + 5.0) {\n\t\t\trfbLog(\"advertise truecolor reset framebuffer\\n\");\n\t\t\tdo_new_fb(1);\n\t\t\tdlast = dnow();\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "near_scrollbar_edge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3500-3527",
    "snippet": "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint sb_t = scrollcopyrect_top;\n\tint sb_b = scrollcopyrect_bot;\n\tint sb_l = scrollcopyrect_left;\n\tint sb_r = scrollcopyrect_right;\n\n\tint near_edge = 0;\n\t\n\tif (sb_t || sb_b || sb_l || sb_r) {\n\t\tif (nabs(y - py) < sb_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < sb_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < sb_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < sb_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
      "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "static int scrollcopyrect_top, scrollcopyrect_bot;",
      "static int scrollcopyrect_left, scrollcopyrect_right;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "x + w - px"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint find_rect(int idx, int x, int y, int w, int h);\nstatic int scrollcopyrect_top, scrollcopyrect_bot;\nstatic int scrollcopyrect_left, scrollcopyrect_right;\n\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint sb_t = scrollcopyrect_top;\n\tint sb_b = scrollcopyrect_bot;\n\tint sb_l = scrollcopyrect_left;\n\tint sb_r = scrollcopyrect_right;\n\n\tint near_edge = 0;\n\t\n\tif (sb_t || sb_b || sb_l || sb_r) {\n\t\tif (nabs(y - py) < sb_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < sb_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < sb_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < sb_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}"
  },
  {
    "function_name": "near_wm_edge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3471-3498",
    "snippet": "int near_wm_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint wf_t = wireframe_top;\n\tint wf_b = wireframe_bot;\n\tint wf_l = wireframe_left;\n\tint wf_r = wireframe_right;\n\n\tint near_edge = 0;\n\t\n\tif (wf_t || wf_b || wf_l || wf_r) {\n\t\tif (nabs(y - py) < wf_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < wf_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < wf_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < wf_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
      "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "static int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "x + w - px"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint find_rect(int idx, int x, int y, int w, int h);\nstatic int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;\n\nint near_wm_edge(int x, int y, int w, int h, int px, int py) {\n\t/* heuristics: */\n\tint wf_t = wireframe_top;\n\tint wf_b = wireframe_bot;\n\tint wf_l = wireframe_left;\n\tint wf_r = wireframe_right;\n\n\tint near_edge = 0;\n\t\n\tif (wf_t || wf_b || wf_l || wf_r) {\n\t\tif (nabs(y - py) < wf_t) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(y + h - py) < wf_b) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x - px) < wf_l) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t\tif (nabs(x + w - px) < wf_r) {\n\t\t\tnear_edge = 1;\n\t\t}\n\t} else {\n\t\t/* all zero; always \"near\" edge: */\n\t\tnear_edge = 1;\n\t}\n\treturn near_edge;\n}"
  },
  {
    "function_name": "try_copyrect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3138-3469",
    "snippet": "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int lookup_win_index(Window);",
      "static int scrollability(Window win, int set);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "static void check_user_input2(double dt);",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "moved_win"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "shifted_region"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "dx",
            "dy",
            "dt"
          ],
          "line": 3460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "shifted_region"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "shifted_region",
            "dx",
            "dy",
            "0"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "shifted_region"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "whole"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "shifted_region",
            "whole"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "shifted_region",
            "dx",
            "dy"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "moved_win"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "moved_win"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "wireframe_copyrect",
            "\"top\""
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  stack_work dt: %.4f\\n\"",
            "dt"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "whole"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "moved_win",
            "tmp_win"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmp_win",
            "whole"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "tmp_win",
            "-dx",
            "-dy"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "moved_win",
            "tmp_win"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmp_win",
            "moved_win"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmp_win",
            "whole"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "extra_clip"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "extra_clip",
            "-off_x",
            "-off_y"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "extra_clip",
            "-coff_x",
            "-coff_y"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "extra_clip"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "moved_win",
            "tmp_win"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "swin"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "attr.y - dy + attr.height",
            "dpy_y+1"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "moved_win",
            "tmp_win"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_win"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"         : clips it.\\n\""
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmp_win",
            "moved_win"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "swin"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sw: %d/%lx  %dx%d+%d+%d\\n\"",
            "k",
            "swin",
            "stack_list[k].width",
            "stack_list[k].height",
            "stack_list[k].x",
            "stack_list[k].y"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "swin",
            "&attr",
            "1"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  ----------\\n\""
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sw: %d/%lx\\n\"",
            "k",
            "swin"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bwin",
          "args": [],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "get_bwin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "303-305",
          "snippet": "int get_bwin(void) {\n\treturn 10;\t\t\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_bwin(void) {\n\treturn 10;\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_boff",
          "args": [],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "get_boff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "295-301",
          "snippet": "int get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "frame"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "rect"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "bo_rect"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "rect",
            "bo_rect"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "blackr[i].x1",
            "blackr[i].y1",
            "blackr[i].x2",
            "blackr[i].y2"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crfix",
          "args": [
            "nfix(y+h, dpy_y+1)",
            "dy",
            "dpy_y+1"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "crfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2245-2259",
          "snippet": "static int crfix(int x, int dx, int Lx) {\n\t/* adjust x so that copy source is on screen */\n\tif (dx > 0) {\n\t\tif (x-dx < 0) {\n\t\t\t/* off on the left */\n\t\t\tx = dx;\t\n\t\t}\n\t} else {\n\t\tif (x-dx >= Lx) {\n\t\t\t/* off on the right */\n\t\t\tx = Lx + dx - 1;\n\t\t}\n\t}\n\treturn x;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int crfix(int x, int dx, int Lx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int crfix(int x, int dx, int Lx);\n\nstatic int crfix(int x, int dx, int Lx) {\n\t/* adjust x so that copy source is on screen */\n\tif (dx > 0) {\n\t\tif (x-dx < 0) {\n\t\t\t/* off on the left */\n\t\t\tx = dx;\t\n\t\t}\n\t} else {\n\t\tif (x-dx >= Lx) {\n\t\t\t/* off on the right */\n\t\t\tx = Lx + dx - 1;\n\t\t}\n\t}\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\"",
            "orig_frame",
            "frame",
            "dt_bad",
            "stack_list_num"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dt",
            "\"xfce\""
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dt",
            "\"kde_maybe_is_ok_now...\""
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_desktop",
          "args": [],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "guess_desktop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1232-1292",
          "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_client_regions",
          "args": [
            "&req",
            "&mod",
            "&cpy",
            "&ncli"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1833-1853",
          "snippet": "static void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "max_wait/2",
            "FB_COPY"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}"
  },
  {
    "function_name": "check_xrecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "3066-3118",
    "snippet": "int check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_xrecord(void);",
      "static int check_xrecord_keys(void);",
      "static int check_xrecord_mouse(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_xrecord_keys",
          "args": [],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2472-2712",
          "snippet": "static int check_xrecord_keys(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gk, gk0, ret = 0, db = debug_scroll;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tstatic double last_key_scroll = 0.0;\n\tstatic double persist_start = 0.0;\n\tstatic double last_bdpush = 0.0;\n\tstatic int persist_count = 0;\n\tint scroll_keysym = 0;\n\tdouble last_scroll, scroll_persist = scr_key_persist;\n\tdouble spin_fac = 1.0, scroll_fac = 2.0, noscroll_fac = 0.75;\n\tdouble max_spin, max_long_spin = 0.3;\n\tdouble set_repeat_in;\n\tstatic double set_repeat = 0.0;\n\n\n\tRAWFB_RET(0)\n\n\tif (unixpw_in_progress) return 0;\n\n\tset_repeat_in = set_repeat;\n\tset_repeat = 0.0;\n\n\tget_out = 1;\n\tif (got_keyboard_input) {\n\t\tget_out = 0;\n\t}\n\n\tdtime0(&tnow);\n\tif (tnow < last_key_scroll + scroll_persist) {\n\t\tget_out = 0;\n\t}\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + set_repeat_in) {\n\t\tget_out = 0;\n\t}\n\n\tif (get_out) {\n\t\tpersist_start = 0.0;\n\t\tpersist_count = 0;\n\t\tlast_bdpush = 0.0;\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t\treturn 0;\n\t}\n\n#if 0\n\t/* not used for keyboard yet */\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n#endif\n\n\tscroll_keysym = xrecord_scroll_keysym(last_rfb_keysym);\n\n\tmax_spin = scr_key_time;\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + 2*set_repeat_in) {\n\t\tmax_spin = 2 * set_repeat_in;\n\t} else if (tnow < last_key_scroll + scroll_persist) {\n\t\tmax_spin = 1.25*(tnow - last_key_scroll);\n\t} else if (tnow < last_key_to_button_remap_time + 1.5*scroll_persist) {\n\t\t/* mostly a hack I use for testing -remap key -> btn4/btn5 */\n\t\tmax_spin = scroll_persist;\n\t} else if (scroll_keysym) {\n\t\tif (repeat_check(last_key_scroll)) {\n\t\t\tspin_fac = scroll_fac;\n\t\t} else {\n\t\t\tspin_fac = noscroll_fac;\n\t\t}\n\t}\n\tif (max_spin > max_long_spin) {\n\t\tmax_spin = max_long_spin;\n\t}\n\n\t/* XXX use this somehow  */\nif (0)\tlink = link_rate(&latency, &netrate);\n\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\nif (db) fprintf(stderr, \"check_xrecord_keys: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin, tm - x11vnc_start);\n\n\twhile (1) {\n\n\t\tif (scr_ev_cnt) {\n\t\t\tgot_one = 1;\n\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_key_scroll = last_scroll;\n\t\t\tscr_cnt++;\n\t\t\tbreak;\n\t\t}\n\n\t\tX_LOCK;\n\t\tflush1 = 1;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (set_repeat_in > 0.0) {\n\t\t\tmax_keyrepeat_time = set_repeat_in;\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tX_LOCK;\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t\tif (set_repeat_in) {\n\t\t\t\t;\n\t\t\t} else if (xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\t\tif (repeat_check(last_key_scroll)) {\n\t\t\t\t\tspin_fac = scroll_fac;\n\t\t\t\t} else {\n\t\t\t\t\tspin_fac = noscroll_fac;\n\t\t\t\t}\n\t\t\t}\nif (0 || db) fprintf(stderr, \"check_xrecord: more keys: %.3f  0x%x \"\n    \" %.4f  %s  %s\\n\", spin, last_rfb_keysym, last_rfb_keytime - x11vnc_start,\n    last_rfb_down ? \"down\":\"up  \", last_rfb_key_accepted ? \"accept\":\"skip\");\n\t\t\tflush2 = 1;\n\t\t\tXFlush_wr(dpy);\n\t\t}\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (spin >= max_spin * spin_fac) {\nif (0 || db) fprintf(stderr, \"check_xrecord: SPIN-OUT: %.3f/%.3f\\n\", spin,\n    max_spin * spin_fac);\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmax_keyrepeat_time = 0.0;\n\n\tif (scr_ev_cnt) {\n\t\tint dret, ev = scr_ev_cnt - 1;\n\t\tint bdx, bdy, bdskinny, bdpush = 0;\n\t\tdouble max_age = 0.25, age, tm, dt;\n\t\tstatic double last_scr_ev = 0.0;\n\n\t\tlast_wx = scr_ev[ev].win_x;\n\t\tlast_wy = scr_ev[ev].win_y;\n\t\tlast_ww = scr_ev[ev].win_w;\n\t\tlast_wh = scr_ev[ev].win_h;\n\n\t\t/* assume scrollbar on rhs: */\n\t\tbdx = last_wx + last_ww + 3;\n\t\tbdy = last_wy + last_wh/2;\n\t\tbdskinny = 32;\n\t\t\t\n\t\tif (persist_start == 0.0) {\n\t\t\tbdpush = 0;\n\t\t} else {\n\t\t\tset_bdpush(SCR_KEY, &last_bdpush, &bdpush);\n\t\t}\n\n\t\tdtime0(&tm);\n\t\tage = max_age;\n\t\tdret = push_scr_ev(&age, SCR_KEY, bdpush, bdx, bdy, bdskinny, 1);\n\t\tdt = dtime(&tm);\n\n\t\tret = 1 + dret;\n\t\tscr_ev_cnt = 0;\n\n\t\tif (ret == 2 && xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\tint repeating;\n\t\t\tdouble time_lo = 1.0/max_keyrepeat_lo;\n\t\t\tdouble time_hi = 1.0/max_keyrepeat_hi;\n\t\t\tdouble rate = typing_rate(0.0, &repeating);\nif (0 || db) fprintf(stderr, \"Typing: dt: %.4f rate: %.1f\\n\", dt, rate);\n\t\t\tif (repeating) {\n\t\t\t\t/* n.b. the \"quantum\" is about 1/30 sec. */\n\t\t\t\tmax_keyrepeat_time = 1.0*dt;\n\t\t\t\tif (max_keyrepeat_time > time_lo ||\n\t\t\t\t    max_keyrepeat_time < time_hi) {\n\t\t\t\t\tmax_keyrepeat_time = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tset_repeat = max_keyrepeat_time;\nif (0 || db) fprintf(stderr, \"set max_keyrepeat_time: %.2f\\n\", max_keyrepeat_time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_scr_ev = dnow();\n\t}\n\n\tif ((got_one && ret < 2) || persist_count) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\tif (xrecording) {\n\t\tif (ret < 2) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t}\n\n\tif (ret == 2) {\n\t\tif (persist_start == 0.0) {\n\t\t\tdtime(&persist_start);\n\t\t\tlast_bdpush = persist_start;\n\t\t}\n\t} else {\n\t\tpersist_start = 0.0;\n\t\tlast_bdpush = 0.0;\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_xrecord(void);",
            "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
            "static int scrollability(Window win, int set);",
            "static int repeat_check(double last_key_scroll);",
            "static int check_xrecord_keys(void);",
            "static void check_user_input2(double dt);",
            "static double scr_key_time, scr_key_persist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int scrollability(Window win, int set);\nstatic int repeat_check(double last_key_scroll);\nstatic int check_xrecord_keys(void);\nstatic void check_user_input2(double dt);\nstatic double scr_key_time, scr_key_persist;\n\nstatic int check_xrecord_keys(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gk, gk0, ret = 0, db = debug_scroll;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tstatic double last_key_scroll = 0.0;\n\tstatic double persist_start = 0.0;\n\tstatic double last_bdpush = 0.0;\n\tstatic int persist_count = 0;\n\tint scroll_keysym = 0;\n\tdouble last_scroll, scroll_persist = scr_key_persist;\n\tdouble spin_fac = 1.0, scroll_fac = 2.0, noscroll_fac = 0.75;\n\tdouble max_spin, max_long_spin = 0.3;\n\tdouble set_repeat_in;\n\tstatic double set_repeat = 0.0;\n\n\n\tRAWFB_RET(0)\n\n\tif (unixpw_in_progress) return 0;\n\n\tset_repeat_in = set_repeat;\n\tset_repeat = 0.0;\n\n\tget_out = 1;\n\tif (got_keyboard_input) {\n\t\tget_out = 0;\n\t}\n\n\tdtime0(&tnow);\n\tif (tnow < last_key_scroll + scroll_persist) {\n\t\tget_out = 0;\n\t}\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + set_repeat_in) {\n\t\tget_out = 0;\n\t}\n\n\tif (get_out) {\n\t\tpersist_start = 0.0;\n\t\tpersist_count = 0;\n\t\tlast_bdpush = 0.0;\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t\treturn 0;\n\t}\n\n#if 0\n\t/* not used for keyboard yet */\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n#endif\n\n\tscroll_keysym = xrecord_scroll_keysym(last_rfb_keysym);\n\n\tmax_spin = scr_key_time;\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + 2*set_repeat_in) {\n\t\tmax_spin = 2 * set_repeat_in;\n\t} else if (tnow < last_key_scroll + scroll_persist) {\n\t\tmax_spin = 1.25*(tnow - last_key_scroll);\n\t} else if (tnow < last_key_to_button_remap_time + 1.5*scroll_persist) {\n\t\t/* mostly a hack I use for testing -remap key -> btn4/btn5 */\n\t\tmax_spin = scroll_persist;\n\t} else if (scroll_keysym) {\n\t\tif (repeat_check(last_key_scroll)) {\n\t\t\tspin_fac = scroll_fac;\n\t\t} else {\n\t\t\tspin_fac = noscroll_fac;\n\t\t}\n\t}\n\tif (max_spin > max_long_spin) {\n\t\tmax_spin = max_long_spin;\n\t}\n\n\t/* XXX use this somehow  */\nif (0)\tlink = link_rate(&latency, &netrate);\n\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\nif (db) fprintf(stderr, \"check_xrecord_keys: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin, tm - x11vnc_start);\n\n\twhile (1) {\n\n\t\tif (scr_ev_cnt) {\n\t\t\tgot_one = 1;\n\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_key_scroll = last_scroll;\n\t\t\tscr_cnt++;\n\t\t\tbreak;\n\t\t}\n\n\t\tX_LOCK;\n\t\tflush1 = 1;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (set_repeat_in > 0.0) {\n\t\t\tmax_keyrepeat_time = set_repeat_in;\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tX_LOCK;\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t\tif (set_repeat_in) {\n\t\t\t\t;\n\t\t\t} else if (xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\t\tif (repeat_check(last_key_scroll)) {\n\t\t\t\t\tspin_fac = scroll_fac;\n\t\t\t\t} else {\n\t\t\t\t\tspin_fac = noscroll_fac;\n\t\t\t\t}\n\t\t\t}\nif (0 || db) fprintf(stderr, \"check_xrecord: more keys: %.3f  0x%x \"\n    \" %.4f  %s  %s\\n\", spin, last_rfb_keysym, last_rfb_keytime - x11vnc_start,\n    last_rfb_down ? \"down\":\"up  \", last_rfb_key_accepted ? \"accept\":\"skip\");\n\t\t\tflush2 = 1;\n\t\t\tXFlush_wr(dpy);\n\t\t}\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (spin >= max_spin * spin_fac) {\nif (0 || db) fprintf(stderr, \"check_xrecord: SPIN-OUT: %.3f/%.3f\\n\", spin,\n    max_spin * spin_fac);\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmax_keyrepeat_time = 0.0;\n\n\tif (scr_ev_cnt) {\n\t\tint dret, ev = scr_ev_cnt - 1;\n\t\tint bdx, bdy, bdskinny, bdpush = 0;\n\t\tdouble max_age = 0.25, age, tm, dt;\n\t\tstatic double last_scr_ev = 0.0;\n\n\t\tlast_wx = scr_ev[ev].win_x;\n\t\tlast_wy = scr_ev[ev].win_y;\n\t\tlast_ww = scr_ev[ev].win_w;\n\t\tlast_wh = scr_ev[ev].win_h;\n\n\t\t/* assume scrollbar on rhs: */\n\t\tbdx = last_wx + last_ww + 3;\n\t\tbdy = last_wy + last_wh/2;\n\t\tbdskinny = 32;\n\t\t\t\n\t\tif (persist_start == 0.0) {\n\t\t\tbdpush = 0;\n\t\t} else {\n\t\t\tset_bdpush(SCR_KEY, &last_bdpush, &bdpush);\n\t\t}\n\n\t\tdtime0(&tm);\n\t\tage = max_age;\n\t\tdret = push_scr_ev(&age, SCR_KEY, bdpush, bdx, bdy, bdskinny, 1);\n\t\tdt = dtime(&tm);\n\n\t\tret = 1 + dret;\n\t\tscr_ev_cnt = 0;\n\n\t\tif (ret == 2 && xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\tint repeating;\n\t\t\tdouble time_lo = 1.0/max_keyrepeat_lo;\n\t\t\tdouble time_hi = 1.0/max_keyrepeat_hi;\n\t\t\tdouble rate = typing_rate(0.0, &repeating);\nif (0 || db) fprintf(stderr, \"Typing: dt: %.4f rate: %.1f\\n\", dt, rate);\n\t\t\tif (repeating) {\n\t\t\t\t/* n.b. the \"quantum\" is about 1/30 sec. */\n\t\t\t\tmax_keyrepeat_time = 1.0*dt;\n\t\t\t\tif (max_keyrepeat_time > time_lo ||\n\t\t\t\t    max_keyrepeat_time < time_hi) {\n\t\t\t\t\tmax_keyrepeat_time = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tset_repeat = max_keyrepeat_time;\nif (0 || db) fprintf(stderr, \"set max_keyrepeat_time: %.2f\\n\", max_keyrepeat_time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_scr_ev = dnow();\n\t}\n\n\tif ((got_one && ret < 2) || persist_count) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\tif (xrecording) {\n\t\tif (ret < 2) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t}\n\n\tif (ret == 2) {\n\t\tif (persist_start == 0.0) {\n\t\t\tdtime(&persist_start);\n\t\t\tlast_bdpush = persist_start;\n\t\t}\n\t} else {\n\t\tpersist_start = 0.0;\n\t\tlast_bdpush = 0.0;\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xrecord_mouse",
          "args": [],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_mouse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2714-3064",
          "snippet": "static int check_xrecord_mouse(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint i, scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gp, gp0, ret = 0, db = debug_scroll;\n\tint gk, gk0;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tint start_x, start_y, last_x, last_y;\n\tstatic double last_mouse_scroll = 0.0;\n\tdouble last_scroll;\n\tdouble max_spin[3], max_long[3], persist[3];\n\tdouble flush1_time = 0.01;\n\tstatic double last_flush = 0.0;\n\tdouble last_bdpush = 0.0, button_up_time = 0.0;\n\tint button_mask_save;\n\tint already_down = 0, max_ptr_eat = 20;\n\tstatic int want_back_in = 0;\n\tint came_back_in;\n\tint first_push = 1;\n\n\tint scroll_wheel = 0;\n\tint btn4 = (1<<3);\n\tint btn5 = (1<<4);\n\n\tRAWFB_RET(0)\n\n\tget_out = 1;\n\tif (button_mask) {\n\t\tget_out = 0;\n\t}\n\tif (want_back_in) {\n\t\tget_out = 0;\n\t}\n\tdtime0(&tnow);\nif (0) fprintf(stderr, \"check_xrecord_mouse: IN xrecording: %d\\n\", xrecording);\n\n\tif (get_out) {\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\tif (want_back_in) {\n\t\tcame_back_in = 1;\n\t\tfirst_push = 0;\n\t} else {\n\t\tcame_back_in = 0;\n\t}\n\twant_back_in = 0;\n\n\tif (button_mask & (btn4|btn5)) {\n\t\tscroll_wheel = 1;\n\t}\n\n\t/*\n\t * set up times for the various \"reputations\"\n\t *\n\t * 0 => -1, has been tried but never found a scroll.\n\t * 1 =>  0, has not been tried.\n\t * 2 => +1, has been tried and found a scroll.\n\t */\n\n\t/* first spin-out time (no events) */\n\tmax_spin[0] = 1*scr_mouse_time;\n\tmax_spin[1] = 2*scr_mouse_time;\n\tmax_spin[2] = 4*scr_mouse_time;\n\tif (!already_down) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 1.5;\n\t\t}\n\t}\n\n\t/* max time between events */\n\tpersist[0] = 1*scr_mouse_persist;\n\tpersist[1] = 2*scr_mouse_persist;\n\tpersist[2] = 4*scr_mouse_persist;\n\n\t/* absolute max time in the loop */\n\tmax_long[0] = scr_mouse_maxtime;\n\tmax_long[1] = scr_mouse_maxtime;\n\tmax_long[2] = scr_mouse_maxtime;\n\n\tpointer_flush_delay = scr_mouse_pointer_delay;\n\n\t/* slow links: */\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 2.0;\n\t\t}\n\t\tpointer_flush_delay *= 2;\n\t} else if (link == LR_BROADBAND) {\n\t\tpointer_flush_delay *= 2;\n\t}\n\n\tgp = gp0 = got_pointer_input;\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\n\t/*\n\t * this is used for border pushes (bdpush) to guess location\n\t * of scrollbar (region rects containing this point are pushed).\n\t */\n\tlast_x = start_x = cursor_x;\n\tlast_y = start_y = cursor_y;\n\nif (db) fprintf(stderr, \"check_xrecord_mouse: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin[scroll_rep], tm - x11vnc_start);\n\n\twhile (1) {\n\t\tdouble spin_check;\n\t\tif (scr_ev_cnt) {\n\t\t\tint dret, ev = scr_ev_cnt - 1;\n\t\t\tint bdpush = 0, bdx, bdy, bdskinny;\n\t\t\tdouble tm, dt, age = 0.35;\n\n\t\t\tgot_one = 1;\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tscr_cnt++;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_mouse_scroll = last_scroll;\n\n\t\t\tif (last_bdpush == 0.0) {\n\t\t\t\tlast_bdpush = last_scroll;\n\t\t\t}\n\n\t\t\tbdx = start_x;\n\t\t\tbdy = start_y;\n\t\t\tif (clipshift) {\n\t\t\t\tbdx += coff_x;\n\t\t\t\tbdy += coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tbdx += off_x;\n\t\t\t\tbdy += off_y;\n\t\t\t}\n\t\t\tbdskinny = 32;\n\t\t\t\n\t\t\tset_bdpush(SCR_MOUSE, &last_bdpush, &bdpush);\n\n\t\t\tdtime0(&tm);\n\n\t\t\tdret = push_scr_ev(&age, SCR_MOUSE, bdpush, bdx,\n\t\t\t    bdy, bdskinny, first_push);\n\t\t\tif (first_push) first_push = 0;\n\t\t\tret = 1 + dret;\n\n\t\t\tdt = dtime(&tm);\n\nif (db) fprintf(stderr, \"  dret: %d  scr_ev_cnt: %d dt: %.4f\\n\",\n\tdret, scr_ev_cnt, dt);\n\n\t\t\tlast_wx = scr_ev[ev].win_x;\n\t\t\tlast_wy = scr_ev[ev].win_y;\n\t\t\tlast_ww = scr_ev[ev].win_w;\n\t\t\tlast_wh = scr_ev[ev].win_h;\n\t\t\tscr_ev_cnt = 0;\n\n\t\t\tif (! dret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (0 && button_up_time > 0.0) {\n\t\t\t\t/* we only take 1 more event with button up */\nif (db) fprintf(stderr, \"check_xrecord: BUTTON_UP_SCROLL: %.3f\\n\", spin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! flush1) {\n\t\t\tif (! already_down || (!scr_cnt && spin>flush1_time)) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tif (got_pointer_input > gp) {\n\t\t\tflush2 = 1;\n\t\t\tinput += eat_pointer(max_ptr_eat, 1);\n\t\t\tgp = got_pointer_input;\n\t\t}\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t}\n\t\tX_LOCK;\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (! input) {\n\t\t\tspin_check = 1.5 * max_spin[scroll_rep];\n\t\t} else {\n\t\t\tspin_check = max_spin[scroll_rep];\n\t\t}\n\n\t\tif (button_up_time > 0.0) {\n\t\t\tif (tm > button_up_time + max_spin[scroll_rep]) {\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-BUTTON_UP: %.3f/%.3f\\n\", spin, tm - button_up_time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!scr_cnt) {\n\t\t\tif (spin >= spin_check) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-1: %.3f/%.3f\\n\", spin, spin_check);\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tm >= last_scroll + persist[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-2: %.3f/%.3f\\n\", spin, tm - last_scroll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (spin >= max_long[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-3: %.3f/%.3f\\n\", spin, max_long[scroll_rep]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (! button_mask) {\n\t\t\tint doflush = 0;\n\t\t\tif (button_up_time > 0.0) {\n\t\t\t\t;\n\t\t\t} else if (came_back_in) {\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t\tdoflush = 1;\n\t\t\t} else if (scroll_wheel) {\nif (db) fprintf(stderr, \"check_xrecord: SCROLL-WHEEL-BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t} else if (last_x == cursor_x && last_y == cursor_y) {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tbreak;\n\t\t\t} else {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t}\n\t\t\tif (doflush) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tlast_x = cursor_x;\n\t\tlast_y = cursor_y;\n\t}\n\n\tif (got_one) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\t/* flush any remaining pointer events. */\n\tbutton_mask_save = button_mask;\n\tpointer_queued_sent = 0;\n\tlast_x = cursor_x;\n\tlast_y = cursor_y;\n\tpointer_event(-1, 0, 0, NULL);\n\tpointer_flush_delay = 0.0;\n\n\tif (xrecording && pointer_queued_sent && button_mask_save &&\n\t    (last_x != cursor_x || last_y != cursor_y) ) {\nif (db) fprintf(stderr, \"  pointer() push yields events on: ret=%d\\n\", ret);\n\t\tif (ret == 2) {\nif (db) fprintf(stderr, \"  we decide to send ret=3\\n\");\n\t\t\twant_back_in = 1;\n\t\t\tret = 3;\n\t\t\tflush2 = 1;\n\t\t} else {\n\t\t\tif (ret) {\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t} else {\n\t\tif (ret) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t}\n\n\tif (flush2) {\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tXFlush_wr(rdpy_ctrl);\n\t\tX_UNLOCK;\n\n\t\tflush2 = 1;\n\t\tdtime0(&last_flush);\n\nif (db) fprintf(stderr, \"FLUSH-2\\n\");\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\tif (ret) {\n\t\treturn ret;\n\t} else if (scr_cnt) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "int check_xrecord(void);",
            "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
            "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);",
            "static int scrollability(Window win, int set);",
            "static int check_xrecord_mouse(void);",
            "static void check_user_input2(double dt);",
            "static double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;",
            "static double scr_mouse_pointer_delay;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nint check_xrecord(void);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);\nstatic int scrollability(Window win, int set);\nstatic int check_xrecord_mouse(void);\nstatic void check_user_input2(double dt);\nstatic double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;\nstatic double scr_mouse_pointer_delay;\n\nstatic int check_xrecord_mouse(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint i, scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gp, gp0, ret = 0, db = debug_scroll;\n\tint gk, gk0;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tint start_x, start_y, last_x, last_y;\n\tstatic double last_mouse_scroll = 0.0;\n\tdouble last_scroll;\n\tdouble max_spin[3], max_long[3], persist[3];\n\tdouble flush1_time = 0.01;\n\tstatic double last_flush = 0.0;\n\tdouble last_bdpush = 0.0, button_up_time = 0.0;\n\tint button_mask_save;\n\tint already_down = 0, max_ptr_eat = 20;\n\tstatic int want_back_in = 0;\n\tint came_back_in;\n\tint first_push = 1;\n\n\tint scroll_wheel = 0;\n\tint btn4 = (1<<3);\n\tint btn5 = (1<<4);\n\n\tRAWFB_RET(0)\n\n\tget_out = 1;\n\tif (button_mask) {\n\t\tget_out = 0;\n\t}\n\tif (want_back_in) {\n\t\tget_out = 0;\n\t}\n\tdtime0(&tnow);\nif (0) fprintf(stderr, \"check_xrecord_mouse: IN xrecording: %d\\n\", xrecording);\n\n\tif (get_out) {\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\tif (want_back_in) {\n\t\tcame_back_in = 1;\n\t\tfirst_push = 0;\n\t} else {\n\t\tcame_back_in = 0;\n\t}\n\twant_back_in = 0;\n\n\tif (button_mask & (btn4|btn5)) {\n\t\tscroll_wheel = 1;\n\t}\n\n\t/*\n\t * set up times for the various \"reputations\"\n\t *\n\t * 0 => -1, has been tried but never found a scroll.\n\t * 1 =>  0, has not been tried.\n\t * 2 => +1, has been tried and found a scroll.\n\t */\n\n\t/* first spin-out time (no events) */\n\tmax_spin[0] = 1*scr_mouse_time;\n\tmax_spin[1] = 2*scr_mouse_time;\n\tmax_spin[2] = 4*scr_mouse_time;\n\tif (!already_down) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 1.5;\n\t\t}\n\t}\n\n\t/* max time between events */\n\tpersist[0] = 1*scr_mouse_persist;\n\tpersist[1] = 2*scr_mouse_persist;\n\tpersist[2] = 4*scr_mouse_persist;\n\n\t/* absolute max time in the loop */\n\tmax_long[0] = scr_mouse_maxtime;\n\tmax_long[1] = scr_mouse_maxtime;\n\tmax_long[2] = scr_mouse_maxtime;\n\n\tpointer_flush_delay = scr_mouse_pointer_delay;\n\n\t/* slow links: */\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 2.0;\n\t\t}\n\t\tpointer_flush_delay *= 2;\n\t} else if (link == LR_BROADBAND) {\n\t\tpointer_flush_delay *= 2;\n\t}\n\n\tgp = gp0 = got_pointer_input;\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\n\t/*\n\t * this is used for border pushes (bdpush) to guess location\n\t * of scrollbar (region rects containing this point are pushed).\n\t */\n\tlast_x = start_x = cursor_x;\n\tlast_y = start_y = cursor_y;\n\nif (db) fprintf(stderr, \"check_xrecord_mouse: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin[scroll_rep], tm - x11vnc_start);\n\n\twhile (1) {\n\t\tdouble spin_check;\n\t\tif (scr_ev_cnt) {\n\t\t\tint dret, ev = scr_ev_cnt - 1;\n\t\t\tint bdpush = 0, bdx, bdy, bdskinny;\n\t\t\tdouble tm, dt, age = 0.35;\n\n\t\t\tgot_one = 1;\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tscr_cnt++;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_mouse_scroll = last_scroll;\n\n\t\t\tif (last_bdpush == 0.0) {\n\t\t\t\tlast_bdpush = last_scroll;\n\t\t\t}\n\n\t\t\tbdx = start_x;\n\t\t\tbdy = start_y;\n\t\t\tif (clipshift) {\n\t\t\t\tbdx += coff_x;\n\t\t\t\tbdy += coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tbdx += off_x;\n\t\t\t\tbdy += off_y;\n\t\t\t}\n\t\t\tbdskinny = 32;\n\t\t\t\n\t\t\tset_bdpush(SCR_MOUSE, &last_bdpush, &bdpush);\n\n\t\t\tdtime0(&tm);\n\n\t\t\tdret = push_scr_ev(&age, SCR_MOUSE, bdpush, bdx,\n\t\t\t    bdy, bdskinny, first_push);\n\t\t\tif (first_push) first_push = 0;\n\t\t\tret = 1 + dret;\n\n\t\t\tdt = dtime(&tm);\n\nif (db) fprintf(stderr, \"  dret: %d  scr_ev_cnt: %d dt: %.4f\\n\",\n\tdret, scr_ev_cnt, dt);\n\n\t\t\tlast_wx = scr_ev[ev].win_x;\n\t\t\tlast_wy = scr_ev[ev].win_y;\n\t\t\tlast_ww = scr_ev[ev].win_w;\n\t\t\tlast_wh = scr_ev[ev].win_h;\n\t\t\tscr_ev_cnt = 0;\n\n\t\t\tif (! dret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (0 && button_up_time > 0.0) {\n\t\t\t\t/* we only take 1 more event with button up */\nif (db) fprintf(stderr, \"check_xrecord: BUTTON_UP_SCROLL: %.3f\\n\", spin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! flush1) {\n\t\t\tif (! already_down || (!scr_cnt && spin>flush1_time)) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tif (got_pointer_input > gp) {\n\t\t\tflush2 = 1;\n\t\t\tinput += eat_pointer(max_ptr_eat, 1);\n\t\t\tgp = got_pointer_input;\n\t\t}\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t}\n\t\tX_LOCK;\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (! input) {\n\t\t\tspin_check = 1.5 * max_spin[scroll_rep];\n\t\t} else {\n\t\t\tspin_check = max_spin[scroll_rep];\n\t\t}\n\n\t\tif (button_up_time > 0.0) {\n\t\t\tif (tm > button_up_time + max_spin[scroll_rep]) {\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-BUTTON_UP: %.3f/%.3f\\n\", spin, tm - button_up_time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!scr_cnt) {\n\t\t\tif (spin >= spin_check) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-1: %.3f/%.3f\\n\", spin, spin_check);\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tm >= last_scroll + persist[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-2: %.3f/%.3f\\n\", spin, tm - last_scroll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (spin >= max_long[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-3: %.3f/%.3f\\n\", spin, max_long[scroll_rep]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (! button_mask) {\n\t\t\tint doflush = 0;\n\t\t\tif (button_up_time > 0.0) {\n\t\t\t\t;\n\t\t\t} else if (came_back_in) {\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t\tdoflush = 1;\n\t\t\t} else if (scroll_wheel) {\nif (db) fprintf(stderr, \"check_xrecord: SCROLL-WHEEL-BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t} else if (last_x == cursor_x && last_y == cursor_y) {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tbreak;\n\t\t\t} else {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t}\n\t\t\tif (doflush) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tlast_x = cursor_x;\n\t\tlast_y = cursor_y;\n\t}\n\n\tif (got_one) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\t/* flush any remaining pointer events. */\n\tbutton_mask_save = button_mask;\n\tpointer_queued_sent = 0;\n\tlast_x = cursor_x;\n\tlast_y = cursor_y;\n\tpointer_event(-1, 0, 0, NULL);\n\tpointer_flush_delay = 0.0;\n\n\tif (xrecording && pointer_queued_sent && button_mask_save &&\n\t    (last_x != cursor_x || last_y != cursor_y) ) {\nif (db) fprintf(stderr, \"  pointer() push yields events on: ret=%d\\n\", ret);\n\t\tif (ret == 2) {\nif (db) fprintf(stderr, \"  we decide to send ret=3\\n\");\n\t\t\twant_back_in = 1;\n\t\t\tret = 3;\n\t\t\tflush2 = 1;\n\t\t} else {\n\t\t\tif (ret) {\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t} else {\n\t\tif (ret) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t}\n\n\tif (flush2) {\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tXFlush_wr(rdpy_ctrl);\n\t\tX_UNLOCK;\n\n\t\tflush2 = 1;\n\t\tdtime0(&last_flush);\n\nif (db) fprintf(stderr, \"FLUSH-2\\n\");\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\tif (ret) {\n\t\treturn ret;\n\t} else if (scr_cnt) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\"",
            "button_mask",
            "mouse_wants_back_in"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "scroll_copyrect",
            "\"mouse\""
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "scroll_copyrect",
            "\"keys\""
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "scroll_copyrect",
            "\"always\""
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: IN xrecording: %d\\n\"",
            "xrecording"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_cr_when_scaling",
          "args": [
            "\"scroll\""
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "skip_cr_when_scaling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "3023-3057",
          "snippet": "int skip_cr_when_scaling(char *mode) {\n\tint got = 0;\n\t\n\tif (!scaling) {\n\t\treturn 0;\n\t}\n\n\tif (scaling_copyrect != scaling_copyrect0) {\n\t\t/* user override via -scale: */\n\t\tif (! scaling_copyrect) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (*mode == 's') {\n\t\tgot = got_scrollcopyrect;\n\t} else if (*mode == 'w') {\n\t\tgot = got_wirecopyrect;\n\t}\n\tif (scaling_copyrect || got) {\n\t\tint lat, rate;\n\t\tint link = link_rate(&lat, &rate);\n\t\tif (link == LR_DIALUP) {\n\t\t\treturn 1;\n\t\t} else if (rate < 25) {\n\t\t\t/* the fill-in of the repair may be too slow */\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int skip_cr_when_scaling(char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint skip_cr_when_scaling(char *mode);\n\nint skip_cr_when_scaling(char *mode) {\n\tint got = 0;\n\t\n\tif (!scaling) {\n\t\treturn 0;\n\t}\n\n\tif (scaling_copyrect != scaling_copyrect0) {\n\t\t/* user override via -scale: */\n\t\tif (! scaling_copyrect) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (*mode == 's') {\n\t\tgot = got_scrollcopyrect;\n\t} else if (*mode == 'w') {\n\t\tgot = got_wirecopyrect;\n\t}\n\tif (scaling_copyrect || got) {\n\t\tint lat, rate;\n\t\tint link = link_rate(&lat, &rate);\n\t\tif (link == LR_DIALUP) {\n\t\t\treturn 1;\n\t\t} else if (rate < 25) {\n\t\t\t/* the fill-in of the repair may be too slow */\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nstatic int check_xrecord_keys(void);\nstatic int check_xrecord_mouse(void);\n\nint check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "check_xrecord_mouse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2714-3064",
    "snippet": "static int check_xrecord_mouse(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint i, scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gp, gp0, ret = 0, db = debug_scroll;\n\tint gk, gk0;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tint start_x, start_y, last_x, last_y;\n\tstatic double last_mouse_scroll = 0.0;\n\tdouble last_scroll;\n\tdouble max_spin[3], max_long[3], persist[3];\n\tdouble flush1_time = 0.01;\n\tstatic double last_flush = 0.0;\n\tdouble last_bdpush = 0.0, button_up_time = 0.0;\n\tint button_mask_save;\n\tint already_down = 0, max_ptr_eat = 20;\n\tstatic int want_back_in = 0;\n\tint came_back_in;\n\tint first_push = 1;\n\n\tint scroll_wheel = 0;\n\tint btn4 = (1<<3);\n\tint btn5 = (1<<4);\n\n\tRAWFB_RET(0)\n\n\tget_out = 1;\n\tif (button_mask) {\n\t\tget_out = 0;\n\t}\n\tif (want_back_in) {\n\t\tget_out = 0;\n\t}\n\tdtime0(&tnow);\nif (0) fprintf(stderr, \"check_xrecord_mouse: IN xrecording: %d\\n\", xrecording);\n\n\tif (get_out) {\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\tif (want_back_in) {\n\t\tcame_back_in = 1;\n\t\tfirst_push = 0;\n\t} else {\n\t\tcame_back_in = 0;\n\t}\n\twant_back_in = 0;\n\n\tif (button_mask & (btn4|btn5)) {\n\t\tscroll_wheel = 1;\n\t}\n\n\t/*\n\t * set up times for the various \"reputations\"\n\t *\n\t * 0 => -1, has been tried but never found a scroll.\n\t * 1 =>  0, has not been tried.\n\t * 2 => +1, has been tried and found a scroll.\n\t */\n\n\t/* first spin-out time (no events) */\n\tmax_spin[0] = 1*scr_mouse_time;\n\tmax_spin[1] = 2*scr_mouse_time;\n\tmax_spin[2] = 4*scr_mouse_time;\n\tif (!already_down) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 1.5;\n\t\t}\n\t}\n\n\t/* max time between events */\n\tpersist[0] = 1*scr_mouse_persist;\n\tpersist[1] = 2*scr_mouse_persist;\n\tpersist[2] = 4*scr_mouse_persist;\n\n\t/* absolute max time in the loop */\n\tmax_long[0] = scr_mouse_maxtime;\n\tmax_long[1] = scr_mouse_maxtime;\n\tmax_long[2] = scr_mouse_maxtime;\n\n\tpointer_flush_delay = scr_mouse_pointer_delay;\n\n\t/* slow links: */\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 2.0;\n\t\t}\n\t\tpointer_flush_delay *= 2;\n\t} else if (link == LR_BROADBAND) {\n\t\tpointer_flush_delay *= 2;\n\t}\n\n\tgp = gp0 = got_pointer_input;\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\n\t/*\n\t * this is used for border pushes (bdpush) to guess location\n\t * of scrollbar (region rects containing this point are pushed).\n\t */\n\tlast_x = start_x = cursor_x;\n\tlast_y = start_y = cursor_y;\n\nif (db) fprintf(stderr, \"check_xrecord_mouse: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin[scroll_rep], tm - x11vnc_start);\n\n\twhile (1) {\n\t\tdouble spin_check;\n\t\tif (scr_ev_cnt) {\n\t\t\tint dret, ev = scr_ev_cnt - 1;\n\t\t\tint bdpush = 0, bdx, bdy, bdskinny;\n\t\t\tdouble tm, dt, age = 0.35;\n\n\t\t\tgot_one = 1;\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tscr_cnt++;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_mouse_scroll = last_scroll;\n\n\t\t\tif (last_bdpush == 0.0) {\n\t\t\t\tlast_bdpush = last_scroll;\n\t\t\t}\n\n\t\t\tbdx = start_x;\n\t\t\tbdy = start_y;\n\t\t\tif (clipshift) {\n\t\t\t\tbdx += coff_x;\n\t\t\t\tbdy += coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tbdx += off_x;\n\t\t\t\tbdy += off_y;\n\t\t\t}\n\t\t\tbdskinny = 32;\n\t\t\t\n\t\t\tset_bdpush(SCR_MOUSE, &last_bdpush, &bdpush);\n\n\t\t\tdtime0(&tm);\n\n\t\t\tdret = push_scr_ev(&age, SCR_MOUSE, bdpush, bdx,\n\t\t\t    bdy, bdskinny, first_push);\n\t\t\tif (first_push) first_push = 0;\n\t\t\tret = 1 + dret;\n\n\t\t\tdt = dtime(&tm);\n\nif (db) fprintf(stderr, \"  dret: %d  scr_ev_cnt: %d dt: %.4f\\n\",\n\tdret, scr_ev_cnt, dt);\n\n\t\t\tlast_wx = scr_ev[ev].win_x;\n\t\t\tlast_wy = scr_ev[ev].win_y;\n\t\t\tlast_ww = scr_ev[ev].win_w;\n\t\t\tlast_wh = scr_ev[ev].win_h;\n\t\t\tscr_ev_cnt = 0;\n\n\t\t\tif (! dret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (0 && button_up_time > 0.0) {\n\t\t\t\t/* we only take 1 more event with button up */\nif (db) fprintf(stderr, \"check_xrecord: BUTTON_UP_SCROLL: %.3f\\n\", spin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! flush1) {\n\t\t\tif (! already_down || (!scr_cnt && spin>flush1_time)) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tif (got_pointer_input > gp) {\n\t\t\tflush2 = 1;\n\t\t\tinput += eat_pointer(max_ptr_eat, 1);\n\t\t\tgp = got_pointer_input;\n\t\t}\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t}\n\t\tX_LOCK;\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (! input) {\n\t\t\tspin_check = 1.5 * max_spin[scroll_rep];\n\t\t} else {\n\t\t\tspin_check = max_spin[scroll_rep];\n\t\t}\n\n\t\tif (button_up_time > 0.0) {\n\t\t\tif (tm > button_up_time + max_spin[scroll_rep]) {\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-BUTTON_UP: %.3f/%.3f\\n\", spin, tm - button_up_time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!scr_cnt) {\n\t\t\tif (spin >= spin_check) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-1: %.3f/%.3f\\n\", spin, spin_check);\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tm >= last_scroll + persist[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-2: %.3f/%.3f\\n\", spin, tm - last_scroll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (spin >= max_long[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-3: %.3f/%.3f\\n\", spin, max_long[scroll_rep]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (! button_mask) {\n\t\t\tint doflush = 0;\n\t\t\tif (button_up_time > 0.0) {\n\t\t\t\t;\n\t\t\t} else if (came_back_in) {\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t\tdoflush = 1;\n\t\t\t} else if (scroll_wheel) {\nif (db) fprintf(stderr, \"check_xrecord: SCROLL-WHEEL-BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t} else if (last_x == cursor_x && last_y == cursor_y) {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tbreak;\n\t\t\t} else {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t}\n\t\t\tif (doflush) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tlast_x = cursor_x;\n\t\tlast_y = cursor_y;\n\t}\n\n\tif (got_one) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\t/* flush any remaining pointer events. */\n\tbutton_mask_save = button_mask;\n\tpointer_queued_sent = 0;\n\tlast_x = cursor_x;\n\tlast_y = cursor_y;\n\tpointer_event(-1, 0, 0, NULL);\n\tpointer_flush_delay = 0.0;\n\n\tif (xrecording && pointer_queued_sent && button_mask_save &&\n\t    (last_x != cursor_x || last_y != cursor_y) ) {\nif (db) fprintf(stderr, \"  pointer() push yields events on: ret=%d\\n\", ret);\n\t\tif (ret == 2) {\nif (db) fprintf(stderr, \"  we decide to send ret=3\\n\");\n\t\t\twant_back_in = 1;\n\t\t\tret = 3;\n\t\t\tflush2 = 1;\n\t\t} else {\n\t\t\tif (ret) {\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t} else {\n\t\tif (ret) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t}\n\n\tif (flush2) {\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tXFlush_wr(rdpy_ctrl);\n\t\tX_UNLOCK;\n\n\t\tflush2 = 1;\n\t\tdtime0(&last_flush);\n\nif (db) fprintf(stderr, \"FLUSH-2\\n\");\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\tif (ret) {\n\t\treturn ret;\n\t} else if (scr_cnt) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "int check_xrecord(void);",
      "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
      "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);",
      "static int scrollability(Window win, int set);",
      "static int check_xrecord_mouse(void);",
      "static void check_user_input2(double dt);",
      "static double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;",
      "static double scr_mouse_pointer_delay;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"FLUSH-2\\n\""
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&last_flush"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "rdpy_ctrl"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecord_watch",
          "args": [
            "0",
            "SCR_MOUSE"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1664-2082",
          "snippet": "void xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NAMEINFO 2048"
          ],
          "globals_used": [
            "int xrecording = 0;",
            "int xrecord_set_by_keys = 0;",
            "int xrecord_set_by_mouse = 0;",
            "Window xrecord_focus_window = None;",
            "Window xrecord_wm_window = None;",
            "Window xrecord_ptr_window = None;",
            "KeySym xrecord_keysym = NoSymbol;",
            "char xrecord_name_info[NAMEINFO];",
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "void xrecord_watch(int start, int setby);",
            "static void xrecord_grabserver(int start);",
            "static void check_xrecord_grabserver(void);",
            "static XID xrecord_seq = 0;",
            "static double xrecord_start = 0.0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NAMEINFO 2048\n\nint xrecording = 0;\nint xrecord_set_by_keys = 0;\nint xrecord_set_by_mouse = 0;\nWindow xrecord_focus_window = None;\nWindow xrecord_wm_window = None;\nWindow xrecord_ptr_window = None;\nKeySym xrecord_keysym = NoSymbol;\nchar xrecord_name_info[NAMEINFO];\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid xrecord_watch(int start, int setby);\nstatic void xrecord_grabserver(int start);\nstatic void check_xrecord_grabserver(void);\nstatic XID xrecord_seq = 0;\nstatic double xrecord_start = 0.0;\n\nvoid xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  we decide to send ret=3\\n\""
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  pointer() push yields events on: ret=%d\\n\"",
            "ret"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointer_event",
          "args": [
            "-1",
            "0",
            "0",
            "NULL"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "pointer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "700-1005",
          "snippet": "void pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int pointer_queued_sent = 0;",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint pointer_queued_sent = 0;\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrollability",
          "args": [
            "xrecord_ptr_window",
            "SCR_FAIL"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "scrollability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2270-2339",
          "snippet": "static int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SCR_RESULTS_MAX 256"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "static int scrollability(Window win, int set);",
            "static scroll_result_t scroll_results[SCR_RESULTS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_RESULTS_MAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic scroll_result_t scroll_results[SCR_RESULTS_MAX];\n\nstatic int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_xdamage_mark",
          "args": [
            "last_wx",
            "last_wy",
            "last_ww",
            "last_wh"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "set_xdamage_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2441-2459",
          "snippet": "void set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\"",
            "spin",
            "max_long[scroll_rep]",
            "last_x",
            "last_y",
            "cursor_x",
            "cursor_y"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: BUTTON-UP:  %.3f/%.3f %d/%d %d/%d\\n\"",
            "spin",
            "max_long[scroll_rep]",
            "last_x",
            "last_y",
            "cursor_x",
            "cursor_y"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SCROLL-WHEEL-BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\"",
            "spin",
            "max_long[scroll_rep]",
            "last_x",
            "last_y",
            "cursor_x",
            "cursor_y"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SPIN-OUT-3: %.3f/%.3f\\n\"",
            "spin",
            "max_long[scroll_rep]"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SPIN-OUT-2: %.3f/%.3f\\n\"",
            "spin",
            "tm - last_scroll"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SPIN-OUT-1: %.3f/%.3f\\n\"",
            "spin",
            "spin_check"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SPIN-OUT-BUTTON_UP: %.3f/%.3f\\n\"",
            "spin",
            "tm - button_up_time"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordProcessReplies",
          "args": [
            "rdpy_data"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eat_pointer",
          "args": [
            "max_ptr_eat",
            "1"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "eat_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2367-2381",
          "snippet": "static int eat_pointer(int max_ptr_eat, int keep) {\n\tint i, count = 0,  gp = got_pointer_input;\n\n\tfor (i=0; i<max_ptr_eat; i++) {\n\t\trfbCFD(0);\n\t\tif (got_pointer_input > gp)  {\n\t\t\tcount++;\nif (0) fprintf(stderr, \"GP*-%d\\n\", i);\n\t\t\tgp = got_pointer_input;\n\t\t} else if (i > keep) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void eat_viewonly_input(int max_eat, int keep);",
            "int fb_update_sent(int *count);",
            "static int eat_pointer(int max_ptr_eat, int keep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid eat_viewonly_input(int max_eat, int keep);\nint fb_update_sent(int *count);\nstatic int eat_pointer(int max_ptr_eat, int keep);\n\nstatic int eat_pointer(int max_ptr_eat, int keep) {\n\tint i, count = 0,  gp = got_pointer_input;\n\n\tfor (i=0; i<max_ptr_eat; i++) {\n\t\trfbCFD(0);\n\t\tif (got_pointer_input > gp)  {\n\t\t\tcount++;\nif (0) fprintf(stderr, \"GP*-%d\\n\", i);\n\t\t\tgp = got_pointer_input;\n\t\t} else if (i > keep) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: BUTTON_UP_SCROLL: %.3f\\n\"",
            "spin"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  dret: %d  scr_ev_cnt: %d dt: %.4f\\n\"",
            "dret",
            "scr_ev_cnt",
            "dt"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_scr_ev",
          "args": [
            "&age",
            "SCR_MOUSE",
            "bdpush",
            "bdx",
            "bdy",
            "bdskinny",
            "first_push"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "push_scr_ev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1429-1831",
          "snippet": "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int last_scroll_type = SCR_NONE;",
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void fb_push(void);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
            "static int set_ypad(void);",
            "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "static void check_user_input2(double dt);",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint last_scroll_type = SCR_NONE;\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int set_ypad(void);\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nvoid batch_push(int ncr, double delay);\n\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bdpush",
          "args": [
            "SCR_MOUSE",
            "&last_bdpush",
            "&bdpush"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "set_bdpush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2383-2407",
          "snippet": "static void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_bdpush(int type, double *last_bdpush, int *pushit);",
            "static double scr_key_bdpush_time, scr_mouse_bdpush_time;",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit);\nstatic double scr_key_bdpush_time, scr_mouse_bdpush_time;\nvoid batch_push(int ncr, double delay);\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord_mouse: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\"",
            "scr_ev_cnt",
            "max_spin[scroll_rep]",
            "tm - x11vnc_start"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord_mouse: IN xrecording: %d\\n\"",
            "xrecording"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nint check_xrecord(void);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);\nstatic int scrollability(Window win, int set);\nstatic int check_xrecord_mouse(void);\nstatic void check_user_input2(double dt);\nstatic double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;\nstatic double scr_mouse_pointer_delay;\n\nstatic int check_xrecord_mouse(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint i, scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gp, gp0, ret = 0, db = debug_scroll;\n\tint gk, gk0;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tint start_x, start_y, last_x, last_y;\n\tstatic double last_mouse_scroll = 0.0;\n\tdouble last_scroll;\n\tdouble max_spin[3], max_long[3], persist[3];\n\tdouble flush1_time = 0.01;\n\tstatic double last_flush = 0.0;\n\tdouble last_bdpush = 0.0, button_up_time = 0.0;\n\tint button_mask_save;\n\tint already_down = 0, max_ptr_eat = 20;\n\tstatic int want_back_in = 0;\n\tint came_back_in;\n\tint first_push = 1;\n\n\tint scroll_wheel = 0;\n\tint btn4 = (1<<3);\n\tint btn5 = (1<<4);\n\n\tRAWFB_RET(0)\n\n\tget_out = 1;\n\tif (button_mask) {\n\t\tget_out = 0;\n\t}\n\tif (want_back_in) {\n\t\tget_out = 0;\n\t}\n\tdtime0(&tnow);\nif (0) fprintf(stderr, \"check_xrecord_mouse: IN xrecording: %d\\n\", xrecording);\n\n\tif (get_out) {\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\tif (want_back_in) {\n\t\tcame_back_in = 1;\n\t\tfirst_push = 0;\n\t} else {\n\t\tcame_back_in = 0;\n\t}\n\twant_back_in = 0;\n\n\tif (button_mask & (btn4|btn5)) {\n\t\tscroll_wheel = 1;\n\t}\n\n\t/*\n\t * set up times for the various \"reputations\"\n\t *\n\t * 0 => -1, has been tried but never found a scroll.\n\t * 1 =>  0, has not been tried.\n\t * 2 => +1, has been tried and found a scroll.\n\t */\n\n\t/* first spin-out time (no events) */\n\tmax_spin[0] = 1*scr_mouse_time;\n\tmax_spin[1] = 2*scr_mouse_time;\n\tmax_spin[2] = 4*scr_mouse_time;\n\tif (!already_down) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 1.5;\n\t\t}\n\t}\n\n\t/* max time between events */\n\tpersist[0] = 1*scr_mouse_persist;\n\tpersist[1] = 2*scr_mouse_persist;\n\tpersist[2] = 4*scr_mouse_persist;\n\n\t/* absolute max time in the loop */\n\tmax_long[0] = scr_mouse_maxtime;\n\tmax_long[1] = scr_mouse_maxtime;\n\tmax_long[2] = scr_mouse_maxtime;\n\n\tpointer_flush_delay = scr_mouse_pointer_delay;\n\n\t/* slow links: */\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tfor (i=0; i<3; i++) {\n\t\t\tmax_spin[i] *= 2.0;\n\t\t}\n\t\tpointer_flush_delay *= 2;\n\t} else if (link == LR_BROADBAND) {\n\t\tpointer_flush_delay *= 2;\n\t}\n\n\tgp = gp0 = got_pointer_input;\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\n\t/*\n\t * this is used for border pushes (bdpush) to guess location\n\t * of scrollbar (region rects containing this point are pushed).\n\t */\n\tlast_x = start_x = cursor_x;\n\tlast_y = start_y = cursor_y;\n\nif (db) fprintf(stderr, \"check_xrecord_mouse: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin[scroll_rep], tm - x11vnc_start);\n\n\twhile (1) {\n\t\tdouble spin_check;\n\t\tif (scr_ev_cnt) {\n\t\t\tint dret, ev = scr_ev_cnt - 1;\n\t\t\tint bdpush = 0, bdx, bdy, bdskinny;\n\t\t\tdouble tm, dt, age = 0.35;\n\n\t\t\tgot_one = 1;\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tscr_cnt++;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_mouse_scroll = last_scroll;\n\n\t\t\tif (last_bdpush == 0.0) {\n\t\t\t\tlast_bdpush = last_scroll;\n\t\t\t}\n\n\t\t\tbdx = start_x;\n\t\t\tbdy = start_y;\n\t\t\tif (clipshift) {\n\t\t\t\tbdx += coff_x;\n\t\t\t\tbdy += coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tbdx += off_x;\n\t\t\t\tbdy += off_y;\n\t\t\t}\n\t\t\tbdskinny = 32;\n\t\t\t\n\t\t\tset_bdpush(SCR_MOUSE, &last_bdpush, &bdpush);\n\n\t\t\tdtime0(&tm);\n\n\t\t\tdret = push_scr_ev(&age, SCR_MOUSE, bdpush, bdx,\n\t\t\t    bdy, bdskinny, first_push);\n\t\t\tif (first_push) first_push = 0;\n\t\t\tret = 1 + dret;\n\n\t\t\tdt = dtime(&tm);\n\nif (db) fprintf(stderr, \"  dret: %d  scr_ev_cnt: %d dt: %.4f\\n\",\n\tdret, scr_ev_cnt, dt);\n\n\t\t\tlast_wx = scr_ev[ev].win_x;\n\t\t\tlast_wy = scr_ev[ev].win_y;\n\t\t\tlast_ww = scr_ev[ev].win_w;\n\t\t\tlast_wh = scr_ev[ev].win_h;\n\t\t\tscr_ev_cnt = 0;\n\n\t\t\tif (! dret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (0 && button_up_time > 0.0) {\n\t\t\t\t/* we only take 1 more event with button up */\nif (db) fprintf(stderr, \"check_xrecord: BUTTON_UP_SCROLL: %.3f\\n\", spin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! flush1) {\n\t\t\tif (! already_down || (!scr_cnt && spin>flush1_time)) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tif (got_pointer_input > gp) {\n\t\t\tflush2 = 1;\n\t\t\tinput += eat_pointer(max_ptr_eat, 1);\n\t\t\tgp = got_pointer_input;\n\t\t}\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t}\n\t\tX_LOCK;\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (! input) {\n\t\t\tspin_check = 1.5 * max_spin[scroll_rep];\n\t\t} else {\n\t\t\tspin_check = max_spin[scroll_rep];\n\t\t}\n\n\t\tif (button_up_time > 0.0) {\n\t\t\tif (tm > button_up_time + max_spin[scroll_rep]) {\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-BUTTON_UP: %.3f/%.3f\\n\", spin, tm - button_up_time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!scr_cnt) {\n\t\t\tif (spin >= spin_check) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-1: %.3f/%.3f\\n\", spin, spin_check);\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tm >= last_scroll + persist[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-2: %.3f/%.3f\\n\", spin, tm - last_scroll);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (spin >= max_long[scroll_rep]) {\n\nif (db) fprintf(stderr, \"check_xrecord: SPIN-OUT-3: %.3f/%.3f\\n\", spin, max_long[scroll_rep]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (! button_mask) {\n\t\t\tint doflush = 0;\n\t\t\tif (button_up_time > 0.0) {\n\t\t\t\t;\n\t\t\t} else if (came_back_in) {\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t\tdoflush = 1;\n\t\t\t} else if (scroll_wheel) {\nif (db) fprintf(stderr, \"check_xrecord: SCROLL-WHEEL-BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t} else if (last_x == cursor_x && last_y == cursor_y) {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tbreak;\n\t\t\t} else {\nif (db) fprintf(stderr, \"check_xrecord: BUTTON-UP-KEEP-GOING:  %.3f/%.3f %d/%d %d/%d\\n\", spin, max_long[scroll_rep], last_x, last_y, cursor_x, cursor_y);\n\t\t\t\tdoflush = 1;\n\t\t\t\tdtime0(&button_up_time);\n\t\t\t}\n\t\t\tif (doflush) {\n\t\t\t\tflush1 = 1;\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tdtime0(&last_flush);\n\t\t\t}\n\t\t}\n\n\t\tlast_x = cursor_x;\n\t\tlast_y = cursor_y;\n\t}\n\n\tif (got_one) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\t/* flush any remaining pointer events. */\n\tbutton_mask_save = button_mask;\n\tpointer_queued_sent = 0;\n\tlast_x = cursor_x;\n\tlast_y = cursor_y;\n\tpointer_event(-1, 0, 0, NULL);\n\tpointer_flush_delay = 0.0;\n\n\tif (xrecording && pointer_queued_sent && button_mask_save &&\n\t    (last_x != cursor_x || last_y != cursor_y) ) {\nif (db) fprintf(stderr, \"  pointer() push yields events on: ret=%d\\n\", ret);\n\t\tif (ret == 2) {\nif (db) fprintf(stderr, \"  we decide to send ret=3\\n\");\n\t\t\twant_back_in = 1;\n\t\t\tret = 3;\n\t\t\tflush2 = 1;\n\t\t} else {\n\t\t\tif (ret) {\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t} else {\n\t\tif (ret) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_MOUSE);\n\t\t}\n\t}\n\n\tif (flush2) {\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tXFlush_wr(rdpy_ctrl);\n\t\tX_UNLOCK;\n\n\t\tflush2 = 1;\n\t\tdtime0(&last_flush);\n\nif (db) fprintf(stderr, \"FLUSH-2\\n\");\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\tif (ret) {\n\t\treturn ret;\n\t} else if (scr_cnt) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "check_xrecord_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2472-2712",
    "snippet": "static int check_xrecord_keys(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gk, gk0, ret = 0, db = debug_scroll;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tstatic double last_key_scroll = 0.0;\n\tstatic double persist_start = 0.0;\n\tstatic double last_bdpush = 0.0;\n\tstatic int persist_count = 0;\n\tint scroll_keysym = 0;\n\tdouble last_scroll, scroll_persist = scr_key_persist;\n\tdouble spin_fac = 1.0, scroll_fac = 2.0, noscroll_fac = 0.75;\n\tdouble max_spin, max_long_spin = 0.3;\n\tdouble set_repeat_in;\n\tstatic double set_repeat = 0.0;\n\n\n\tRAWFB_RET(0)\n\n\tif (unixpw_in_progress) return 0;\n\n\tset_repeat_in = set_repeat;\n\tset_repeat = 0.0;\n\n\tget_out = 1;\n\tif (got_keyboard_input) {\n\t\tget_out = 0;\n\t}\n\n\tdtime0(&tnow);\n\tif (tnow < last_key_scroll + scroll_persist) {\n\t\tget_out = 0;\n\t}\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + set_repeat_in) {\n\t\tget_out = 0;\n\t}\n\n\tif (get_out) {\n\t\tpersist_start = 0.0;\n\t\tpersist_count = 0;\n\t\tlast_bdpush = 0.0;\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t\treturn 0;\n\t}\n\n#if 0\n\t/* not used for keyboard yet */\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n#endif\n\n\tscroll_keysym = xrecord_scroll_keysym(last_rfb_keysym);\n\n\tmax_spin = scr_key_time;\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + 2*set_repeat_in) {\n\t\tmax_spin = 2 * set_repeat_in;\n\t} else if (tnow < last_key_scroll + scroll_persist) {\n\t\tmax_spin = 1.25*(tnow - last_key_scroll);\n\t} else if (tnow < last_key_to_button_remap_time + 1.5*scroll_persist) {\n\t\t/* mostly a hack I use for testing -remap key -> btn4/btn5 */\n\t\tmax_spin = scroll_persist;\n\t} else if (scroll_keysym) {\n\t\tif (repeat_check(last_key_scroll)) {\n\t\t\tspin_fac = scroll_fac;\n\t\t} else {\n\t\t\tspin_fac = noscroll_fac;\n\t\t}\n\t}\n\tif (max_spin > max_long_spin) {\n\t\tmax_spin = max_long_spin;\n\t}\n\n\t/* XXX use this somehow  */\nif (0)\tlink = link_rate(&latency, &netrate);\n\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\nif (db) fprintf(stderr, \"check_xrecord_keys: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin, tm - x11vnc_start);\n\n\twhile (1) {\n\n\t\tif (scr_ev_cnt) {\n\t\t\tgot_one = 1;\n\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_key_scroll = last_scroll;\n\t\t\tscr_cnt++;\n\t\t\tbreak;\n\t\t}\n\n\t\tX_LOCK;\n\t\tflush1 = 1;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (set_repeat_in > 0.0) {\n\t\t\tmax_keyrepeat_time = set_repeat_in;\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tX_LOCK;\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t\tif (set_repeat_in) {\n\t\t\t\t;\n\t\t\t} else if (xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\t\tif (repeat_check(last_key_scroll)) {\n\t\t\t\t\tspin_fac = scroll_fac;\n\t\t\t\t} else {\n\t\t\t\t\tspin_fac = noscroll_fac;\n\t\t\t\t}\n\t\t\t}\nif (0 || db) fprintf(stderr, \"check_xrecord: more keys: %.3f  0x%x \"\n    \" %.4f  %s  %s\\n\", spin, last_rfb_keysym, last_rfb_keytime - x11vnc_start,\n    last_rfb_down ? \"down\":\"up  \", last_rfb_key_accepted ? \"accept\":\"skip\");\n\t\t\tflush2 = 1;\n\t\t\tXFlush_wr(dpy);\n\t\t}\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (spin >= max_spin * spin_fac) {\nif (0 || db) fprintf(stderr, \"check_xrecord: SPIN-OUT: %.3f/%.3f\\n\", spin,\n    max_spin * spin_fac);\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmax_keyrepeat_time = 0.0;\n\n\tif (scr_ev_cnt) {\n\t\tint dret, ev = scr_ev_cnt - 1;\n\t\tint bdx, bdy, bdskinny, bdpush = 0;\n\t\tdouble max_age = 0.25, age, tm, dt;\n\t\tstatic double last_scr_ev = 0.0;\n\n\t\tlast_wx = scr_ev[ev].win_x;\n\t\tlast_wy = scr_ev[ev].win_y;\n\t\tlast_ww = scr_ev[ev].win_w;\n\t\tlast_wh = scr_ev[ev].win_h;\n\n\t\t/* assume scrollbar on rhs: */\n\t\tbdx = last_wx + last_ww + 3;\n\t\tbdy = last_wy + last_wh/2;\n\t\tbdskinny = 32;\n\t\t\t\n\t\tif (persist_start == 0.0) {\n\t\t\tbdpush = 0;\n\t\t} else {\n\t\t\tset_bdpush(SCR_KEY, &last_bdpush, &bdpush);\n\t\t}\n\n\t\tdtime0(&tm);\n\t\tage = max_age;\n\t\tdret = push_scr_ev(&age, SCR_KEY, bdpush, bdx, bdy, bdskinny, 1);\n\t\tdt = dtime(&tm);\n\n\t\tret = 1 + dret;\n\t\tscr_ev_cnt = 0;\n\n\t\tif (ret == 2 && xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\tint repeating;\n\t\t\tdouble time_lo = 1.0/max_keyrepeat_lo;\n\t\t\tdouble time_hi = 1.0/max_keyrepeat_hi;\n\t\t\tdouble rate = typing_rate(0.0, &repeating);\nif (0 || db) fprintf(stderr, \"Typing: dt: %.4f rate: %.1f\\n\", dt, rate);\n\t\t\tif (repeating) {\n\t\t\t\t/* n.b. the \"quantum\" is about 1/30 sec. */\n\t\t\t\tmax_keyrepeat_time = 1.0*dt;\n\t\t\t\tif (max_keyrepeat_time > time_lo ||\n\t\t\t\t    max_keyrepeat_time < time_hi) {\n\t\t\t\t\tmax_keyrepeat_time = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tset_repeat = max_keyrepeat_time;\nif (0 || db) fprintf(stderr, \"set max_keyrepeat_time: %.2f\\n\", max_keyrepeat_time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_scr_ev = dnow();\n\t}\n\n\tif ((got_one && ret < 2) || persist_count) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\tif (xrecording) {\n\t\tif (ret < 2) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t}\n\n\tif (ret == 2) {\n\t\tif (persist_start == 0.0) {\n\t\t\tdtime(&persist_start);\n\t\t\tlast_bdpush = persist_start;\n\t\t}\n\t} else {\n\t\tpersist_start = 0.0;\n\t\tlast_bdpush = 0.0;\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_xrecord(void);",
      "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
      "static int scrollability(Window win, int set);",
      "static int repeat_check(double last_key_scroll);",
      "static int check_xrecord_keys(void);",
      "static void check_user_input2(double dt);",
      "static double scr_key_time, scr_key_persist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&persist_start"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecord_watch",
          "args": [
            "0",
            "SCR_KEY"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1664-2082",
          "snippet": "void xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NAMEINFO 2048"
          ],
          "globals_used": [
            "int xrecording = 0;",
            "int xrecord_set_by_keys = 0;",
            "int xrecord_set_by_mouse = 0;",
            "Window xrecord_focus_window = None;",
            "Window xrecord_wm_window = None;",
            "Window xrecord_ptr_window = None;",
            "KeySym xrecord_keysym = NoSymbol;",
            "char xrecord_name_info[NAMEINFO];",
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "void xrecord_watch(int start, int setby);",
            "static void xrecord_grabserver(int start);",
            "static void check_xrecord_grabserver(void);",
            "static XID xrecord_seq = 0;",
            "static double xrecord_start = 0.0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NAMEINFO 2048\n\nint xrecording = 0;\nint xrecord_set_by_keys = 0;\nint xrecord_set_by_mouse = 0;\nWindow xrecord_focus_window = None;\nWindow xrecord_wm_window = None;\nWindow xrecord_ptr_window = None;\nKeySym xrecord_keysym = NoSymbol;\nchar xrecord_name_info[NAMEINFO];\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid xrecord_watch(int start, int setby);\nstatic void xrecord_grabserver(int start);\nstatic void check_xrecord_grabserver(void);\nstatic XID xrecord_seq = 0;\nstatic double xrecord_start = 0.0;\n\nvoid xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrollability",
          "args": [
            "xrecord_ptr_window",
            "SCR_FAIL"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "scrollability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2270-2339",
          "snippet": "static int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SCR_RESULTS_MAX 256"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int lookup_win_index(Window);",
            "static int scrollability(Window win, int set);",
            "static scroll_result_t scroll_results[SCR_RESULTS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_RESULTS_MAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic scroll_result_t scroll_results[SCR_RESULTS_MAX];\n\nstatic int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_xdamage_mark",
          "args": [
            "last_wx",
            "last_wy",
            "last_ww",
            "last_wh"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "set_xdamage_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2441-2459",
          "snippet": "void set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set max_keyrepeat_time: %.2f\\n\"",
            "max_keyrepeat_time"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Typing: dt: %.4f rate: %.1f\\n\"",
            "dt",
            "rate"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typing_rate",
          "args": [
            "0.0",
            "&repeating"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "typing_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2974-3021",
          "snippet": "double typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define KEY_HIST 256"
          ],
          "globals_used": [
            "double typing_rate(double time_window, int *repeating);",
            "static int key_history_idx = -1;",
            "static keyevent_t key_history[KEY_HIST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define KEY_HIST 256\n\ndouble typing_rate(double time_window, int *repeating);\nstatic int key_history_idx = -1;\nstatic keyevent_t key_history[KEY_HIST];\n\ndouble typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecord_scroll_keysym",
          "args": [
            "last_rfb_keysym"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_scroll_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "443-464",
          "snippet": "int xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecord_skip_keysym(rfbKeySym keysym);",
            "int xrecord_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nint xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_scr_ev",
          "args": [
            "&age",
            "SCR_KEY",
            "bdpush",
            "bdx",
            "bdy",
            "bdskinny",
            "1"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "push_scr_ev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1429-1831",
          "snippet": "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int last_scroll_type = SCR_NONE;",
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void fb_push(void);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
            "static int set_ypad(void);",
            "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "static void check_user_input2(double dt);",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint last_scroll_type = SCR_NONE;\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int set_ypad(void);\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nvoid batch_push(int ncr, double delay);\n\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bdpush",
          "args": [
            "SCR_KEY",
            "&last_bdpush",
            "&bdpush"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "set_bdpush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2383-2407",
          "snippet": "static void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_bdpush(int type, double *last_bdpush, int *pushit);",
            "static double scr_key_bdpush_time, scr_mouse_bdpush_time;",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit);\nstatic double scr_key_bdpush_time, scr_mouse_bdpush_time;\nvoid batch_push(int ncr, double delay);\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: SPIN-OUT: %.3f/%.3f\\n\"",
            "spin",
            "max_spin * spin_fac"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordProcessReplies",
          "args": [
            "rdpy_data"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord: more keys: %.3f  0x%x \"\n    \" %.4f  %s  %s\\n\"",
            "spin",
            "last_rfb_keysym",
            "last_rfb_keytime - x11vnc_start",
            "last_rfb_down ? \"down\":\"up  \"",
            "last_rfb_key_accepted ? \"accept\":\"skip\""
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repeat_check",
          "args": [
            "last_key_scroll"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "repeat_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2461-2470",
          "snippet": "static int repeat_check(double last_key_scroll) {\n\tint repeating;\n\tdouble rate = typing_rate(0.0, &repeating);\n\tdouble now = dnow(), delay = 0.5;\n\tif (rate > 2.0 && repeating && now > last_key_scroll + delay) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int repeat_check(double last_key_scroll);",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int repeat_check(double last_key_scroll);\nvoid batch_push(int ncr, double delay);\n\nstatic int repeat_check(double last_key_scroll) {\n\tint repeating;\n\tdouble rate = typing_rate(0.0, &repeating);\n\tdouble now = dnow(), delay = 0.5;\n\tif (rate > 2.0 && repeating && now > last_key_scroll + delay) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "1000"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord_keys: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\"",
            "scr_ev_cnt",
            "max_spin",
            "tm - x11vnc_start"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int scrollability(Window win, int set);\nstatic int repeat_check(double last_key_scroll);\nstatic int check_xrecord_keys(void);\nstatic void check_user_input2(double dt);\nstatic double scr_key_time, scr_key_persist;\n\nstatic int check_xrecord_keys(void) {\n\tstatic int last_wx, last_wy, last_ww, last_wh;\n\tdouble spin = 0.0, tm, tnow;\n\tint scr_cnt = 0, input = 0, scroll_rep;\n\tint get_out, got_one = 0, flush1 = 0, flush2 = 0;\n\tint gk, gk0, ret = 0, db = debug_scroll;\n\tint fail = 0;\n\tint link, latency, netrate;\n\n\tstatic double last_key_scroll = 0.0;\n\tstatic double persist_start = 0.0;\n\tstatic double last_bdpush = 0.0;\n\tstatic int persist_count = 0;\n\tint scroll_keysym = 0;\n\tdouble last_scroll, scroll_persist = scr_key_persist;\n\tdouble spin_fac = 1.0, scroll_fac = 2.0, noscroll_fac = 0.75;\n\tdouble max_spin, max_long_spin = 0.3;\n\tdouble set_repeat_in;\n\tstatic double set_repeat = 0.0;\n\n\n\tRAWFB_RET(0)\n\n\tif (unixpw_in_progress) return 0;\n\n\tset_repeat_in = set_repeat;\n\tset_repeat = 0.0;\n\n\tget_out = 1;\n\tif (got_keyboard_input) {\n\t\tget_out = 0;\n\t}\n\n\tdtime0(&tnow);\n\tif (tnow < last_key_scroll + scroll_persist) {\n\t\tget_out = 0;\n\t}\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + set_repeat_in) {\n\t\tget_out = 0;\n\t}\n\n\tif (get_out) {\n\t\tpersist_start = 0.0;\n\t\tpersist_count = 0;\n\t\tlast_bdpush = 0.0;\n\t\tif (xrecording) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t\treturn 0;\n\t}\n\n#if 0\n\t/* not used for keyboard yet */\n\tscroll_rep = scrollability(xrecord_ptr_window, SCR_NONE) + 1;\n\tif (scroll_rep == 1) {\n\t\tscroll_rep = 2;\t\t/* if no info, assume the best. */\n\t}\n#endif\n\n\tscroll_keysym = xrecord_scroll_keysym(last_rfb_keysym);\n\n\tmax_spin = scr_key_time;\n\n\tif (set_repeat_in > 0.0 && tnow < last_key_scroll + 2*set_repeat_in) {\n\t\tmax_spin = 2 * set_repeat_in;\n\t} else if (tnow < last_key_scroll + scroll_persist) {\n\t\tmax_spin = 1.25*(tnow - last_key_scroll);\n\t} else if (tnow < last_key_to_button_remap_time + 1.5*scroll_persist) {\n\t\t/* mostly a hack I use for testing -remap key -> btn4/btn5 */\n\t\tmax_spin = scroll_persist;\n\t} else if (scroll_keysym) {\n\t\tif (repeat_check(last_key_scroll)) {\n\t\t\tspin_fac = scroll_fac;\n\t\t} else {\n\t\t\tspin_fac = noscroll_fac;\n\t\t}\n\t}\n\tif (max_spin > max_long_spin) {\n\t\tmax_spin = max_long_spin;\n\t}\n\n\t/* XXX use this somehow  */\nif (0)\tlink = link_rate(&latency, &netrate);\n\n\tgk = gk0 = got_keyboard_input;\n\tdtime0(&tm);\n\nif (db) fprintf(stderr, \"check_xrecord_keys: BEGIN LOOP: scr_ev_cnt: \"\n    \"%d max: %.3f  %.4f\\n\", scr_ev_cnt, max_spin, tm - x11vnc_start);\n\n\twhile (1) {\n\n\t\tif (scr_ev_cnt) {\n\t\t\tgot_one = 1;\n\n\t\t\tscrollability(xrecord_ptr_window, SCR_SUCCESS);\n\t\t\tscroll_rep = 2;\n\n\t\t\tdtime0(&last_scroll);\n\t\t\tlast_key_scroll = last_scroll;\n\t\t\tscr_cnt++;\n\t\t\tbreak;\n\t\t}\n\n\t\tX_LOCK;\n\t\tflush1 = 1;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (set_repeat_in > 0.0) {\n\t\t\tmax_keyrepeat_time = set_repeat_in;\n\t\t}\n\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tspin += dtime(&tm);\n\n\t\tX_LOCK;\n\t\tif (got_keyboard_input > gk) {\n\t\t\tgk = got_keyboard_input;\n\t\t\tinput++;\n\t\t\tif (set_repeat_in) {\n\t\t\t\t;\n\t\t\t} else if (xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\t\tif (repeat_check(last_key_scroll)) {\n\t\t\t\t\tspin_fac = scroll_fac;\n\t\t\t\t} else {\n\t\t\t\t\tspin_fac = noscroll_fac;\n\t\t\t\t}\n\t\t\t}\nif (0 || db) fprintf(stderr, \"check_xrecord: more keys: %.3f  0x%x \"\n    \" %.4f  %s  %s\\n\", spin, last_rfb_keysym, last_rfb_keytime - x11vnc_start,\n    last_rfb_down ? \"down\":\"up  \", last_rfb_key_accepted ? \"accept\":\"skip\");\n\t\t\tflush2 = 1;\n\t\t\tXFlush_wr(dpy);\n\t\t}\n#if HAVE_RECORD\n\t\tSCR_LOCK;\n\t\tXRecordProcessReplies(rdpy_data);\n\t\tSCR_UNLOCK;\n#endif\n\t\tX_UNLOCK;\n\n\t\tif (spin >= max_spin * spin_fac) {\nif (0 || db) fprintf(stderr, \"check_xrecord: SPIN-OUT: %.3f/%.3f\\n\", spin,\n    max_spin * spin_fac);\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmax_keyrepeat_time = 0.0;\n\n\tif (scr_ev_cnt) {\n\t\tint dret, ev = scr_ev_cnt - 1;\n\t\tint bdx, bdy, bdskinny, bdpush = 0;\n\t\tdouble max_age = 0.25, age, tm, dt;\n\t\tstatic double last_scr_ev = 0.0;\n\n\t\tlast_wx = scr_ev[ev].win_x;\n\t\tlast_wy = scr_ev[ev].win_y;\n\t\tlast_ww = scr_ev[ev].win_w;\n\t\tlast_wh = scr_ev[ev].win_h;\n\n\t\t/* assume scrollbar on rhs: */\n\t\tbdx = last_wx + last_ww + 3;\n\t\tbdy = last_wy + last_wh/2;\n\t\tbdskinny = 32;\n\t\t\t\n\t\tif (persist_start == 0.0) {\n\t\t\tbdpush = 0;\n\t\t} else {\n\t\t\tset_bdpush(SCR_KEY, &last_bdpush, &bdpush);\n\t\t}\n\n\t\tdtime0(&tm);\n\t\tage = max_age;\n\t\tdret = push_scr_ev(&age, SCR_KEY, bdpush, bdx, bdy, bdskinny, 1);\n\t\tdt = dtime(&tm);\n\n\t\tret = 1 + dret;\n\t\tscr_ev_cnt = 0;\n\n\t\tif (ret == 2 && xrecord_scroll_keysym(last_rfb_keysym)) {\n\t\t\tint repeating;\n\t\t\tdouble time_lo = 1.0/max_keyrepeat_lo;\n\t\t\tdouble time_hi = 1.0/max_keyrepeat_hi;\n\t\t\tdouble rate = typing_rate(0.0, &repeating);\nif (0 || db) fprintf(stderr, \"Typing: dt: %.4f rate: %.1f\\n\", dt, rate);\n\t\t\tif (repeating) {\n\t\t\t\t/* n.b. the \"quantum\" is about 1/30 sec. */\n\t\t\t\tmax_keyrepeat_time = 1.0*dt;\n\t\t\t\tif (max_keyrepeat_time > time_lo ||\n\t\t\t\t    max_keyrepeat_time < time_hi) {\n\t\t\t\t\tmax_keyrepeat_time = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tset_repeat = max_keyrepeat_time;\nif (0 || db) fprintf(stderr, \"set max_keyrepeat_time: %.2f\\n\", max_keyrepeat_time);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlast_scr_ev = dnow();\n\t}\n\n\tif ((got_one && ret < 2) || persist_count) {\n\t\tset_xdamage_mark(last_wx, last_wy, last_ww, last_wh);\n\t}\n\n\tif (fail) {\n\t\tscrollability(xrecord_ptr_window, SCR_FAIL);\n\t}\n\n\tif (xrecording) {\n\t\tif (ret < 2) {\n\t\t\txrecord_watch(0, SCR_KEY);\n\t\t}\n\t}\n\n\tif (ret == 2) {\n\t\tif (persist_start == 0.0) {\n\t\t\tdtime(&persist_start);\n\t\t\tlast_bdpush = persist_start;\n\t\t}\n\t} else {\n\t\tpersist_start = 0.0;\n\t\tlast_bdpush = 0.0;\n\t}\n\n\t/* since we've flushed it, we might as well avoid -input_skip */\n\tif (flush1 || flush2) {\n\t\tgot_keyboard_input = 0;\n\t\tgot_pointer_input = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "repeat_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2461-2470",
    "snippet": "static int repeat_check(double last_key_scroll) {\n\tint repeating;\n\tdouble rate = typing_rate(0.0, &repeating);\n\tdouble now = dnow(), delay = 0.5;\n\tif (rate > 2.0 && repeating && now > last_key_scroll + delay) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int repeat_check(double last_key_scroll);",
      "void batch_push(int ncr, double delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typing_rate",
          "args": [
            "0.0",
            "&repeating"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "typing_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2974-3021",
          "snippet": "double typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define KEY_HIST 256"
          ],
          "globals_used": [
            "double typing_rate(double time_window, int *repeating);",
            "static int key_history_idx = -1;",
            "static keyevent_t key_history[KEY_HIST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define KEY_HIST 256\n\ndouble typing_rate(double time_window, int *repeating);\nstatic int key_history_idx = -1;\nstatic keyevent_t key_history[KEY_HIST];\n\ndouble typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int repeat_check(double last_key_scroll);\nvoid batch_push(int ncr, double delay);\n\nstatic int repeat_check(double last_key_scroll) {\n\tint repeating;\n\tdouble rate = typing_rate(0.0, &repeating);\n\tdouble now = dnow(), delay = 0.5;\n\tif (rate > 2.0 && repeating && now > last_key_scroll + delay) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "set_xdamage_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2441-2459",
    "snippet": "void set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "region"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "xdamage_scheduled_mark_region",
            "region"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + w"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_for_xdamage",
          "args": [
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "mark_for_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2409-2425",
          "snippet": "void mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}"
  },
  {
    "function_name": "mark_region_for_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2427-2439",
    "snippet": "void mark_region_for_xdamage(sraRegionPtr region) {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\titer = sraRgnGetIterator(region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x1 = rect.x1;\n\t\tint y1 = rect.y1;\n\t\tint x2 = rect.x2;\n\t\tint y2 = rect.y2;\n\t\tmark_for_xdamage(x1, y1, x2 - x1, y2 - y1);\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_region_for_xdamage(sraRegionPtr region);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_for_xdamage",
          "args": [
            "x1",
            "y1",
            "x2 - x1",
            "y2 - y1"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "mark_for_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2409-2425",
          "snippet": "void mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "region"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\n\nvoid mark_region_for_xdamage(sraRegionPtr region) {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\titer = sraRgnGetIterator(region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x1 = rect.x1;\n\t\tint y1 = rect.y1;\n\t\tint x2 = rect.x2;\n\t\tint y2 = rect.y2;\n\t\tmark_for_xdamage(x1, y1, x2 - x1, y2 - y1);\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
  },
  {
    "function_name": "mark_for_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2409-2425",
    "snippet": "void mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_region_xdamage",
          "args": [
            "tmpregion"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "add_region_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "191-210",
          "snippet": "void add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "void add_region_xdamage(sraRegionPtr new_region);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nvoid add_region_xdamage(sraRegionPtr new_region);\n\nvoid add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y + h",
            "dpy_y+1"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}"
  },
  {
    "function_name": "set_bdpush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2383-2407",
    "snippet": "static void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_bdpush(int type, double *last_bdpush, int *pushit);",
      "static double scr_key_bdpush_time, scr_mouse_bdpush_time;",
      "void batch_push(int ncr, double delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&now"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit);\nstatic double scr_key_bdpush_time, scr_mouse_bdpush_time;\nvoid batch_push(int ncr, double delay);\n\nstatic void set_bdpush(int type, double *last_bdpush, int *pushit) {\n\tdouble now, delay = 0.0;\n\tint link, latency, netrate;\n\n\t*pushit = 0;\n\n\tif (type == SCR_MOUSE) {\n\t\tdelay = scr_mouse_bdpush_time;\n\t} else if (type == SCR_KEY) {\n\t\tdelay = scr_key_bdpush_time;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\tif (link == LR_DIALUP) {\n\t\tdelay *= 1.5;\n\t} else if (link == LR_BROADBAND) {\n\t\tdelay *= 1.25;\n\t}\n\n\tdtime0(&now);\n\tif (delay > 0.0 && now > *last_bdpush + delay) {\n\t\t*pushit = 1;\n\t\t*last_bdpush = now;\n\t}\n}"
  },
  {
    "function_name": "eat_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2367-2381",
    "snippet": "static int eat_pointer(int max_ptr_eat, int keep) {\n\tint i, count = 0,  gp = got_pointer_input;\n\n\tfor (i=0; i<max_ptr_eat; i++) {\n\t\trfbCFD(0);\n\t\tif (got_pointer_input > gp)  {\n\t\t\tcount++;\nif (0) fprintf(stderr, \"GP*-%d\\n\", i);\n\t\t\tgp = got_pointer_input;\n\t\t} else if (i > keep) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void eat_viewonly_input(int max_eat, int keep);",
      "int fb_update_sent(int *count);",
      "static int eat_pointer(int max_ptr_eat, int keep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"GP*-%d\\n\"",
            "i"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid eat_viewonly_input(int max_eat, int keep);\nint fb_update_sent(int *count);\nstatic int eat_pointer(int max_ptr_eat, int keep);\n\nstatic int eat_pointer(int max_ptr_eat, int keep) {\n\tint i, count = 0,  gp = got_pointer_input;\n\n\tfor (i=0; i<max_ptr_eat; i++) {\n\t\trfbCFD(0);\n\t\tif (got_pointer_input > gp)  {\n\t\t\tcount++;\nif (0) fprintf(stderr, \"GP*-%d\\n\", i);\n\t\t\tgp = got_pointer_input;\n\t\t} else if (i > keep) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "eat_viewonly_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2341-2365",
    "snippet": "void eat_viewonly_input(int max_eat, int keep) {\n\tint i, gp, gk;\n\t\n\tfor (i=0; i<max_eat; i++) {\n\t\tint cont = 0;\n\t\tgp = got_pointer_calls;\n\t\tgk = got_keyboard_calls;\n\t\trfbCFD(0);\n\t\tif (got_pointer_calls > gp)  {\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"eat_viewonly_input: pointer: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (got_keyboard_calls > gk)  {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"eat_viewonly_input: keyboard: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (i >= keep - 1 && ! cont) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void eat_viewonly_input(int max_eat, int keep);",
      "static int eat_pointer(int max_ptr_eat, int keep);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"eat_viewonly_input: keyboard: %d\\n\"",
            "i"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"eat_viewonly_input: pointer: %d\\n\"",
            "i"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid eat_viewonly_input(int max_eat, int keep);\nstatic int eat_pointer(int max_ptr_eat, int keep);\n\nvoid eat_viewonly_input(int max_eat, int keep) {\n\tint i, gp, gk;\n\t\n\tfor (i=0; i<max_eat; i++) {\n\t\tint cont = 0;\n\t\tgp = got_pointer_calls;\n\t\tgk = got_keyboard_calls;\n\t\trfbCFD(0);\n\t\tif (got_pointer_calls > gp)  {\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"eat_viewonly_input: pointer: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (got_keyboard_calls > gk)  {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"eat_viewonly_input: keyboard: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (i >= keep - 1 && ! cont) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "scrollability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2270-2339",
    "snippet": "static int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SCR_RESULTS_MAX 256"
    ],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int lookup_win_index(Window);",
      "static int scrollability(Window win, int set);",
      "static scroll_result_t scroll_results[SCR_RESULTS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_RESULTS_MAX 256\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic scroll_result_t scroll_results[SCR_RESULTS_MAX];\n\nstatic int scrollability(Window win, int set) {\n\tdouble oldest = -1.0;\n\tint i, index = -1, next_index = -1;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tscroll_results[i].win = None;\n\t\t\tscroll_results[i].time = 0.0;\n\t\t\tscroll_results[i].result = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (set == SCR_NONE) {\n\t\t/* lookup case */\n\t\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\t\tif (win == scroll_results[i].win) {\n\t\t\t\treturn scroll_results[i].result;\n\t\t\t}\n\t\t\tif (scroll_results[i].win == None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<SCR_RESULTS_MAX; i++) {\n\t\tif (oldest == -1.0 || scroll_results[i].time < oldest) {\n\t\t\tnext_index = i;\n\t\t\toldest = scroll_results[i].time;\n\t\t}\n\t\tif (win == scroll_results[i].win) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_index >= 0 && scroll_results[i].win == None) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set == SCR_SUCCESS) {\n\t\tset = 1;\n\t} else if (set == SCR_FAIL) {\n\t\tset = -1;\n\t} else {\n\t\tset = 0;\n\t}\n\tif (index == -1) {\n\t\tscroll_results[next_index].win = win;\n\t\tscroll_results[next_index].time = dnow();\n\t\tscroll_results[next_index].result = set;\n\t} else {\n\t\tif (scroll_results[index].result == 1) {\n\t\t\t/*\n\t\t\t * once a success, always a success, until they\n\t\t\t * forget about us...\n\t\t\t */\n\t\t\tset = 1;\n\t\t} else {\n\t\t\tscroll_results[index].result = set;\n\t\t}\n\t\tscroll_results[index].time = dnow();\n\t}\n\n\treturn set;\n}"
  },
  {
    "function_name": "crfix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2245-2259",
    "snippet": "static int crfix(int x, int dx, int Lx) {\n\t/* adjust x so that copy source is on screen */\n\tif (dx > 0) {\n\t\tif (x-dx < 0) {\n\t\t\t/* off on the left */\n\t\t\tx = dx;\t\n\t\t}\n\t} else {\n\t\tif (x-dx >= Lx) {\n\t\t\t/* off on the right */\n\t\t\tx = Lx + dx - 1;\n\t\t}\n\t}\n\treturn x;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int crfix(int x, int dx, int Lx);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int crfix(int x, int dx, int Lx);\n\nstatic int crfix(int x, int dx, int Lx) {\n\t/* adjust x so that copy source is on screen */\n\tif (dx > 0) {\n\t\tif (x-dx < 0) {\n\t\t\t/* off on the left */\n\t\t\tx = dx;\t\n\t\t}\n\t} else {\n\t\tif (x-dx >= Lx) {\n\t\t\t/* off on the right */\n\t\t\tx = Lx + dx - 1;\n\t\t}\n\t}\n\treturn x;\n}"
  },
  {
    "function_name": "fb_push_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2207-2240",
    "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fb_push(void);",
      "int fb_push_wait(double max_wait, int flags);",
      "static void check_user_input2(double dt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_client_regions",
          "args": [
            "&req",
            "&mod",
            "&cpy",
            "&ncli"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1833-1853",
          "snippet": "static void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
  },
  {
    "function_name": "fb_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2170-2205",
    "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fb_push(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\"",
            "req0",
            "req1",
            "mod0",
            "mod1",
            "cpy0",
            "cpy1",
            "dnowx()"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_client_regions",
          "args": [
            "&req1",
            "&mod1",
            "&cpy1",
            "&ncli"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1833-1853",
          "snippet": "static void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** fb_push ublen NOT ZERO: %d\\n\"",
            "cl->ublen"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** fb_push ublen not zero: %d\\n\"",
            "cl->ublen"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*** rfbSendFramebufferUpdate *FAILED* #1\\n\""
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendFramebufferUpdate",
          "args": [
            "cl",
            "cl->modifiedRegion"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FB_UPDATE_PENDING",
          "args": [
            "cl"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
  },
  {
    "function_name": "batch_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2160-2168",
    "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fb_push(void);",
      "int batch_dxs[], batch_dys[];",
      "sraRegionPtr batch_reg[];",
      "void batch_push(int ncr, double delay);",
      "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
      "sraRegionPtr batch_reg[NBATCHMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "batch_reg[k]"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_copyregion",
          "args": [
            "batch_reg",
            "batch_dxs",
            "batch_dys",
            "nreg",
            "delay"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "batch_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2043-2158",
          "snippet": "void batch_copyregion(sraRegionPtr* region, int *dx, int *dy, int ncr, double delay)  {\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\tint k, direct, mode, nrects = 0, bad = 0;\n\tdouble t1, t2, start = dnow();\n\n\tfor (k=0; k < ncr; k++) {\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\n\t\titer = sraRgnGetIterator(region[k]);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\tint x1 = rect.x1;\n\t\t\tint y1 = rect.y1;\n\t\t\tint x2 = rect.x2;\n\t\t\tint y2 = rect.y2;\n\t\t\tint ym = dpy_y * (ncache+1);\n\t\t\tint xm = dpy_x;\n\t\t\tif (x1 > xm || y1 > ym || x2 > xm || y2 > ym) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tnrects += sraRgnCountRects(region[k]);\n\t}\n\tif (bad || nrects == 0) {\n\t\treturn;\n\t}\n\n\tif (delay < 0.0) {\n\t\tdelay = 0.1;\n\t}\n\tif (!fb_push_wait(delay, FB_COPY|FB_MOD)) {\n\t\tif (use_threads) usleep(100 * 1000);\n\t\tfb_push_wait(0.75, FB_COPY|FB_MOD);\n\t}\n\n\tt1 = dnow();\n\n\tbad = 0;\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (cl->ublen != 0) {\n\t\t\tfprintf(stderr, \"batch_copyregion: *** BAD ublen != 0: %d\\n\", cl->ublen);\n\t\t\tbad++;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (bad) {\n\t\treturn;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\trfbFramebufferUpdateMsg *fu;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tfu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n\t\tfu->nRects = Swap16IfLE((uint16_t)(nrects));\n\t\tfu->type = rfbFramebufferUpdate;\n\n\t\tif (cl->ublen != 0) fprintf(stderr, \"batch_copyregion: *** BAD-2 ublen != 0: %d\\n\", cl->ublen);\n\n\t\tcl->ublen = sz_rfbFramebufferUpdateMsg;\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (rfb_fb == main_fb && !rotating) {\n\t\tdirect = 0;\n\t\tmode = DCR_FBOnly;\n\t} else {\n\t\tdirect = 1;\n\t\tmode = DCR_Direct;\n\t}\n\tfor (k=0; k < ncr; k++) {\n\t\tdo_copyregion(region[k], dx[k], dy[k], mode);\n\t}\n\n\tt2 = dnow();\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (!direct)  {\n\t\t\tfor (k=0; k < ncr; k++) {\n\t\t\t\trfbSendCopyRegion(cl, region[k], dx[k], dy[k]);\n\t\t\t}\n\t\t}\n\t\trfbSendUpdateBuf(cl);\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tlast_copyrect = dnow();\n\nif (0) fprintf(stderr, \"batch_copyregion: nrects: %d nregions: %d  tot=%.4f t10=%.4f t21=%.4f t32=%.4f  %.4f\\n\",\n    nrects, ncr, last_copyrect - start, t1 - start, t2 - t1, last_copyrect - t2, dnowx());\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "void batch_push(int ncr, double delay);",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nvoid batch_push(int ncr, double delay);\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid batch_copyregion(sraRegionPtr* region, int *dx, int *dy, int ncr, double delay)  {\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\tint k, direct, mode, nrects = 0, bad = 0;\n\tdouble t1, t2, start = dnow();\n\n\tfor (k=0; k < ncr; k++) {\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\n\t\titer = sraRgnGetIterator(region[k]);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\tint x1 = rect.x1;\n\t\t\tint y1 = rect.y1;\n\t\t\tint x2 = rect.x2;\n\t\t\tint y2 = rect.y2;\n\t\t\tint ym = dpy_y * (ncache+1);\n\t\t\tint xm = dpy_x;\n\t\t\tif (x1 > xm || y1 > ym || x2 > xm || y2 > ym) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tnrects += sraRgnCountRects(region[k]);\n\t}\n\tif (bad || nrects == 0) {\n\t\treturn;\n\t}\n\n\tif (delay < 0.0) {\n\t\tdelay = 0.1;\n\t}\n\tif (!fb_push_wait(delay, FB_COPY|FB_MOD)) {\n\t\tif (use_threads) usleep(100 * 1000);\n\t\tfb_push_wait(0.75, FB_COPY|FB_MOD);\n\t}\n\n\tt1 = dnow();\n\n\tbad = 0;\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (cl->ublen != 0) {\n\t\t\tfprintf(stderr, \"batch_copyregion: *** BAD ublen != 0: %d\\n\", cl->ublen);\n\t\t\tbad++;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (bad) {\n\t\treturn;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\trfbFramebufferUpdateMsg *fu;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tfu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n\t\tfu->nRects = Swap16IfLE((uint16_t)(nrects));\n\t\tfu->type = rfbFramebufferUpdate;\n\n\t\tif (cl->ublen != 0) fprintf(stderr, \"batch_copyregion: *** BAD-2 ublen != 0: %d\\n\", cl->ublen);\n\n\t\tcl->ublen = sz_rfbFramebufferUpdateMsg;\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (rfb_fb == main_fb && !rotating) {\n\t\tdirect = 0;\n\t\tmode = DCR_FBOnly;\n\t} else {\n\t\tdirect = 1;\n\t\tmode = DCR_Direct;\n\t}\n\tfor (k=0; k < ncr; k++) {\n\t\tdo_copyregion(region[k], dx[k], dy[k], mode);\n\t}\n\n\tt2 = dnow();\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (!direct)  {\n\t\t\tfor (k=0; k < ncr; k++) {\n\t\t\t\trfbSendCopyRegion(cl, region[k], dx[k], dy[k]);\n\t\t\t}\n\t\t}\n\t\trfbSendUpdateBuf(cl);\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tlast_copyrect = dnow();\n\nif (0) fprintf(stderr, \"batch_copyregion: nrects: %d nregions: %d  tot=%.4f t10=%.4f t21=%.4f t32=%.4f  %.4f\\n\",\n    nrects, ncr, last_copyrect - start, t1 - start, t2 - t1, last_copyrect - t2, dnowx());\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
  },
  {
    "function_name": "batch_copyregion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "2043-2158",
    "snippet": "void batch_copyregion(sraRegionPtr* region, int *dx, int *dy, int ncr, double delay)  {\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\tint k, direct, mode, nrects = 0, bad = 0;\n\tdouble t1, t2, start = dnow();\n\n\tfor (k=0; k < ncr; k++) {\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\n\t\titer = sraRgnGetIterator(region[k]);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\tint x1 = rect.x1;\n\t\t\tint y1 = rect.y1;\n\t\t\tint x2 = rect.x2;\n\t\t\tint y2 = rect.y2;\n\t\t\tint ym = dpy_y * (ncache+1);\n\t\t\tint xm = dpy_x;\n\t\t\tif (x1 > xm || y1 > ym || x2 > xm || y2 > ym) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tnrects += sraRgnCountRects(region[k]);\n\t}\n\tif (bad || nrects == 0) {\n\t\treturn;\n\t}\n\n\tif (delay < 0.0) {\n\t\tdelay = 0.1;\n\t}\n\tif (!fb_push_wait(delay, FB_COPY|FB_MOD)) {\n\t\tif (use_threads) usleep(100 * 1000);\n\t\tfb_push_wait(0.75, FB_COPY|FB_MOD);\n\t}\n\n\tt1 = dnow();\n\n\tbad = 0;\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (cl->ublen != 0) {\n\t\t\tfprintf(stderr, \"batch_copyregion: *** BAD ublen != 0: %d\\n\", cl->ublen);\n\t\t\tbad++;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (bad) {\n\t\treturn;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\trfbFramebufferUpdateMsg *fu;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tfu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n\t\tfu->nRects = Swap16IfLE((uint16_t)(nrects));\n\t\tfu->type = rfbFramebufferUpdate;\n\n\t\tif (cl->ublen != 0) fprintf(stderr, \"batch_copyregion: *** BAD-2 ublen != 0: %d\\n\", cl->ublen);\n\n\t\tcl->ublen = sz_rfbFramebufferUpdateMsg;\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (rfb_fb == main_fb && !rotating) {\n\t\tdirect = 0;\n\t\tmode = DCR_FBOnly;\n\t} else {\n\t\tdirect = 1;\n\t\tmode = DCR_Direct;\n\t}\n\tfor (k=0; k < ncr; k++) {\n\t\tdo_copyregion(region[k], dx[k], dy[k], mode);\n\t}\n\n\tt2 = dnow();\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (!direct)  {\n\t\t\tfor (k=0; k < ncr; k++) {\n\t\t\t\trfbSendCopyRegion(cl, region[k], dx[k], dy[k]);\n\t\t\t}\n\t\t}\n\t\trfbSendUpdateBuf(cl);\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tlast_copyrect = dnow();\n\nif (0) fprintf(stderr, \"batch_copyregion: nrects: %d nregions: %d  tot=%.4f t10=%.4f t21=%.4f t32=%.4f  %.4f\\n\",\n    nrects, ncr, last_copyrect - start, t1 - start, t2 - t1, last_copyrect - t2, dnowx());\n\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "void batch_push(int ncr, double delay);",
      "int DCR_FBOnly = 1;",
      "int DCR_Direct = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"batch_copyregion: nrects: %d nregions: %d  tot=%.4f t10=%.4f t21=%.4f t32=%.4f  %.4f\\n\"",
            "nrects",
            "ncr",
            "last_copyrect - start",
            "t1 - start",
            "t2 - t1",
            "last_copyrect - t2",
            "dnowx()"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendUpdateBuf",
          "args": [
            "cl"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendCopyRegion",
          "args": [
            "cl",
            "region[k]",
            "dx[k]",
            "dy[k]"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "region[k]",
            "dx[k]",
            "dy[k]",
            "mode"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"batch_copyregion: *** BAD-2 ublen != 0: %d\\n\"",
            "cl->ublen"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap16IfLE",
          "args": [
            "(uint16_t)(nrects)"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"batch_copyregion: *** BAD ublen != 0: %d\\n\"",
            "cl->ublen"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.75",
            "FB_COPY|FB_MOD"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "region[k]"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\"",
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\"",
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "region[k]"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nvoid batch_push(int ncr, double delay);\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid batch_copyregion(sraRegionPtr* region, int *dx, int *dy, int ncr, double delay)  {\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\tint k, direct, mode, nrects = 0, bad = 0;\n\tdouble t1, t2, start = dnow();\n\n\tfor (k=0; k < ncr; k++) {\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\n\t\titer = sraRgnGetIterator(region[k]);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\tint x1 = rect.x1;\n\t\t\tint y1 = rect.y1;\n\t\t\tint x2 = rect.x2;\n\t\t\tint y2 = rect.y2;\n\t\t\tint ym = dpy_y * (ncache+1);\n\t\t\tint xm = dpy_x;\n\t\t\tif (x1 > xm || y1 > ym || x2 > xm || y2 > ym) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) {\n\t\t\t\tif (ncdb) fprintf(stderr, \"batch_copyregion: BAD RECTANGLE: %d,%d %d,%d\\n\", x1, y1, x2, y2);\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t\tnrects += sraRgnCountRects(region[k]);\n\t}\n\tif (bad || nrects == 0) {\n\t\treturn;\n\t}\n\n\tif (delay < 0.0) {\n\t\tdelay = 0.1;\n\t}\n\tif (!fb_push_wait(delay, FB_COPY|FB_MOD)) {\n\t\tif (use_threads) usleep(100 * 1000);\n\t\tfb_push_wait(0.75, FB_COPY|FB_MOD);\n\t}\n\n\tt1 = dnow();\n\n\tbad = 0;\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (cl->ublen != 0) {\n\t\t\tfprintf(stderr, \"batch_copyregion: *** BAD ublen != 0: %d\\n\", cl->ublen);\n\t\t\tbad++;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (bad) {\n\t\treturn;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\trfbFramebufferUpdateMsg *fu;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tfu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n\t\tfu->nRects = Swap16IfLE((uint16_t)(nrects));\n\t\tfu->type = rfbFramebufferUpdate;\n\n\t\tif (cl->ublen != 0) fprintf(stderr, \"batch_copyregion: *** BAD-2 ublen != 0: %d\\n\", cl->ublen);\n\n\t\tcl->ublen = sz_rfbFramebufferUpdateMsg;\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tif (rfb_fb == main_fb && !rotating) {\n\t\tdirect = 0;\n\t\tmode = DCR_FBOnly;\n\t} else {\n\t\tdirect = 1;\n\t\tmode = DCR_Direct;\n\t}\n\tfor (k=0; k < ncr; k++) {\n\t\tdo_copyregion(region[k], dx[k], dy[k], mode);\n\t}\n\n\tt2 = dnow();\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (!direct)  {\n\t\t\tfor (k=0; k < ncr; k++) {\n\t\t\t\trfbSendCopyRegion(cl, region[k], dx[k], dy[k]);\n\t\t\t}\n\t\t}\n\t\trfbSendUpdateBuf(cl);\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\n\tlast_copyrect = dnow();\n\nif (0) fprintf(stderr, \"batch_copyregion: nrects: %d nregions: %d  tot=%.4f t10=%.4f t21=%.4f t32=%.4f  %.4f\\n\",\n    nrects, ncr, last_copyrect - start, t1 - start, t2 - t1, last_copyrect - t2, dnowx());\n\n}"
  },
  {
    "function_name": "do_copyregion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1864-2041",
    "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "int DCR_Normal = 0;",
      "int DCR_FBOnly = 1;",
      "int DCR_Direct = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDoCopyRect",
          "args": [
            "screen",
            "sx1",
            "sy1",
            "sx2",
            "sy2",
            "sdx",
            "sdy"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendCopyRegion",
          "args": [
            "cl",
            "r",
            "sdx",
            "sdy"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "sx1",
            "sy1",
            "sx2",
            "sy2"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sb.. %d %d %d %d %d %d\\n\"",
            "sx1",
            "sy1",
            "sx2",
            "sy2",
            "sdx",
            "sdy"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rotate_coords",
          "args": [
            "sx2",
            "sy2",
            "&sx2",
            "&sy2",
            "-1",
            "-1"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_coords_inverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1388-1434",
          "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
            "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sa.. %d %d %d %d %d %d\\n\"",
            "sx1",
            "sy1",
            "sx2",
            "sy2",
            "sdx",
            "sdy"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst",
            "src",
            "w"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst",
            "src",
            "w"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"copyrect: cmap8to24_fb: mode=%d\\n\"",
            "mode"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetReverseIterator",
          "args": [
            "region",
            "dx < 0",
            "dy < 0"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\"",
            "req",
            "mod",
            "cpy"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_client_regions",
          "args": [
            "&req",
            "&mod",
            "&cpy",
            "&ncli"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1833-1853",
          "snippet": "static void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDoCopyRegion",
          "args": [
            "screen",
            "region",
            "dx",
            "dy"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\"",
            "req",
            "mod",
            "cpy"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
  },
  {
    "function_name": "get_client_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1833-1853",
    "snippet": "static void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void get_client_regions(int *req, int *mod, int *cpy, int *num) ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "i"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->copyRegion"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "i"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num) ;\n\nstatic void get_client_regions(int *req, int *mod, int *cpy, int *num)  {\n\t\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\t*req = 0;\n\t*mod = 0;\n\t*cpy = 0;\n\t*num = 0;\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t*req += sraRgnCountRects(cl->requestedRegion);\n\t\t*mod += sraRgnCountRects(cl->modifiedRegion);\n\t\t*cpy += sraRgnCountRects(cl->copyRegion);\n\t\t*num += 1;\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n}"
  },
  {
    "function_name": "push_scr_ev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1429-1831",
    "snippet": "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int last_scroll_type = SCR_NONE;",
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void fb_push(void);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void mark_region_for_xdamage(sraRegionPtr region);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int lookup_win_index(Window);",
      "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
      "static int set_ypad(void);",
      "static int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);",
      "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
      "static void check_user_input2(double dt);",
      "void batch_push(int ncr, double delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "whole"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "backfill"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_mark",
          "args": [
            "x0",
            "y0",
            "x0 + w0",
            "y0 + h0",
            "1"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "scale_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1408-1415",
          "snippet": "static void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\n\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "typing_rate",
          "args": [
            "0.0",
            "&repeating"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "typing_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2974-3021",
          "snippet": "double typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define KEY_HIST 256"
          ],
          "globals_used": [
            "double typing_rate(double time_window, int *repeating);",
            "static int key_history_idx = -1;",
            "static keyevent_t key_history[KEY_HIST];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define KEY_HIST 256\n\ndouble typing_rate(double time_window, int *repeating);\nstatic int key_history_idx = -1;\nstatic keyevent_t key_history[KEY_HIST];\n\ndouble typing_rate(double time_window, int *repeating) {\n\tdouble dt = 1.0, now = dnow();\n\tKeySym key = NoSymbol;\n\tint i, idx, cnt = 0, repeat_keys = 0;\n\n\tif (key_history_idx == -1) {\n\t\tif (repeating) {\n\t\t\t*repeating = 0;\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif (time_window > 0.0) {\n\t\tdt = time_window;\n\t}\n\tfor (i=0; i<KEY_HIST; i++) {\n\t\tidx = key_history_idx - i;\n\t\tif (idx < 0) {\n\t\t\tidx += KEY_HIST;\n\t\t}\n\t\tif (! key_history[idx].down) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (now > key_history[idx].time + dt) {\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\t\tif (key == NoSymbol) {\n\t\t\tkey = key_history[idx].sym;\n\t\t\trepeat_keys = 1;\n\t\t} else if (key == key_history[idx].sym) {\n\t\t\trepeat_keys++;\n\t\t}\n\t}\n\n\tif (repeating) {\n\t\tif (repeat_keys >= 2) {\n\t\t\t*repeating = repeat_keys;\n\t\t} else {\n\t\t\t*repeating = 0;\n\t\t}\n\t}\n\n\t/*\n\t * n.b. keyrate could seem very high with libvncserver buffering them\n\t * so avoid using small dt.\n\t */\n\treturn ((double) cnt)/dt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&lat",
            "&rate"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  fb_push dt: %.4f\"",
            "dt"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_bdpush",
          "args": [
            "xrecord_wm_window",
            "x",
            "y",
            "w",
            "h",
            "bdx",
            "bdy",
            "bdskinny"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "do_bdpush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1182-1294",
          "snippet": "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny) {\n\n\tXWindowAttributes attr;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tsraRegionPtr frame, whole, tmpregion;\n\tint tx1, ty1, tx2, ty2;\n\tstatic Window last_wm_win = None;\n\tstatic int last_x, last_y, last_w, last_h;\n\tint do_fb_push = 0;\n\tint db = debug_scroll;\n\n\tif (wm_win == last_wm_win) {\n\t\tattr.x = last_x;\n\t\tattr.y = last_y;\n\t\tattr.width = last_w;\n\t\tattr.height = last_h;\n\t} else {\n\t\tif (!valid_window(wm_win, &attr, 1)) {\n\t\t\treturn do_fb_push;\n\t\t}\n\t\tlast_wm_win = wm_win;\n\t\tlast_x = attr.x;\n\t\tlast_y = attr.y;\n\t\tlast_w = attr.width;\n\t\tlast_h = attr.height;\n\t}\nif (db > 1) fprintf(stderr, \"BDP  %d %d %d %d  %d %d %d  %d %d %d %d\\n\",\n\tx0, y0, w0, h0, bdx, bdy, bdskinny, last_x, last_y, last_w, last_h);\n\n\t/* wm frame: */\n\ttx1 = attr.x;\n\tty1 = attr.y;\n\ttx2 = attr.x + attr.width;\n\tty2 = attr.y + attr.height;\n\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\tframe = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tsraRgnAnd(frame, whole);\n\n\t/* scrolling window: */\n\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\tsraRgnAnd(tmpregion, whole);\n\n\tsraRgnSubtract(frame, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\n\tif (!sraRgnEmpty(frame)) {\n\t\tdouble dt = 0.0, dm;\n\t\tdtime0(&dm);\n\t\titer = sraRgnGetIterator(frame);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tif (bdskinny > 0) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (nabs(ty2-ty1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (nabs(tx2-tx1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (! ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bdx >= 0) {\n\t\t\t\tif (bdx < tx1 || tx2 <= bdx) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bdy >= 0) {\n\t\t\t\tif (bdy < ty1 || ty2 <= bdy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\ttx1 -= coff_x;\n\t\t\t\tty1 -= coff_y;\n\t\t\t\ttx2 -= coff_x;\n\t\t\t\tty2 -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\ttx1 -= off_x;\n\t\t\t\tty1 -= off_y;\n\t\t\t\ttx2 -= off_x;\n\t\t\t\tty2 -= off_y;\n\t\t\t}\n\n\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\n\t\t\tdo_fb_push++;\n\t\t\tdt += dtime(&dm);\nif (db > 1) fprintf(stderr, \"  BDP(%d,%d-%d,%d)  dt: %.4f\\n\", tx1, ty1, tx2, ty2, dt);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t}\n\tsraRgnDestroy(whole);\n\tsraRgnDestroy(frame);\n\n\treturn do_fb_push;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int lookup_win_index(Window);",
            "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic void check_user_input2(double dt);\n\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny) {\n\n\tXWindowAttributes attr;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tsraRegionPtr frame, whole, tmpregion;\n\tint tx1, ty1, tx2, ty2;\n\tstatic Window last_wm_win = None;\n\tstatic int last_x, last_y, last_w, last_h;\n\tint do_fb_push = 0;\n\tint db = debug_scroll;\n\n\tif (wm_win == last_wm_win) {\n\t\tattr.x = last_x;\n\t\tattr.y = last_y;\n\t\tattr.width = last_w;\n\t\tattr.height = last_h;\n\t} else {\n\t\tif (!valid_window(wm_win, &attr, 1)) {\n\t\t\treturn do_fb_push;\n\t\t}\n\t\tlast_wm_win = wm_win;\n\t\tlast_x = attr.x;\n\t\tlast_y = attr.y;\n\t\tlast_w = attr.width;\n\t\tlast_h = attr.height;\n\t}\nif (db > 1) fprintf(stderr, \"BDP  %d %d %d %d  %d %d %d  %d %d %d %d\\n\",\n\tx0, y0, w0, h0, bdx, bdy, bdskinny, last_x, last_y, last_w, last_h);\n\n\t/* wm frame: */\n\ttx1 = attr.x;\n\tty1 = attr.y;\n\ttx2 = attr.x + attr.width;\n\tty2 = attr.y + attr.height;\n\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\tframe = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tsraRgnAnd(frame, whole);\n\n\t/* scrolling window: */\n\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\tsraRgnAnd(tmpregion, whole);\n\n\tsraRgnSubtract(frame, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\n\tif (!sraRgnEmpty(frame)) {\n\t\tdouble dt = 0.0, dm;\n\t\tdtime0(&dm);\n\t\titer = sraRgnGetIterator(frame);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tif (bdskinny > 0) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (nabs(ty2-ty1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (nabs(tx2-tx1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (! ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bdx >= 0) {\n\t\t\t\tif (bdx < tx1 || tx2 <= bdx) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bdy >= 0) {\n\t\t\t\tif (bdy < ty1 || ty2 <= bdy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\ttx1 -= coff_x;\n\t\t\t\tty1 -= coff_y;\n\t\t\t\ttx2 -= coff_x;\n\t\t\t\tty2 -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\ttx1 -= off_x;\n\t\t\t\tty1 -= off_y;\n\t\t\t\ttx2 -= off_x;\n\t\t\t\tty2 -= off_y;\n\t\t\t}\n\n\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\n\t\t\tdo_fb_push++;\n\t\t\tdt += dtime(&dm);\nif (db > 1) fprintf(stderr, \"  BDP(%d,%d-%d,%d)  dt: %.4f\\n\", tx1, ty1, tx2, ty2, dt);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t}\n\tsraRgnDestroy(whole);\n\tsraRgnDestroy(frame);\n\n\treturn do_fb_push;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BDPUSH-TIME:  0x%lx\\n\"",
            "xrecord_wm_window"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" ---- dret=%d\"",
            "dret"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" **** dret=%d\"",
            "dret"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  dfc---- dt: %.4f\"",
            "dt"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUSH_TEST",
          "args": [
            "0"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "direct_fb_copy",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "1"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "direct_fb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1066-1180",
          "snippet": "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static int scrollability(Window win, int set);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  DFC(%d,%d-%d,%d)\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "ty2",
            "dpy_y+1"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "backfill"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  EST_TOO_LARGE\""
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  AREA_TOO_MUCH\""
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  area %.1f win_area %.1f est: %.4f\"",
            "area",
            "win_area",
            "est"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "backfill"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "tmpregion"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "backfill",
            "tmpregion"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmpregion",
            "whole"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x0",
            "y0",
            "x0 + w0",
            "y0 + h0"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "backfill",
            "tmpregion"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmpregion",
            "whole"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "nx",
            "ny",
            "nx + nw",
            "ny + nh"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "backfill",
            "whole"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "backfill",
            "dx",
            "dy"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  try_copyrect dt: %.4f\\n\"",
            "dt"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUSH_TEST",
          "args": [
            "0"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_copyrect",
          "args": [
            "frame",
            "frame",
            "x",
            "y",
            "w",
            "h",
            "dx",
            "dy",
            "&obscured",
            "tmpregion",
            "waittime",
            "NULL"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "try_copyrect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3138-3469",
          "snippet": "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "static int scrollability(Window win, int set);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "static void check_user_input2(double dt);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int scrollability(Window win, int set);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch) {\n\n\tstatic int dt_bad = 0;\n\tstatic time_t dt_bad_check = 0;\n\tint x1, y1, x2, y2, sent_copyrect = 0;\n\tint req, mod, cpy, ncli;\n\tdouble tm, dt;\n\tDB_SET\n\n\tif (nbatch == NULL) {\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (cpy) {\n\t\t\t/* one is still pending... try to force it out: */\n\t\t\tif (!fb_push_wait(max_wait, FB_COPY)) {\n\t\t\t\tfb_push_wait(max_wait/2, FB_COPY);\n\t\t\t}\n\n\t\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\t}\n\t\tif (cpy) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*obscured = 0;\n\t/*\n\t * XXX KDE and xfce do some weird things with the \n\t * stacking, it does not match XQueryTree.  Work around\n\t * it for now by CopyRect-ing the *whole* on-screen \n\t * rectangle (whether obscured or not!)\n\t */\n\tif (time(NULL) > dt_bad_check + 5) {\n\t\tchar *dt = guess_desktop();\n\t\tif (!strcmp(dt, \"kde_maybe_is_ok_now...\")) {\n\t\t\tdt_bad = 1;\n\t\t} else if (!strcmp(dt, \"xfce\")) {\n\t\t\tdt_bad = 1;\n\t\t} else {\n\t\t\tdt_bad = 0;\n\t\t}\n\t\tdt_bad_check = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\tif (subwin) {\n\t\tx -= off_x;\n\t\ty -= off_y;\n\t}\nif (db2) fprintf(stderr, \"try_copyrect: 0x%lx/0x%lx  bad: %d stack_list_num: %d\\n\", orig_frame, frame, dt_bad, stack_list_num);\n\n/* XXX Y dt_bad = 0 */\n\tif (dt_bad && wireframe_in_progress) {\n\t\tsraRegionPtr rect;\n\t\t/* send the whole thing... */\n\t\tx1 = crfix(nfix(x,   dpy_x), dx, dpy_x);\n\t\ty1 = crfix(nfix(y,   dpy_y), dy, dpy_y);\n\t\tx2 = crfix(nfix(x+w, dpy_x+1), dx, dpy_x+1);\n\t\ty2 = crfix(nfix(y+h, dpy_y+1), dy, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\n\t\tif (blackouts) {\n\t\t\tint i;\n\t\t\tsraRegionPtr bo_rect;\n\t\t\tfor (i=0; i<blackouts; i++) {\n\t\t\t\tbo_rect = sraRgnCreateRect(blackr[i].x1,\n\t\t\t\t    blackr[i].y1, blackr[i].x2, blackr[i].y2);\n\t\t\t\tsraRgnSubtract(rect, bo_rect);\n\t\t\t\tsraRgnDestroy(bo_rect);\n\t\t\t}\n\t\t}\n\t\tif (!nbatch) {\n\t\t\tdo_copyregion(rect, dx, dy, 0);\n\t\t} else {\n\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(rect);\n\t\t\t(*nbatch)++;\n\t\t}\n\t\tsraRgnDestroy(rect);\n\n\t\tsent_copyrect = 1;\n\t\t*obscured = 1;\t/* set to avoid an aggressive push */\n\n\t} else if (stack_list_num || dt_bad) {\n\t\tint k, tx1, tx2, ty1, ty2;\n\t\tsraRegionPtr moved_win, tmp_win, whole;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint saw_me = 0;\n\t\tint orig_x, orig_y;\n\t\tint boff, bwin;\n\t\tXWindowAttributes attr;\n\n\t\torig_x = x - dx;\n\t\torig_y = y - dy;\n\n\t\ttx1 = nfix(orig_x,   dpy_x);\n\t\tty1 = nfix(orig_y,   dpy_y);\n\t\ttx2 = nfix(orig_x+w, dpy_x+1);\n\t\tty2 = nfix(orig_y+h, dpy_y+1);\n\nif (db2) fprintf(stderr, \"moved_win: %4d %3d, %4d %3d  0x%lx ---\\n\",\n\ttx1, ty1, tx2, ty2, frame);\n\n\t\tmoved_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\n\t\tdtime0(&tm);\n\n\t\tboff = get_boff();\n\t\tbwin = get_bwin();\n\n\t\tX_LOCK;\n\n\t\t/*\n\t\t * loop over the stack, top to bottom until we\n\t\t * find our wm frame:\n\t\t */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin;\n\n\t\t\tif (0 && dt_bad) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswin = stack_list[k].win;\nif (db2) fprintf(stderr, \"sw: %d/%lx\\n\", k, swin);\n\t\t\tif (swin == frame || swin == orig_frame) {\n if (db2) {\n saw_me = 1; fprintf(stderr, \"  ----------\\n\");\n } else {\n\t\t\t\tbreak;\t\n }\n\t\t\t}\n\n\t\t\t/* skip some unwanted cases: */\n#ifndef MACOSX\n\t\t\tif (swin == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (boff <= (int) swin && (int) swin < boff + bwin) {\n\t\t\t\t;\t/* blackouts */\n\t\t\t} else if (! stack_list[k].fetched ||\n\t\t\t    stack_list[k].time > tm + 2.0) {\n\t\t\t\tif (!valid_window(swin, &attr, 1)) {\n\t\t\t\t\tstack_list[k].valid = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack_list[k].valid = 1;\n\t\t\t\t\tstack_list[k].x = attr.x;\n\t\t\t\t\tstack_list[k].y = attr.y;\n\t\t\t\t\tstack_list[k].width = attr.width;\n\t\t\t\t\tstack_list[k].height = attr.height;\n\t\t\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\t\t\tstack_list[k].depth = attr.depth;\n\t\t\t\t\tstack_list[k].class = attr.class;\n\t\t\t\t\tstack_list[k].backing_store =\n\t\t\t\t\t    attr.backing_store;\n\t\t\t\t\tstack_list[k].map_state =\n\t\t\t\t\t    attr.map_state;\n\t\t\t\t}\n\t\t\t\tstack_list[k].fetched = 1;\n\t\t\t\tstack_list[k].time = tm;\n\t\t\t}\n\t\t\tif (!stack_list[k].valid) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattr.x      = stack_list[k].x;\n\t\t\tattr.y      = stack_list[k].y;\n\t\t\tattr.depth  = stack_list[k].depth;\n\t\t\tattr.width  = stack_list[k].width;\n\t\t\tattr.height = stack_list[k].height;\n\t\t\tattr.border_width = stack_list[k].border_width;\n\t\t\tattr.map_state = stack_list[k].map_state;\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\nif (db2) fprintf(stderr, \"sw: %d/%lx  %dx%d+%d+%d\\n\", k, swin, stack_list[k].width, stack_list[k].height, stack_list[k].x, stack_list[k].y);\n\n\t\t\tif (clipshift) {\n\t\t\t\tattr.x -= coff_x;\n\t\t\t\tattr.y -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\tattr.x -= off_x;\n\t\t\t\tattr.y -= off_y;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * first subtract any overlap from the initial\n\t\t\t * window rectangle\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x, dpy_x);\n\t\t\tty1 = nfix(attr.y, dpy_y);\n\t\t\ttx2 = nfix(attr.x + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-1: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* see if window clips us: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\nif (db2) fprintf(stderr, \"         : clips it.\\n\");\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = nfix(attr.x - dx, dpy_x);\n\t\t\tty1 = nfix(attr.y - dy, dpy_y);\n\t\t\ttx2 = nfix(attr.x - dx + attr.width,  dpy_x+1);\n\t\t\tty2 = nfix(attr.y - dy + attr.height, dpy_y+1);\n\nif (db2) fprintf(stderr, \"  tmp_win-2: %4d %3d, %4d %3d  0x%lx\\n\",\n\ttx1, ty1, tx2, ty2, swin);\nif (db2 && saw_me) continue;\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t}\n\n\t\tX_UNLOCK;\n\n\t\tif (extra_clip && ! sraRgnEmpty(extra_clip)) {\n\t\t    whole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\t\t    if (clipshift) {\n\t\t\tsraRgnOffset(extra_clip, -coff_x, -coff_y);\n\t\t    }\n\t\t    if (subwin) {\n\t\t\tsraRgnOffset(extra_clip, -off_x, -off_y);\n\t\t    }\n\n\t\t    iter = sraRgnGetIterator(extra_clip);\n\t\t    while (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t/* clip the window to the visible screen: */\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* see if window clips us: */\n\t\t\tif (sraRgnAnd(tmp_win, moved_win)) {\n\t\t\t\t*obscured = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/* subtract it from our region: */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\n\t\t\t/*\n\t\t\t * next, subtract from the initial window rectangle\n\t\t\t * anything that would clip it.\n\t\t\t */\n\t\t\ttmp_win = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\t\t\tsraRgnOffset(tmp_win, -dx, -dy);\n\n\t\t\t/* clip the window to the visible screen: */\n\t\t\tsraRgnAnd(tmp_win, whole);\n\n\t\t\t/* subtract it from our region: */\n\t\t\tsraRgnSubtract(moved_win, tmp_win);\n\t\t\tsraRgnDestroy(tmp_win);\n\t\t    }\n\t\t    sraRgnReleaseIterator(iter);\n\t\t    sraRgnDestroy(whole);\n\t\t}\n\n\t\tdt = dtime(&tm);\nif (db2) fprintf(stderr, \"  stack_work dt: %.4f\\n\", dt);\n\n\t\tif (*obscured && !strcmp(wireframe_copyrect, \"top\")) {\n\t\t\t;\t/* cannot send CopyRegion */\n\t\t} else if (! sraRgnEmpty(moved_win)) {\n\t\t\tsraRegionPtr whole, shifted_region;\n\n\t\t\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\tshifted_region = sraRgnCreateRgn(moved_win);\n\t\t\tsraRgnOffset(shifted_region, dx, dy);\n\t\t\tsraRgnAnd(shifted_region, whole);\n\n\t\t\tsraRgnDestroy(whole);\n\n\t\t\t/* now send the CopyRegion: */\n\t\t\tif (! sraRgnEmpty(shifted_region)) {\n\t\t\t\tdtime0(&tm);\n\t\t\t\tif (!nbatch) {\n\t\t\t\t\tdo_copyregion(shifted_region, dx, dy, 0);\n\t\t\t\t} else {\n\t\t\t\t\tbatch_dxs[*nbatch] = dx;\n\t\t\t\t\tbatch_dys[*nbatch] = dy;\n\t\t\t\t\tbatch_reg[*nbatch] = sraRgnCreateRgn(shifted_region);\n\t\t\t\t\t(*nbatch)++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdt = dtime(&tm);\nif (0 || db2) fprintf(stderr, \"do_copyregion: %d %d %d %d  dx: %d  dy: %d dt: %.4f\\n\",\n\ttx1, ty1, tx2, ty2, dx, dy, dt);\n\t\t\t\tsent_copyrect = 1;\n\t\t\t}\n\t\t\tsraRgnDestroy(shifted_region);\n\t\t}\n\t\tsraRgnDestroy(moved_win);\n\t}\n\treturn sent_copyrect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch_push",
          "args": [
            "nbatch",
            "delay"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "batch_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2160-2168",
          "snippet": "void batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int batch_dxs[], batch_dys[];",
            "sraRegionPtr batch_reg[];",
            "void batch_push(int ncr, double delay);",
            "int batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];",
            "sraRegionPtr batch_reg[NBATCHMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint batch_dxs[], batch_dys[];\nsraRegionPtr batch_reg[];\nvoid batch_push(int ncr, double delay);\nint batch_dxs[NBATCHMAX], batch_dys[NBATCHMAX];\nsraRegionPtr batch_reg[NBATCHMAX];\n\nvoid batch_push(int nreg, double delay) {\n\tint k;\n\tbatch_copyregion(batch_reg, batch_dxs, batch_dys, nreg, delay);\n\t/* XXX Y */\n\tfb_push();\n\tfor (k=0; k < nreg; k++) {\n\t\tsraRgnDestroy(batch_reg[k]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion2"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "tmpregion",
            "tmpregion2"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmpregion2",
            "whole"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion2"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "tmpregion",
            "tmpregion2"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmpregion2",
            "whole"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "wx",
            "wy",
            "wx+ww",
            "wy+wh"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "tmpregion",
            "off_x",
            "off_y"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "tmpregion",
            "coff_x",
            "coff_y"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "query_pointer",
          "args": [
            "rootwin"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "query_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "355-384",
          "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\"",
            "ev",
            "nx",
            "ny",
            "nw",
            "nh",
            "nw",
            "nh",
            "nx",
            "ny"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\"",
            "ev",
            "wx",
            "wy",
            "ww",
            "wh",
            "ww",
            "wh",
            "wx",
            "wy"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\"",
            "ev",
            "x",
            "y",
            "w",
            "h",
            "dx",
            "dy",
            "w",
            "h",
            "x",
            "y",
            "win"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\"",
            "w",
            "h",
            "ww",
            "wh"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: WIN RESIZE: %d %d, %d %d\"",
            "ww",
            "w0",
            "wh",
            "h0"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: WIN SHIFT: %d %d, %d %d\"",
            "wx",
            "x0",
            "wy",
            "y0"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\"",
            "win",
            "win0"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: AGE:     %.4f\\n\"",
            "ag"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\"",
            "ag",
            "dnow()",
            "servertime_diff",
            "st"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dabs",
          "args": [
            "ag"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "dabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "128-134",
          "snippet": "double dabs(double x) {\n\tif (x < 0.0) {\n\t\treturn -x;\n\t} else {\n\t\treturn x;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dabs(double x);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\n\ndouble dabs(double x) {\n\tif (x < 0.0) {\n\t\treturn -x;\n\t} else {\n\t\treturn x;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ypad: %d  dy[0]: %d ev_tot: %d\\n\"",
            "ypad",
            "scr_ev[0].dy",
            "ev_tot"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ypad",
          "args": [],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "set_ypad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1296-1406",
          "snippet": "static int set_ypad(void) {\n\tint ev, ev_tot = scr_ev_cnt;\n\tstatic Window last_win = None;\n\tstatic double last_time = 0.0;\n\tstatic int y_accum = 0, last_sign = 0;\n\tdouble now, cut = 0.1;\n\tint dy_sum = 0, ys = 0, sign;\n\tint font_size = 15;\n\tint win_y, scr_y, loc_cut = 4*font_size, y_cut = 10*font_size;\n\t\n\tif (!xrecord_set_by_keys || !xrecord_name_info) {\n\t\treturn 0;\n\t}\n\tif (xrecord_name_info[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! ev_tot) {\n\t\treturn 0;\n\t}\n\tif (xrecord_keysym == NoSymbol)  {\n\t\treturn 0;\n\t}\n\tif (!xrecord_scroll_keysym(xrecord_keysym)) {\n\t\treturn 0;\n\t}\n\tif (!scroll_term) {\n\t\treturn 0;\n\t}\n\tif (!match_str_list(xrecord_name_info, scroll_term)) {\n\t\treturn 0;\n\t}\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdy_sum += nabs(scr_ev[ev].dy);\n\t\tif (scr_ev[ev].dy < 0) {\n\t\t\tys--;\n\t\t} else if (scr_ev[ev].dy > 0) {\n\t\t\tys++;\n\t\t} else {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].win != scr_ev[0].win) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].dx != 0) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ys != ev_tot && ys != -ev_tot) {\n\t\treturn 0;\n\t}\n\tif (ys < 0) {\n\t\tsign = -1;\n\t} else {\n\t\tsign = 1;\n\t}\n\n\tif (sign > 0) {\n\t\t/*\n\t\t * this case is not as useful as scrolling near the\n\t\t * bottom of a terminal.  But there are problems for it too.\n\t\t */\n\t\treturn 0;\n\t}\n\n\twin_y = scr_ev[0].win_y + scr_ev[0].win_h;\n\tscr_y = scr_ev[0].y + scr_ev[0].h;\n\tif (nabs(scr_y - win_y) > loc_cut) {\n\t\t/* require it to be near the bottom. */\n\t\treturn 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now < last_time + cut) {\n\t\tint ok = 1;\n\t\tif (last_win && scr_ev[0].win != last_win) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (last_sign && sign != last_sign) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (! ok) {\n\t\t\tlast_win = None;\n\t\t\tlast_sign = 0;\n\t\t\ty_accum = 0;\n\t\t\tlast_time = 0.0;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tlast_win = None;\n\t\tlast_sign = 0;\n\t\tlast_time = 0.0;\n\t\ty_accum = 0;\n\t}\n\n\ty_accum += sign * dy_sum;\n\n\tif (4 * nabs(y_accum) > scr_ev[0].h && y_cut) {\n\t\t;\t/* TBD */\n\t}\n\n\tlast_sign = sign;\n\tlast_win = scr_ev[0].win;\n\tlast_time = now;\n\n\treturn y_accum;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int lookup_win_index(Window);",
            "static int set_ypad(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int set_ypad(void);\n\nstatic int set_ypad(void) {\n\tint ev, ev_tot = scr_ev_cnt;\n\tstatic Window last_win = None;\n\tstatic double last_time = 0.0;\n\tstatic int y_accum = 0, last_sign = 0;\n\tdouble now, cut = 0.1;\n\tint dy_sum = 0, ys = 0, sign;\n\tint font_size = 15;\n\tint win_y, scr_y, loc_cut = 4*font_size, y_cut = 10*font_size;\n\t\n\tif (!xrecord_set_by_keys || !xrecord_name_info) {\n\t\treturn 0;\n\t}\n\tif (xrecord_name_info[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! ev_tot) {\n\t\treturn 0;\n\t}\n\tif (xrecord_keysym == NoSymbol)  {\n\t\treturn 0;\n\t}\n\tif (!xrecord_scroll_keysym(xrecord_keysym)) {\n\t\treturn 0;\n\t}\n\tif (!scroll_term) {\n\t\treturn 0;\n\t}\n\tif (!match_str_list(xrecord_name_info, scroll_term)) {\n\t\treturn 0;\n\t}\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdy_sum += nabs(scr_ev[ev].dy);\n\t\tif (scr_ev[ev].dy < 0) {\n\t\t\tys--;\n\t\t} else if (scr_ev[ev].dy > 0) {\n\t\t\tys++;\n\t\t} else {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].win != scr_ev[0].win) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].dx != 0) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ys != ev_tot && ys != -ev_tot) {\n\t\treturn 0;\n\t}\n\tif (ys < 0) {\n\t\tsign = -1;\n\t} else {\n\t\tsign = 1;\n\t}\n\n\tif (sign > 0) {\n\t\t/*\n\t\t * this case is not as useful as scrolling near the\n\t\t * bottom of a terminal.  But there are problems for it too.\n\t\t */\n\t\treturn 0;\n\t}\n\n\twin_y = scr_ev[0].win_y + scr_ev[0].win_h;\n\tscr_y = scr_ev[0].y + scr_ev[0].h;\n\tif (nabs(scr_y - win_y) > loc_cut) {\n\t\t/* require it to be near the bottom. */\n\t\treturn 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now < last_time + cut) {\n\t\tint ok = 1;\n\t\tif (last_win && scr_ev[0].win != last_win) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (last_sign && sign != last_sign) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (! ok) {\n\t\t\tlast_win = None;\n\t\t\tlast_sign = 0;\n\t\t\ty_accum = 0;\n\t\t\tlast_time = 0.0;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tlast_win = None;\n\t\tlast_sign = 0;\n\t\tlast_time = 0.0;\n\t\ty_accum = 0;\n\t}\n\n\ty_accum += sign * dy_sum;\n\n\tif (4 * nabs(y_accum) > scr_ev[0].h && y_cut) {\n\t\t;\t/* TBD */\n\t}\n\n\tlast_sign = sign;\n\tlast_win = scr_ev[0].win;\n\tlast_time = now;\n\n\treturn y_accum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "whole",
            "off_x",
            "off_y"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "whole",
            "coff_x",
            "coff_y"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_read_rate",
          "args": [],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "get_read_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "272-280",
          "snippet": "int get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_read_rate = 0;",
            "int speeds_read_rate_measured = 0;",
            "int get_read_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nint get_read_rate(void);\n\nint get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint last_scroll_type = SCR_NONE;\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic int set_ypad(void);\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nstatic void check_user_input2(double dt);\nvoid batch_push(int ncr, double delay);\n\nstatic int push_scr_ev(double *age, int type, int bdpush, int bdx, int bdy,\n    int bdskinny, int first_push) {\n\tWindow frame, win, win0;\n\tint x, y, w, h, wx, wy, ww, wh, dx, dy;\n\tint x0, y0, w0, h0;\n\tint nx, ny, nw, nh;\n\tint dret = 1, do_fb_push = 0, obscured;\n\tint ev, ev_tot = scr_ev_cnt;\n\tdouble tm, dt, st, waittime = 0.125;\n\tdouble max_age = *age;\n\tint db = debug_scroll, rrate = get_read_rate();\n\tsraRegionPtr backfill, whole, tmpregion, tmpregion2;\n\tint link, latency, netrate;\n\tint ypad = 0;\n\tdouble last_scroll_event_save = last_scroll_event;\n\tint fast_push = 0, rc;\n\n\t/* we return the oldest one. */\n\t*age = 0.0;\n\n\tif (ev_tot == 0) {\n\t\treturn dret;\n\t}\n\n\tlink = link_rate(&latency, &netrate);\n\n\tif (link == LR_DIALUP) {\n\t\twaittime *= 5;\n\t} else if (link == LR_BROADBAND) {\n\t\twaittime *= 3;\n\t} else if (latency > 80 || netrate < 40) {\n\t\twaittime *= 3;\n\t}\n\n\tbackfill = sraRgnCreate();\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\n\twin0 = scr_ev[0].win;\n\tx0 = scr_ev[0].win_x;\n\ty0 = scr_ev[0].win_y;\n\tw0 = scr_ev[0].win_w;\n\th0 = scr_ev[0].win_h;\n\n\typad = set_ypad();\n\nif (db) fprintf(stderr, \"ypad: %d  dy[0]: %d ev_tot: %d\\n\", ypad, scr_ev[0].dy, ev_tot);\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdouble ag;\n\t\n\t\tx   = scr_ev[ev].x;\n\t\ty   = scr_ev[ev].y;\n\t\tw   = scr_ev[ev].w;\n\t\th   = scr_ev[ev].h;\n\t\tdx  = scr_ev[ev].dx;\n\t\tdy  = scr_ev[ev].dy;\n\t\twin = scr_ev[ev].win;\n\t\twx  = scr_ev[ev].win_x;\n\t\twy  = scr_ev[ev].win_y;\n\t\tww  = scr_ev[ev].win_w;\n\t\twh  = scr_ev[ev].win_h;\n\t\tnx  = scr_ev[ev].new_x;\n\t\tny  = scr_ev[ev].new_y;\n\t\tnw  = scr_ev[ev].new_w;\n\t\tnh  = scr_ev[ev].new_h;\n\t\tst  = scr_ev[ev].t;\n\n\t\tag = (dnow() - servertime_diff) - st;\n\t\tif (ag > *age) {\n\t\t\t*age = ag;\n\t\t}\n\n\t\tif (dabs(ag) > max_age) {\nif (db) fprintf(stderr, \"push_scr_ev: TOO OLD: %.4f :: (%.4f - %.4f) \"\n    \"- %.4f \\n\", ag, dnow(), servertime_diff, st);\t\t\t\t\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t} else {\nif (db) fprintf(stderr, \"push_scr_ev: AGE:     %.4f\\n\", ag);\n\t\t}\n\t\tif (win != win0) {\nif (db) fprintf(stderr, \"push_scr_ev: DIFF WIN: 0x%lx != 0x%lx\\n\", win, win0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (wx != x0 || wy != y0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN SHIFT: %d %d, %d %d\", wx, x0, wy, y0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ww != w0 || wh != h0) {\nif (db) fprintf(stderr, \"push_scr_ev: WIN RESIZE: %d %d, %d %d\", ww, w0, wh, h0);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (w < 1 || h < 1 || ww < 1 || wh < 1) {\nif (db) fprintf(stderr, \"push_scr_ev: NEGATIVE h/w: %d %d %d %d\\n\", w, h, ww, wh);\n\t\t\tdret = 0;\n\t\t\tbreak;\n\t\t}\n\nif (db > 1) fprintf(stderr, \"push_scr_ev: got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d  dx: %d dy: %d %dx%d+%d+%d   win: 0x%lx\\n\",\n    ev, x, y, w, h, dx, dy, w, h, x, y, win);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, wx, wy, ww, wh, ww, wh, wx, wy);\n\nif (db > 1) fprintf(stderr, \"------------ got: %d x: %4d y: %3d\"\n    \" w: %4d h: %3d %dx%d+%d+%d\\n\",\n    ev, nx, ny, nw, nh, nw, nh, nx, ny);\n\n\t\tframe = None;\n\t\tif (xrecord_wm_window) {\n\t\t\tframe = xrecord_wm_window;\n\t\t}\n\t\tif (! frame) {\n\t\t\tX_LOCK;\n\t\t\tframe = query_pointer(rootwin);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tif (! frame) {\n\t\t\tframe = win;\n\t\t}\n\n\t\tdtime0(&tm);\n\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tif (clipshift) {\n\t\t\tsraRgnOffset(tmpregion, coff_x, coff_y);\n\t\t}\n\t\tif (subwin) {\n\t\t\tsraRgnOffset(tmpregion, off_x, off_y);\n\t\t}\n\t\ttmpregion2 = sraRgnCreateRect(wx, wy, wx+ww, wy+wh);\n\t\tsraRgnAnd(tmpregion2, whole);\n\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\tsraRgnDestroy(tmpregion2);\n\n\t\t/* do the wm frame just incase the above is bogus too. */\n\t\tif (frame && frame != win) {\n\t\t\tint k, gotk = -1;\n\t\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\t\tif (stack_list[k].win == frame &&\n\t\t\t\t    stack_list[k].fetched && \n\t\t\t\t    stack_list[k].valid && \n\t\t\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\t\t\tgotk = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gotk != -1) {\n\t\t\t\tint tx1, ty1, tx2, ty2;\n\t\t\t\ttx1 = stack_list[gotk].x;\n\t\t\t\tty1 = stack_list[gotk].y;\n\t\t\t\ttx2 = tx1 + stack_list[gotk].width;\n\t\t\t\tty2 = ty1 + stack_list[gotk].height;\n\t\t\t\ttmpregion2 = sraRgnCreateRect(tx1,ty1,tx2,ty2);\n\t\t\t\tsraRgnAnd(tmpregion2, whole);\n\t\t\t\tsraRgnSubtract(tmpregion, tmpregion2);\n\t\t\t\tsraRgnDestroy(tmpregion2);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * XXX Need to also clip:\n\t\t *\tchildren of win\n\t\t *\tsiblings of win higher in stacking order.\n\t\t * ignore for now... probably will make some apps\n\t\t * act very strangely.\n\t\t */\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tif (h > -ypad) {\n\t\t\t\t\th += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (h > ypad) {\n\t\t\t\t\ty += ypad;\n\t\t\t\t} else {\n\t\t\t\t\typad = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fast_push) {\n\t\t\tint nbatch = 0; \n\t\t\tdouble delay, d1 = 0.1, d2 = 0.02;\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, &nbatch);\n\n\t\t\tif (first_push) {\n\t\t\t\tdelay = d1;\n\t\t\t} else {\n\t\t\t\tdelay = d2;\n\t\t\t}\n\n\t\t\tbatch_push(nbatch, delay);\n\t\t\tfb_push();\n\t\t} else {\n\t\t\trc = try_copyrect(frame, frame, x, y, w, h, dx, dy, &obscured,\n\t\t\t    tmpregion, waittime, NULL);\n\t\t\tif (rc) {\n\t\t\t\tlast_scroll_type = type;\n\t\t\t\tdtime0(&last_scroll_event);\n\n\t\t\t\tdo_fb_push++;\n\t\t\t\turgent_update = 1;\n\t\t\t\tsraRgnDestroy(tmpregion);\nPUSH_TEST(0);\n\t\t\t}\n\t\t}\n\n\t\tif (! rc) {\n\t\t\tdret = 0;\n\t\t\tsraRgnDestroy(tmpregion);\n\t\t\tbreak;\t\n\t\t}\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  try_copyrect dt: %.4f\\n\", dt);\n\n\t\tif (ev > 0) {\n\t\t\tsraRgnOffset(backfill, dx, dy);\n\t\t\tsraRgnAnd(backfill, whole);\n\t\t}\n\n\t\tif (ypad) {\n\t\t\tif (ypad < 0) {\n\t\t\t\tny += ypad;\t\n\t\t\t\tnh -= ypad;\n\t\t\t} else {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\n\t\ttmpregion = sraRgnCreateRect(nx, ny, nx + nw, ny + nh);\n\t\tsraRgnAnd(tmpregion, whole);\n\t\tsraRgnOr(backfill, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t}\n\n\t/* try to update the backfill region (new window contents) */\n\tif (dret != 0) {\n\t\tdouble est, win_area = 0.0, area = 0.0;\n\t\tsraRectangleIterator *iter;\n\t\tsraRect rect;\n\t\tint tx1, ty1, tx2, ty2;\n\n\t\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\t\tsraRgnAnd(tmpregion, whole);\n\n\t\tsraRgnAnd(backfill, tmpregion);\n\n\t\titer = sraRgnGetIterator(tmpregion);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\twin_area += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\tsraRgnDestroy(tmpregion);\n\n\n\t\titer = sraRgnGetIterator(backfill);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tarea += (tx2 - tx1)*(ty2 - ty1);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\n\t\test = (area * (bpp/8)) / (1000000.0 * rrate);\nif (db) fprintf(stderr, \"  area %.1f win_area %.1f est: %.4f\", area, win_area, est);\n\t\tif (area > 0.90 * win_area) {\nif (db) fprintf(stderr, \"  AREA_TOO_MUCH\");\n\t\t\tdret = 0;\n\t\t} else if (est > 0.6) {\nif (db) fprintf(stderr, \"  EST_TOO_LARGE\");\n\t\t\tdret = 0;\n\t\t} else if (area <= 0.0) {\n\t\t\t;\n\t\t} else {\n\t\t\tdtime0(&tm);\n\t\t\titer = sraRgnGetIterator(backfill);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\ttx1 = rect.x1;\n\t\t\t\tty1 = rect.y1;\n\t\t\t\ttx2 = rect.x2;\n\t\t\t\tty2 = rect.y2;\n\n\t\t\t\tif (clipshift) {\n\t\t\t\t\ttx1 -= coff_x;\n\t\t\t\t\tty1 -= coff_y;\n\t\t\t\t\ttx2 -= coff_x;\n\t\t\t\t\tty2 -= coff_y;\n\t\t\t\t}\n\t\t\t\tif (subwin) {\n\t\t\t\t\ttx1 -= off_x;\n\t\t\t\t\tty1 -= off_y;\n\t\t\t\t\ttx2 -= off_x;\n\t\t\t\t\tty2 -= off_y;\n\t\t\t\t}\n\t\t\t\ttx1 = nfix(tx1, dpy_x);\n\t\t\t\tty1 = nfix(ty1, dpy_y);\n\t\t\t\ttx2 = nfix(tx2, dpy_x+1);\n\t\t\t\tty2 = nfix(ty2, dpy_y+1);\n\n\t\t\t\tdtime(&tm);\nif (db) fprintf(stderr, \"  DFC(%d,%d-%d,%d)\", tx1, ty1, tx2, ty2);\n\t\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\t\t\t\tif (fast_push) {\n\t\t\t\t\tfb_push();\n\t\t\t\t}\n\t\t\t\tdo_fb_push++;\nPUSH_TEST(0);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\n\t\t\tdt = dtime(&tm);\nif (db) fprintf(stderr, \"  dfc---- dt: %.4f\", dt);\n\n\t\t}\nif (db &&  dret) fprintf(stderr, \" **** dret=%d\", dret);\nif (db && !dret) fprintf(stderr, \" ---- dret=%d\", dret);\nif (db) fprintf(stderr, \"\\n\");\n\t}\n\nif (db && bdpush) fprintf(stderr, \"BDPUSH-TIME:  0x%lx\\n\", xrecord_wm_window);\n\n\tif (bdpush && xrecord_wm_window != None) {\n\t\tint x, y, w, h;\n\t\tx = scr_ev[0].x;\n\t\ty = scr_ev[0].y;\n\t\tw = scr_ev[0].w;\n\t\th = scr_ev[0].h;\n\t\tdo_fb_push += do_bdpush(xrecord_wm_window, x, y, w, h,\n\t\t    bdx, bdy, bdskinny); \n\t\tif (fast_push) {\n\t\t\tfb_push();\n\t\t}\n\t}\n\n\tif (do_fb_push) {\n\t\tdtime0(&tm);\n\t\tfb_push();\n\t\tdt = dtime(&tm);\nif (0) fprintf(stderr, \"  fb_push dt: %.4f\", dt);\n\t\tif (scaling) {\n\t\t\tstatic double last_time = 0.0;\n\t\t\tdouble now = dnow(), delay = 0.4, first_wait = 3.0;\n\t\t\tdouble trate;\n\t\t\tint repeating, lat, rate;\n\t\t\tint link = link_rate(&lat, &rate);\n\t\t\tint skip_first = 0;\n\n\t\t\tif (link == LR_DIALUP || rate < 35) {\n\t\t\t\tdelay *= 4;\n\t\t\t} else if (link != LR_LAN || rate < 100) {\n\t\t\t\tdelay *= 2;\n\t\t\t}\n\n\t\t\ttrate = typing_rate(0.0, &repeating);\n\t\t\t\n\t\t\tif (xrecord_set_by_mouse || repeating >= 3) {\n\t\t\t\tif (now > last_scroll_event_save + first_wait) {\n\t\t\t\t\tskip_first = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip_first) {\n\t\t\t\t/* \n\t\t\t\t * try not to send the first one, but a\n\t\t\t\t * single keystroke scroll would be OK.\n\t\t\t\t */\n\t\t\t} else if (now > last_time + delay) {\n\n\t\t\t\tscale_mark(x0, y0, x0 + w0, y0 + h0, 1);\n\t\t\t\tlast_copyrect_fix = now;\n\t\t\t}\n\t\t\tlast_time = now;\n\t\t}\n\t}\n\n\tsraRgnDestroy(backfill);\n\tsraRgnDestroy(whole);\n\treturn dret;\n}"
  },
  {
    "function_name": "scale_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1408-1415",
    "snippet": "static void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
      "static void scale_mark(int x1, int y1, int x2, int y2, int mark);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scale_and_mark_rect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "mark"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "scale_and_mark_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1300-1342",
          "snippet": "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark) {\n\tchar *dst_fb, *src_fb = main_fb;\n\tint dst_bpl, Bpp = bpp/8, fac = 1;\n\n\tif (!screen || !rfb_fb || !main_fb) {\n\t\treturn;\n\t}\n\tif (! screen->serverFormat.trueColour) {\n\t\t/*\n\t\t * PseudoColor colormap... blending leads to random colors.\n\t\t * User can override with \":fb\"\n\t\t */\n\t\tif (scaling_blend == 1) {\n\t\t\t/* :fb option sets it to 2 */\n\t\t\tif (default_visual->class == StaticGray) {\n\t\t\t\t/*\n\t\t\t\t * StaticGray can be blended OK, otherwise\n\t\t\t\t * user can disable with :nb\n\t\t\t\t */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tscaling_blend = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tsrc_fb = cmap8to24_fb;\n\t\tif (scaling) {\n\t\t\tif (depth <= 8) {\n\t\t\t\tfac = 4;\n\t\t\t} else if (depth <= 16) {\n\t\t\t\tfac = 2;\n\t\t\t}\n\t\t}\n\t}\n\tdst_fb = rfb_fb;\n\tdst_bpl = rfb_bytes_per_line;\n\n\tscale_rect(scale_fac_x, scale_fac_y, scaling_blend, scaling_interpolate, fac * Bpp,\n\t    src_fb, fac * main_bytes_per_line, dst_fb, dst_bpl, dpy_x, dpy_y,\n\t    scaled_x, scaled_y, X1, Y1, X2, Y2, mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2 + s",
            "dpy_y+1"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\n\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark) {\n\tint s = 2;\n\tx1 = nfix(x1 - s, dpy_x);\n\ty1 = nfix(y1 - s, dpy_y);\n\tx2 = nfix(x2 + s, dpy_x+1);\n\ty2 = nfix(y2 + s, dpy_y+1);\n\tscale_and_mark_rect(x1, y1, x2, y2, mark);\n}"
  },
  {
    "function_name": "set_ypad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1296-1406",
    "snippet": "static int set_ypad(void) {\n\tint ev, ev_tot = scr_ev_cnt;\n\tstatic Window last_win = None;\n\tstatic double last_time = 0.0;\n\tstatic int y_accum = 0, last_sign = 0;\n\tdouble now, cut = 0.1;\n\tint dy_sum = 0, ys = 0, sign;\n\tint font_size = 15;\n\tint win_y, scr_y, loc_cut = 4*font_size, y_cut = 10*font_size;\n\t\n\tif (!xrecord_set_by_keys || !xrecord_name_info) {\n\t\treturn 0;\n\t}\n\tif (xrecord_name_info[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! ev_tot) {\n\t\treturn 0;\n\t}\n\tif (xrecord_keysym == NoSymbol)  {\n\t\treturn 0;\n\t}\n\tif (!xrecord_scroll_keysym(xrecord_keysym)) {\n\t\treturn 0;\n\t}\n\tif (!scroll_term) {\n\t\treturn 0;\n\t}\n\tif (!match_str_list(xrecord_name_info, scroll_term)) {\n\t\treturn 0;\n\t}\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdy_sum += nabs(scr_ev[ev].dy);\n\t\tif (scr_ev[ev].dy < 0) {\n\t\t\tys--;\n\t\t} else if (scr_ev[ev].dy > 0) {\n\t\t\tys++;\n\t\t} else {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].win != scr_ev[0].win) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].dx != 0) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ys != ev_tot && ys != -ev_tot) {\n\t\treturn 0;\n\t}\n\tif (ys < 0) {\n\t\tsign = -1;\n\t} else {\n\t\tsign = 1;\n\t}\n\n\tif (sign > 0) {\n\t\t/*\n\t\t * this case is not as useful as scrolling near the\n\t\t * bottom of a terminal.  But there are problems for it too.\n\t\t */\n\t\treturn 0;\n\t}\n\n\twin_y = scr_ev[0].win_y + scr_ev[0].win_h;\n\tscr_y = scr_ev[0].y + scr_ev[0].h;\n\tif (nabs(scr_y - win_y) > loc_cut) {\n\t\t/* require it to be near the bottom. */\n\t\treturn 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now < last_time + cut) {\n\t\tint ok = 1;\n\t\tif (last_win && scr_ev[0].win != last_win) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (last_sign && sign != last_sign) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (! ok) {\n\t\t\tlast_win = None;\n\t\t\tlast_sign = 0;\n\t\t\ty_accum = 0;\n\t\t\tlast_time = 0.0;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tlast_win = None;\n\t\tlast_sign = 0;\n\t\tlast_time = 0.0;\n\t\ty_accum = 0;\n\t}\n\n\ty_accum += sign * dy_sum;\n\n\tif (4 * nabs(y_accum) > scr_ev[0].h && y_cut) {\n\t\t;\t/* TBD */\n\t}\n\n\tlast_sign = sign;\n\tlast_win = scr_ev[0].win;\n\tlast_time = now;\n\n\treturn y_accum;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int lookup_win_index(Window);",
      "static int set_ypad(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "y_accum"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_str_list",
          "args": [
            "xrecord_name_info",
            "scroll_term"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "match_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "353-370",
          "snippet": "int match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int match_str_list(char *str, char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\n\nint match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecord_scroll_keysym",
          "args": [
            "xrecord_keysym"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_scroll_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "443-464",
          "snippet": "int xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecord_skip_keysym(rfbKeySym keysym);",
            "int xrecord_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nint xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\nstatic int set_ypad(void);\n\nstatic int set_ypad(void) {\n\tint ev, ev_tot = scr_ev_cnt;\n\tstatic Window last_win = None;\n\tstatic double last_time = 0.0;\n\tstatic int y_accum = 0, last_sign = 0;\n\tdouble now, cut = 0.1;\n\tint dy_sum = 0, ys = 0, sign;\n\tint font_size = 15;\n\tint win_y, scr_y, loc_cut = 4*font_size, y_cut = 10*font_size;\n\t\n\tif (!xrecord_set_by_keys || !xrecord_name_info) {\n\t\treturn 0;\n\t}\n\tif (xrecord_name_info[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! ev_tot) {\n\t\treturn 0;\n\t}\n\tif (xrecord_keysym == NoSymbol)  {\n\t\treturn 0;\n\t}\n\tif (!xrecord_scroll_keysym(xrecord_keysym)) {\n\t\treturn 0;\n\t}\n\tif (!scroll_term) {\n\t\treturn 0;\n\t}\n\tif (!match_str_list(xrecord_name_info, scroll_term)) {\n\t\treturn 0;\n\t}\n\n\tfor (ev=0; ev < ev_tot; ev++) {\n\t\tdy_sum += nabs(scr_ev[ev].dy);\n\t\tif (scr_ev[ev].dy < 0) {\n\t\t\tys--;\n\t\t} else if (scr_ev[ev].dy > 0) {\n\t\t\tys++;\n\t\t} else {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].win != scr_ev[0].win) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (scr_ev[ev].dx != 0) {\n\t\t\tys = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ys != ev_tot && ys != -ev_tot) {\n\t\treturn 0;\n\t}\n\tif (ys < 0) {\n\t\tsign = -1;\n\t} else {\n\t\tsign = 1;\n\t}\n\n\tif (sign > 0) {\n\t\t/*\n\t\t * this case is not as useful as scrolling near the\n\t\t * bottom of a terminal.  But there are problems for it too.\n\t\t */\n\t\treturn 0;\n\t}\n\n\twin_y = scr_ev[0].win_y + scr_ev[0].win_h;\n\tscr_y = scr_ev[0].y + scr_ev[0].h;\n\tif (nabs(scr_y - win_y) > loc_cut) {\n\t\t/* require it to be near the bottom. */\n\t\treturn 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now < last_time + cut) {\n\t\tint ok = 1;\n\t\tif (last_win && scr_ev[0].win != last_win) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (last_sign && sign != last_sign) {\n\t\t\tok = 0;\n\t\t}\n\t\tif (! ok) {\n\t\t\tlast_win = None;\n\t\t\tlast_sign = 0;\n\t\t\ty_accum = 0;\n\t\t\tlast_time = 0.0;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tlast_win = None;\n\t\tlast_sign = 0;\n\t\tlast_time = 0.0;\n\t\ty_accum = 0;\n\t}\n\n\ty_accum += sign * dy_sum;\n\n\tif (4 * nabs(y_accum) > scr_ev[0].h && y_cut) {\n\t\t;\t/* TBD */\n\t}\n\n\tlast_sign = sign;\n\tlast_win = scr_ev[0].win;\n\tlast_time = now;\n\n\treturn y_accum;\n}"
  },
  {
    "function_name": "do_bdpush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1182-1294",
    "snippet": "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny) {\n\n\tXWindowAttributes attr;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tsraRegionPtr frame, whole, tmpregion;\n\tint tx1, ty1, tx2, ty2;\n\tstatic Window last_wm_win = None;\n\tstatic int last_x, last_y, last_w, last_h;\n\tint do_fb_push = 0;\n\tint db = debug_scroll;\n\n\tif (wm_win == last_wm_win) {\n\t\tattr.x = last_x;\n\t\tattr.y = last_y;\n\t\tattr.width = last_w;\n\t\tattr.height = last_h;\n\t} else {\n\t\tif (!valid_window(wm_win, &attr, 1)) {\n\t\t\treturn do_fb_push;\n\t\t}\n\t\tlast_wm_win = wm_win;\n\t\tlast_x = attr.x;\n\t\tlast_y = attr.y;\n\t\tlast_w = attr.width;\n\t\tlast_h = attr.height;\n\t}\nif (db > 1) fprintf(stderr, \"BDP  %d %d %d %d  %d %d %d  %d %d %d %d\\n\",\n\tx0, y0, w0, h0, bdx, bdy, bdskinny, last_x, last_y, last_w, last_h);\n\n\t/* wm frame: */\n\ttx1 = attr.x;\n\tty1 = attr.y;\n\ttx2 = attr.x + attr.width;\n\tty2 = attr.y + attr.height;\n\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\tframe = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tsraRgnAnd(frame, whole);\n\n\t/* scrolling window: */\n\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\tsraRgnAnd(tmpregion, whole);\n\n\tsraRgnSubtract(frame, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\n\tif (!sraRgnEmpty(frame)) {\n\t\tdouble dt = 0.0, dm;\n\t\tdtime0(&dm);\n\t\titer = sraRgnGetIterator(frame);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tif (bdskinny > 0) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (nabs(ty2-ty1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (nabs(tx2-tx1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (! ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bdx >= 0) {\n\t\t\t\tif (bdx < tx1 || tx2 <= bdx) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bdy >= 0) {\n\t\t\t\tif (bdy < ty1 || ty2 <= bdy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\ttx1 -= coff_x;\n\t\t\t\tty1 -= coff_y;\n\t\t\t\ttx2 -= coff_x;\n\t\t\t\tty2 -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\ttx1 -= off_x;\n\t\t\t\tty1 -= off_y;\n\t\t\t\ttx2 -= off_x;\n\t\t\t\tty2 -= off_y;\n\t\t\t}\n\n\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\n\t\t\tdo_fb_push++;\n\t\t\tdt += dtime(&dm);\nif (db > 1) fprintf(stderr, \"  BDP(%d,%d-%d,%d)  dt: %.4f\\n\", tx1, ty1, tx2, ty2, dt);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t}\n\tsraRgnDestroy(whole);\n\tsraRgnDestroy(frame);\n\n\treturn do_fb_push;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int lookup_win_index(Window);",
      "static int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);",
      "static void check_user_input2(double dt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "frame"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "whole"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  BDP(%d,%d-%d,%d)  dt: %.4f\\n\"",
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "dt"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&dm"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "direct_fb_copy",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2",
            "1"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "direct_fb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1066-1180",
          "snippet": "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static int scrollability(Window win, int set);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "tx2-tx1"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "frame"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "frame"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "frame",
            "tmpregion"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "tmpregion",
            "whole"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x0",
            "y0",
            "x0 + w0",
            "y0 + h0"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "frame",
            "whole"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "tx1",
            "ty1",
            "tx2",
            "ty2"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "whole",
            "off_x",
            "off_y"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "whole",
            "coff_x",
            "coff_y"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"BDP  %d %d %d %d  %d %d %d  %d %d %d %d\\n\"",
            "x0",
            "y0",
            "w0",
            "h0",
            "bdx",
            "bdy",
            "bdskinny",
            "last_x",
            "last_y",
            "last_w",
            "last_h"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "wm_win",
            "&attr",
            "1"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint lookup_win_index(Window);\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny);\nstatic void check_user_input2(double dt);\n\nstatic int do_bdpush(Window wm_win, int x0, int y0, int w0, int h0, int bdx,\n    int bdy, int bdskinny) {\n\n\tXWindowAttributes attr;\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tsraRegionPtr frame, whole, tmpregion;\n\tint tx1, ty1, tx2, ty2;\n\tstatic Window last_wm_win = None;\n\tstatic int last_x, last_y, last_w, last_h;\n\tint do_fb_push = 0;\n\tint db = debug_scroll;\n\n\tif (wm_win == last_wm_win) {\n\t\tattr.x = last_x;\n\t\tattr.y = last_y;\n\t\tattr.width = last_w;\n\t\tattr.height = last_h;\n\t} else {\n\t\tif (!valid_window(wm_win, &attr, 1)) {\n\t\t\treturn do_fb_push;\n\t\t}\n\t\tlast_wm_win = wm_win;\n\t\tlast_x = attr.x;\n\t\tlast_y = attr.y;\n\t\tlast_w = attr.width;\n\t\tlast_h = attr.height;\n\t}\nif (db > 1) fprintf(stderr, \"BDP  %d %d %d %d  %d %d %d  %d %d %d %d\\n\",\n\tx0, y0, w0, h0, bdx, bdy, bdskinny, last_x, last_y, last_w, last_h);\n\n\t/* wm frame: */\n\ttx1 = attr.x;\n\tty1 = attr.y;\n\ttx2 = attr.x + attr.width;\n\tty2 = attr.y + attr.height;\n\n\twhole = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tif (clipshift) {\n\t\tsraRgnOffset(whole, coff_x, coff_y);\n\t}\n\tif (subwin) {\n\t\tsraRgnOffset(whole, off_x, off_y);\n\t}\n\tframe = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tsraRgnAnd(frame, whole);\n\n\t/* scrolling window: */\n\ttmpregion = sraRgnCreateRect(x0, y0, x0 + w0, y0 + h0);\n\tsraRgnAnd(tmpregion, whole);\n\n\tsraRgnSubtract(frame, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\n\tif (!sraRgnEmpty(frame)) {\n\t\tdouble dt = 0.0, dm;\n\t\tdtime0(&dm);\n\t\titer = sraRgnGetIterator(frame);\n\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\ttx1 = rect.x1;\n\t\t\tty1 = rect.y1;\n\t\t\ttx2 = rect.x2;\n\t\t\tty2 = rect.y2;\n\n\t\t\tif (bdskinny > 0) {\n\t\t\t\tint ok = 0;\n\t\t\t\tif (nabs(ty2-ty1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (nabs(tx2-tx1) <= bdskinny) {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (! ok) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bdx >= 0) {\n\t\t\t\tif (bdx < tx1 || tx2 <= bdx) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bdy >= 0) {\n\t\t\t\tif (bdy < ty1 || ty2 <= bdy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\ttx1 -= coff_x;\n\t\t\t\tty1 -= coff_y;\n\t\t\t\ttx2 -= coff_x;\n\t\t\t\tty2 -= coff_y;\n\t\t\t}\n\t\t\tif (subwin) {\n\t\t\t\ttx1 -= off_x;\n\t\t\t\tty1 -= off_y;\n\t\t\t\ttx2 -= off_x;\n\t\t\t\tty2 -= off_y;\n\t\t\t}\n\n\t\t\tdirect_fb_copy(tx1, ty1, tx2, ty2, 1);\n\n\t\t\tdo_fb_push++;\n\t\t\tdt += dtime(&dm);\nif (db > 1) fprintf(stderr, \"  BDP(%d,%d-%d,%d)  dt: %.4f\\n\", tx1, ty1, tx2, ty2, dt);\n\t\t}\n\t\tsraRgnReleaseIterator(iter);\n\t}\n\tsraRgnDestroy(whole);\n\tsraRgnDestroy(frame);\n\n\treturn do_fb_push;\n}"
  },
  {
    "function_name": "direct_fb_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "1066-1180",
    "snippet": "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
      "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
      "static int scrollability(Window win, int set);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\"",
            "x2 - x1",
            "y2 - y1",
            "x1",
            "y1",
            "mark",
            "dtime(&tm)"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "xmin",
            "ymin",
            "xmax",
            "ymax",
            "0"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst2",
            "src2",
            "n*pixelsize"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst2",
            "src2",
            "n*pixelsize"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(x2 - x1)*pixelsize"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst",
            "src",
            "(x2 - x1)*pixelsize"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(x2 - x1)*pixelsize"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRANDR_CHK_TRAP_RET",
          "args": [
            "0",
            "\"direct_fb_copy-chk\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "scanline",
            "x1",
            "y",
            "x2 - x1",
            "1"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRANDR_SET_TRAP_RET",
          "args": [
            "0",
            "\"direct_fb_copy-set\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}"
  },
  {
    "function_name": "draw_box",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "803-1064",
    "snippet": "static void draw_box(int x, int y, int w, int h, int restore) {\n\tint x0, y0, x1, y1, i, pixelsize = bpp/8;\n\tchar *dst, *src, *use_fb;\n\tstatic saveline_t *save[4];\n\tstatic int first = 1, len = 0;\n\tint max = dpy_x > dpy_y ? dpy_x : dpy_y;\n\tint use_Bpl, lw = wireframe_lw;\n\tunsigned long shade = wireframe_shade;\n\tint color = 0;\n\tunsigned short us = 0;\n\tunsigned long ul = 0;\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\n\t/* handle -8to24 mode: use 2nd fb only */\n\tuse_fb  = main_fb;\n\tuse_Bpl = main_bytes_per_line; \n\t\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tuse_fb = cmap8to24_fb;\n\t\tpixelsize = 4;\n\t\tif (depth <= 8) {\n\t\t\tuse_Bpl *= 4;\n\t\t} else if (depth <= 16) {\n\t\t\tuse_Bpl *= 2;\n\t\t}\n\t}\n\n\tif (max > len) {\n\t\t/* create/resize storage lines: */\n\t\tfor (i=0; i<4; i++) {\n\t\t\tlen = max;\n\t\t\tif (! first && save[i]) {\n\t\t\t\tif (save[i]->data) {\n\t\t\t\t\tfree(save[i]->data);\n\t\t\t\t\tsave[i]->data = NULL;\n\t\t\t\t}\n\t\t\t\tfree(save[i]);\n\t\t\t}\n\t\t\tsave[i] = (saveline_t *) malloc(sizeof(saveline_t));\n\t\t\tsave[i]->saved = 0;\n\t\t\tsave[i]->data = (char *) malloc( (LW_MAX+1)*len*4 );\n\n\t\t\t/* \n\t\t\t * Four types of lines:\n\t\t\t *\t0) top horizontal\n\t\t\t *\t1) bottom horizontal\n\t\t\t *\t2) left vertical\n\t\t\t *\t3) right vertical\n\t\t\t *\n\t\t\t * shift means shifted by width or height.\n\t\t\t */\n\t\t\tif (i == 0) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t} else if (i == 2) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 3) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\t/*\n\t * restore any saved lines. see below for algorithm and\n\t * how x0, etc. are used.  we just reverse those steps.\n\t */\n\tfor (i=0; i<4; i++) {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (! save[i]->saved) {\n\t\t\tcontinue;\n\t\t}\n\t\tx0 = save[i]->x0;\n\t\ty0 = save[i]->y0;\n\t\tx1 = save[i]->x1;\n\t\ty1 = save[i]->y1;\n\t\tif (save[i]->vert) {\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\t\t} else {\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\t\t}\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\t\t\tsrc = save[i]->data + (yu-y_start)*y_step;\n\t\t\tdst = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\t\t}\n\t\tif (y_min >= 0) {\nif (0) fprintf(stderr, \"Mark-1 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t\tsave[i]->saved = 0;\n\t}\n\nif (0) fprintf(stderr, \"  DrawBox: %04dx%04d+%04d+%04d B=%d rest=%d lw=%d %.4f\\n\", w, h, x, y, 2*(w+h)*(2-restore)*pixelsize*lw, restore, lw, dnowx());\n\n\tif (restore) {\n\t\treturn;\n\t}\n\n\n\t/*\n\t * work out shade/color for the wireframe line, could be a color\n\t * for 16bpp or 24bpp.\n\t */\n\tif (shade > 255) {\n\t\tif (pixelsize == 2) {\n\t\t\tus = (unsigned short) (shade & 0xffff);\n\t\t\tcolor = 1;\n\t\t} else if (pixelsize == 4) {\n\t\t\tul = (unsigned long) shade;\n\t\t\tcolor = 1;\n\t\t} else {\n\t\t\tshade = shade % 256;\n\t\t}\n\t}\n\n\tfor (i=0; i<4; i++)  {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint yblack = -1, xblack1 = -1, xblack2 = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (save[i]->vert) {\n\t\t\t/*\n\t\t\t * make the narrow x's be on the screen, let\n\t\t\t * the y's hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x + s*w - s*lw, dpy_x);\n\t\t\tsave[i]->y0 = y0 = y;\n\t\t\tsave[i]->x1 = x1 = nfix(x + s*w - s*lw + lw, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y + h;\n\n\t\t\t/*\n\t\t\t * start and stop a linewidth away from true edge,\n\t\t\t * to avoid interfering with horizontal lines.\n\t\t\t */\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\n\t\t\t/* draw a black pixel for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\txblack1 = x1-1;\n\t\t\t} else {\n\t\t\t\txblack1 = x0;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * make the wide x's be on the screen, let the y's\n\t\t\t * hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x,     dpy_x);\n\t\t\tsave[i]->y0 = y0 = y + s*h;\n\t\t\tsave[i]->x1 = x1 = nfix(x + w, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y0 + lw;\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\n\t\t\t/* draw a black pixels for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\tyblack = y_stop - 1;\n\t\t\t} else {\n\t\t\t\tyblack = y_start;\n\t\t\t}\n\t\t\txblack1 = x0;\n\t\t\txblack2 = x1-1;\n\t\t}\n\n\t\t/* now loop over the allowed y's for either case */\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* record min and max y's for marking rectangle: */\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\n\t\t\t/* save fb data for this line: */\n\t\t\tsave[i]->saved = 1;\n\t\t\tsrc = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tdst = save[i]->data + (yu-y_start)*y_step;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\n\t\t\t/* apply the shade/color to make the wireframe line: */\n\t\t\tif (! color) {\n\t\t\t\tmemset(src, shade, (x1-x0)*pixelsize);\n\t\t\t} else {\n\t\t\t\tchar *csrc = src;\n\t\t\t\tunsigned short *usp;\n\t\t\t\tunsigned long *ulp;\n\t\t\t\tint k;\n\t\t\t\tfor (k=0; k < x1 - x0; k++) {\n\t\t\t\t\tif (pixelsize == 4) {\n\t\t\t\t\t\tulp = (unsigned long *)csrc;\n\t\t\t\t\t\t*ulp = ul;\n\t\t\t\t\t} else if (pixelsize == 2) {\n\t\t\t\t\t\tusp = (unsigned short *)csrc;\n\t\t\t\t\t\t*usp = us;\n\t\t\t\t\t}\n\t\t\t\t\tcsrc += pixelsize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* apply black border for lw >= 2 */\n\t\t\tif (lw > 1) {\n\t\t\t\tif (yu == yblack) {\n\t\t\t\t\tmemset(src, 0, (x1-x0)*pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack1 >= 0) {\n\t\t\t\t\tsrc = src + (xblack1 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack2 >= 0) {\n\t\t\t\t\tsrc = src + (xblack2 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* mark it for sending: */\n\t\tif (save[i]->saved) {\nif (0) fprintf(stderr, \"Mark-2 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define LW_MAX 8"
    ],
    "globals_used": [
      "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
      "static void draw_box(int x, int y, int w, int h, int restore);",
      "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
      "static unsigned long wireframe_shade = 0xff;",
      "static int wireframe_lw;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x0",
            "y_min",
            "x1",
            "y_max+1",
            "0"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Mark-2 %d %d %d %d\\n\"",
            "x0",
            "y_min",
            "x1",
            "y_max+1"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src",
            "0",
            "pixelsize"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src",
            "0",
            "pixelsize"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src",
            "0",
            "(x1-x0)*pixelsize"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src",
            "shade",
            "(x1-x0)*pixelsize"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(x1-x0)*pixelsize"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "x + w",
            "dpy_x"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  DrawBox: %04dx%04d+%04d+%04d B=%d rest=%d lw=%d %.4f\\n\"",
            "w",
            "h",
            "x",
            "y",
            "2*(w+h)*(2-restore)*pixelsize*lw",
            "restore",
            "lw",
            "dnowx()"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Mark-1 %d %d %d %d\\n\"",
            "x0",
            "y_min",
            "x1",
            "y_max+1"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "(x1-x0)*pixelsize"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(LW_MAX+1)*len*4"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(saveline_t)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "save[i]"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define LW_MAX 8\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nstatic void draw_box(int x, int y, int w, int h, int restore);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic unsigned long wireframe_shade = 0xff;\nstatic int wireframe_lw;\n\nstatic void draw_box(int x, int y, int w, int h, int restore) {\n\tint x0, y0, x1, y1, i, pixelsize = bpp/8;\n\tchar *dst, *src, *use_fb;\n\tstatic saveline_t *save[4];\n\tstatic int first = 1, len = 0;\n\tint max = dpy_x > dpy_y ? dpy_x : dpy_y;\n\tint use_Bpl, lw = wireframe_lw;\n\tunsigned long shade = wireframe_shade;\n\tint color = 0;\n\tunsigned short us = 0;\n\tunsigned long ul = 0;\n\n\tif (clipshift) {\n\t\tx -= coff_x;\n\t\ty -= coff_y;\n\t}\n\n\t/* handle -8to24 mode: use 2nd fb only */\n\tuse_fb  = main_fb;\n\tuse_Bpl = main_bytes_per_line; \n\t\n\tif (cmap8to24 && cmap8to24_fb) {\n\t\tuse_fb = cmap8to24_fb;\n\t\tpixelsize = 4;\n\t\tif (depth <= 8) {\n\t\t\tuse_Bpl *= 4;\n\t\t} else if (depth <= 16) {\n\t\t\tuse_Bpl *= 2;\n\t\t}\n\t}\n\n\tif (max > len) {\n\t\t/* create/resize storage lines: */\n\t\tfor (i=0; i<4; i++) {\n\t\t\tlen = max;\n\t\t\tif (! first && save[i]) {\n\t\t\t\tif (save[i]->data) {\n\t\t\t\t\tfree(save[i]->data);\n\t\t\t\t\tsave[i]->data = NULL;\n\t\t\t\t}\n\t\t\t\tfree(save[i]);\n\t\t\t}\n\t\t\tsave[i] = (saveline_t *) malloc(sizeof(saveline_t));\n\t\t\tsave[i]->saved = 0;\n\t\t\tsave[i]->data = (char *) malloc( (LW_MAX+1)*len*4 );\n\n\t\t\t/* \n\t\t\t * Four types of lines:\n\t\t\t *\t0) top horizontal\n\t\t\t *\t1) bottom horizontal\n\t\t\t *\t2) left vertical\n\t\t\t *\t3) right vertical\n\t\t\t *\n\t\t\t * shift means shifted by width or height.\n\t\t\t */\n\t\t\tif (i == 0) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 1) {\n\t\t\t\tsave[i]->vert  = 0;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t} else if (i == 2) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 0;\n\t\t\t} else if (i == 3) {\n\t\t\t\tsave[i]->vert  = 1;\n\t\t\t\tsave[i]->shift = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfirst = 0;\n\n\t/*\n\t * restore any saved lines. see below for algorithm and\n\t * how x0, etc. are used.  we just reverse those steps.\n\t */\n\tfor (i=0; i<4; i++) {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (! save[i]->saved) {\n\t\t\tcontinue;\n\t\t}\n\t\tx0 = save[i]->x0;\n\t\ty0 = save[i]->y0;\n\t\tx1 = save[i]->x1;\n\t\ty1 = save[i]->y1;\n\t\tif (save[i]->vert) {\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\t\t} else {\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\t\t}\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\t\t\tsrc = save[i]->data + (yu-y_start)*y_step;\n\t\t\tdst = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\t\t}\n\t\tif (y_min >= 0) {\nif (0) fprintf(stderr, \"Mark-1 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t\tsave[i]->saved = 0;\n\t}\n\nif (0) fprintf(stderr, \"  DrawBox: %04dx%04d+%04d+%04d B=%d rest=%d lw=%d %.4f\\n\", w, h, x, y, 2*(w+h)*(2-restore)*pixelsize*lw, restore, lw, dnowx());\n\n\tif (restore) {\n\t\treturn;\n\t}\n\n\n\t/*\n\t * work out shade/color for the wireframe line, could be a color\n\t * for 16bpp or 24bpp.\n\t */\n\tif (shade > 255) {\n\t\tif (pixelsize == 2) {\n\t\t\tus = (unsigned short) (shade & 0xffff);\n\t\t\tcolor = 1;\n\t\t} else if (pixelsize == 4) {\n\t\t\tul = (unsigned long) shade;\n\t\t\tcolor = 1;\n\t\t} else {\n\t\t\tshade = shade % 256;\n\t\t}\n\t}\n\n\tfor (i=0; i<4; i++)  {\n\t\tint s = save[i]->shift;\n\t\tint yu, y_min = -1, y_max = -1;\n\t\tint yblack = -1, xblack1 = -1, xblack2 = -1;\n\t\tint y_start, y_stop, y_step;\n\n\t\tif (save[i]->vert) {\n\t\t\t/*\n\t\t\t * make the narrow x's be on the screen, let\n\t\t\t * the y's hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x + s*w - s*lw, dpy_x);\n\t\t\tsave[i]->y0 = y0 = y;\n\t\t\tsave[i]->x1 = x1 = nfix(x + s*w - s*lw + lw, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y + h;\n\n\t\t\t/*\n\t\t\t * start and stop a linewidth away from true edge,\n\t\t\t * to avoid interfering with horizontal lines.\n\t\t\t */\n\t\t\ty_start = y0+lw;\n\t\t\ty_stop  = y1-lw;\n\t\t\ty_step  = lw*pixelsize;\n\n\t\t\t/* draw a black pixel for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\txblack1 = x1-1;\n\t\t\t} else {\n\t\t\t\txblack1 = x0;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * make the wide x's be on the screen, let the y's\n\t\t\t * hang off (not drawn).\n\t\t\t */\n\t\t\tsave[i]->x0 = x0 = nfix(x,     dpy_x);\n\t\t\tsave[i]->y0 = y0 = y + s*h;\n\t\t\tsave[i]->x1 = x1 = nfix(x + w, dpy_x);\n\t\t\tsave[i]->y1 = y1 = y0 + lw;\n\t\t\ty_start = y0 - s*lw;\n\t\t\ty_stop  = y_start + lw;\n\t\t\ty_step  = max*pixelsize;\n\n\t\t\t/* draw a black pixels for the border if lw > 1 */\n\t\t\tif (s) {\n\t\t\t\tyblack = y_stop - 1;\n\t\t\t} else {\n\t\t\t\tyblack = y_start;\n\t\t\t}\n\t\t\txblack1 = x0;\n\t\t\txblack2 = x1-1;\n\t\t}\n\n\t\t/* now loop over the allowed y's for either case */\n\t\tfor (yu = y_start; yu < y_stop; yu++) {\n\t\t\tif (x0 == x1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (yu < 0 || yu >= dpy_y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* record min and max y's for marking rectangle: */\n\t\t\tif (y_min < 0 || yu < y_min) {\n\t\t\t\ty_min = yu;\n\t\t\t}\n\t\t\tif (y_max < 0 || yu > y_max) {\n\t\t\t\ty_max = yu;\n\t\t\t}\n\n\t\t\t/* save fb data for this line: */\n\t\t\tsave[i]->saved = 1;\n\t\t\tsrc = use_fb + yu*use_Bpl + x0*pixelsize;\n\t\t\tdst = save[i]->data + (yu-y_start)*y_step;\n\t\t\tmemcpy(dst, src, (x1-x0)*pixelsize);\n\n\t\t\t/* apply the shade/color to make the wireframe line: */\n\t\t\tif (! color) {\n\t\t\t\tmemset(src, shade, (x1-x0)*pixelsize);\n\t\t\t} else {\n\t\t\t\tchar *csrc = src;\n\t\t\t\tunsigned short *usp;\n\t\t\t\tunsigned long *ulp;\n\t\t\t\tint k;\n\t\t\t\tfor (k=0; k < x1 - x0; k++) {\n\t\t\t\t\tif (pixelsize == 4) {\n\t\t\t\t\t\tulp = (unsigned long *)csrc;\n\t\t\t\t\t\t*ulp = ul;\n\t\t\t\t\t} else if (pixelsize == 2) {\n\t\t\t\t\t\tusp = (unsigned short *)csrc;\n\t\t\t\t\t\t*usp = us;\n\t\t\t\t\t}\n\t\t\t\t\tcsrc += pixelsize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* apply black border for lw >= 2 */\n\t\t\tif (lw > 1) {\n\t\t\t\tif (yu == yblack) {\n\t\t\t\t\tmemset(src, 0, (x1-x0)*pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack1 >= 0) {\n\t\t\t\t\tsrc = src + (xblack1 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t\tif (xblack2 >= 0) {\n\t\t\t\t\tsrc = src + (xblack2 - x0)*pixelsize;\n\t\t\t\t\tmemset(src, 0, pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* mark it for sending: */\n\t\tif (save[i]->saved) {\nif (0) fprintf(stderr, \"Mark-2 %d %d %d %d\\n\", x0, y_min, x1, y_max+1);\n\t\t\tmark_rect_as_modified(x0, y_min, x1, y_max+1, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "initialize_max_keyrepeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "765-787",
    "snippet": "void initialize_max_keyrepeat(void) {\n\tchar *str;\n\tint lo, hi;\n\n\tif (max_keyrepeat_str != NULL && *max_keyrepeat_str != '\\0') {\n\t\tstr = max_keyrepeat_str;\n\t} else {\n\t\tstr = max_keyrepeat_str0;\n\t}\n\n\tif (sscanf(str, \"%d-%d\", &lo, &hi) != 2) {\n\t\trfbLog(\"skipping invalid -scr_keyrepeat string: %s\\n\", str);\n\t\tsscanf(max_keyrepeat_str0, \"%d-%d\", &lo, &hi);\n\t}\n\tmax_keyrepeat_lo = lo;\n\tmax_keyrepeat_hi = hi;\n\tif (max_keyrepeat_lo < 1) {\n\t\tmax_keyrepeat_lo = 1;\n\t}\n\tif (max_keyrepeat_hi > 40) {\n\t\tmax_keyrepeat_hi = 40;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void initialize_max_keyrepeat(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "max_keyrepeat_str0",
            "\"%d-%d\"",
            "&lo",
            "&hi"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid -scr_keyrepeat string: %s\\n\"",
            "str"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d-%d\"",
            "&lo",
            "&hi"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_max_keyrepeat(void);\n\nvoid initialize_max_keyrepeat(void) {\n\tchar *str;\n\tint lo, hi;\n\n\tif (max_keyrepeat_str != NULL && *max_keyrepeat_str != '\\0') {\n\t\tstr = max_keyrepeat_str;\n\t} else {\n\t\tstr = max_keyrepeat_str0;\n\t}\n\n\tif (sscanf(str, \"%d-%d\", &lo, &hi) != 2) {\n\t\trfbLog(\"skipping invalid -scr_keyrepeat string: %s\\n\", str);\n\t\tsscanf(max_keyrepeat_str0, \"%d-%d\", &lo, &hi);\n\t}\n\tmax_keyrepeat_lo = lo;\n\tmax_keyrepeat_hi = hi;\n\tif (max_keyrepeat_lo < 1) {\n\t\tmax_keyrepeat_lo = 1;\n\t}\n\tif (max_keyrepeat_hi > 40) {\n\t\tmax_keyrepeat_hi = 40;\n\t}\n}"
  },
  {
    "function_name": "initialize_scroll_term",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "740-763",
    "snippet": "void initialize_scroll_term(void) {\n\tchar *str;\n\tint n;\n\n\tdestroy_str_list(scroll_term);\n\tscroll_term = NULL;\n\n\tif (scroll_term_str != NULL && *scroll_term_str != '\\0') {\n\t\tstr = scroll_term_str;\n\t} else {\n\t\tstr = scroll_term_str0;\n\t}\n\tif (!strcmp(str, \"none\")) {\n\t\treturn;\n\t}\n\tscroll_term = create_str_list(str);\n\n\tn = 0;\n\twhile (scroll_term[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\t/* pull parameters out at some point */\n\t\ts = NULL;\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void initialize_scroll_term(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_str_list",
          "args": [
            "str"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "create_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "372-403",
          "snippet": "char **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int match_str_list(char *str, char **list);",
            "char **create_str_list(char *cslist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\nchar **create_str_list(char *cslist);\n\nchar **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"none\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_str_list",
          "args": [
            "scroll_term"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "632-641",
          "snippet": "static void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void destroy_str_list(char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void destroy_str_list(char **list);\n\nstatic void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_term(void);\n\nvoid initialize_scroll_term(void) {\n\tchar *str;\n\tint n;\n\n\tdestroy_str_list(scroll_term);\n\tscroll_term = NULL;\n\n\tif (scroll_term_str != NULL && *scroll_term_str != '\\0') {\n\t\tstr = scroll_term_str;\n\t} else {\n\t\tstr = scroll_term_str0;\n\t}\n\tif (!strcmp(str, \"none\")) {\n\t\treturn;\n\t}\n\tscroll_term = create_str_list(str);\n\n\tn = 0;\n\twhile (scroll_term[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\t/* pull parameters out at some point */\n\t\ts = NULL;\n\t}\n}"
  },
  {
    "function_name": "initialize_scroll_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "643-738",
    "snippet": "void initialize_scroll_matches(void) {\n\tchar *str, *imp = \"__IMPOSSIBLE_STR__\";\n\tint i, n, nkey, nmouse;\n\n\tdestroy_str_list(scroll_good_all);\n\tscroll_good_all = NULL;\n\tdestroy_str_list(scroll_good_key);\n\tscroll_good_key = NULL;\n\tdestroy_str_list(scroll_good_mouse);\n\tscroll_good_mouse = NULL;\n\n\tdestroy_str_list(scroll_skip_all);\n\tscroll_skip_all = NULL;\n\tdestroy_str_list(scroll_skip_key);\n\tscroll_skip_key = NULL;\n\tdestroy_str_list(scroll_skip_mouse);\n\tscroll_skip_mouse = NULL;\n\n\t/* scroll_good: */\n\tif (scroll_good_str != NULL && *scroll_good_str != '\\0') {\n\t\tstr = scroll_good_str;\n\t} else {\n\t\tstr = scroll_good_str0;\n\t}\n\tscroll_good_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_good_all[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_good_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_good_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_good_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_good_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_good_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_good_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_good_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t}\n\t}\n\n\t/* scroll_skip: */\n\tif (scroll_skip_str != NULL && *scroll_skip_str != '\\0') {\n\t\tstr = scroll_skip_str;\n\t} else {\n\t\tstr = scroll_skip_str0;\n\t}\n\tscroll_skip_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_skip_all[n] != NULL) {\n\t\tchar *s = scroll_skip_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_skip_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_skip_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_skip_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_skip_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_skip_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_skip_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_skip_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void initialize_scroll_matches(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "imp"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s+strlen(\"MOUSE:\")"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"MOUSE:\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"MOUSE:\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "imp"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s+strlen(\"KEY:\")"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"KEY:\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"KEY:\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nmouse*sizeof(char *)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nkey*sizeof(char *)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"MOUSE:\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"KEY:\""
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_str_list",
          "args": [
            "str"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "create_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "372-403",
          "snippet": "char **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int match_str_list(char *str, char **list);",
            "char **create_str_list(char *cslist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\nchar **create_str_list(char *cslist);\n\nchar **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "imp"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s+strlen(\"MOUSE:\")"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"MOUSE:\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"MOUSE:\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "imp"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s+strlen(\"KEY:\")"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"KEY:\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"KEY:\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nmouse*sizeof(char *)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nkey*sizeof(char *)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"MOUSE:\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"KEY:\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_str_list",
          "args": [
            "scroll_skip_mouse"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "632-641",
          "snippet": "static void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void destroy_str_list(char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void destroy_str_list(char **list);\n\nstatic void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_matches(void);\n\nvoid initialize_scroll_matches(void) {\n\tchar *str, *imp = \"__IMPOSSIBLE_STR__\";\n\tint i, n, nkey, nmouse;\n\n\tdestroy_str_list(scroll_good_all);\n\tscroll_good_all = NULL;\n\tdestroy_str_list(scroll_good_key);\n\tscroll_good_key = NULL;\n\tdestroy_str_list(scroll_good_mouse);\n\tscroll_good_mouse = NULL;\n\n\tdestroy_str_list(scroll_skip_all);\n\tscroll_skip_all = NULL;\n\tdestroy_str_list(scroll_skip_key);\n\tscroll_skip_key = NULL;\n\tdestroy_str_list(scroll_skip_mouse);\n\tscroll_skip_mouse = NULL;\n\n\t/* scroll_good: */\n\tif (scroll_good_str != NULL && *scroll_good_str != '\\0') {\n\t\tstr = scroll_good_str;\n\t} else {\n\t\tstr = scroll_good_str0;\n\t}\n\tscroll_good_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_good_all[n] != NULL) {\n\t\tchar *s = scroll_good_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_good_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_good_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_good_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_good_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_good_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_good_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_good_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_good_all[i] = strdup(imp);\n\t\t}\n\t}\n\n\t/* scroll_skip: */\n\tif (scroll_skip_str != NULL && *scroll_skip_str != '\\0') {\n\t\tstr = scroll_skip_str;\n\t} else {\n\t\tstr = scroll_skip_str0;\n\t}\n\tscroll_skip_all = create_str_list(str);\n\n\tnkey = 0;\n\tnmouse = 0;\n\tn = 0;\n\twhile (scroll_skip_all[n] != NULL) {\n\t\tchar *s = scroll_skip_all[n++];\n\t\tif (strstr(s, \"KEY:\") == s) nkey++;\n\t\tif (strstr(s, \"MOUSE:\") == s) nmouse++;\n\t}\n\tif (nkey++) {\n\t\tscroll_skip_key = (char **) malloc(nkey*sizeof(char *));\n\t\tfor (i=0; i<nkey; i++) scroll_skip_key[i] = NULL;\n\t}\n\tif (nmouse++) {\n\t\tscroll_skip_mouse = (char **) malloc(nmouse*sizeof(char *));\n\t\tfor (i=0; i<nmouse; i++) scroll_skip_mouse[i] = NULL;\n\t}\n\tnkey = 0;\n\tnmouse = 0;\n\tfor (i=0; i<n; i++) {\n\t\tchar *s = scroll_skip_all[i];\n\t\tif (strstr(s, \"KEY:\") == s) {\n\t\t\tscroll_skip_key[nkey++] = strdup(s+strlen(\"KEY:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t} else if (strstr(s, \"MOUSE:\") == s) {\n\t\t\tscroll_skip_mouse[nmouse++]=strdup(s+strlen(\"MOUSE:\"));\n\t\t\tfree(s);\n\t\t\tscroll_skip_all[i] = strdup(imp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "destroy_str_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "632-641",
    "snippet": "static void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void destroy_str_list(char **list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void destroy_str_list(char **list);\n\nstatic void destroy_str_list(char **list) {\n\tint i = 0;\n\tif (! list) {\n\t\treturn;\n\t}\n\twhile (list[i] != NULL) {\n\t\tfree(list[i++]);\n\t}\n\tfree(list);\n}"
  },
  {
    "function_name": "initialize_scroll_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "555-630",
    "snippet": "void initialize_scroll_keys(void) {\n\tchar *str, *p;\n\tint i, nkeys = 0, saw_builtin = 0;\n\tint ks_max = 2 * 0xFFFF;\n\n\tif (scroll_key_list) {\n\t\tfree(scroll_key_list);\n\t\tscroll_key_list = NULL;\n\t}\n\tif (! scroll_key_list_str || *scroll_key_list_str == '\\0') {\n\t\treturn;\n\t}\n\n\tif (strstr(scroll_key_list_str, \"builtin\")) {\n\t\tint k;\n\t\t/* add in number of keysyms builtin gives */\n\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\tnkeys++;\n\t\t\t}\n\t\t}\n\t}\n\n\tnkeys++;\t/* first key, i.e. no commas. */\n\tp = str = strdup(scroll_key_list_str);\n\twhile(*p) {\n\t\tif (*p == ',') {\n\t\t\tnkeys++;\t/* additional key. */\n\t\t}\n\t\tp++;\n\t}\n\t\n\tnkeys++;\t/* exclude/include 0 element */\n\tnkeys++;\t/* trailing NoSymbol */\n\n\tscroll_key_list = (KeySym *) malloc(nkeys*sizeof(KeySym)); \n\tfor (i=0; i<nkeys; i++) {\n\t\tscroll_key_list[i] = NoSymbol;\n\t}\n\tif (*str == '-') {\n\t\tscroll_key_list[0] = 1;\n\t\tp = strtok(str+1, \",\");\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\ti = 1;\n\twhile (p) {\n\t\tif (!strcmp(p, \"builtin\")) {\n\t\t\tint k;\n\t\t\tif (saw_builtin) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_builtin = 1;\n\t\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\t\tscroll_key_list[i++] = (rfbKeySym) k;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int in;\n\t\t\tif (sscanf(p, \"%u\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (XStringToKeysym(p) != NoSymbol) { \n\t\t\t\tscroll_key_list[i++] = XStringToKeysym(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"initialize_scroll_keys: skip unknown \"\n\t\t\t\t    \"keysym: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void initialize_scroll_keys(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_scroll_keys: skip unknown \"\n\t\t\t\t    \"keysym: %s\\n\"",
            "p"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XStringToKeysym",
          "args": [
            "p"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "XStringToKeysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "88-1446",
          "snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"0x%x\"",
            "&in"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%u\"",
            "&in"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrecord_scroll_keysym",
          "args": [
            "(rfbKeySym) k"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_scroll_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "443-464",
          "snippet": "int xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecord_skip_keysym(rfbKeySym keysym);",
            "int xrecord_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nint xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"builtin\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str+1",
            "\",\""
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nkeys*sizeof(KeySym)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "scroll_key_list_str"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "scroll_key_list_str",
            "\"builtin\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid initialize_scroll_keys(void);\n\nvoid initialize_scroll_keys(void) {\n\tchar *str, *p;\n\tint i, nkeys = 0, saw_builtin = 0;\n\tint ks_max = 2 * 0xFFFF;\n\n\tif (scroll_key_list) {\n\t\tfree(scroll_key_list);\n\t\tscroll_key_list = NULL;\n\t}\n\tif (! scroll_key_list_str || *scroll_key_list_str == '\\0') {\n\t\treturn;\n\t}\n\n\tif (strstr(scroll_key_list_str, \"builtin\")) {\n\t\tint k;\n\t\t/* add in number of keysyms builtin gives */\n\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\tnkeys++;\n\t\t\t}\n\t\t}\n\t}\n\n\tnkeys++;\t/* first key, i.e. no commas. */\n\tp = str = strdup(scroll_key_list_str);\n\twhile(*p) {\n\t\tif (*p == ',') {\n\t\t\tnkeys++;\t/* additional key. */\n\t\t}\n\t\tp++;\n\t}\n\t\n\tnkeys++;\t/* exclude/include 0 element */\n\tnkeys++;\t/* trailing NoSymbol */\n\n\tscroll_key_list = (KeySym *) malloc(nkeys*sizeof(KeySym)); \n\tfor (i=0; i<nkeys; i++) {\n\t\tscroll_key_list[i] = NoSymbol;\n\t}\n\tif (*str == '-') {\n\t\tscroll_key_list[0] = 1;\n\t\tp = strtok(str+1, \",\");\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\ti = 1;\n\twhile (p) {\n\t\tif (!strcmp(p, \"builtin\")) {\n\t\t\tint k;\n\t\t\tif (saw_builtin) {\n\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsaw_builtin = 1;\n\t\t\tfor (k=1; k<ks_max; k++)  {\n\t\t\t\tif (xrecord_scroll_keysym((rfbKeySym) k)) {\n\t\t\t\t\tscroll_key_list[i++] = (rfbKeySym) k;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int in;\n\t\t\tif (sscanf(p, \"%u\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\t\tscroll_key_list[i++] = (rfbKeySym) in;\n\t\t\t} else if (XStringToKeysym(p) != NoSymbol) { \n\t\t\t\tscroll_key_list[i++] = XStringToKeysym(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"initialize_scroll_keys: skip unknown \"\n\t\t\t\t    \"keysym: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}"
  },
  {
    "function_name": "set_scrollcopyrect_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "528-553",
    "snippet": "void set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "orig"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unknown -scrollcopyrect mode: %s, using: %s\\n\"",
            "str",
            "scroll_copyrect"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "scroll_copyrect_default"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"never\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"none\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"never\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"mouse\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"pointer\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"mouse\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"keys\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"keyboard\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"keys\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"always\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"both\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"always\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "scroll_copyrect_default"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_scrollcopyrect_mode(char *str) {\n\tchar *orig = scroll_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\") ||\n\t\t    !strcmp(str, \"both\")) {\n\t\tscroll_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"keys\") || !strcmp(str, \"keyboard\")) {\n\t\tscroll_copyrect = strdup(\"keys\");\n\t} else if (!strcmp(str, \"mouse\") || !strcmp(str, \"pointer\")) {\n\t\tscroll_copyrect = strdup(\"mouse\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\tscroll_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! scroll_copyrect) {\n\t\t\tscroll_copyrect = strdup(scroll_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -scrollcopyrect mode: %s, using: %s\\n\", str,\n\t\t    scroll_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
  },
  {
    "function_name": "set_wirecopyrect_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "501-523",
    "snippet": "void set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
      "int check_ncache(int reset, int mode);",
      "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "orig"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unknown -wirecopyrect mode: %s, using: %s\\n\"",
            "str",
            "wireframe_copyrect"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "wireframe_copyrect_default"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"never\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"none\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"never\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"top\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"top\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"always\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"always\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "wireframe_copyrect_default"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\n\nvoid set_wirecopyrect_mode(char *str) {\n\tchar *orig = wireframe_copyrect;\n\tif (str == NULL || *str == '\\0') {\n\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t} else if (!strcmp(str, \"always\") || !strcmp(str, \"all\")) {\n\t\twireframe_copyrect = strdup(\"always\");\n\t} else if (!strcmp(str, \"top\")) {\n\t\twireframe_copyrect = strdup(\"top\");\n\t} else if (!strcmp(str, \"never\") || !strcmp(str, \"none\")) {\n\t\twireframe_copyrect = strdup(\"never\");\n\t} else {\n\t\tif (! wireframe_copyrect) {\n\t\t\twireframe_copyrect = strdup(wireframe_copyrect_default);\n\t\t} else {\n\t\t\torig = NULL;\n\t\t}\n\t\trfbLog(\"unknown -wirecopyrect mode: %s, using: %s\\n\", str,\n\t\t    wireframe_copyrect);\n\t}\n\tif (orig) {\n\t\tfree(orig);\n\t}\n}"
  },
  {
    "function_name": "parse_wireframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "490-496",
    "snippet": "void parse_wireframe(void) {\n\tparse_wireframe_str(WIREFRAME_PARMS);\n\tif (! wireframe_str) {\n\t\twireframe_str = strdup(WIREFRAME_PARMS);\n\t}\n\tparse_wireframe_str(wireframe_str);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void parse_wireframe(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_wireframe_str",
          "args": [
            "wireframe_str"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "parse_wireframe_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "334-485",
          "snippet": "static void parse_wireframe_str(char *wf) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (wf == NULL || *wf == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(wf);\n\n\t/* leading \",\", make it start with ignorable string \"z\" */\n\tif (*str == ',') {\n\t\tchar *tmp = (char *) malloc(strlen(str)+2);\t\n\t\tstrcpy(tmp, \"z\");\n\t\tstrcat(tmp, str);\n\t\tfree(str);\n\t\tstr = tmp;\n\t}\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/* Wireframe shade, color, RGB: */\n\tif ((str = part[0]) != NULL) {\n\t\tunsigned long n;\n\t\tint r, g, b, ok = 0;\n\t\tXColor cdef;\n\t\tColormap cmap;\n\t\tif (dpy && (bpp == 32 || bpp == 16)) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t \tcmap = DefaultColormap (dpy, scr);\n\t\t\tif (XParseColor(dpy, cmap, str, &cdef) &&\n\t\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\t\tr = cdef.red   >> 8;\n\t\t\t\tg = cdef.green >> 8;\n\t\t\t\tb = cdef.blue  >> 8;\n\t\t\t\tif (r == 0 && g == 0) {\n\t\t\t\t\tg = 1;\t/* need to be > 255 */\n\t\t\t\t}\n\t\t\t\tn = 0;\n\t\t\t\tn |= (r << main_red_shift);\n\t\t\t\tn |= (g << main_green_shift);\n\t\t\t\tn |= (b << main_blue_shift);\n\t\t\t\twireframe_shade = n;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tX_UNLOCK;\n#else\n\t\t\tr = g = b = 0;\n\t\t\tcmap = 0;\n\t\t\tcdef.pixel = 0;\n#endif\n\t\t}\n\t\tif (ok) {\n\t\t\t;\n\t\t} else if (sscanf(str, \"0x%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lu\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t}\n\t}\n\n\t/* linewidth: # of pixels wide for the wireframe lines */\n\tif ((str = part[1]) != NULL) {\n\t\tint n;\n\t\tif (sscanf(str, \"%d\", &n) == 1) {\n\t\t\twireframe_lw = n;\t\n\t\t\tif (wireframe_lw < 1) {\n\t\t\t\twireframe_lw = 1; \n\t\t\t}\n\t\t\tif (wireframe_lw > LW_MAX) {\n\t\t\t\twireframe_lw = LW_MAX; \n\t\t\t}\n\t\t}\n\t}\n\n\t/* percentage cutoff for opaque move/resize (like WM's) */\n\tif ((str = part[2]) != NULL) {\n\t\tif (*str == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(str, '.')) {\n\t\t\twireframe_frac = atof(str);\n\t\t} else {\n\t\t\twireframe_frac = ((double) atoi(str))/100.0;\n\t\t}\n\t}\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances to guess the wm frame is\n\t * being grabbed (Top is traditionally bigger, i.e. titlebar):\n\t */\n\tif ((str = part[3]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\twireframe_top   = t;\n\t\t\twireframe_bot   = b;\n\t\t\twireframe_left  = l;\n\t\t\twireframe_right = r;\n\t\t}\n\t}\n\n\t/*\n\t * wireframe in interior with Modifier down.\n\t * 0 => no mods\n\t * 1 => all mods\n\t * Shift,Alt,Control,Meta,Super,Hyper\n\t */\n\tif (wireframe_mods) {\n\t\tfree(wireframe_mods);\n\t}\n\twireframe_mods = NULL;\n\tif ((str = part[4]) != NULL) {\n\t\tif (*str == '0' || !strcmp(str, \"none\")) {\n\t\t\t;\n\t\t} else if (*str == '1' || !strcmp(str, \"all\")) {\n\t\t\twireframe_mods = strdup(\"all\");\t\n\t\t} else if (!strcmp(str, \"Alt\") || !strcmp(str, \"Shift\")\n\t\t    || !strcmp(str, \"Control\") || !strcmp(str, \"Meta\")\n\t\t    || !strcmp(str, \"Super\") || !strcmp(str, \"Hyper\")) {\n\t\t\twireframe_mods = strdup(str);\n\t\t}\n\t}\n\n\t/* check_wireframe() timing heuristics. */\n\tif ((str = part[5]) != NULL) {\n\t\tdouble t1, t2, t3, t4;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4) == 4) {\n\t\t\twireframe_t1 = t1;\n\t\t\twireframe_t2 = t2;\n\t\t\twireframe_t3 = t3;\n\t\t\twireframe_t4 = t4;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define LW_MAX 8"
          ],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "int check_wireframe(void);",
            "static void parse_scroll_copyrect_str(char *scr);",
            "static void parse_wireframe_str(char *wf);",
            "static unsigned long wireframe_shade = 0xff;",
            "static int wireframe_lw;",
            "static double wireframe_frac;",
            "static int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;",
            "static double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;",
            "static char *wireframe_mods = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define LW_MAX 8\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nint check_wireframe(void);\nstatic void parse_scroll_copyrect_str(char *scr);\nstatic void parse_wireframe_str(char *wf);\nstatic unsigned long wireframe_shade = 0xff;\nstatic int wireframe_lw;\nstatic double wireframe_frac;\nstatic int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;\nstatic double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;\nstatic char *wireframe_mods = NULL;\n\nstatic void parse_wireframe_str(char *wf) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (wf == NULL || *wf == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(wf);\n\n\t/* leading \",\", make it start with ignorable string \"z\" */\n\tif (*str == ',') {\n\t\tchar *tmp = (char *) malloc(strlen(str)+2);\t\n\t\tstrcpy(tmp, \"z\");\n\t\tstrcat(tmp, str);\n\t\tfree(str);\n\t\tstr = tmp;\n\t}\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/* Wireframe shade, color, RGB: */\n\tif ((str = part[0]) != NULL) {\n\t\tunsigned long n;\n\t\tint r, g, b, ok = 0;\n\t\tXColor cdef;\n\t\tColormap cmap;\n\t\tif (dpy && (bpp == 32 || bpp == 16)) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t \tcmap = DefaultColormap (dpy, scr);\n\t\t\tif (XParseColor(dpy, cmap, str, &cdef) &&\n\t\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\t\tr = cdef.red   >> 8;\n\t\t\t\tg = cdef.green >> 8;\n\t\t\t\tb = cdef.blue  >> 8;\n\t\t\t\tif (r == 0 && g == 0) {\n\t\t\t\t\tg = 1;\t/* need to be > 255 */\n\t\t\t\t}\n\t\t\t\tn = 0;\n\t\t\t\tn |= (r << main_red_shift);\n\t\t\t\tn |= (g << main_green_shift);\n\t\t\t\tn |= (b << main_blue_shift);\n\t\t\t\twireframe_shade = n;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tX_UNLOCK;\n#else\n\t\t\tr = g = b = 0;\n\t\t\tcmap = 0;\n\t\t\tcdef.pixel = 0;\n#endif\n\t\t}\n\t\tif (ok) {\n\t\t\t;\n\t\t} else if (sscanf(str, \"0x%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lu\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t}\n\t}\n\n\t/* linewidth: # of pixels wide for the wireframe lines */\n\tif ((str = part[1]) != NULL) {\n\t\tint n;\n\t\tif (sscanf(str, \"%d\", &n) == 1) {\n\t\t\twireframe_lw = n;\t\n\t\t\tif (wireframe_lw < 1) {\n\t\t\t\twireframe_lw = 1; \n\t\t\t}\n\t\t\tif (wireframe_lw > LW_MAX) {\n\t\t\t\twireframe_lw = LW_MAX; \n\t\t\t}\n\t\t}\n\t}\n\n\t/* percentage cutoff for opaque move/resize (like WM's) */\n\tif ((str = part[2]) != NULL) {\n\t\tif (*str == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(str, '.')) {\n\t\t\twireframe_frac = atof(str);\n\t\t} else {\n\t\t\twireframe_frac = ((double) atoi(str))/100.0;\n\t\t}\n\t}\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances to guess the wm frame is\n\t * being grabbed (Top is traditionally bigger, i.e. titlebar):\n\t */\n\tif ((str = part[3]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\twireframe_top   = t;\n\t\t\twireframe_bot   = b;\n\t\t\twireframe_left  = l;\n\t\t\twireframe_right = r;\n\t\t}\n\t}\n\n\t/*\n\t * wireframe in interior with Modifier down.\n\t * 0 => no mods\n\t * 1 => all mods\n\t * Shift,Alt,Control,Meta,Super,Hyper\n\t */\n\tif (wireframe_mods) {\n\t\tfree(wireframe_mods);\n\t}\n\twireframe_mods = NULL;\n\tif ((str = part[4]) != NULL) {\n\t\tif (*str == '0' || !strcmp(str, \"none\")) {\n\t\t\t;\n\t\t} else if (*str == '1' || !strcmp(str, \"all\")) {\n\t\t\twireframe_mods = strdup(\"all\");\t\n\t\t} else if (!strcmp(str, \"Alt\") || !strcmp(str, \"Shift\")\n\t\t    || !strcmp(str, \"Control\") || !strcmp(str, \"Meta\")\n\t\t    || !strcmp(str, \"Super\") || !strcmp(str, \"Hyper\")) {\n\t\t\twireframe_mods = strdup(str);\n\t\t}\n\t}\n\n\t/* check_wireframe() timing heuristics. */\n\tif ((str = part[5]) != NULL) {\n\t\tdouble t1, t2, t3, t4;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4) == 4) {\n\t\t\twireframe_t1 = t1;\n\t\t\twireframe_t2 = t2;\n\t\t\twireframe_t3 = t3;\n\t\t\twireframe_t4 = t4;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "WIREFRAME_PARMS"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_wireframe(void);\n\nvoid parse_wireframe(void) {\n\tparse_wireframe_str(WIREFRAME_PARMS);\n\tif (! wireframe_str) {\n\t\twireframe_str = strdup(WIREFRAME_PARMS);\n\t}\n\tparse_wireframe_str(wireframe_str);\n}"
  },
  {
    "function_name": "parse_wireframe_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "334-485",
    "snippet": "static void parse_wireframe_str(char *wf) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (wf == NULL || *wf == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(wf);\n\n\t/* leading \",\", make it start with ignorable string \"z\" */\n\tif (*str == ',') {\n\t\tchar *tmp = (char *) malloc(strlen(str)+2);\t\n\t\tstrcpy(tmp, \"z\");\n\t\tstrcat(tmp, str);\n\t\tfree(str);\n\t\tstr = tmp;\n\t}\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/* Wireframe shade, color, RGB: */\n\tif ((str = part[0]) != NULL) {\n\t\tunsigned long n;\n\t\tint r, g, b, ok = 0;\n\t\tXColor cdef;\n\t\tColormap cmap;\n\t\tif (dpy && (bpp == 32 || bpp == 16)) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t \tcmap = DefaultColormap (dpy, scr);\n\t\t\tif (XParseColor(dpy, cmap, str, &cdef) &&\n\t\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\t\tr = cdef.red   >> 8;\n\t\t\t\tg = cdef.green >> 8;\n\t\t\t\tb = cdef.blue  >> 8;\n\t\t\t\tif (r == 0 && g == 0) {\n\t\t\t\t\tg = 1;\t/* need to be > 255 */\n\t\t\t\t}\n\t\t\t\tn = 0;\n\t\t\t\tn |= (r << main_red_shift);\n\t\t\t\tn |= (g << main_green_shift);\n\t\t\t\tn |= (b << main_blue_shift);\n\t\t\t\twireframe_shade = n;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tX_UNLOCK;\n#else\n\t\t\tr = g = b = 0;\n\t\t\tcmap = 0;\n\t\t\tcdef.pixel = 0;\n#endif\n\t\t}\n\t\tif (ok) {\n\t\t\t;\n\t\t} else if (sscanf(str, \"0x%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lu\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t}\n\t}\n\n\t/* linewidth: # of pixels wide for the wireframe lines */\n\tif ((str = part[1]) != NULL) {\n\t\tint n;\n\t\tif (sscanf(str, \"%d\", &n) == 1) {\n\t\t\twireframe_lw = n;\t\n\t\t\tif (wireframe_lw < 1) {\n\t\t\t\twireframe_lw = 1; \n\t\t\t}\n\t\t\tif (wireframe_lw > LW_MAX) {\n\t\t\t\twireframe_lw = LW_MAX; \n\t\t\t}\n\t\t}\n\t}\n\n\t/* percentage cutoff for opaque move/resize (like WM's) */\n\tif ((str = part[2]) != NULL) {\n\t\tif (*str == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(str, '.')) {\n\t\t\twireframe_frac = atof(str);\n\t\t} else {\n\t\t\twireframe_frac = ((double) atoi(str))/100.0;\n\t\t}\n\t}\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances to guess the wm frame is\n\t * being grabbed (Top is traditionally bigger, i.e. titlebar):\n\t */\n\tif ((str = part[3]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\twireframe_top   = t;\n\t\t\twireframe_bot   = b;\n\t\t\twireframe_left  = l;\n\t\t\twireframe_right = r;\n\t\t}\n\t}\n\n\t/*\n\t * wireframe in interior with Modifier down.\n\t * 0 => no mods\n\t * 1 => all mods\n\t * Shift,Alt,Control,Meta,Super,Hyper\n\t */\n\tif (wireframe_mods) {\n\t\tfree(wireframe_mods);\n\t}\n\twireframe_mods = NULL;\n\tif ((str = part[4]) != NULL) {\n\t\tif (*str == '0' || !strcmp(str, \"none\")) {\n\t\t\t;\n\t\t} else if (*str == '1' || !strcmp(str, \"all\")) {\n\t\t\twireframe_mods = strdup(\"all\");\t\n\t\t} else if (!strcmp(str, \"Alt\") || !strcmp(str, \"Shift\")\n\t\t    || !strcmp(str, \"Control\") || !strcmp(str, \"Meta\")\n\t\t    || !strcmp(str, \"Super\") || !strcmp(str, \"Hyper\")) {\n\t\t\twireframe_mods = strdup(str);\n\t\t}\n\t}\n\n\t/* check_wireframe() timing heuristics. */\n\tif ((str = part[5]) != NULL) {\n\t\tdouble t1, t2, t3, t4;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4) == 4) {\n\t\t\twireframe_t1 = t1;\n\t\t\twireframe_t2 = t2;\n\t\t\twireframe_t3 = t3;\n\t\t\twireframe_t4 = t4;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define LW_MAX 8"
    ],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "int check_wireframe(void);",
      "static void parse_scroll_copyrect_str(char *scr);",
      "static void parse_wireframe_str(char *wf);",
      "static unsigned long wireframe_shade = 0xff;",
      "static int wireframe_lw;",
      "static double wireframe_frac;",
      "static int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;",
      "static double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;",
      "static char *wireframe_mods = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "part[i]"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lf+%lf+%lf+%lf\"",
            "&t1",
            "&t2",
            "&t3",
            "&t4"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Hyper\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Super\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Meta\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Control\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Shift\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Alt\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"all\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"none\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d+%d+%d+%d\"",
            "&t",
            "&b",
            "&l",
            "&r"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "str"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'.'"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d\"",
            "&n"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lx\"",
            "&n"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lu\"",
            "&n"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"0x%lx\"",
            "&n"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocColor",
          "args": [
            "dpy",
            "cmap",
            "&cdef"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XParseColor",
          "args": [
            "dpy",
            "cmap",
            "str",
            "&cdef"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultColormap",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "str"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"z\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(str)+2"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "wf"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define LW_MAX 8\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nint check_wireframe(void);\nstatic void parse_scroll_copyrect_str(char *scr);\nstatic void parse_wireframe_str(char *wf);\nstatic unsigned long wireframe_shade = 0xff;\nstatic int wireframe_lw;\nstatic double wireframe_frac;\nstatic int wireframe_top, wireframe_bot, wireframe_left, wireframe_right;\nstatic double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;\nstatic char *wireframe_mods = NULL;\n\nstatic void parse_wireframe_str(char *wf) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (wf == NULL || *wf == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(wf);\n\n\t/* leading \",\", make it start with ignorable string \"z\" */\n\tif (*str == ',') {\n\t\tchar *tmp = (char *) malloc(strlen(str)+2);\t\n\t\tstrcpy(tmp, \"z\");\n\t\tstrcat(tmp, str);\n\t\tfree(str);\n\t\tstr = tmp;\n\t}\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/* Wireframe shade, color, RGB: */\n\tif ((str = part[0]) != NULL) {\n\t\tunsigned long n;\n\t\tint r, g, b, ok = 0;\n\t\tXColor cdef;\n\t\tColormap cmap;\n\t\tif (dpy && (bpp == 32 || bpp == 16)) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t \tcmap = DefaultColormap (dpy, scr);\n\t\t\tif (XParseColor(dpy, cmap, str, &cdef) &&\n\t\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\t\tr = cdef.red   >> 8;\n\t\t\t\tg = cdef.green >> 8;\n\t\t\t\tb = cdef.blue  >> 8;\n\t\t\t\tif (r == 0 && g == 0) {\n\t\t\t\t\tg = 1;\t/* need to be > 255 */\n\t\t\t\t}\n\t\t\t\tn = 0;\n\t\t\t\tn |= (r << main_red_shift);\n\t\t\t\tn |= (g << main_green_shift);\n\t\t\t\tn |= (b << main_blue_shift);\n\t\t\t\twireframe_shade = n;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tX_UNLOCK;\n#else\n\t\t\tr = g = b = 0;\n\t\t\tcmap = 0;\n\t\t\tcdef.pixel = 0;\n#endif\n\t\t}\n\t\tif (ok) {\n\t\t\t;\n\t\t} else if (sscanf(str, \"0x%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lu\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t} else if (sscanf(str, \"%lx\", &n) == 1) {\n\t\t\twireframe_shade = n;\t\n\t\t}\n\t}\n\n\t/* linewidth: # of pixels wide for the wireframe lines */\n\tif ((str = part[1]) != NULL) {\n\t\tint n;\n\t\tif (sscanf(str, \"%d\", &n) == 1) {\n\t\t\twireframe_lw = n;\t\n\t\t\tif (wireframe_lw < 1) {\n\t\t\t\twireframe_lw = 1; \n\t\t\t}\n\t\t\tif (wireframe_lw > LW_MAX) {\n\t\t\t\twireframe_lw = LW_MAX; \n\t\t\t}\n\t\t}\n\t}\n\n\t/* percentage cutoff for opaque move/resize (like WM's) */\n\tif ((str = part[2]) != NULL) {\n\t\tif (*str == '\\0') {\n\t\t\t;\n\t\t} else if (strchr(str, '.')) {\n\t\t\twireframe_frac = atof(str);\n\t\t} else {\n\t\t\twireframe_frac = ((double) atoi(str))/100.0;\n\t\t}\n\t}\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances to guess the wm frame is\n\t * being grabbed (Top is traditionally bigger, i.e. titlebar):\n\t */\n\tif ((str = part[3]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\twireframe_top   = t;\n\t\t\twireframe_bot   = b;\n\t\t\twireframe_left  = l;\n\t\t\twireframe_right = r;\n\t\t}\n\t}\n\n\t/*\n\t * wireframe in interior with Modifier down.\n\t * 0 => no mods\n\t * 1 => all mods\n\t * Shift,Alt,Control,Meta,Super,Hyper\n\t */\n\tif (wireframe_mods) {\n\t\tfree(wireframe_mods);\n\t}\n\twireframe_mods = NULL;\n\tif ((str = part[4]) != NULL) {\n\t\tif (*str == '0' || !strcmp(str, \"none\")) {\n\t\t\t;\n\t\t} else if (*str == '1' || !strcmp(str, \"all\")) {\n\t\t\twireframe_mods = strdup(\"all\");\t\n\t\t} else if (!strcmp(str, \"Alt\") || !strcmp(str, \"Shift\")\n\t\t    || !strcmp(str, \"Control\") || !strcmp(str, \"Meta\")\n\t\t    || !strcmp(str, \"Super\") || !strcmp(str, \"Hyper\")) {\n\t\t\twireframe_mods = strdup(str);\n\t\t}\n\t}\n\n\t/* check_wireframe() timing heuristics. */\n\tif ((str = part[5]) != NULL) {\n\t\tdouble t1, t2, t3, t4;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4) == 4) {\n\t\t\twireframe_t1 = t1;\n\t\t\twireframe_t2 = t2;\n\t\t\twireframe_t3 = t3;\n\t\t\twireframe_t4 = t4;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}"
  },
  {
    "function_name": "parse_fixscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "282-316",
    "snippet": "void parse_fixscreen(void) {\n\tchar *str, *p;\n\n\tscreen_fixup_V = 0.0;\n\tscreen_fixup_C = 0.0;\n\tscreen_fixup_X = 0.0;\n\tscreen_fixup_8 = 0.0;\n\n\tif (! screen_fixup_str) {\n\t\treturn;\n\t}\n\n\tstr = strdup(screen_fixup_str);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tdouble t;\n\t\tif (*p == 'V' && sscanf(p, \"V=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_V = t;\n\t\t} else if (*p == 'C' && sscanf(p, \"C=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_C = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"X=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_X = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"8=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_8 = t;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (screen_fixup_V < 0.0) screen_fixup_V = 0.0;\n\tif (screen_fixup_C < 0.0) screen_fixup_C = 0.0;\n\tif (screen_fixup_X < 0.0) screen_fixup_X = 0.0;\n\tif (screen_fixup_8 < 0.0) screen_fixup_8 = 0.0;\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void parse_fixscreen(void);",
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"8=%lf\"",
            "&t"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"X=%lf\"",
            "&t"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"C=%lf\"",
            "&t"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"V=%lf\"",
            "&t"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "screen_fixup_str"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_fixscreen(void);\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\n\nvoid parse_fixscreen(void) {\n\tchar *str, *p;\n\n\tscreen_fixup_V = 0.0;\n\tscreen_fixup_C = 0.0;\n\tscreen_fixup_X = 0.0;\n\tscreen_fixup_8 = 0.0;\n\n\tif (! screen_fixup_str) {\n\t\treturn;\n\t}\n\n\tstr = strdup(screen_fixup_str);\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tdouble t;\n\t\tif (*p == 'V' && sscanf(p, \"V=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_V = t;\n\t\t} else if (*p == 'C' && sscanf(p, \"C=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_C = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"X=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_X = t;\n\t\t} else if (*p == 'X' && sscanf(p, \"8=%lf\", &t) == 1) {\n\t\t\tscreen_fixup_8 = t;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tif (screen_fixup_V < 0.0) screen_fixup_V = 0.0;\n\tif (screen_fixup_C < 0.0) screen_fixup_C = 0.0;\n\tif (screen_fixup_X < 0.0) screen_fixup_X = 0.0;\n\tif (screen_fixup_8 < 0.0) screen_fixup_8 = 0.0;\n}"
  },
  {
    "function_name": "parse_scroll_copyrect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "274-280",
    "snippet": "void parse_scroll_copyrect(void) {\n\tparse_scroll_copyrect_str(SCROLL_COPYRECT_PARMS);\n\tif (! scroll_copyrect_str) {\n\t\tscroll_copyrect_str = strdup(SCROLL_COPYRECT_PARMS);\n\t}\n\tparse_scroll_copyrect_str(scroll_copyrect_str);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void parse_scroll_copyrect(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_scroll_copyrect_str",
          "args": [
            "scroll_copyrect_str"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scroll_copyrect_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "209-272",
          "snippet": "static void parse_scroll_copyrect_str(char *scr) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (scr == NULL || *scr == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(scr);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances for scrollbar locations.\n\t */\n\tif ((str = part[0]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\tscrollcopyrect_top   = t;\n\t\t\tscrollcopyrect_bot   = b;\n\t\t\tscrollcopyrect_left  = l;\n\t\t\tscrollcopyrect_right = r;\n\t\t}\n\t}\n\n\t/* key scrolling timing heuristics. */\n\tif ((str = part[1]) != NULL) {\n\t\tdouble t1, t2, t3;\n\t\tif (sscanf(str, \"%lf+%lf+%lf\", &t1, &t2, &t3) == 3) {\n\t\t\tscr_key_time = t1;\n\t\t\tscr_key_persist = t2;\n\t\t\tscr_key_bdpush_time = t3;\n\t\t}\n\t}\n\n\t/* mouse scrolling timing heuristics. */\n\tif ((str = part[2]) != NULL) {\n\t\tdouble t1, t2, t3, t4, t5;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4,\n\t\t    &t5) == 5) {\n\t\t\tscr_mouse_time = t1;\n\t\t\tscr_mouse_persist = t2;\n\t\t\tscr_mouse_bdpush_time = t3;\n\t\t\tscr_mouse_pointer_delay = t4;\n\t\t\tscr_mouse_maxtime = t5;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_wirecopyrect_mode(char *str);",
            "void set_scrollcopyrect_mode(char *str);",
            "static void parse_scroll_copyrect_str(char *scr);",
            "static int scrollcopyrect_top, scrollcopyrect_bot;",
            "static int scrollcopyrect_left, scrollcopyrect_right;",
            "static double scr_key_time, scr_key_persist;",
            "static double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;",
            "static double scr_mouse_pointer_delay;",
            "static double scr_key_bdpush_time, scr_mouse_bdpush_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nstatic void parse_scroll_copyrect_str(char *scr);\nstatic int scrollcopyrect_top, scrollcopyrect_bot;\nstatic int scrollcopyrect_left, scrollcopyrect_right;\nstatic double scr_key_time, scr_key_persist;\nstatic double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;\nstatic double scr_mouse_pointer_delay;\nstatic double scr_key_bdpush_time, scr_mouse_bdpush_time;\n\nstatic void parse_scroll_copyrect_str(char *scr) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (scr == NULL || *scr == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(scr);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances for scrollbar locations.\n\t */\n\tif ((str = part[0]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\tscrollcopyrect_top   = t;\n\t\t\tscrollcopyrect_bot   = b;\n\t\t\tscrollcopyrect_left  = l;\n\t\t\tscrollcopyrect_right = r;\n\t\t}\n\t}\n\n\t/* key scrolling timing heuristics. */\n\tif ((str = part[1]) != NULL) {\n\t\tdouble t1, t2, t3;\n\t\tif (sscanf(str, \"%lf+%lf+%lf\", &t1, &t2, &t3) == 3) {\n\t\t\tscr_key_time = t1;\n\t\t\tscr_key_persist = t2;\n\t\t\tscr_key_bdpush_time = t3;\n\t\t}\n\t}\n\n\t/* mouse scrolling timing heuristics. */\n\tif ((str = part[2]) != NULL) {\n\t\tdouble t1, t2, t3, t4, t5;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4,\n\t\t    &t5) == 5) {\n\t\t\tscr_mouse_time = t1;\n\t\t\tscr_mouse_persist = t2;\n\t\t\tscr_mouse_bdpush_time = t3;\n\t\t\tscr_mouse_pointer_delay = t4;\n\t\t\tscr_mouse_maxtime = t5;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "SCROLL_COPYRECT_PARMS"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid parse_scroll_copyrect(void);\n\nvoid parse_scroll_copyrect(void) {\n\tparse_scroll_copyrect_str(SCROLL_COPYRECT_PARMS);\n\tif (! scroll_copyrect_str) {\n\t\tscroll_copyrect_str = strdup(SCROLL_COPYRECT_PARMS);\n\t}\n\tparse_scroll_copyrect_str(scroll_copyrect_str);\n}"
  },
  {
    "function_name": "parse_scroll_copyrect_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "209-272",
    "snippet": "static void parse_scroll_copyrect_str(char *scr) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (scr == NULL || *scr == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(scr);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances for scrollbar locations.\n\t */\n\tif ((str = part[0]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\tscrollcopyrect_top   = t;\n\t\t\tscrollcopyrect_bot   = b;\n\t\t\tscrollcopyrect_left  = l;\n\t\t\tscrollcopyrect_right = r;\n\t\t}\n\t}\n\n\t/* key scrolling timing heuristics. */\n\tif ((str = part[1]) != NULL) {\n\t\tdouble t1, t2, t3;\n\t\tif (sscanf(str, \"%lf+%lf+%lf\", &t1, &t2, &t3) == 3) {\n\t\t\tscr_key_time = t1;\n\t\t\tscr_key_persist = t2;\n\t\t\tscr_key_bdpush_time = t3;\n\t\t}\n\t}\n\n\t/* mouse scrolling timing heuristics. */\n\tif ((str = part[2]) != NULL) {\n\t\tdouble t1, t2, t3, t4, t5;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4,\n\t\t    &t5) == 5) {\n\t\t\tscr_mouse_time = t1;\n\t\t\tscr_mouse_persist = t2;\n\t\t\tscr_mouse_bdpush_time = t3;\n\t\t\tscr_mouse_pointer_delay = t4;\n\t\t\tscr_mouse_maxtime = t5;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_wirecopyrect_mode(char *str);",
      "void set_scrollcopyrect_mode(char *str);",
      "static void parse_scroll_copyrect_str(char *scr);",
      "static int scrollcopyrect_top, scrollcopyrect_bot;",
      "static int scrollcopyrect_left, scrollcopyrect_right;",
      "static double scr_key_time, scr_key_persist;",
      "static double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;",
      "static double scr_mouse_pointer_delay;",
      "static double scr_key_bdpush_time, scr_mouse_bdpush_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "part[i]"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lf+%lf+%lf+%lf+%lf\"",
            "&t1",
            "&t2",
            "&t3",
            "&t4",
            "&t5"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lf+%lf+%lf\"",
            "&t1",
            "&t2",
            "&t3"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d+%d+%d+%d\"",
            "&t",
            "&b",
            "&l",
            "&r"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "scr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_wirecopyrect_mode(char *str);\nvoid set_scrollcopyrect_mode(char *str);\nstatic void parse_scroll_copyrect_str(char *scr);\nstatic int scrollcopyrect_top, scrollcopyrect_bot;\nstatic int scrollcopyrect_left, scrollcopyrect_right;\nstatic double scr_key_time, scr_key_persist;\nstatic double scr_mouse_time, scr_mouse_persist, scr_mouse_maxtime;\nstatic double scr_mouse_pointer_delay;\nstatic double scr_key_bdpush_time, scr_mouse_bdpush_time;\n\nstatic void parse_scroll_copyrect_str(char *scr) {\n\tchar *p, *str;\n\tint i;\n\tchar *part[16];\n\n\tfor (i=0; i<16; i++) {\n\t\tpart[i] = NULL;\n\t}\n\n\tif (scr == NULL || *scr == '\\0') {\n\t\treturn;\n\t}\n\n\tstr = strdup(scr);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tpart[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t\tif (i >= 16) break;\n\t}\n\tfree(str);\n\n\n\t/*\n\t * Top, Bottom, Left, Right tolerances for scrollbar locations.\n\t */\n\tif ((str = part[0]) != NULL) {\n\t\tint t, b, l, r;\n\t\tif (sscanf(str, \"%d+%d+%d+%d\", &t, &b, &l, &r) == 4) {\n\t\t\tscrollcopyrect_top   = t;\n\t\t\tscrollcopyrect_bot   = b;\n\t\t\tscrollcopyrect_left  = l;\n\t\t\tscrollcopyrect_right = r;\n\t\t}\n\t}\n\n\t/* key scrolling timing heuristics. */\n\tif ((str = part[1]) != NULL) {\n\t\tdouble t1, t2, t3;\n\t\tif (sscanf(str, \"%lf+%lf+%lf\", &t1, &t2, &t3) == 3) {\n\t\t\tscr_key_time = t1;\n\t\t\tscr_key_persist = t2;\n\t\t\tscr_key_bdpush_time = t3;\n\t\t}\n\t}\n\n\t/* mouse scrolling timing heuristics. */\n\tif ((str = part[2]) != NULL) {\n\t\tdouble t1, t2, t3, t4, t5;\n\t\tif (sscanf(str, \"%lf+%lf+%lf+%lf+%lf\", &t1, &t2, &t3, &t4,\n\t\t    &t5) == 5) {\n\t\t\tscr_mouse_time = t1;\n\t\t\tscr_mouse_persist = t2;\n\t\t\tscr_mouse_bdpush_time = t3;\n\t\t\tscr_mouse_pointer_delay = t4;\n\t\t\tscr_mouse_maxtime = t5;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tfree(part[i]);\n}"
  },
  {
    "function_name": "get_wm_frame_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
    "lines": "138-200",
    "snippet": "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n#if !NO_X11\n\tWindow r, c;\n\tXWindowAttributes attr;\n\tBool ret;\n\tint rootx, rooty, wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_wm_frame_pos(px, py, x, y, w, h, frame, win);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tif (!px || !py || !x || !y || !w || !h || !frame || !win) {}\n\treturn 0;\n#else\n\n\n\tret = XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty, &wx, &wy,\n\t    &mask);\n\n\t*frame = c;\n\n\t/* current pointer position is returned too */\n\t*px = rootx;\n\t*py = rooty;\n\n\tif (!ret || ! c || c == rootwin) {\n\t\t/* no immediate child */\n\t\treturn 0;\n\t}\n\n\t/* child window position and size */\n\tif (! valid_window(c, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\t*x = attr.x;\n\t*y = attr.y;\n\t*w = attr.width;\n\t*h = attr.height;\n\n#if 0\n\t/* more accurate, but the animation is bogus anyway */\n\tif (attr.border_width > 0) {\n\t\t*w += 2 * attr.border_width;\n\t\t*h += 2 * attr.border_width;\n\t}\n#endif\n\n\tif (win != NULL) {\n\t\t*win = descend_pointer(5, c, NULL, 0);\n\t}\n\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"default8x16.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"cursor.h\"",
      "#include \"macosxCGS.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"8to24.h\"",
      "#include \"xrandr.h\"",
      "#include \"solid.h\"",
      "#include \"keyboard.h\"",
      "#include \"rates.h\"",
      "#include \"pointer.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"xevents.h\"",
      "#include \"win_utils.h\"",
      "#include \"xinerama.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void mark_for_xdamage(int x, int y, int w, int h);",
      "void set_xdamage_mark(int x, int y, int w, int h);",
      "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
      "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
      "int find_rect(int idx, int x, int y, int w, int h);",
      "int lookup_win_index(Window);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "descend_pointer",
          "args": [
            "5",
            "c",
            "NULL",
            "0"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "descend_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "480-598",
          "snippet": "Window descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "c",
            "&attr",
            "1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&c",
            "&rootx",
            "&rooty",
            "&wx",
            "&wy",
            "&mask"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_get_wm_frame_pos",
          "args": [
            "px",
            "py",
            "x",
            "y",
            "w",
            "h",
            "frame",
            "win"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_wm_frame_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "543-583",
          "snippet": "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint find_rect(int idx, int x, int y, int w, int h);\nint lookup_win_index(Window);\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n#if !NO_X11\n\tWindow r, c;\n\tXWindowAttributes attr;\n\tBool ret;\n\tint rootx, rooty, wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_wm_frame_pos(px, py, x, y, w, h, frame, win);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tif (!px || !py || !x || !y || !w || !h || !frame || !win) {}\n\treturn 0;\n#else\n\n\n\tret = XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty, &wx, &wy,\n\t    &mask);\n\n\t*frame = c;\n\n\t/* current pointer position is returned too */\n\t*px = rootx;\n\t*py = rooty;\n\n\tif (!ret || ! c || c == rootwin) {\n\t\t/* no immediate child */\n\t\treturn 0;\n\t}\n\n\t/* child window position and size */\n\tif (! valid_window(c, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\t*x = attr.x;\n\t*y = attr.y;\n\t*w = attr.width;\n\t*h = attr.height;\n\n#if 0\n\t/* more accurate, but the animation is bogus anyway */\n\tif (attr.border_width > 0) {\n\t\t*w += 2 * attr.border_width;\n\t\t*h += 2 * attr.border_width;\n\t}\n#endif\n\n\tif (win != NULL) {\n\t\t*win = descend_pointer(5, c, NULL, 0);\n\t}\n\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
  }
]