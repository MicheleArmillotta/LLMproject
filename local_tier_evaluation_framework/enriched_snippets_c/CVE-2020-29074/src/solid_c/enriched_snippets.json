[
  {
    "function_name": "solid_bg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1330-1425",
    "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *guess_desktop(void);",
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);",
      "static void solid_macosx(int restore);",
      "static char *last_color = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "solid_str"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "prev_str"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_root",
          "args": [
            "color"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "solid_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "177-285",
          "snippet": "XImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\n\nXImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_xfce",
          "args": [
            "color"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "solid_xfce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "768-873",
          "snippet": "static void solid_xfce(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show\";\n\tchar set_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show -s '%s'\";\n\tchar get_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style\";\n\tchar set_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style -s '%s'\";\n\n\tstatic char *orig_image_show = NULL;\n\tstatic char *orig_color_style = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_image_show) {\n\t\t\torig_image_show = \"true\";\n\t\t}\n\t\tif (! orig_color_style) {\n\t\t\torig_color_style = \"0\";\n\t\t}\n\t\tif (strstr(orig_image_show, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid image show: %s\\n\", orig_image_show);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_color_style, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color style: %s\\n\", orig_color_style);\n\t\t\treturn;\n\t\t}\n\t\tif (orig_image_show[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_image_show) - 2 + strlen(orig_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_image_show, dbus, orig_image_show);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\tif (orig_color_style[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_color_style) - 2 + strlen(orig_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_color_style, dbus, orig_color_style);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! orig_image_show) {\n\t\tchar *q;\n\t\torig_image_show = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_image_show, dbus);\n\t\t\torig_image_show = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_image_show, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_image_show returned: '%s'\\n\\n\", orig_image_show);\n\t\t\tfree(cmd);\n\t\t\tif (strcasecmp(orig_image_show, \"false\") && strcasecmp(orig_image_show, \"true\")) {\n\t\t\t\tfprintf(stderr, \"unrecognized image_show, disabling.\\n\");\n\t\t\t\tfree(orig_image_show);\n\t\t\t\torig_image_show = \"\";\n\t\t\t}\n\t\t}\n\t}\n\tif (! orig_color_style) {\n\t\tchar *q;\n\t\torig_color_style = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color_style, dbus);\n\t\t\torig_color_style = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_color_style, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_color_style returned: '%s'\\n\\n\", orig_color_style);\n\t\t\tfree(cmd);\n\t\t\tif (strlen(orig_color_style) > 1 || !isdigit((unsigned char) (*orig_color_style))) {\n\t\t\t\tfprintf(stderr, \"unrecognized color_style, disabling.\\n\");\n\t\t\t\tfree(orig_color_style);\n\t\t\t\torig_color_style = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tcmd = (char *) malloc(strlen(set_color_style) + strlen(\"0\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_color_style, dbus, \"0\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_image_show) + strlen(\"false\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_image_show, dbus, \"false\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *dbus_session(void);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_xfce(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show\";\n\tchar set_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show -s '%s'\";\n\tchar get_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style\";\n\tchar set_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style -s '%s'\";\n\n\tstatic char *orig_image_show = NULL;\n\tstatic char *orig_color_style = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_image_show) {\n\t\t\torig_image_show = \"true\";\n\t\t}\n\t\tif (! orig_color_style) {\n\t\t\torig_color_style = \"0\";\n\t\t}\n\t\tif (strstr(orig_image_show, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid image show: %s\\n\", orig_image_show);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_color_style, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color style: %s\\n\", orig_color_style);\n\t\t\treturn;\n\t\t}\n\t\tif (orig_image_show[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_image_show) - 2 + strlen(orig_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_image_show, dbus, orig_image_show);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\tif (orig_color_style[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_color_style) - 2 + strlen(orig_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_color_style, dbus, orig_color_style);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! orig_image_show) {\n\t\tchar *q;\n\t\torig_image_show = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_image_show, dbus);\n\t\t\torig_image_show = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_image_show, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_image_show returned: '%s'\\n\\n\", orig_image_show);\n\t\t\tfree(cmd);\n\t\t\tif (strcasecmp(orig_image_show, \"false\") && strcasecmp(orig_image_show, \"true\")) {\n\t\t\t\tfprintf(stderr, \"unrecognized image_show, disabling.\\n\");\n\t\t\t\tfree(orig_image_show);\n\t\t\t\torig_image_show = \"\";\n\t\t\t}\n\t\t}\n\t}\n\tif (! orig_color_style) {\n\t\tchar *q;\n\t\torig_color_style = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color_style, dbus);\n\t\t\torig_color_style = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_color_style, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_color_style returned: '%s'\\n\\n\", orig_color_style);\n\t\t\tfree(cmd);\n\t\t\tif (strlen(orig_color_style) > 1 || !isdigit((unsigned char) (*orig_color_style))) {\n\t\t\t\tfprintf(stderr, \"unrecognized color_style, disabling.\\n\");\n\t\t\t\tfree(orig_color_style);\n\t\t\t\torig_color_style = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tcmd = (char *) malloc(strlen(set_color_style) + strlen(\"0\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_color_style, dbus, \"0\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_image_show) + strlen(\"false\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_image_show, dbus, \"false\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dtname",
            "\"xfce\""
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_cde",
          "args": [
            "color"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "solid_cde",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "287-551",
          "snippet": "static void solid_cde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tint wsmax = 16;\n\tstatic XImage *image[16];\n\tstatic Window ws_wins[16];\n\tstatic int nws = -1;\n\n\tWindow expose;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tunsigned long mask, pixel;\n\tXColor cdef;\n\tColormap cmap;\n\tint n;\n\n\tRAWFB_RET_VOID\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\t\t/* restore the backdrop windows from the XImage snapshots */\n\n\t\tfor (n=0; n < nws; n++) {\n\t\t\tWindow twin;\n\n\t\t\tif (! image[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttwin = ws_wins[n];\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\t\t\tif (! valid_window(twin, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpixmap = XCreatePixmap(dpy, twin, wdpy_x, wdpy_y,\n\t\t\t    depth);\n\t\t\t\n\t\t\t/* draw the image to a pixmap: */\n\t\t\tgcv.function = GXcopy;\n\t\t\tgcv.plane_mask = AllPlanes;\n\t\t\tgc = XCreateGC(dpy, twin, GCFunction|GCPlaneMask, &gcv);\n\n\t\t\tXPutImage(dpy, pixmap, gc, image[n], 0, 0, 0, 0,\n\t\t\t    wdpy_x, wdpy_y);\n\n\t\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\t\tgc = XCreateGC(dpy, twin, GCForeground|GCBackground,\n\t\t\t    &gcv);\n\n\t\t\trfbLog(\"restoring CDE ws%d snapshot to 0x%lx\\n\",\n\t\t\t    n, twin);\n\t\t\t/* set the pixmap as the bg: */\n\t\t\tXSetWindowBackgroundPixmap(dpy, twin, pixmap);\n\t\t\tXFreePixmap(dpy, pixmap);\n\t\t\tXClearWindow(dpy, twin);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn;\n\t}\n\n\tif (nws < 0) {\n\t\t/* need to retrieve snapshots of the ws backgrounds: */\n\t\tWindow iwin, wm_win;\n\t\tXSetWindowAttributes iswa;\n\t\tAtom dt_list, wm_info, type;\n\t\tint format;\n\t\tunsigned long length, after;\n\t\tunsigned char *data;\n\t\tunsigned long *dp;\t/* crash on 64bit with int */\n\n\t\tnws = 0;\n\n\t\t/* extract the hidden wm properties about backdrops: */\n\n\t\twm_info = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\t\tif (wm_info == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, rootwin, wm_info, 0L, 10L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\t/*\n\t\t * xprop -notype -root _MOTIF_WM_INFO\n\t\t * _MOTIF_WM_INFO = 0x2, 0x580028\n\t\t */\n\n\t\tif (length < 2 || format != 32 || after != 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tdp = (unsigned long *) data;\n\t\twm_win = (Window) *(dp+1);\t/* 2nd item. */\n\n\n\t\tdt_list = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (dt_list == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, wm_win, dt_list, 0L, 10L, False,\n\t\t   AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\tnws = length;\n\n\t\tif (nws > wsmax) {\n\t\t\tnws = wsmax;\n\t\t}\n\t\tif (nws < 0) {\n\t\t\tnws = 0;\n\t\t}\n\n\t\trfbLog(\"special CDE win: 0x%lx, %d workspaces\\n\", wm_win, nws);\n\t\tif (nws == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (n=0; n<nws; n++) {\n\t\t\tAtom ws_atom;\n\t\t\tchar tmp[32];\n\t\t\tWindow twin;\n\t\t\tXWindowAttributes attr;\n\t\t\tint i, cnt;\n\n\t\t\timage[n] = NULL;\n\t\t\tws_wins[n] = 0x0;\n\n\t\t\tsprintf(tmp, \"_DT_WORKSPACE_INFO_ws%d\", n);\n\t\t\tws_atom = XInternAtom(dpy, tmp, False);\n\t\t\tif (ws_atom == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tXGetWindowProperty(dpy, wm_win, ws_atom, 0L, 100L,\n\t\t\t   False, AnyPropertyType, &type, &format, &length,\n\t\t\t   &after, &data);\n\n\t\t\tif (format != 8 || after != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * xprop -notype -id wm_win\n\t\t\t * _DT_WORKSPACE_INFO_ws0 = \"One\", \"3\", \"0x2f2f4a\",\n\t\t\t * \"0x63639c\", \"0x103\", \"1\", \"0x58044e\"\n\t\t\t */\n\n\t\t\tcnt = 0;\n\t\t\ttwin = 0x0;\n\t\t\tfor (i=0; i< (int) length; i++) {\n\t\t\t\tif (*(data+i) != '\\0') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcnt++;\t/* count nulls to indicate field */\n\t\t\t\tif (cnt == 6) {\n\t\t\t\t\t/* one past the null: */\n\t\t\t\t\tchar *q = (char *) (data+i+1);\n\t\t\t\t\tunsigned long in;\n\t\t\t\t\tif (sscanf(q, \"0x%lx\", &in) == 1) {\n\t\t\t\t\t\ttwin = (Window) in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tws_wins[n] = twin;\n\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\n\t\t\tXGetWindowAttributes(dpy, twin, &attr);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXMapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t\tXRaiseWindow(dpy, twin);\n\t\t\t}\n\t\t\tXSync(dpy, False);\n\t\t\n\t\t\t/* create image window: */\n\t\t\tiswa.override_redirect = True;\n\t\t\tiswa.backing_store = NotUseful;\n\t\t\tiswa.save_under = False;\n\t\t\tiswa.background_pixmap = ParentRelative;\n\t\t\tvisual.visualid = CopyFromParent;\n\n\t\t\tiwin = XCreateWindow(dpy, twin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    0, depth, InputOutput, &visual, mask, &iswa);\n\n\t\t\trfbLog(\"snapshotting CDE backdrop ws%d 0x%lx -> \"\n\t\t\t    \"0x%lx ...\\n\", n, twin, iwin);\n\t\t\tXMapWindow(dpy, iwin);\n\t\t\tXSync(dpy, False);\n\n\t\t\timage[n] = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    AllPlanes, ZPixmap);\n\t\t\tXSync(dpy, False);\n\t\t\tXDestroyWindow(dpy, iwin);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tXLowerWindow(dpy, twin);\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXUnmapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (nws == 0) {\n\t\treturn;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\n\trfbLog(\"setting solid backgrounds...\\n\");\n\n\tfor (n=0; n < nws; n++)  {\n\t\tWindow twin = ws_wins[n];\n\t\tif (image[n] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (! twin)  {\n\t\t\ttwin = rootwin;\n\t\t}\n\t\tXSetWindowBackground(dpy, twin, pixel);\n\t}\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\n\nstatic void solid_cde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tint wsmax = 16;\n\tstatic XImage *image[16];\n\tstatic Window ws_wins[16];\n\tstatic int nws = -1;\n\n\tWindow expose;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tunsigned long mask, pixel;\n\tXColor cdef;\n\tColormap cmap;\n\tint n;\n\n\tRAWFB_RET_VOID\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\t\t/* restore the backdrop windows from the XImage snapshots */\n\n\t\tfor (n=0; n < nws; n++) {\n\t\t\tWindow twin;\n\n\t\t\tif (! image[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttwin = ws_wins[n];\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\t\t\tif (! valid_window(twin, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpixmap = XCreatePixmap(dpy, twin, wdpy_x, wdpy_y,\n\t\t\t    depth);\n\t\t\t\n\t\t\t/* draw the image to a pixmap: */\n\t\t\tgcv.function = GXcopy;\n\t\t\tgcv.plane_mask = AllPlanes;\n\t\t\tgc = XCreateGC(dpy, twin, GCFunction|GCPlaneMask, &gcv);\n\n\t\t\tXPutImage(dpy, pixmap, gc, image[n], 0, 0, 0, 0,\n\t\t\t    wdpy_x, wdpy_y);\n\n\t\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\t\tgc = XCreateGC(dpy, twin, GCForeground|GCBackground,\n\t\t\t    &gcv);\n\n\t\t\trfbLog(\"restoring CDE ws%d snapshot to 0x%lx\\n\",\n\t\t\t    n, twin);\n\t\t\t/* set the pixmap as the bg: */\n\t\t\tXSetWindowBackgroundPixmap(dpy, twin, pixmap);\n\t\t\tXFreePixmap(dpy, pixmap);\n\t\t\tXClearWindow(dpy, twin);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn;\n\t}\n\n\tif (nws < 0) {\n\t\t/* need to retrieve snapshots of the ws backgrounds: */\n\t\tWindow iwin, wm_win;\n\t\tXSetWindowAttributes iswa;\n\t\tAtom dt_list, wm_info, type;\n\t\tint format;\n\t\tunsigned long length, after;\n\t\tunsigned char *data;\n\t\tunsigned long *dp;\t/* crash on 64bit with int */\n\n\t\tnws = 0;\n\n\t\t/* extract the hidden wm properties about backdrops: */\n\n\t\twm_info = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\t\tif (wm_info == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, rootwin, wm_info, 0L, 10L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\t/*\n\t\t * xprop -notype -root _MOTIF_WM_INFO\n\t\t * _MOTIF_WM_INFO = 0x2, 0x580028\n\t\t */\n\n\t\tif (length < 2 || format != 32 || after != 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tdp = (unsigned long *) data;\n\t\twm_win = (Window) *(dp+1);\t/* 2nd item. */\n\n\n\t\tdt_list = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (dt_list == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, wm_win, dt_list, 0L, 10L, False,\n\t\t   AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\tnws = length;\n\n\t\tif (nws > wsmax) {\n\t\t\tnws = wsmax;\n\t\t}\n\t\tif (nws < 0) {\n\t\t\tnws = 0;\n\t\t}\n\n\t\trfbLog(\"special CDE win: 0x%lx, %d workspaces\\n\", wm_win, nws);\n\t\tif (nws == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (n=0; n<nws; n++) {\n\t\t\tAtom ws_atom;\n\t\t\tchar tmp[32];\n\t\t\tWindow twin;\n\t\t\tXWindowAttributes attr;\n\t\t\tint i, cnt;\n\n\t\t\timage[n] = NULL;\n\t\t\tws_wins[n] = 0x0;\n\n\t\t\tsprintf(tmp, \"_DT_WORKSPACE_INFO_ws%d\", n);\n\t\t\tws_atom = XInternAtom(dpy, tmp, False);\n\t\t\tif (ws_atom == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tXGetWindowProperty(dpy, wm_win, ws_atom, 0L, 100L,\n\t\t\t   False, AnyPropertyType, &type, &format, &length,\n\t\t\t   &after, &data);\n\n\t\t\tif (format != 8 || after != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * xprop -notype -id wm_win\n\t\t\t * _DT_WORKSPACE_INFO_ws0 = \"One\", \"3\", \"0x2f2f4a\",\n\t\t\t * \"0x63639c\", \"0x103\", \"1\", \"0x58044e\"\n\t\t\t */\n\n\t\t\tcnt = 0;\n\t\t\ttwin = 0x0;\n\t\t\tfor (i=0; i< (int) length; i++) {\n\t\t\t\tif (*(data+i) != '\\0') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcnt++;\t/* count nulls to indicate field */\n\t\t\t\tif (cnt == 6) {\n\t\t\t\t\t/* one past the null: */\n\t\t\t\t\tchar *q = (char *) (data+i+1);\n\t\t\t\t\tunsigned long in;\n\t\t\t\t\tif (sscanf(q, \"0x%lx\", &in) == 1) {\n\t\t\t\t\t\ttwin = (Window) in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tws_wins[n] = twin;\n\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\n\t\t\tXGetWindowAttributes(dpy, twin, &attr);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXMapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t\tXRaiseWindow(dpy, twin);\n\t\t\t}\n\t\t\tXSync(dpy, False);\n\t\t\n\t\t\t/* create image window: */\n\t\t\tiswa.override_redirect = True;\n\t\t\tiswa.backing_store = NotUseful;\n\t\t\tiswa.save_under = False;\n\t\t\tiswa.background_pixmap = ParentRelative;\n\t\t\tvisual.visualid = CopyFromParent;\n\n\t\t\tiwin = XCreateWindow(dpy, twin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    0, depth, InputOutput, &visual, mask, &iswa);\n\n\t\t\trfbLog(\"snapshotting CDE backdrop ws%d 0x%lx -> \"\n\t\t\t    \"0x%lx ...\\n\", n, twin, iwin);\n\t\t\tXMapWindow(dpy, iwin);\n\t\t\tXSync(dpy, False);\n\n\t\t\timage[n] = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    AllPlanes, ZPixmap);\n\t\t\tXSync(dpy, False);\n\t\t\tXDestroyWindow(dpy, iwin);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tXLowerWindow(dpy, twin);\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXUnmapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (nws == 0) {\n\t\treturn;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\n\trfbLog(\"setting solid backgrounds...\\n\");\n\n\tfor (n=0; n < nws; n++)  {\n\t\tWindow twin = ws_wins[n];\n\t\tif (image[n] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (! twin)  {\n\t\t\ttwin = rootwin;\n\t\t}\n\t\tXSetWindowBackground(dpy, twin, pixel);\n\t}\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dtname",
            "\"cde\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_kde",
          "args": [
            "color"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "solid_kde",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "992-1053",
          "snippet": "static void solid_kde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar set_color[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setColor '%s' 1\";\n\tchar bg_off[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 0\";\n\tchar bg_on[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 1\";\n\tchar *cmd, *user = NULL, *sess;\n\tint len;\n\n\tRAWFB_RET_VOID\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tif (! color) {\n\t\tsess = dcop_session();\n\t\tlen = strlen(bg_on) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, bg_on, user, sess);\n\n\t\tdt_cmd(cmd);\n\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\n\t\treturn;\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tsess = dcop_session();\n\n\tlen = strlen(set_color) + strlen(user) + strlen(sess) + strlen(color) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, set_color, user, sess, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tlen = strlen(bg_off) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, bg_off, user, sess);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\tfree(user);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_kde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar set_color[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setColor '%s' 1\";\n\tchar bg_off[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 0\";\n\tchar bg_on[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 1\";\n\tchar *cmd, *user = NULL, *sess;\n\tint len;\n\n\tRAWFB_RET_VOID\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tif (! color) {\n\t\tsess = dcop_session();\n\t\tlen = strlen(bg_on) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, bg_on, user, sess);\n\n\t\tdt_cmd(cmd);\n\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\n\t\treturn;\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tsess = dcop_session();\n\n\tlen = strlen(set_color) + strlen(user) + strlen(sess) + strlen(color) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, set_color, user, sess, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tlen = strlen(bg_off) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, bg_off, user, sess);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\tfree(user);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dtname",
            "\"kde\""
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_gnome",
          "args": [
            "color"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "solid_gnome",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "651-766",
          "snippet": "static void solid_gnome(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_color[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/primary_color\";\n\tchar set_color[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/primary_color '%s'\";\n\tchar get_option[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_options\";\n\tchar set_option[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_options '%s'\";\n#if 0\n\tchar get_shading[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/color_shading_type\";\n\tchar set_shading[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/color_shading_type '%s'\";\n\tchar get_filename[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_filename\";\n\tchar set_filename[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_filename '%s'\";\n#endif\n\tstatic char *orig_color = NULL;\n\tstatic char *orig_option = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_color) {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif (! orig_option) {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif (strstr(orig_color, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color: %s\\n\", orig_color);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_option, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid option: %s\\n\", orig_option);\n\t\t\treturn;\n\t\t}\n\t\tcmd = (char *) malloc(strlen(set_option) - 2 + strlen(orig_option) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_option, dbus, orig_option);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tcmd = (char *) malloc(strlen(set_color) - 2 + strlen(orig_color) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_color, dbus, orig_color);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\treturn;\n\t}\n\n\tif (! orig_color) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color, dbus);\n\t\t\torig_color = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_color == '\\0') {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif ((q = strchr(orig_color, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (! orig_option) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_option) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_option, dbus);\n\t\t\torig_option = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_option == '\\0') {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif ((q = strchr(orig_option, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\tcmd = (char *) malloc(strlen(set_color) + strlen(color) + strlen(dbus) + 1);\n\tsprintf(cmd, set_color, dbus, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_option) + strlen(\"none\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_option, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#if 0\n\tcmd = (char *) malloc(strlen(set_filename) + strlen(\"none\") + 1);\n\tsprintf(cmd, set_filename, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n#endif\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *dbus_session(void);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_gnome(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_color[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/primary_color\";\n\tchar set_color[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/primary_color '%s'\";\n\tchar get_option[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_options\";\n\tchar set_option[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_options '%s'\";\n#if 0\n\tchar get_shading[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/color_shading_type\";\n\tchar set_shading[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/color_shading_type '%s'\";\n\tchar get_filename[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_filename\";\n\tchar set_filename[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_filename '%s'\";\n#endif\n\tstatic char *orig_color = NULL;\n\tstatic char *orig_option = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_color) {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif (! orig_option) {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif (strstr(orig_color, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color: %s\\n\", orig_color);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_option, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid option: %s\\n\", orig_option);\n\t\t\treturn;\n\t\t}\n\t\tcmd = (char *) malloc(strlen(set_option) - 2 + strlen(orig_option) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_option, dbus, orig_option);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tcmd = (char *) malloc(strlen(set_color) - 2 + strlen(orig_color) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_color, dbus, orig_color);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\treturn;\n\t}\n\n\tif (! orig_color) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color, dbus);\n\t\t\torig_color = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_color == '\\0') {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif ((q = strchr(orig_color, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (! orig_option) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_option) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_option, dbus);\n\t\t\torig_option = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_option == '\\0') {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif ((q = strchr(orig_option, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\tcmd = (char *) malloc(strlen(set_color) + strlen(color) + strlen(dbus) + 1);\n\tsprintf(cmd, set_color, dbus, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_option) + strlen(\"none\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_option, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#if 0\n\tcmd = (char *) malloc(strlen(set_filename) + strlen(\"none\") + 1);\n\tsprintf(cmd, set_filename, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n#endif\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dtname",
            "\"gnome\""
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "color"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "solid_str",
            "':'"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "solid_str",
            "\"xfce:\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "solid_str",
            "\"cde:\""
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "solid_str",
            "\"kde:\""
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "solid_str",
            "\"gnome:\""
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed desktop: %s\\n\"",
            "dtname"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_desktop",
          "args": [],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "guess_desktop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1232-1292",
          "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "solid_str",
            "':'"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "solid_str",
            "\"guess:\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prev_str",
            "solid_str"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "solid_macosx",
          "args": [
            "restore"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "solid_macosx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1169-1230",
          "snippet": "static void solid_macosx(int restore) {\n\tchar tmp[] = \"/tmp/macosx_solid_background.XXXXXX\";\n\tpid_t pid, parent = getpid();\n\n\tif (restore) {\n\t\trfbLog(\"restore pid: %d\\n\", (int) solid_macosx_pid);\n\t\tif (solid_macosx_pid > 0) {\n#if 0\n\t\t\tint i, status;\n#endif\n\t\t\trfbLog(\"kill -TERM macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\t\t\tkill(solid_macosx_pid, SIGTERM);\n#if 0\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H\n#if HAVE_WAITPID\n\t\t\tfor (i=0; i < 7; i++) {\n\t\t\t\tusleep(1000 * 1000);\n\t\t\t\twaitpid(solid_macosx_pid, &status, WNOHANG); \n\t\t\t\tif (kill(solid_macosx_pid, 0) != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n#endif\n#endif\n\t\t\tsolid_macosx_pid = 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t}\n\tif (pid == 0) {\n\t\tint fd = mkstemp(tmp);\n#if HAVE_SETSID\n\t\tsetsid();\n#else\n\t\tsetpgrp();\n#endif\n\t\tif (fd >= 0) {\n\t\t\tchar num[32];\n\t\t\twrite(fd, macosx_solid_background, strlen(macosx_solid_background));\n\t\t\tclose(fd);\n\t\t\tsprintf(num, \"%d\", (int) parent);\n\t\t\tset_env(\"SS_WATCH_PID\", num);\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", tmp, (char *) NULL);\n\t\t}\n\t\texit(1);\n\t}\n\tsolid_macosx_pid = pid;\n\trfbLog(\"macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\tusleep(2750 * 1000);\n\tunlink(tmp);\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static void solid_macosx(int restore);",
            "static pid_t solid_macosx_pid = 0;",
            "extern char macosx_solid_background[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic void solid_macosx(int restore);\nstatic pid_t solid_macosx_pid = 0;\nextern char macosx_solid_background[];\n\nstatic void solid_macosx(int restore) {\n\tchar tmp[] = \"/tmp/macosx_solid_background.XXXXXX\";\n\tpid_t pid, parent = getpid();\n\n\tif (restore) {\n\t\trfbLog(\"restore pid: %d\\n\", (int) solid_macosx_pid);\n\t\tif (solid_macosx_pid > 0) {\n#if 0\n\t\t\tint i, status;\n#endif\n\t\t\trfbLog(\"kill -TERM macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\t\t\tkill(solid_macosx_pid, SIGTERM);\n#if 0\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H\n#if HAVE_WAITPID\n\t\t\tfor (i=0; i < 7; i++) {\n\t\t\t\tusleep(1000 * 1000);\n\t\t\t\twaitpid(solid_macosx_pid, &status, WNOHANG); \n\t\t\t\tif (kill(solid_macosx_pid, 0) != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n#endif\n#endif\n\t\t\tsolid_macosx_pid = 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t}\n\tif (pid == 0) {\n\t\tint fd = mkstemp(tmp);\n#if HAVE_SETSID\n\t\tsetsid();\n#else\n\t\tsetpgrp();\n#endif\n\t\tif (fd >= 0) {\n\t\t\tchar num[32];\n\t\t\twrite(fd, macosx_solid_background, strlen(macosx_solid_background));\n\t\t\tclose(fd);\n\t\t\tsprintf(num, \"%d\", (int) parent);\n\t\t\tset_env(\"SS_WATCH_PID\", num);\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", tmp, (char *) NULL);\n\t\t}\n\t\texit(1);\n\t}\n\tsolid_macosx_pid = pid;\n\trfbLog(\"macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\tusleep(2750 * 1000);\n\tunlink(tmp);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
  },
  {
    "function_name": "solid_image",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1294-1328",
    "snippet": "XImage *solid_image(char *color) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\treturn NULL;\n#else\n\tXImage *image = NULL;\n\tunsigned long pixel = 0;\n\tint x, y;\n\n\tRAWFB_RET(NULL)\n\n\tif (!color) {\n\t\tcolor = last_color;\n\t}\n\n\tif (!color) {\n\t\treturn NULL;\n\t}\n\n\timage = XGetImage(dpy, rootwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t    ZPixmap);\n\n\tif (!image) {\n\t\treturn NULL;\n\t}\n\tpixel = get_pixel(color);\n\n\tfor (y=0; y<wdpy_y; y++) {\n\t\tfor (x=0; x<wdpy_x; x++) {\n\t\t\tXPutPixel(image, x, y, pixel);\n\t\t}\n\t}\n\treturn image;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);",
      "static char *last_color = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XPutPixel",
          "args": [
            "image",
            "x",
            "y",
            "pixel"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pixel",
          "args": [
            "color"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "get_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "157-175",
          "snippet": "unsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nunsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetImage",
          "args": [
            "dpy",
            "rootwin",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic char *last_color = NULL;\n\nXImage *solid_image(char *color) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\treturn NULL;\n#else\n\tXImage *image = NULL;\n\tunsigned long pixel = 0;\n\tint x, y;\n\n\tRAWFB_RET(NULL)\n\n\tif (!color) {\n\t\tcolor = last_color;\n\t}\n\n\tif (!color) {\n\t\treturn NULL;\n\t}\n\n\timage = XGetImage(dpy, rootwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t    ZPixmap);\n\n\tif (!image) {\n\t\treturn NULL;\n\t}\n\tpixel = get_pixel(color);\n\n\tfor (y=0; y<wdpy_y; y++) {\n\t\tfor (x=0; x<wdpy_x; x++) {\n\t\t\tXPutPixel(image, x, y, pixel);\n\t\t}\n\t}\n\treturn image;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "guess_desktop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1232-1292",
    "snippet": "char *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *guess_desktop(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_DT_WORKSPACE_LIST\"",
            "True"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_MOTIF_WM_INFO\"",
            "True"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"KDE_DESKTOP_WINDOW\"",
            "True"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_KDE_RUNNING\"",
            "True"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"KWIN_RUNNING\"",
            "True"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"NAUTILUS_DESKTOP_WINDOW_ID\"",
            "True"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_WINDOWMAKER_COMMAND\"",
            "True"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_WINDOWMAKER_WM_PROTOCOLS\"",
            "True"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"XFCE_DESKTOP_WINDOW\"",
            "True"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"cde\""
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"kwin\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"kde\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"metacity\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"gnome\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"xfce\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "s"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "136-146",
          "snippet": "void lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "\"root\""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "\"root\""
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\n\nchar *guess_desktop(void) {\n#if NO_X11\n\tRAWFB_RET(\"root\")\n\treturn \"root\";\n#else\n\tAtom prop;\n\n\tRAWFB_RET(\"root\")\n\n\tif (wmdt_str && *wmdt_str != '\\0') {\n\t\tchar *s = wmdt_str;\n\t\tlowercase(s);\n\t\tif (strstr(s, \"xfce\")) {\n\t\t\treturn \"xfce\";\n\t\t}\n\t\tif (strstr(s, \"gnome\") || strstr(s, \"metacity\")) {\n\t\t\treturn \"gnome\";\n\t\t}\n\t\tif (strstr(s, \"kde\") || strstr(s, \"kwin\")) {\n\t\t\treturn \"kde\";\n\t\t}\n\t\tif (strstr(s, \"cde\")) {\n\t\t\treturn \"cde\";\n\t\t}\n\t\treturn \"root\";\n\t}\n\n\tif (! dpy) {\n\t\treturn \"\";\n\t}\n\n\tprop = XInternAtom(dpy, \"XFCE_DESKTOP_WINDOW\", True);\n\tif (prop != None) return \"xfce\";\n\n\t/* special case windowmaker */\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_WM_PROTOCOLS\", True);\n\tif (prop != None)  return \"root\";\n\n\tprop = XInternAtom(dpy, \"_WINDOWMAKER_COMMAND\", True);\n\tif (prop != None) return \"root\";\n\n\tprop = XInternAtom(dpy, \"NAUTILUS_DESKTOP_WINDOW_ID\", True);\n\tif (prop != None) return \"gnome\";\n\n\tprop = XInternAtom(dpy, \"KWIN_RUNNING\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_KDE_RUNNING\", True);\n\t\tif (prop != None) {\n\t\t\tprop = XInternAtom(dpy, \"KDE_DESKTOP_WINDOW\", True);\n\t\t\tif (prop != None) return \"kde\";\n\t\t}\n\t}\n\n\tprop = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\tif (prop != None) {\n\t\tprop = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (prop != None) return \"cde\";\n\t}\n\treturn \"root\";\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "solid_macosx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1169-1230",
    "snippet": "static void solid_macosx(int restore) {\n\tchar tmp[] = \"/tmp/macosx_solid_background.XXXXXX\";\n\tpid_t pid, parent = getpid();\n\n\tif (restore) {\n\t\trfbLog(\"restore pid: %d\\n\", (int) solid_macosx_pid);\n\t\tif (solid_macosx_pid > 0) {\n#if 0\n\t\t\tint i, status;\n#endif\n\t\t\trfbLog(\"kill -TERM macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\t\t\tkill(solid_macosx_pid, SIGTERM);\n#if 0\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H\n#if HAVE_WAITPID\n\t\t\tfor (i=0; i < 7; i++) {\n\t\t\t\tusleep(1000 * 1000);\n\t\t\t\twaitpid(solid_macosx_pid, &status, WNOHANG); \n\t\t\t\tif (kill(solid_macosx_pid, 0) != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n#endif\n#endif\n\t\t\tsolid_macosx_pid = 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t}\n\tif (pid == 0) {\n\t\tint fd = mkstemp(tmp);\n#if HAVE_SETSID\n\t\tsetsid();\n#else\n\t\tsetpgrp();\n#endif\n\t\tif (fd >= 0) {\n\t\t\tchar num[32];\n\t\t\twrite(fd, macosx_solid_background, strlen(macosx_solid_background));\n\t\t\tclose(fd);\n\t\t\tsprintf(num, \"%d\", (int) parent);\n\t\t\tset_env(\"SS_WATCH_PID\", num);\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", tmp, (char *) NULL);\n\t\t}\n\t\texit(1);\n\t}\n\tsolid_macosx_pid = pid;\n\trfbLog(\"macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\tusleep(2750 * 1000);\n\tunlink(tmp);\n#endif\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "static void solid_macosx(int restore);",
      "static pid_t solid_macosx_pid = 0;",
      "extern char macosx_solid_background[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2750 * 1000"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"macosx_solid_background helper pid: %d\\n\"",
            "(int) solid_macosx_pid"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"/bin/sh\"",
            "\"/bin/sh\"",
            "tmp",
            "(char *) NULL"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"SS_WATCH_PID\"",
            "num"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"%d\"",
            "(int) parent"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "macosx_solid_background",
            "strlen(macosx_solid_background)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "macosx_solid_background"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"dt\""
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "solid_macosx_pid",
            "0"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "solid_macosx_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"kill -TERM macosx_solid_background helper pid: %d\\n\"",
            "(int) solid_macosx_pid"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restore pid: %d\\n\"",
            "(int) solid_macosx_pid"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic void solid_macosx(int restore);\nstatic pid_t solid_macosx_pid = 0;\nextern char macosx_solid_background[];\n\nstatic void solid_macosx(int restore) {\n\tchar tmp[] = \"/tmp/macosx_solid_background.XXXXXX\";\n\tpid_t pid, parent = getpid();\n\n\tif (restore) {\n\t\trfbLog(\"restore pid: %d\\n\", (int) solid_macosx_pid);\n\t\tif (solid_macosx_pid > 0) {\n#if 0\n\t\t\tint i, status;\n#endif\n\t\t\trfbLog(\"kill -TERM macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\t\t\tkill(solid_macosx_pid, SIGTERM);\n#if 0\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H\n#if HAVE_WAITPID\n\t\t\tfor (i=0; i < 7; i++) {\n\t\t\t\tusleep(1000 * 1000);\n\t\t\t\twaitpid(solid_macosx_pid, &status, WNOHANG); \n\t\t\t\tif (kill(solid_macosx_pid, 0) != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n#endif\n#endif\n\t\t\tsolid_macosx_pid = 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t}\n\tif (pid == 0) {\n\t\tint fd = mkstemp(tmp);\n#if HAVE_SETSID\n\t\tsetsid();\n#else\n\t\tsetpgrp();\n#endif\n\t\tif (fd >= 0) {\n\t\t\tchar num[32];\n\t\t\twrite(fd, macosx_solid_background, strlen(macosx_solid_background));\n\t\t\tclose(fd);\n\t\t\tsprintf(num, \"%d\", (int) parent);\n\t\t\tset_env(\"SS_WATCH_PID\", num);\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", tmp, (char *) NULL);\n\t\t}\n\t\texit(1);\n\t}\n\tsolid_macosx_pid = pid;\n\trfbLog(\"macosx_solid_background helper pid: %d\\n\", (int) solid_macosx_pid);\n\tusleep(2750 * 1000);\n\tunlink(tmp);\n#endif\n}"
  },
  {
    "function_name": "gnome_no_animate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1162-1164",
    "snippet": "void gnome_no_animate(void) {\n\t;\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid gnome_no_animate(void) {\n\t;\n}"
  },
  {
    "function_name": "kde_no_animate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "1055-1160",
    "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);",
      "static void solid_macosx(int restore);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sess"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_cmd",
          "args": [
            "cmd2"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "83-117",
          "snippet": "static int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd2",
            "\"(sleep 10; %s; %s; sleep 5; %s) &\"",
            "kwinrc_off",
            "cmd",
            "kwinrc_on"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kwinrc_on"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sleep 5\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kwinrc_off"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sleep 10\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "kwin_reconfigure",
            "user",
            "sess"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kwin_reconfigure"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcop_session",
          "args": [],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "dcop_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "876-990",
          "snippet": "static char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "DisplayString(dpy)"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"********************************************************\\n\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   Desktop -> Window Behavior -> Moving\\n\""
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"change it now (toggle its setting a few times):\\n\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disconnects.  Or you can use the Control Center GUI to\\n\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"It will be reset for the next session or when VNC client\\n\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"To improve the -ncache client-side caching performance\\n\""
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"********************************************************\\n\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"********************************************************\\n\""
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"KDE kwinrc AnimateMinimize is false. Good.\\n\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"********************************************************\\n\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "out",
            "\"false\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_output",
          "args": [
            "query_setting"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "119-153",
          "snippet": "static char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid user: %s\\n\"",
            "user"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"'\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_name",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "271-293",
          "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_user_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Restoring KDE kwinrc settings.\\n\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "kwin_reconfigure",
            "user",
            "sess"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kwin_reconfigure"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid user: %s\\n\"",
            "user"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"'\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "solid_kde",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "992-1053",
    "snippet": "static void solid_kde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar set_color[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setColor '%s' 1\";\n\tchar bg_off[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 0\";\n\tchar bg_on[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 1\";\n\tchar *cmd, *user = NULL, *sess;\n\tint len;\n\n\tRAWFB_RET_VOID\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tif (! color) {\n\t\tsess = dcop_session();\n\t\tlen = strlen(bg_on) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, bg_on, user, sess);\n\n\t\tdt_cmd(cmd);\n\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\n\t\treturn;\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tsess = dcop_session();\n\n\tlen = strlen(set_color) + strlen(user) + strlen(sess) + strlen(color) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, set_color, user, sess, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tlen = strlen(bg_off) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, bg_off, user, sess);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\tfree(user);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "user"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_cmd",
          "args": [
            "cmd"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "83-117",
          "snippet": "static int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "bg_off",
            "user",
            "sess"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bg_off"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_color",
            "user",
            "sess",
            "color"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "color"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_color"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcop_session",
          "args": [],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "dcop_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "876-990",
          "snippet": "static char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid color: %s\\n\"",
            "color"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "color",
            "\"'\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "bg_on",
            "user",
            "sess"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bg_on"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "DisplayString(dpy)"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid user: %s\\n\"",
            "user"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"'\""
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_name",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "271-293",
          "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_user_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_kde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar set_color[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setColor '%s' 1\";\n\tchar bg_off[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 0\";\n\tchar bg_on[] =\n\t    \"dcop --user '%s' %s kdesktop KBackgroundIface setBackgroundEnabled 1\";\n\tchar *cmd, *user = NULL, *sess;\n\tint len;\n\n\tRAWFB_RET_VOID\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tif (! color) {\n\t\tsess = dcop_session();\n\t\tlen = strlen(bg_on) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, bg_on, user, sess);\n\n\t\tdt_cmd(cmd);\n\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\n\t\treturn;\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tsess = dcop_session();\n\n\tlen = strlen(set_color) + strlen(user) + strlen(sess) + strlen(color) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, set_color, user, sess, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tlen = strlen(bg_off) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, bg_off, user, sess);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\tfree(user);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "dcop_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "876-990",
    "snippet": "static char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sess"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"--session '%s'\"",
            "sess"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sess"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--session \""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"--all-sessions\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sess",
            "'\\''"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\\n\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(int) *(r+n)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dsn"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "dsn"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(int) *(r+n)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dsn"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "dsn"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "host"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"p:  %s\\n\"",
            "p"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\".DCOP\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "out",
            "\"\\n\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"host: %s\\n\"",
            "host"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "h2",
            "\"_%s_\"",
            "host"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(host) + 2 + 1"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dsn: %s\\n\"",
            "dsn"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ds:  %s\\n\"",
            "ds"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"_0\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ds",
            "':'"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "ds",
            "'.'"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ds"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ds",
            "\"\""
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd_output(cmd)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_output",
          "args": [
            "cmd"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "119-153",
          "snippet": "static char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "list_sessions",
            "user"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list_sessions"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid user: %s\\n\"",
            "user"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "user",
            "\"'\""
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_name",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "271-293",
          "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_user_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SESSION_MANAGER\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "empty"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "empty"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *dcop_session(void) {\n\tchar *empty = strdup(\"\");\n#if NO_X11\n\tRAWFB_RET(empty);\n\treturn empty;\n#else\n\tchar list_sessions[] = \"dcop --user '%s' --list-sessions\";\n\tint len;\n\tchar *cmd, *host, *user = NULL;\n\tchar *out, *p, *ds, *dsn = NULL, *sess = NULL, *sess2 = NULL;\n\tint db = 0;\n\n\tRAWFB_RET(empty);\n\n\tif (getenv(\"SESSION_MANAGER\")) {\n\t\treturn empty;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn empty;\n\t}\n\n\tlen = strlen(list_sessions) + strlen(user) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, list_sessions, user);\n\n\tout = strdup(cmd_output(cmd));\n\tfree(cmd);\n\tfree(user);\n\n\tds = DisplayString(dpy);\n\tif (!ds || !strcmp(ds, \"\")) {\n\t\tds = getenv(\"DISPLAY\");\n\t}\n\tif (!ds) {\n\t\tds = \":0\";\n\t}\n\tds = strdup(ds);\n\tp = strrchr(ds, '.');\n\tif (p) *p = '\\0';\n\n\tdsn = strchr(ds, ':');\n\tif (dsn) {\n\t\t*dsn = '_';\n\t} else {\n\t\tfree(ds);\n\t\tds = strdup(\"_0\");\n\t\tdsn = ds;\n\t}\n\tif (db) fprintf(stderr, \"ds:  %s\\n\", ds);\n\tif (db) fprintf(stderr, \"dsn: %s\\n\", dsn);\n\n\thost = this_host();\n\tif (host) {\n\t\tchar *h2 = (char *) malloc(strlen(host) + 2 + 1);\n\t\tsprintf(h2, \"_%s_\", host);\n\t\tfree(host);\n\t\thost = h2;\n\t} else {\n\t\thost = strdup(\"\");\n\t}\n\tif (db) fprintf(stderr, \"host: %s\\n\", host);\n\n\tp = strtok(out, \"\\n\");\n\twhile (p) {\n\t\tchar *q = strstr(p, \".DCOP\");\n\t\tif (db) fprintf(stderr, \"p:  %s\\n\", p);\n\t\tif (q == NULL) {\n\t\t\t;\n\t\t} else if (host) {\n\t\t\tif (strstr(q, host)) {\n\t\t\t\tchar *r = strstr(p, dsn);\n\t\t\t\tint n = strlen(dsn);\n\t\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\t\tsess = strdup(q);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif (sess2) {\n\t\t\t\t\t\tfree(sess2);\n\t\t\t\t\t}\n\t\t\t\t\tsess2 = strdup(q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tchar *r = strstr(p, dsn);\n\t\t\tint n = strlen(dsn);\n\t\t\tif(r && !isalnum((int) *(r+n))) {\n\t\t\t\tsess = strdup(q);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(ds);\n\tfree(out);\n\tfree(host);\n\tif (!sess && sess2) {\n\t\tsess = sess2;\n\t}\n\tif (!sess || strchr(sess, '\\'')) {\n\t\tif (sess) free(sess);\n\t\tsess = strdup(\"--all-sessions\");\n\t} else {\n\t\tlen = strlen(\"--session \") + 2 + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, \"--session '%s'\", sess);\n\t\tfree(sess);\n\t\tsess = cmd;\n\t}\n\treturn sess;\n#endif\n}"
  },
  {
    "function_name": "solid_xfce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "768-873",
    "snippet": "static void solid_xfce(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show\";\n\tchar set_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show -s '%s'\";\n\tchar get_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style\";\n\tchar set_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style -s '%s'\";\n\n\tstatic char *orig_image_show = NULL;\n\tstatic char *orig_color_style = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_image_show) {\n\t\t\torig_image_show = \"true\";\n\t\t}\n\t\tif (! orig_color_style) {\n\t\t\torig_color_style = \"0\";\n\t\t}\n\t\tif (strstr(orig_image_show, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid image show: %s\\n\", orig_image_show);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_color_style, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color style: %s\\n\", orig_color_style);\n\t\t\treturn;\n\t\t}\n\t\tif (orig_image_show[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_image_show) - 2 + strlen(orig_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_image_show, dbus, orig_image_show);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\tif (orig_color_style[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_color_style) - 2 + strlen(orig_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_color_style, dbus, orig_color_style);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! orig_image_show) {\n\t\tchar *q;\n\t\torig_image_show = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_image_show, dbus);\n\t\t\torig_image_show = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_image_show, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_image_show returned: '%s'\\n\\n\", orig_image_show);\n\t\t\tfree(cmd);\n\t\t\tif (strcasecmp(orig_image_show, \"false\") && strcasecmp(orig_image_show, \"true\")) {\n\t\t\t\tfprintf(stderr, \"unrecognized image_show, disabling.\\n\");\n\t\t\t\tfree(orig_image_show);\n\t\t\t\torig_image_show = \"\";\n\t\t\t}\n\t\t}\n\t}\n\tif (! orig_color_style) {\n\t\tchar *q;\n\t\torig_color_style = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color_style, dbus);\n\t\t\torig_color_style = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_color_style, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_color_style returned: '%s'\\n\\n\", orig_color_style);\n\t\t\tfree(cmd);\n\t\t\tif (strlen(orig_color_style) > 1 || !isdigit((unsigned char) (*orig_color_style))) {\n\t\t\t\tfprintf(stderr, \"unrecognized color_style, disabling.\\n\");\n\t\t\t\tfree(orig_color_style);\n\t\t\t\torig_color_style = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tcmd = (char *) malloc(strlen(set_color_style) + strlen(\"0\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_color_style, dbus, \"0\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_image_show) + strlen(\"false\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_image_show, dbus, \"false\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *dbus_session(void);",
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_cmd",
          "args": [
            "cmd"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "83-117",
          "snippet": "static int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_image_show",
            "dbus",
            "\"false\""
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_image_show) + strlen(\"false\") + strlen(dbus) + 1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"false\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_image_show"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_color_style",
            "dbus",
            "\"0\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_color_style) + strlen(\"0\") + strlen(dbus) + 1"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"0\""
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_color_style"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid color: %s\\n\"",
            "color"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "color",
            "\"'\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unrecognized color_style, disabling.\\n\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*orig_color_style)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig_color_style"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_color_style returned: '%s'\\n\\n\"",
            "orig_color_style"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "orig_color_style",
            "'\\n'"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd_output(cmd)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_output",
          "args": [
            "cmd"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "119-153",
          "snippet": "static char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "get_color_style",
            "dbus"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(get_color_style) + strlen(dbus) + 1"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "get_color_style"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"dt\""
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unrecognized image_show, disabling.\\n\""
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "orig_image_show",
            "\"true\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "orig_image_show",
            "\"false\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_image_show returned: '%s'\\n\\n\"",
            "orig_image_show"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "orig_image_show",
            "'\\n'"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd_output(cmd)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "get_image_show",
            "dbus"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(get_image_show) + strlen(dbus) + 1"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "get_image_show"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_color_style",
            "dbus",
            "orig_color_style"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_color_style) - 2 + strlen(orig_color_style) + strlen(dbus) + 1"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig_color_style"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_color_style"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_image_show",
            "dbus",
            "orig_image_show"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_image_show) - 2 + strlen(orig_image_show) + strlen(dbus) + 1"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig_image_show"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_image_show"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid color style: %s\\n\"",
            "orig_color_style"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "orig_color_style",
            "\"'\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid image show: %s\\n\"",
            "orig_image_show"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "orig_image_show",
            "\"'\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed dbus: %s\\n\"",
            "dbus"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_session",
          "args": [],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "dbus_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "555-649",
          "snippet": "char *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *dbus_session(void);",
            "static char _dbus_str[1100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic char _dbus_str[1100];\n\nchar *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_xfce(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show\";\n\tchar set_image_show[]  = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/image-show -s '%s'\";\n\tchar get_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style\";\n\tchar set_color_style[] = \"%s xfconf-query -v -c xfce4-desktop -p /backdrop/screen0/monitor0/color-style -s '%s'\";\n\n\tstatic char *orig_image_show = NULL;\n\tstatic char *orig_color_style = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_image_show) {\n\t\t\torig_image_show = \"true\";\n\t\t}\n\t\tif (! orig_color_style) {\n\t\t\torig_color_style = \"0\";\n\t\t}\n\t\tif (strstr(orig_image_show, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid image show: %s\\n\", orig_image_show);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_color_style, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color style: %s\\n\", orig_color_style);\n\t\t\treturn;\n\t\t}\n\t\tif (orig_image_show[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_image_show) - 2 + strlen(orig_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_image_show, dbus, orig_image_show);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\tif (orig_color_style[0] != '\\0') {\n\t\t\tcmd = (char *) malloc(strlen(set_color_style) - 2 + strlen(orig_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, set_color_style, dbus, orig_color_style);\n\t\t\tdt_cmd(cmd);\n\t\t\tfree(cmd);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! orig_image_show) {\n\t\tchar *q;\n\t\torig_image_show = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_image_show) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_image_show, dbus);\n\t\t\torig_image_show = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_image_show, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_image_show returned: '%s'\\n\\n\", orig_image_show);\n\t\t\tfree(cmd);\n\t\t\tif (strcasecmp(orig_image_show, \"false\") && strcasecmp(orig_image_show, \"true\")) {\n\t\t\t\tfprintf(stderr, \"unrecognized image_show, disabling.\\n\");\n\t\t\t\tfree(orig_image_show);\n\t\t\t\torig_image_show = \"\";\n\t\t\t}\n\t\t}\n\t}\n\tif (! orig_color_style) {\n\t\tchar *q;\n\t\torig_color_style = \"\";\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color_style) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color_style, dbus);\n\t\t\torig_color_style = strdup(cmd_output(cmd));\n\t\t\tif ((q = strrchr(orig_color_style, '\\n')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tfprintf(stderr, \"get_color_style returned: '%s'\\n\\n\", orig_color_style);\n\t\t\tfree(cmd);\n\t\t\tif (strlen(orig_color_style) > 1 || !isdigit((unsigned char) (*orig_color_style))) {\n\t\t\t\tfprintf(stderr, \"unrecognized color_style, disabling.\\n\");\n\t\t\t\tfree(orig_color_style);\n\t\t\t\torig_color_style = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\n\tcmd = (char *) malloc(strlen(set_color_style) + strlen(\"0\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_color_style, dbus, \"0\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_image_show) + strlen(\"false\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_image_show, dbus, \"false\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "solid_gnome",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "651-766",
    "snippet": "static void solid_gnome(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_color[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/primary_color\";\n\tchar set_color[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/primary_color '%s'\";\n\tchar get_option[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_options\";\n\tchar set_option[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_options '%s'\";\n#if 0\n\tchar get_shading[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/color_shading_type\";\n\tchar set_shading[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/color_shading_type '%s'\";\n\tchar get_filename[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_filename\";\n\tchar set_filename[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_filename '%s'\";\n#endif\n\tstatic char *orig_color = NULL;\n\tstatic char *orig_option = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_color) {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif (! orig_option) {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif (strstr(orig_color, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color: %s\\n\", orig_color);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_option, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid option: %s\\n\", orig_option);\n\t\t\treturn;\n\t\t}\n\t\tcmd = (char *) malloc(strlen(set_option) - 2 + strlen(orig_option) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_option, dbus, orig_option);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tcmd = (char *) malloc(strlen(set_color) - 2 + strlen(orig_color) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_color, dbus, orig_color);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\treturn;\n\t}\n\n\tif (! orig_color) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color, dbus);\n\t\t\torig_color = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_color == '\\0') {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif ((q = strchr(orig_color, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (! orig_option) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_option) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_option, dbus);\n\t\t\torig_option = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_option == '\\0') {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif ((q = strchr(orig_option, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\tcmd = (char *) malloc(strlen(set_color) + strlen(color) + strlen(dbus) + 1);\n\tsprintf(cmd, set_color, dbus, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_option) + strlen(\"none\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_option, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#if 0\n\tcmd = (char *) malloc(strlen(set_filename) + strlen(\"none\") + 1);\n\tsprintf(cmd, set_filename, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n#endif\n\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *dbus_session(void);",
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_cmd",
          "args": [
            "cmd"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "83-117",
          "snippet": "static int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_filename",
            "dbus",
            "\"none\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_filename) + strlen(\"none\") + 1"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"none\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_filename"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_option",
            "dbus",
            "\"none\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_option) + strlen(\"none\") + strlen(dbus) + 1"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"none\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_option"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_color",
            "dbus",
            "color"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_color) + strlen(color) + strlen(dbus) + 1"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "color"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_color"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid color: %s\\n\"",
            "color"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "color",
            "\"'\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig_option",
            "'\\n'"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"stretched\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd_output(cmd)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_output",
          "args": [
            "cmd"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "119-153",
          "snippet": "static char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "get_option",
            "dbus"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(get_option) + strlen(dbus) + 1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "get_option"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"dt\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "orig_color",
            "'\\n'"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"#FFFFFF\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmd_output(cmd)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "get_color",
            "dbus"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(get_color) + strlen(dbus) + 1"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "get_color"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_color",
            "dbus",
            "orig_color"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_color) - 2 + strlen(orig_color) + strlen(dbus) + 1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig_color"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_color"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "set_option",
            "dbus",
            "orig_option"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(set_option) - 2 + strlen(orig_option) + strlen(dbus) + 1"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "orig_option"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "set_option"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid option: %s\\n\"",
            "orig_option"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "orig_option",
            "\"'\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid color: %s\\n\"",
            "orig_color"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "orig_color",
            "\"'\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"stretched\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"#FFFFFF\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed dbus: %s\\n\"",
            "dbus"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_session",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "dbus_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "555-649",
          "snippet": "char *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *dbus_session(void);",
            "static char _dbus_str[1100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic char _dbus_str[1100];\n\nchar *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nstatic void solid_gnome(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tchar get_color[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/primary_color\";\n\tchar set_color[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/primary_color '%s'\";\n\tchar get_option[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_options\";\n\tchar set_option[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_options '%s'\";\n#if 0\n\tchar get_shading[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/color_shading_type\";\n\tchar set_shading[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/color_shading_type '%s'\";\n\tchar get_filename[] = \"%s gconftool-2 --get \"\n\t    \"/desktop/gnome/background/picture_filename\";\n\tchar set_filename[] = \"%s gconftool-2 --set --type string \"\n\t    \"/desktop/gnome/background/picture_filename '%s'\";\n#endif\n\tstatic char *orig_color = NULL;\n\tstatic char *orig_option = NULL;\n\tchar *cmd, *dbus = \"\";\n\n\tRAWFB_RET_VOID\n\n\tdbus = dbus_session();\n\trfbLog(\"guessed dbus: %s\\n\", dbus);\n\t\n\tif (! color) {\n\t\tif (! orig_color) {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif (! orig_option) {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif (strstr(orig_color, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid color: %s\\n\", orig_color);\n\t\t\treturn;\n\t\t}\n\t\tif (strstr(orig_option, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid option: %s\\n\", orig_option);\n\t\t\treturn;\n\t\t}\n\t\tcmd = (char *) malloc(strlen(set_option) - 2 + strlen(orig_option) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_option, dbus, orig_option);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tcmd = (char *) malloc(strlen(set_color) - 2 + strlen(orig_color) + strlen(dbus) + 1);\n\t\tsprintf(cmd, set_color, dbus, orig_color);\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\treturn;\n\t}\n\n\tif (! orig_color) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_color) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_color, dbus);\n\t\t\torig_color = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_color == '\\0') {\n\t\t\torig_color = strdup(\"#FFFFFF\");\n\t\t}\n\t\tif ((q = strchr(orig_color, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (! orig_option) {\n\t\tchar *q;\n\t\tif (cmd_ok(\"dt\")) {\n\t\t\tcmd = (char *) malloc(strlen(get_option) + strlen(dbus) + 1);\n\t\t\tsprintf(cmd, get_option, dbus);\n\t\t\torig_option = strdup(cmd_output(cmd));\n\t\t\tfree(cmd);\n\t\t} else {\n\t\t\torig_color = \"\";\n\t\t}\n\t\tif (*orig_option == '\\0') {\n\t\t\torig_option = strdup(\"stretched\");\n\t\t}\n\t\tif ((q = strchr(orig_option, '\\n')) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tif (strstr(color, \"'\") != NULL)  {\n\t\trfbLog(\"invalid color: %s\\n\", color);\n\t\treturn;\n\t}\n\tcmd = (char *) malloc(strlen(set_color) + strlen(color) + strlen(dbus) + 1);\n\tsprintf(cmd, set_color, dbus, color);\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n\tcmd = (char *) malloc(strlen(set_option) + strlen(\"none\") + strlen(dbus) + 1);\n\tsprintf(cmd, set_option, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n\n#if 0\n\tcmd = (char *) malloc(strlen(set_filename) + strlen(\"none\") + 1);\n\tsprintf(cmd, set_filename, dbus, \"none\");\n\tdt_cmd(cmd);\n\tfree(cmd);\n#endif\n\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "dbus_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "555-649",
    "snippet": "char *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *dbus_session(void);",
      "static char _dbus_str[1100];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "children"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "_dbus_str",
            "\"env DBUS_SESSION_BUS_ADDRESS='%s'\"",
            "tmp"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\"",
            "children[i]",
            "pid",
            "score",
            "tmp"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DBUS_DEBUG\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "procfile",
            "&sb"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procfile",
            "\"/proc/%d\"",
            "pid"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'\\''"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "children[i]",
            "dbus_pid",
            "0",
            "1",
            "False",
            "XA_CARDINAL",
            "&atype",
            "&aformat",
            "&nitems",
            "&bafter",
            "&prop"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_prop",
          "args": [
            "tmp",
            "sizeof(tmp)-1",
            "dbus_prop",
            "children[i]"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "get_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "448-494",
          "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "sizeof(tmp)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&w",
            "&children",
            "&ui"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "_dbus_str",
            "\"env DBUS_SESSION_BUS_ADDRESS='%s'\"",
            "tmp"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'\\''"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "sizeof(tmp)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_DBUS_SESSION_BUS_PID\"",
            "True"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_DBUS_SESSION_BUS_ADDRESS\"",
            "True"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "_dbus_str",
            "0",
            "sizeof(_dbus_str)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbus_env"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DBUS_SESSION_BUS_ADDRESS\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *dbus_session(void);\nstatic char _dbus_str[1100];\n\nchar *dbus_session(void) {\n\tchar *dbus_env = getenv(\"DBUS_SESSION_BUS_ADDRESS\"); \n\tchar tmp[1000];\n\n\tif (dbus_env != NULL && strlen(dbus_env) > 0) {\n\t\treturn \"\";\n\t}\n\tif (!dpy) {\n\t\treturn \"\";\n\t}\n#if NO_X11\n\treturn \"\";\n#else\n\t{\n\t\tAtom dbus_prop, dbus_pid;\n\t\tWindow r, w, *children;\n\t\tint sbest = -1;\n\t\tunsigned int ui;\n\t\tint rc, i;\n\n\t\tmemset(_dbus_str, 0, sizeof(_dbus_str));\n\n\t\tX_LOCK;\n\t\tdbus_prop = XInternAtom(dpy, \"_DBUS_SESSION_BUS_ADDRESS\", True);\n\t\tdbus_pid  = XInternAtom(dpy, \"_DBUS_SESSION_BUS_PID\", True);\n\t\tX_UNLOCK;\n\t\tif (dbus_prop == None) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tX_LOCK;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, None);\n\t\tX_UNLOCK;\n\t\tif (strcmp(tmp, \"\")) {\n\t\t\tif (!strchr(tmp, '\\'')) {\n\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\treturn _dbus_str;\n\t\t\t}\n\t\t}\n\n\t\tX_LOCK;\n\t\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &children, &ui);\n\t\tX_UNLOCK;\n\t\tif (!rc || children == NULL || ui == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfor (i=0; i < (int) ui; i++) {\n\t\t\tint pid = -1;\n\t\n\t\t\tX_LOCK;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\tget_prop(tmp, sizeof(tmp)-1, dbus_prop, children[i]);\n\t\t\tif (dbus_pid != None) {\n\t\t\t\tAtom atype;\n\t\t\t\tint aformat;\n\t\t\t\tunsigned long nitems, bafter;\n\t\t\t\tunsigned char *prop;\n\t\t\t\tif (XGetWindowProperty(dpy, children[i], dbus_pid,\n\t\t\t\t    0, 1, False, XA_CARDINAL, &atype, &aformat,\n\t\t\t\t    &nitems, &bafter, &prop) == Success\n\t\t\t\t    && atype == XA_CARDINAL) {\n\t\t\t\t\tpid = *((int *) prop);\n\t\t\t\t\tXFree_wr(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\tif (strcmp(tmp, \"\")  && !strchr(tmp, '\\'')) {\n\t\t\t\tint score = 0;\n\t\t\t\tif (1 < pid && pid < 10000000) {\n\t\t\t\t\tstruct stat sb;\n\t\t\t\t\tchar procfile[32];\n\n\t\t\t\t\tsprintf(procfile, \"/proc/%d\", pid);\n\t\t\t\t\tif (stat(procfile, &sb) == 0) {\n\t\t\t\t\t\tscore += 10000000;\n\t\t\t\t\t}\n\t\t\t\t\tscore += pid;\n\t\t\t\t}\n\t\t\t\tif (getenv(\"X11VNC_DBUS_DEBUG\")) fprintf(stderr, \"win: 0x%lx  pid: %8d  score: %8d  str: %s\\n\", children[i], pid, score, tmp);\n\t\t\t\tif (score > sbest) {\n\t\t\t\t\tsprintf(_dbus_str, \"env DBUS_SESSION_BUS_ADDRESS='%s'\", tmp);\n\t\t\t\t\tsbest = score;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tX_LOCK;\n\t\tXFree_wr(children);\n\t\tX_UNLOCK;\n\n\t\treturn _dbus_str;\n\t}\n#endif\n}"
  },
  {
    "function_name": "solid_cde",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "287-551",
    "snippet": "static void solid_cde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tint wsmax = 16;\n\tstatic XImage *image[16];\n\tstatic Window ws_wins[16];\n\tstatic int nws = -1;\n\n\tWindow expose;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tunsigned long mask, pixel;\n\tXColor cdef;\n\tColormap cmap;\n\tint n;\n\n\tRAWFB_RET_VOID\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\t\t/* restore the backdrop windows from the XImage snapshots */\n\n\t\tfor (n=0; n < nws; n++) {\n\t\t\tWindow twin;\n\n\t\t\tif (! image[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttwin = ws_wins[n];\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\t\t\tif (! valid_window(twin, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpixmap = XCreatePixmap(dpy, twin, wdpy_x, wdpy_y,\n\t\t\t    depth);\n\t\t\t\n\t\t\t/* draw the image to a pixmap: */\n\t\t\tgcv.function = GXcopy;\n\t\t\tgcv.plane_mask = AllPlanes;\n\t\t\tgc = XCreateGC(dpy, twin, GCFunction|GCPlaneMask, &gcv);\n\n\t\t\tXPutImage(dpy, pixmap, gc, image[n], 0, 0, 0, 0,\n\t\t\t    wdpy_x, wdpy_y);\n\n\t\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\t\tgc = XCreateGC(dpy, twin, GCForeground|GCBackground,\n\t\t\t    &gcv);\n\n\t\t\trfbLog(\"restoring CDE ws%d snapshot to 0x%lx\\n\",\n\t\t\t    n, twin);\n\t\t\t/* set the pixmap as the bg: */\n\t\t\tXSetWindowBackgroundPixmap(dpy, twin, pixmap);\n\t\t\tXFreePixmap(dpy, pixmap);\n\t\t\tXClearWindow(dpy, twin);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn;\n\t}\n\n\tif (nws < 0) {\n\t\t/* need to retrieve snapshots of the ws backgrounds: */\n\t\tWindow iwin, wm_win;\n\t\tXSetWindowAttributes iswa;\n\t\tAtom dt_list, wm_info, type;\n\t\tint format;\n\t\tunsigned long length, after;\n\t\tunsigned char *data;\n\t\tunsigned long *dp;\t/* crash on 64bit with int */\n\n\t\tnws = 0;\n\n\t\t/* extract the hidden wm properties about backdrops: */\n\n\t\twm_info = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\t\tif (wm_info == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, rootwin, wm_info, 0L, 10L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\t/*\n\t\t * xprop -notype -root _MOTIF_WM_INFO\n\t\t * _MOTIF_WM_INFO = 0x2, 0x580028\n\t\t */\n\n\t\tif (length < 2 || format != 32 || after != 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tdp = (unsigned long *) data;\n\t\twm_win = (Window) *(dp+1);\t/* 2nd item. */\n\n\n\t\tdt_list = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (dt_list == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, wm_win, dt_list, 0L, 10L, False,\n\t\t   AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\tnws = length;\n\n\t\tif (nws > wsmax) {\n\t\t\tnws = wsmax;\n\t\t}\n\t\tif (nws < 0) {\n\t\t\tnws = 0;\n\t\t}\n\n\t\trfbLog(\"special CDE win: 0x%lx, %d workspaces\\n\", wm_win, nws);\n\t\tif (nws == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (n=0; n<nws; n++) {\n\t\t\tAtom ws_atom;\n\t\t\tchar tmp[32];\n\t\t\tWindow twin;\n\t\t\tXWindowAttributes attr;\n\t\t\tint i, cnt;\n\n\t\t\timage[n] = NULL;\n\t\t\tws_wins[n] = 0x0;\n\n\t\t\tsprintf(tmp, \"_DT_WORKSPACE_INFO_ws%d\", n);\n\t\t\tws_atom = XInternAtom(dpy, tmp, False);\n\t\t\tif (ws_atom == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tXGetWindowProperty(dpy, wm_win, ws_atom, 0L, 100L,\n\t\t\t   False, AnyPropertyType, &type, &format, &length,\n\t\t\t   &after, &data);\n\n\t\t\tif (format != 8 || after != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * xprop -notype -id wm_win\n\t\t\t * _DT_WORKSPACE_INFO_ws0 = \"One\", \"3\", \"0x2f2f4a\",\n\t\t\t * \"0x63639c\", \"0x103\", \"1\", \"0x58044e\"\n\t\t\t */\n\n\t\t\tcnt = 0;\n\t\t\ttwin = 0x0;\n\t\t\tfor (i=0; i< (int) length; i++) {\n\t\t\t\tif (*(data+i) != '\\0') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcnt++;\t/* count nulls to indicate field */\n\t\t\t\tif (cnt == 6) {\n\t\t\t\t\t/* one past the null: */\n\t\t\t\t\tchar *q = (char *) (data+i+1);\n\t\t\t\t\tunsigned long in;\n\t\t\t\t\tif (sscanf(q, \"0x%lx\", &in) == 1) {\n\t\t\t\t\t\ttwin = (Window) in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tws_wins[n] = twin;\n\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\n\t\t\tXGetWindowAttributes(dpy, twin, &attr);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXMapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t\tXRaiseWindow(dpy, twin);\n\t\t\t}\n\t\t\tXSync(dpy, False);\n\t\t\n\t\t\t/* create image window: */\n\t\t\tiswa.override_redirect = True;\n\t\t\tiswa.backing_store = NotUseful;\n\t\t\tiswa.save_under = False;\n\t\t\tiswa.background_pixmap = ParentRelative;\n\t\t\tvisual.visualid = CopyFromParent;\n\n\t\t\tiwin = XCreateWindow(dpy, twin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    0, depth, InputOutput, &visual, mask, &iswa);\n\n\t\t\trfbLog(\"snapshotting CDE backdrop ws%d 0x%lx -> \"\n\t\t\t    \"0x%lx ...\\n\", n, twin, iwin);\n\t\t\tXMapWindow(dpy, iwin);\n\t\t\tXSync(dpy, False);\n\n\t\t\timage[n] = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    AllPlanes, ZPixmap);\n\t\t\tXSync(dpy, False);\n\t\t\tXDestroyWindow(dpy, iwin);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tXLowerWindow(dpy, twin);\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXUnmapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (nws == 0) {\n\t\treturn;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\n\trfbLog(\"setting solid backgrounds...\\n\");\n\n\tfor (n=0; n < nws; n++)  {\n\t\tWindow twin = ws_wins[n];\n\t\tif (image[n] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (! twin)  {\n\t\t\ttwin = rootwin;\n\t\t}\n\t\tXSetWindowBackground(dpy, twin, pixel);\n\t}\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);",
      "static void solid_macosx(int restore);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWindowBackground",
          "args": [
            "dpy",
            "twin",
            "pixel"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting solid backgrounds...\\n\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error parsing/allocing color: %s\\n\"",
            "color"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocColor",
          "args": [
            "dpy",
            "cmap",
            "&cdef"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XParseColor",
          "args": [
            "dpy",
            "cmap",
            "color",
            "&cdef"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultColormap",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "color",
            "solid_default"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUnmapWindow",
          "args": [
            "dpy",
            "twin"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLowerWindow",
          "args": [
            "dpy",
            "twin"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "iwin"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetImage",
          "args": [
            "dpy",
            "iwin",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "iwin"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"snapshotting CDE backdrop ws%d 0x%lx -> \"\n\t\t\t    \"0x%lx ...\\n\"",
            "n",
            "twin",
            "iwin"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateWindow",
          "args": [
            "dpy",
            "twin",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "0",
            "depth",
            "InputOutput",
            "&visual",
            "mask",
            "&iswa"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRaiseWindow",
          "args": [
            "dpy",
            "twin"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "twin"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "twin",
            "&attr"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"0x%lx\"",
            "&in"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "wm_win",
            "ws_atom",
            "0L",
            "100L",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&length",
            "&after",
            "&data"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "tmp",
            "False"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"_DT_WORKSPACE_INFO_ws%d\"",
            "n"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"special CDE win: 0x%lx, %d workspaces\\n\"",
            "wm_win",
            "nws"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "wm_win",
            "dt_list",
            "0L",
            "10L",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&length",
            "&after",
            "&data"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_DT_WORKSPACE_LIST\"",
            "True"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "rootwin",
            "wm_info",
            "0L",
            "10L",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&length",
            "&after",
            "&data"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_MOTIF_WM_INFO\"",
            "True"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XClearWindow",
          "args": [
            "dpy",
            "twin"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFreePixmap",
          "args": [
            "dpy",
            "pixmap"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWindowBackgroundPixmap",
          "args": [
            "dpy",
            "twin",
            "pixmap"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restoring CDE ws%d snapshot to 0x%lx\\n\"",
            "n",
            "twin"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateGC",
          "args": [
            "dpy",
            "twin",
            "GCForeground|GCBackground",
            "&gcv"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XPutImage",
          "args": [
            "dpy",
            "pixmap",
            "gc",
            "image[n]",
            "0",
            "0",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateGC",
          "args": [
            "dpy",
            "twin",
            "GCFunction|GCPlaneMask",
            "&gcv"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreatePixmap",
          "args": [
            "dpy",
            "twin",
            "wdpy_x",
            "wdpy_y",
            "depth"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "twin",
            "NULL",
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCreateWindow",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "0",
            "depth",
            "InputOutput",
            "&visual",
            "mask",
            "&swa"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot set subwin to solid color, must be rootwin\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\n\nstatic void solid_cde(char *color) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!color) {}\n\treturn;\n#else\n\tint wsmax = 16;\n\tstatic XImage *image[16];\n\tstatic Window ws_wins[16];\n\tstatic int nws = -1;\n\n\tWindow expose;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tunsigned long mask, pixel;\n\tXColor cdef;\n\tColormap cmap;\n\tint n;\n\n\tRAWFB_RET_VOID\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\t\t/* restore the backdrop windows from the XImage snapshots */\n\n\t\tfor (n=0; n < nws; n++) {\n\t\t\tWindow twin;\n\n\t\t\tif (! image[n]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttwin = ws_wins[n];\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\t\t\tif (! valid_window(twin, NULL, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpixmap = XCreatePixmap(dpy, twin, wdpy_x, wdpy_y,\n\t\t\t    depth);\n\t\t\t\n\t\t\t/* draw the image to a pixmap: */\n\t\t\tgcv.function = GXcopy;\n\t\t\tgcv.plane_mask = AllPlanes;\n\t\t\tgc = XCreateGC(dpy, twin, GCFunction|GCPlaneMask, &gcv);\n\n\t\t\tXPutImage(dpy, pixmap, gc, image[n], 0, 0, 0, 0,\n\t\t\t    wdpy_x, wdpy_y);\n\n\t\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\t\tgc = XCreateGC(dpy, twin, GCForeground|GCBackground,\n\t\t\t    &gcv);\n\n\t\t\trfbLog(\"restoring CDE ws%d snapshot to 0x%lx\\n\",\n\t\t\t    n, twin);\n\t\t\t/* set the pixmap as the bg: */\n\t\t\tXSetWindowBackgroundPixmap(dpy, twin, pixmap);\n\t\t\tXFreePixmap(dpy, pixmap);\n\t\t\tXClearWindow(dpy, twin);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn;\n\t}\n\n\tif (nws < 0) {\n\t\t/* need to retrieve snapshots of the ws backgrounds: */\n\t\tWindow iwin, wm_win;\n\t\tXSetWindowAttributes iswa;\n\t\tAtom dt_list, wm_info, type;\n\t\tint format;\n\t\tunsigned long length, after;\n\t\tunsigned char *data;\n\t\tunsigned long *dp;\t/* crash on 64bit with int */\n\n\t\tnws = 0;\n\n\t\t/* extract the hidden wm properties about backdrops: */\n\n\t\twm_info = XInternAtom(dpy, \"_MOTIF_WM_INFO\", True);\n\t\tif (wm_info == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, rootwin, wm_info, 0L, 10L, False,\n\t\t    AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\t/*\n\t\t * xprop -notype -root _MOTIF_WM_INFO\n\t\t * _MOTIF_WM_INFO = 0x2, 0x580028\n\t\t */\n\n\t\tif (length < 2 || format != 32 || after != 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tdp = (unsigned long *) data;\n\t\twm_win = (Window) *(dp+1);\t/* 2nd item. */\n\n\n\t\tdt_list = XInternAtom(dpy, \"_DT_WORKSPACE_LIST\", True);\n\t\tif (dt_list == None) {\n\t\t\treturn;\n\t\t}\n\n\t\tXGetWindowProperty(dpy, wm_win, dt_list, 0L, 10L, False,\n\t\t   AnyPropertyType, &type, &format, &length, &after, &data);\n\n\t\tnws = length;\n\n\t\tif (nws > wsmax) {\n\t\t\tnws = wsmax;\n\t\t}\n\t\tif (nws < 0) {\n\t\t\tnws = 0;\n\t\t}\n\n\t\trfbLog(\"special CDE win: 0x%lx, %d workspaces\\n\", wm_win, nws);\n\t\tif (nws == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (n=0; n<nws; n++) {\n\t\t\tAtom ws_atom;\n\t\t\tchar tmp[32];\n\t\t\tWindow twin;\n\t\t\tXWindowAttributes attr;\n\t\t\tint i, cnt;\n\n\t\t\timage[n] = NULL;\n\t\t\tws_wins[n] = 0x0;\n\n\t\t\tsprintf(tmp, \"_DT_WORKSPACE_INFO_ws%d\", n);\n\t\t\tws_atom = XInternAtom(dpy, tmp, False);\n\t\t\tif (ws_atom == None) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tXGetWindowProperty(dpy, wm_win, ws_atom, 0L, 100L,\n\t\t\t   False, AnyPropertyType, &type, &format, &length,\n\t\t\t   &after, &data);\n\n\t\t\tif (format != 8 || after != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * xprop -notype -id wm_win\n\t\t\t * _DT_WORKSPACE_INFO_ws0 = \"One\", \"3\", \"0x2f2f4a\",\n\t\t\t * \"0x63639c\", \"0x103\", \"1\", \"0x58044e\"\n\t\t\t */\n\n\t\t\tcnt = 0;\n\t\t\ttwin = 0x0;\n\t\t\tfor (i=0; i< (int) length; i++) {\n\t\t\t\tif (*(data+i) != '\\0') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcnt++;\t/* count nulls to indicate field */\n\t\t\t\tif (cnt == 6) {\n\t\t\t\t\t/* one past the null: */\n\t\t\t\t\tchar *q = (char *) (data+i+1);\n\t\t\t\t\tunsigned long in;\n\t\t\t\t\tif (sscanf(q, \"0x%lx\", &in) == 1) {\n\t\t\t\t\t\ttwin = (Window) in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tws_wins[n] = twin;\n\n\t\t\tif (! twin) {\n\t\t\t\ttwin = rootwin;\n\t\t\t}\n\n\t\t\tXGetWindowAttributes(dpy, twin, &attr);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXMapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t\tXRaiseWindow(dpy, twin);\n\t\t\t}\n\t\t\tXSync(dpy, False);\n\t\t\n\t\t\t/* create image window: */\n\t\t\tiswa.override_redirect = True;\n\t\t\tiswa.backing_store = NotUseful;\n\t\t\tiswa.save_under = False;\n\t\t\tiswa.background_pixmap = ParentRelative;\n\t\t\tvisual.visualid = CopyFromParent;\n\n\t\t\tiwin = XCreateWindow(dpy, twin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    0, depth, InputOutput, &visual, mask, &iswa);\n\n\t\t\trfbLog(\"snapshotting CDE backdrop ws%d 0x%lx -> \"\n\t\t\t    \"0x%lx ...\\n\", n, twin, iwin);\n\t\t\tXMapWindow(dpy, iwin);\n\t\t\tXSync(dpy, False);\n\n\t\t\timage[n] = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y,\n\t\t\t    AllPlanes, ZPixmap);\n\t\t\tXSync(dpy, False);\n\t\t\tXDestroyWindow(dpy, iwin);\n\t\t\tif (twin != rootwin) {\n\t\t\t\tXLowerWindow(dpy, twin);\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tXUnmapWindow(dpy, twin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (nws == 0) {\n\t\treturn;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\n\trfbLog(\"setting solid backgrounds...\\n\");\n\n\tfor (n=0; n < nws; n++)  {\n\t\tWindow twin = ws_wins[n];\n\t\tif (image[n] == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (! twin)  {\n\t\t\ttwin = rootwin;\n\t\t}\n\t\tXSetWindowBackground(dpy, twin, pixel);\n\t}\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "solid_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "177-285",
    "snippet": "XImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);",
      "static void solid_macosx(int restore);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWindowBackground",
          "args": [
            "dpy",
            "window",
            "pixel"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting solid background...\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pixel",
          "args": [
            "color"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "get_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "157-175",
          "snippet": "unsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nunsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"done.\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "iwin"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetImage",
          "args": [
            "dpy",
            "iwin",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "iwin"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"snapshotting background...\\n\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateWindow",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "0",
            "depth",
            "InputOutput",
            "&visual",
            "mask",
            "&iswa"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XClearWindow",
          "args": [
            "dpy",
            "window"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFreePixmap",
          "args": [
            "dpy",
            "pixmap"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWindowBackgroundPixmap",
          "args": [
            "dpy",
            "window",
            "pixmap"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restoring root snapshot...\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateGC",
          "args": [
            "dpy",
            "window",
            "GCForeground|GCBackground",
            "&gcv"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XPutImage",
          "args": [
            "dpy",
            "pixmap",
            "gc",
            "image",
            "0",
            "0",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateGC",
          "args": [
            "dpy",
            "window",
            "GCFunction|GCPlaneMask",
            "&gcv"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreatePixmap",
          "args": [
            "dpy",
            "window",
            "wdpy_x",
            "wdpy_y",
            "depth"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"no root snapshot available.\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "expose"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateWindow",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "wdpy_x",
            "wdpy_y",
            "0",
            "depth",
            "InputOutput",
            "&visual",
            "mask",
            "&swa"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot set subwin to solid color, must be rootwin\\n\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\n\nXImage *solid_root(char *color) {\n#if NO_X11\n\tif (!color) {}\n\treturn NULL;\n#else\n\tWindow expose;\n\tstatic XImage *image = NULL;\n\tPixmap pixmap;\n\tXGCValues gcv;\n\tGC gc;\n\tXSetWindowAttributes swa;\n\tVisual visual;\n\tstatic unsigned long mask, pixel = 0;\n\n\tRAWFB_RET(NULL)\n\n\tif (subwin || window != rootwin) {\n\t\trfbLog(\"cannot set subwin to solid color, must be rootwin\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* create the \"clear\" window just for generating exposures */\n\tswa.override_redirect = True;\n\tswa.backing_store = NotUseful;\n\tswa.save_under = False;\n\tswa.background_pixmap = None;\n\tvisual.visualid = CopyFromParent;\n\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\texpose = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0, depth,\n\t    InputOutput, &visual, mask, &swa);\n\n\tif (! color) {\n\n\t\tif (! image) {\n\t\t\t/* whoops */\n\t\t\tXDestroyWindow(dpy, expose);\n\t\t\trfbLog(\"no root snapshot available.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* restore the root window from the XImage snapshot */\n\t\tpixmap = XCreatePixmap(dpy, window, wdpy_x, wdpy_y, depth);\n\t\t\n\t\t/* draw the image to a pixmap: */\n\t\tgcv.function = GXcopy;\n\t\tgcv.plane_mask = AllPlanes;\n\t\tgc = XCreateGC(dpy, window, GCFunction|GCPlaneMask, &gcv);\n\n\t\tXPutImage(dpy, pixmap, gc, image, 0, 0, 0, 0, wdpy_x, wdpy_y);\n\n\t\tgcv.foreground = gcv.background = BlackPixel(dpy, scr);\n\t\tgc = XCreateGC(dpy, window, GCForeground|GCBackground, &gcv);\n\n\t\trfbLog(\"restoring root snapshot...\\n\");\n\t\t/* set the pixmap as the bg: */\n\t\tXSetWindowBackgroundPixmap(dpy, window, pixmap);\n\t\tXFreePixmap(dpy, pixmap);\n\t\tXClearWindow(dpy, window);\n\t\tXFlush_wr(dpy);\n\t\t\n\t\t/* generate exposures */\n\t\tXMapWindow(dpy, expose);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, expose);\n\t\treturn NULL;\n\t}\n\n\tif (! image) {\n\t\t/* need to retrieve a snapshot of the root background: */\n\t\tWindow iwin;\n\t\tXSetWindowAttributes iswa;\n\n\t\t/* create image window: */\n\t\tiswa.override_redirect = True;\n\t\tiswa.backing_store = NotUseful;\n\t\tiswa.save_under = False;\n\t\tiswa.background_pixmap = ParentRelative;\n\n\t\tiwin = XCreateWindow(dpy, window, 0, 0, wdpy_x, wdpy_y, 0,\n\t\t    depth, InputOutput, &visual, mask, &iswa);\n\n\t\trfbLog(\"snapshotting background...\\n\");\n\n\t\tXMapWindow(dpy, iwin);\n\t\tXSync(dpy, False);\n\t\timage = XGetImage(dpy, iwin, 0, 0, wdpy_x, wdpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tXSync(dpy, False);\n\t\tXDestroyWindow(dpy, iwin);\n\t\trfbLog(\"done.\\n\");\n\t}\n\tif (color == (char *) 0x1) {\n\t\t/* caller will XDestroyImage it: */\n\t\tXImage *xi = image;\n\t\timage = NULL;\n\t\treturn xi;\n\t}\n\n\t/* use black for low colors or failure */\n\tpixel = get_pixel(color);\n\n\trfbLog(\"setting solid background...\\n\");\n\tXSetWindowBackground(dpy, window, pixel);\n\tXMapWindow(dpy, expose);\n\tXSync(dpy, False);\n\tXDestroyWindow(dpy, expose);\n#endif\t/* NO_X11 */\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_pixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "157-175",
    "snippet": "unsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "XImage *solid_root(char *color);",
      "static void solid_cde(char *color);",
      "static void solid_gnome(char *color);",
      "static void solid_kde(char *color);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error parsing/allocing color: %s\\n\"",
            "color"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocColor",
          "args": [
            "dpy",
            "cmap",
            "&cdef"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XParseColor",
          "args": [
            "dpy",
            "cmap",
            "color",
            "&cdef"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultColormap",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "color",
            "solid_default"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nunsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}"
  },
  {
    "function_name": "cmd_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "119-153",
    "snippet": "static char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "output",
            "line"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "output"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "p"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usr_bin_path",
          "args": [
            "1"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "usr_bin_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "56-81",
          "snippet": "static void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic void solid_macosx(int restore);\n\nstatic void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n  %s\\n\\n\"",
            "cmd"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running pipe:\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   cmd_output: null string.\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "cmd"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic char *cmd_output(char *cmd) {\n\tFILE *p;\n\tstatic char output[50000];\n\tchar line[1024];\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn \"\";\n\t}\n\n\tif (no_external_cmds) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   cmd_output: null string.\\n\");\n\t\treturn \"\";\n\t}\n\n\trfbLog(\"running pipe:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\tp = popen(cmd, \"r\");\n\tusr_bin_path(1);\n\n\toutput[0] = '\\0';\n\n\twhile (fgets(line, 1024, p) != NULL) {\n\t\tif (strlen(output) + strlen(line) + 1 < 50000) {\n\t\t\tstrcat(output, line);\n\t\t}\n\t}\n\tpclose(p);\n\treturn(output);\n}"
  },
  {
    "function_name": "dt_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "83-117",
    "snippet": "static int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int dt_cmd(char *cmd);",
      "static char *cmd_output(char *cmd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usr_bin_path",
          "args": [
            "1"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "usr_bin_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "56-81",
          "snippet": "static void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic void solid_macosx(int restore);\n\nstatic void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n  %s\\n\\n\"",
            "cmd"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running command:\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "DisplayString(dpy)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   dt_cmd: returning 1\\n\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "cmd"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"dt\""
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\n\nstatic int dt_cmd(char *cmd) {\n\tint rc;\n\n\tRAWFB_RET(0)\n\n\tif (!cmd || *cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\t/* dt */\n\tif (no_external_cmds || !cmd_ok(\"dt\")) {\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   dt_cmd: returning 1\\n\");\n\t\treturn 1;\n\t}\n\n\tif (getenv(\"DISPLAY\") == NULL) {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tusr_bin_path(0);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tusr_bin_path(1);\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "usr_bin_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
    "lines": "56-81",
    "snippet": "static void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}",
    "includes": [
      "#include \"xevents.h\"",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void solid_bg(int restore);",
      "static void usr_bin_path(int restore);",
      "static void solid_macosx(int restore);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newpath"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"PATH\"",
            "newpath"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "newpath",
            "oldpath"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "newpath",
            "addpath"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(oldpath) + strlen(addpath) + 1"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "addpath"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oldpath"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/usr/bin\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"PATH\")"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic void solid_macosx(int restore);\n\nstatic void usr_bin_path(int restore) {\n\tstatic char *oldpath = NULL;\n\tchar *newpath;\n\tchar addpath[] = \"/usr/bin:/bin:\";\n\n\tif (restore) {\n\t\tif (oldpath) {\n\t\t\tset_env(\"PATH\", oldpath);\n\t\t\tfree(oldpath);\n\t\t\toldpath = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"PATH\")) {\n\t\toldpath = strdup(getenv(\"PATH\"));\n\t} else {\n\t\toldpath = strdup(\"/usr/bin\");\n\t}\n\tnewpath = (char *) malloc(strlen(oldpath) + strlen(addpath) + 1);\n\tnewpath[0] = '\\0';\n\tstrcat(newpath, addpath);\n\tstrcat(newpath, oldpath);\n\tset_env(\"PATH\", newpath);\n\tfree(newpath);\n}"
  }
]