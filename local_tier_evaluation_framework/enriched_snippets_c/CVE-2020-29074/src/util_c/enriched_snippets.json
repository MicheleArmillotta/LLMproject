[
  {
    "function_name": "choose_title",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "713-790",
    "snippet": "char *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);",
      "double dabs(double x);",
      "char *get_user_name(void);",
      "char *this_host(void);",
      "char *choose_title(char *display);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"appshare title: %s\\n\"",
            "title"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "title",
            "tmp",
            "MAXN - strlen(title)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\" XY=%d,%d\"",
            "x",
            "y"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "subwin",
            "rootwin",
            "0",
            "0",
            "&x",
            "&y",
            "&c",
            "1"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "title",
            "name",
            "MAXN - strlen(title)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "title",
            "\" \"",
            "MAXN - strlen(title)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "subwin",
            "&name"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_ACTIVE\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "subwin",
            "NULL",
            "0"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "title",
            "display",
            "MAXN - strlen(title)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "title",
            "th",
            "MAXN - strlen(title)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "title",
            "th ? th : UT.nodename",
            "MAXN - strlen(title)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "title"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "title",
            "\"@\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "title",
            "u"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "u"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_name",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "271-293",
          "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_user_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "display",
            "\"/tmp/\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "title",
            "\"x11vnc\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "title",
            "0",
            "sizeof(title)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dabs(double x);\nchar *get_user_name(void);\nchar *this_host(void);\nchar *choose_title(char *display);\n\nchar *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}"
  },
  {
    "function_name": "rect_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "673-708",
    "snippet": "double rect_overlap(int x1, int y1, int x2, int y2, int X1, int Y1,\n    int X2, int Y2) {\n\tdouble a, A, o;\n\tsraRegionPtr r, R;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\n\ta = nabs((x2 - x1) * (y2 - y1));\n\tA = nabs((X2 - X1) * (Y2 - Y1));\n\n\tif (a == 0 || A == 0) {\n\t\treturn 0.0;\n\t}\n\n\tr = sraRgnCreateRect(x1, y1, x2, y2);\n\tR = sraRgnCreateRect(X1, Y1, X2, Y2);\n\n\tsraRgnAnd(r, R);\n\t\n\to = 0.0;\n\titer = sraRgnGetIterator(r);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\to += nabs( (rt.x2 - rt.x1) * (rt.y2 - rt.y1) );\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\tsraRgnDestroy(r);\n\tsraRgnDestroy(R);\n\n\tif (a < A) {\n\t\to = o/a;\n\t} else {\n\t\to = o/A;\n\t}\n\treturn o;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double rect_overlap(int x1, int y1, int x2, int y2, int X1, int Y1,\n    int X2, int Y2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "R"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "(rt.x2 - rt.x1) * (rt.y2 - rt.y1)"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rt"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "r"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r",
            "R"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "X1",
            "Y1",
            "X2",
            "Y2"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rect_overlap(int x1, int y1, int x2, int y2, int X1, int Y1,\n    int X2, int Y2);\n\ndouble rect_overlap(int x1, int y1, int x2, int y2, int X1, int Y1,\n    int X2, int Y2) {\n\tdouble a, A, o;\n\tsraRegionPtr r, R;\n\tsraRectangleIterator *iter;\n\tsraRect rt;\n\n\ta = nabs((x2 - x1) * (y2 - y1));\n\tA = nabs((X2 - X1) * (Y2 - Y1));\n\n\tif (a == 0 || A == 0) {\n\t\treturn 0.0;\n\t}\n\n\tr = sraRgnCreateRect(x1, y1, x2, y2);\n\tR = sraRgnCreateRect(X1, Y1, X2, Y2);\n\n\tsraRgnAnd(r, R);\n\t\n\to = 0.0;\n\titer = sraRgnGetIterator(r);\n\twhile (sraRgnIteratorNext(iter, &rt)) {\n\t\to += nabs( (rt.x2 - rt.x1) * (rt.y2 - rt.y1) );\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\tsraRgnDestroy(r);\n\tsraRgnDestroy(R);\n\n\tif (a < A) {\n\t\to = o/a;\n\t} else {\n\t\to = o/A;\n\t}\n\treturn o;\n}"
  },
  {
    "function_name": "rfbCFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "621-671",
    "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
    ],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);",
      "double dnow(void);",
      "int rfbPE(long usec);",
      "void rfbCFD(long usec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbCFD: got new client in non-rfbPE\\n\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCheckFds",
          "args": [
            "screen",
            "usec"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_allinput",
          "args": [
            "usec"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "do_allinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "512-554",
          "snippet": "static void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nmin(int n, int m);",
            "int nmax(int n, int m);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nstatic void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rfbCFD(%d) t: %.4f\\n\"",
            "(int) usec",
            "tm - x11vnc_start"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_in_rfbPE: skipping rfbCFD\\n\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
  },
  {
    "function_name": "rfbPE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "561-619",
    "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
    ],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);",
      "double dnow(void);",
      "int rfbPE(long usec);",
      "void rfbCFD(long usec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_allinput",
          "args": [
            "usec"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "do_allinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "512-554",
          "snippet": "static void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nmin(int n, int m);",
            "int nmax(int n, int m);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nstatic void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_allinput_rate",
          "args": [],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "check_allinput_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "475-510",
          "snippet": "void check_allinput_rate(void) {\n\tstatic double last_all_input_check = 0.0;\n\tstatic int set = 0, verb = -1;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\tif (! set) {\n\t\tset = 1;\n\t\tlast_all_input_check = dnow();\n\t} else {\n\t\tint dt = 5;\n\t\tif (x11vnc_current > last_all_input_check + dt) {\n\t\t\tint n, nq = 0;\n\t\t\twhile ((n = rfbCheckFds(screen, 0))) {\n\t\t\t\tnq += n;\n\t\t\t}\n\t\t\tif (verb) fprintf(stderr, \"nqueued: %d\\n\", nq);\n\t\t\tif (getenv(\"CHECK_RATE\") && nq > 18 * dt) {\n\t\t\t\tdouble rate = nq / dt;\n\t\t\t\tif (verb) rfbLog(\"check_allinput_rate:\\n\");\n\t\t\t\tif (verb) rfbLog(\"Client is sending %.1f extra requests per second for the\\n\", rate);\n\t\t\t\tif (verb) rfbLog(\"past %d seconds! (queued: %d)\\n\", dt, nq);\n\t\t\t\tif (strstr(getenv(\"CHECK_RATE\"), \"allinput\") && !all_input && !handle_events_eagerly) {\n\t\t\t\t\trfbLog(\"Switching to -allpinput mode.\\n\");\n\t\t\t\t\tall_input = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\n\nvoid check_allinput_rate(void) {\n\tstatic double last_all_input_check = 0.0;\n\tstatic int set = 0, verb = -1;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\tif (! set) {\n\t\tset = 1;\n\t\tlast_all_input_check = dnow();\n\t} else {\n\t\tint dt = 5;\n\t\tif (x11vnc_current > last_all_input_check + dt) {\n\t\t\tint n, nq = 0;\n\t\t\twhile ((n = rfbCheckFds(screen, 0))) {\n\t\t\t\tnq += n;\n\t\t\t}\n\t\t\tif (verb) fprintf(stderr, \"nqueued: %d\\n\", nq);\n\t\t\tif (getenv(\"CHECK_RATE\") && nq > 18 * dt) {\n\t\t\t\tdouble rate = nq / dt;\n\t\t\t\tif (verb) rfbLog(\"check_allinput_rate:\\n\");\n\t\t\t\tif (verb) rfbLog(\"Client is sending %.1f extra requests per second for the\\n\", rate);\n\t\t\t\tif (verb) rfbLog(\"past %d seconds! (queued: %d)\\n\", dt, nq);\n\t\t\t\tif (strstr(getenv(\"CHECK_RATE\"), \"allinput\") && !all_input && !handle_events_eagerly) {\n\t\t\t\t\trfbLog(\"Switching to -allpinput mode.\\n\");\n\t\t\t\t\tall_input = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"CHECK_RATE\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_unix_sock",
          "args": [
            "usec"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "check_unix_sock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1860-1921",
          "snippet": "void check_unix_sock(long usec) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1;\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!unix_sock || unix_sock_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (unix_sock_fd >= 0) {\n\t\tFD_SET(unix_sock_fd, &fds);\n\t\tnmax = unix_sock_fd;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (unix_sock_fd >= 0 && FD_ISSET(unix_sock_fd, &fds)) {\n\t\tcsock = accept_unix(unix_sock_fd);\n\t\tif (csock < 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_unix_sock: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* rfbNewClient() will screw us with setsockopt TCP_NODELAY...\n\t\t   you need to comment out in libvncserver/rfbserver.c:\n\t\t\trfbLogPerror(\"setsockopt failed\");\n\t\t\tclose(sock);\n\t\t\treturn NULL;\n\t\t */\n\t\tcl = rfbNewClient(screen, csock);\n\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\tname = strdup(unix_sock);\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"unix sock client: %s\\n\", name);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void check_ipv6_listen(long usec);",
            "void check_unix_sock(long usec);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid check_ipv6_listen(long usec);\nvoid check_unix_sock(long usec);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid check_unix_sock(long usec) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1;\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!unix_sock || unix_sock_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (unix_sock_fd >= 0) {\n\t\tFD_SET(unix_sock_fd, &fds);\n\t\tnmax = unix_sock_fd;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (unix_sock_fd >= 0 && FD_ISSET(unix_sock_fd, &fds)) {\n\t\tcsock = accept_unix(unix_sock_fd);\n\t\tif (csock < 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_unix_sock: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* rfbNewClient() will screw us with setsockopt TCP_NODELAY...\n\t\t   you need to comment out in libvncserver/rfbserver.c:\n\t\t\trfbLogPerror(\"setsockopt failed\");\n\t\t\tclose(sock);\n\t\t\treturn NULL;\n\t\t */\n\t\tcl = rfbNewClient(screen, csock);\n\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\tname = strdup(unix_sock);\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"unix sock client: %s\\n\", name);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ipv6_listen",
          "args": [
            "usec"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "check_ipv6_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1746-1858",
          "snippet": "void check_ipv6_listen(long usec) {\n#if X11VNC_IPV6\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1, one = 1;\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!ipv6_listen || noipv6) {\n\t\treturn;\n\t}\n\tif (ipv6_listen_fd < 0 && ipv6_http_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (ipv6_listen_fd >= 0) {\n\t\tFD_SET(ipv6_listen_fd, &fds);\n\t\tnmax = ipv6_listen_fd;\n\t}\n\tif (ipv6_http_fd >= 0 && screen->httpSock < 0) {\n\t\tFD_SET(ipv6_http_fd, &fds);\n\t\tif (ipv6_http_fd > nmax) {\n\t\t\tnmax = ipv6_http_fd;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ipv6_listen_fd >= 0 && FD_ISSET(ipv6_listen_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_listen_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\tgoto err1;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tname = ipv6_getipaddr((struct sockaddr *) &addr, addrlen);\n\n\t\tipv6_client_ip_str = name;\n\t\tcl = rfbNewClient(screen, csock);\n\t\tipv6_client_ip_str = NULL;\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"ipv6 client: %s\\n\", name);\n\t\t}\n\t}\n\n\terr1:\n\n\tif (ipv6_http_fd >= 0 && FD_ISSET(ipv6_http_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_http_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"check_ipv6_listen: setting httpSock to %d\\n\", csock);\n\t\tscreen->httpSock = csock;\n\n\t\tif (screen->httpListenSock < 0) {\n\t\t\t/* this may not always work... */\n\t\t\tint save = screen->httpListenSock;\n\t\t\tscreen->httpListenSock = ipv6_http_fd;\t\n\t\t\trfbLog(\"check_ipv6_listen: no httpListenSock, calling rfbHttpCheckFds()\\n\");\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tscreen->httpListenSock = save;\t\n\t\t}\n\t}\n#endif\n\tif (usec) {}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void check_ipv6_listen(long usec);",
            "void check_unix_sock(long usec);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid check_ipv6_listen(long usec);\nvoid check_unix_sock(long usec);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\n\nvoid check_ipv6_listen(long usec) {\n#if X11VNC_IPV6\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1, one = 1;\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!ipv6_listen || noipv6) {\n\t\treturn;\n\t}\n\tif (ipv6_listen_fd < 0 && ipv6_http_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (ipv6_listen_fd >= 0) {\n\t\tFD_SET(ipv6_listen_fd, &fds);\n\t\tnmax = ipv6_listen_fd;\n\t}\n\tif (ipv6_http_fd >= 0 && screen->httpSock < 0) {\n\t\tFD_SET(ipv6_http_fd, &fds);\n\t\tif (ipv6_http_fd > nmax) {\n\t\t\tnmax = ipv6_http_fd;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ipv6_listen_fd >= 0 && FD_ISSET(ipv6_listen_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_listen_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\tgoto err1;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tname = ipv6_getipaddr((struct sockaddr *) &addr, addrlen);\n\n\t\tipv6_client_ip_str = name;\n\t\tcl = rfbNewClient(screen, csock);\n\t\tipv6_client_ip_str = NULL;\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"ipv6 client: %s\\n\", name);\n\t\t}\n\t}\n\n\terr1:\n\n\tif (ipv6_http_fd >= 0 && FD_ISSET(ipv6_http_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_http_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"check_ipv6_listen: setting httpSock to %d\\n\", csock);\n\t\tscreen->httpSock = csock;\n\n\t\tif (screen->httpListenSock < 0) {\n\t\t\t/* this may not always work... */\n\t\t\tint save = screen->httpListenSock;\n\t\t\tscreen->httpListenSock = ipv6_http_fd;\t\n\t\t\trfbLog(\"check_ipv6_listen: no httpListenSock, calling rfbHttpCheckFds()\\n\");\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tscreen->httpListenSock = save;\t\n\t\t}\n\t}\n#endif\n\tif (usec) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbPE: got new client in non-rfbPE\\n\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbProcessEvents",
          "args": [
            "screen",
            "usec"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rfbPE(%d)  t: %.4f\\n\"",
            "(int) usec",
            "tm - x11vnc_start"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_in_rfbPE: skipping rfbPE\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "do_allinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "512-554",
    "snippet": "static void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nmin(int n, int m);",
      "int nmax(int n, int m);",
      "int nabs(int n);",
      "double dnow(void);",
      "int rfbPE(long usec);",
      "void rfbCFD(long usec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n allinput rate: %.2f \"",
            "rate"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"+%d/%d\"",
            "cnt",
            "m"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" *\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCheckFds",
          "args": [
            "screen",
            "usec"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RATE_VERB\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nstatic void do_allinput(long usec) {\n\tstatic double last = 0.0;\n\tstatic int meas = 0, verb = -1;\n\tint n, f = 1, cnt = 0, m = 0;\n\tlong usec0;\n\tdouble now;\n\tif (!screen || !screen->clientHead) {\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (usec < 0) {\n\t\tusec = 0;\n\t}\n\tusec0 = usec;\n\tif (last == 0.0) {\n\t\tlast = dnow();\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\twhile ((n = rfbCheckFds(screen, usec)) > 0) {\n\t\tif (f) {\n\t\t\tif (verb) fprintf(stderr, \" *\");\n\t\t\tf = 0;\n\t\t}\n\t\tif (cnt++ > 30) {\n\t\t\tbreak;\n\t\t}\n\t\tmeas += n;\n\t\tm += n;\n\t}\n\tif (verb) fprintf(stderr, \"+%d/%d\", cnt, m);\n\tnow = dnow();\n\tif (now > last + 2.0) {\n\t\tdouble rate = meas / (now - last);\n\t\tif (verb) fprintf(stderr, \"\\n allinput rate: %.2f \", rate);\n\t\tmeas = 0;\n\t\tlast = dnow();\n\t}\n}"
  },
  {
    "function_name": "check_allinput_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "475-510",
    "snippet": "void check_allinput_rate(void) {\n\tstatic double last_all_input_check = 0.0;\n\tstatic int set = 0, verb = -1;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\tif (! set) {\n\t\tset = 1;\n\t\tlast_all_input_check = dnow();\n\t} else {\n\t\tint dt = 5;\n\t\tif (x11vnc_current > last_all_input_check + dt) {\n\t\t\tint n, nq = 0;\n\t\t\twhile ((n = rfbCheckFds(screen, 0))) {\n\t\t\t\tnq += n;\n\t\t\t}\n\t\t\tif (verb) fprintf(stderr, \"nqueued: %d\\n\", nq);\n\t\t\tif (getenv(\"CHECK_RATE\") && nq > 18 * dt) {\n\t\t\t\tdouble rate = nq / dt;\n\t\t\t\tif (verb) rfbLog(\"check_allinput_rate:\\n\");\n\t\t\t\tif (verb) rfbLog(\"Client is sending %.1f extra requests per second for the\\n\", rate);\n\t\t\t\tif (verb) rfbLog(\"past %d seconds! (queued: %d)\\n\", dt, nq);\n\t\t\t\tif (strstr(getenv(\"CHECK_RATE\"), \"allinput\") && !all_input && !handle_events_eagerly) {\n\t\t\t\t\trfbLog(\"Switching to -allpinput mode.\\n\");\n\t\t\t\t\tall_input = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);",
      "double dnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Switching to -allpinput mode.\\n\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "getenv(\"CHECK_RATE\")",
            "\"allinput\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"CHECK_RATE\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"past %d seconds! (queued: %d)\\n\"",
            "dt",
            "nq"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Client is sending %.1f extra requests per second for the\\n\"",
            "rate"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_allinput_rate:\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"CHECK_RATE\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nqueued: %d\\n\"",
            "nq"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCheckFds",
          "args": [
            "screen",
            "0"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RATE_VERB\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\n\nvoid check_allinput_rate(void) {\n\tstatic double last_all_input_check = 0.0;\n\tstatic int set = 0, verb = -1;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\tif (verb < 0) {\n\t\tverb = 0;\n\t\tif (getenv(\"RATE_VERB\")) verb = 1;\n\t}\n\tif (! set) {\n\t\tset = 1;\n\t\tlast_all_input_check = dnow();\n\t} else {\n\t\tint dt = 5;\n\t\tif (x11vnc_current > last_all_input_check + dt) {\n\t\t\tint n, nq = 0;\n\t\t\twhile ((n = rfbCheckFds(screen, 0))) {\n\t\t\t\tnq += n;\n\t\t\t}\n\t\t\tif (verb) fprintf(stderr, \"nqueued: %d\\n\", nq);\n\t\t\tif (getenv(\"CHECK_RATE\") && nq > 18 * dt) {\n\t\t\t\tdouble rate = nq / dt;\n\t\t\t\tif (verb) rfbLog(\"check_allinput_rate:\\n\");\n\t\t\t\tif (verb) rfbLog(\"Client is sending %.1f extra requests per second for the\\n\", rate);\n\t\t\t\tif (verb) rfbLog(\"past %d seconds! (queued: %d)\\n\", dt, nq);\n\t\t\t\tif (strstr(getenv(\"CHECK_RATE\"), \"allinput\") && !all_input && !handle_events_eagerly) {\n\t\t\t\t\trfbLog(\"Switching to -allpinput mode.\\n\");\n\t\t\t\t\tall_input = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rfac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "454-473",
    "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double rnow(void);",
      "double rfac(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xrandr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "61-84",
          "snippet": "void initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "void initialize_xrandr(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nvoid initialize_xrandr(void);\n\nvoid initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "s"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnow",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "rnow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "443-452",
          "snippet": "double rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double rnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble rnow(void);\n\ndouble rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"RAND_SEED\")"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RAND_SEED\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RAND_SEED\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
  },
  {
    "function_name": "rnow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "443-452",
    "snippet": "double rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dnow(void);",
      "double rnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble rnow(void);\n\ndouble rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}"
  },
  {
    "function_name": "dnowx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "439-441",
    "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dnow(void);",
      "double dnowx(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
  },
  {
    "function_name": "dnow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "434-437",
    "snippet": "double dnow(void) {\n\tdouble t;\n\treturn dtime0(&t);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dtime0(double *);",
      "double dnow(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&t"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime0(double *);\ndouble dnow(void);\n\ndouble dnow(void) {\n\tdouble t;\n\treturn dtime0(&t);\n}"
  },
  {
    "function_name": "dtime0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "429-432",
    "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dtime(double *);",
      "double dtime0(double *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "t_old"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
  },
  {
    "function_name": "dtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "409-426",
    "snippet": "double dtime(double *t_old) {\n\t/* \n\t * usage: call with 0.0 to initialize, subsequent calls give\n\t * the time difference since last call.\n\t */\n\tdouble t_now, dt;\n\tstruct timeval now;\n\n\tgettimeofday(&now, NULL);\n\tt_now = now.tv_sec + ( (double) now.tv_usec/1000000. );\n\tif (*t_old == 0.0) {\n\t\t*t_old = t_now;\n\t\treturn t_now;\n\t}\n\tdt = t_now - *t_old;\n\t*t_old = t_now;\n\treturn(dt);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dtime(double *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&now",
            "NULL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\n\ndouble dtime(double *t_old) {\n\t/* \n\t * usage: call with 0.0 to initialize, subsequent calls give\n\t * the time difference since last call.\n\t */\n\tdouble t_now, dt;\n\tstruct timeval now;\n\n\tgettimeofday(&now, NULL);\n\tt_now = now.tv_sec + ( (double) now.tv_usec/1000000. );\n\tif (*t_old == 0.0) {\n\t\t*t_old = t_now;\n\t\treturn t_now;\n\t}\n\tdt = t_now - *t_old;\n\t*t_old = t_now;\n\treturn(dt);\n}"
  },
  {
    "function_name": "create_str_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "372-403",
    "snippet": "char **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);",
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "int match_str_list(char *str, char **list);",
      "char **create_str_list(char *cslist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(n+1)*sizeof(char *)",
            "1"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cslist"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\nchar **create_str_list(char *cslist);\n\nchar **create_str_list(char *cslist) {\n\tint i, n;\n\tchar *p, *str;\n\tchar **list = NULL;\n\n\tif (! cslist) {\n\t\treturn NULL;\n\t}\n\t\n\tstr = strdup(cslist);\n\tn = 1;\n\tp = str;\n\twhile (*p != '\\0') {\n\t\tif (*p == ',') {\n\t\t\tn++;\n\t\t}\n\t\tp++;\n\t}\n\n\t/* the extra last one holds NULL */\n\tlist = (char **) calloc((n+1)*sizeof(char *), 1);\n\n\tp = strtok(str, \",\");\n\ti = 0;\n\twhile (p && i < n) {\n\t\tlist[i++] = strdup(p);\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\treturn list;\n}"
  },
  {
    "function_name": "match_str_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "353-370",
    "snippet": "int match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "int match_str_list(char *str, char **list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "list[i]"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "list[i]",
            "\"*\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\n\nint match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}"
  },
  {
    "function_name": "this_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "340-351",
    "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *this_host(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UT.nodename"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "host",
            "MAXN"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "316-335",
    "snippet": "char *get_shell(void) {\n\tchar *shell = NULL;\n\n\tshell = getenv(\"SHELL\");\n\n#if HAVE_PWD_H\n\tif (shell == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tshell = pw->pw_shell;\n\t\t}\n\t}\n#endif\n\n\tif (shell) {\n\t\treturn(strdup(shell));\n\t} else {\n\t\treturn(strdup(\"/bin/sh\"));\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_shell(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/bin/sh\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "shell"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_shell(void);\n\nchar *get_shell(void) {\n\tchar *shell = NULL;\n\n\tshell = getenv(\"SHELL\");\n\n#if HAVE_PWD_H\n\tif (shell == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tshell = pw->pw_shell;\n\t\t}\n\t}\n#endif\n\n\tif (shell) {\n\t\treturn(strdup(shell));\n\t} else {\n\t\treturn(strdup(\"/bin/sh\"));\n\t}\n}"
  },
  {
    "function_name": "get_home_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "295-314",
    "snippet": "char *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_home_dir(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "home"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"HOME\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_home_dir(void);\n\nchar *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}"
  },
  {
    "function_name": "get_user_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "271-293",
    "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_user_name(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown-user\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwuid",
          "args": [
            "getuid()"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LOGNAME\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"USER\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
  },
  {
    "function_name": "bitprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "251-269",
    "snippet": "char *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "char *bitprint(unsigned int st, int nbits);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nchar *bitprint(unsigned int st, int nbits);\n\nchar *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}"
  },
  {
    "function_name": "set_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "239-249",
    "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "void set_env(char *name, char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "name",
            "value",
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
  },
  {
    "function_name": "parse_geom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "210-237",
    "snippet": "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dabs(double x);",
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "h"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%dx%d-%d-%d\"",
            "&w",
            "&h",
            "&x",
            "&y"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%dx%d+%d-%d\"",
            "&w",
            "&h",
            "&x",
            "&y"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%dx%d-%d+%d\"",
            "&w",
            "&h",
            "&x",
            "&y"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%dx%d+%d+%d\"",
            "&w",
            "&h",
            "&x",
            "&y"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);\n\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}"
  },
  {
    "function_name": "scan_hexdec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "201-208",
    "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);",
      "int scan_hexdec(char *str, unsigned long *num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lu\"",
            "num"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"0x%lx\"",
            "num"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "is_decimal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "181-199",
    "snippet": "int is_decimal(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\tint first = 1;\n\t\twhile (*p != '\\0') {\n\t\t\tif (first && *p == '-') {\n\t\t\t\t;\n\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t\tp++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(int) *p"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nint is_decimal(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\tint first = 1;\n\t\twhile (*p != '\\0') {\n\t\t\tif (first && *p == '-') {\n\t\t\t\t;\n\t\t\t} else if (isdigit((int) *p)) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t\tp++;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "strzero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "171-179",
    "snippet": "void strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "lblanks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "160-169",
    "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) (*p)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "uppercase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "148-158",
    "snippet": "void uppercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = toupper((unsigned char) (*p));\n\t\tp++;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "(unsigned char) (*p)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid uppercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = toupper((unsigned char) (*p));\n\t\tp++;\n\t}\n}"
  },
  {
    "function_name": "lowercase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "136-146",
    "snippet": "void lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void lowercase(char *str);",
      "void uppercase(char *str);",
      "char *lblanks(char *str);",
      "void strzero(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "(unsigned char) (*p)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}"
  },
  {
    "function_name": "dabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "128-134",
    "snippet": "double dabs(double x) {\n\tif (x < 0.0) {\n\t\treturn -x;\n\t} else {\n\t\treturn x;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "double dabs(double x);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\n\ndouble dabs(double x) {\n\tif (x < 0.0) {\n\t\treturn -x;\n\t} else {\n\t\treturn x;\n\t}\n}"
  },
  {
    "function_name": "nabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "120-126",
    "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
  },
  {
    "function_name": "nmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "112-118",
    "snippet": "int nmax(int n, int m) {\n\tif (n > m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nmin(int n, int m);",
      "int nmax(int n, int m);",
      "int nabs(int n);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\n\nint nmax(int n, int m) {\n\tif (n > m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}"
  },
  {
    "function_name": "nmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "104-110",
    "snippet": "int nmin(int n, int m) {\n\tif (n < m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nmin(int n, int m);",
      "int nmax(int n, int m);",
      "int nabs(int n);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nmin(int n, int m);\nint nmax(int n, int m);\nint nabs(int n);\n\nint nmin(int n, int m) {\n\tif (n < m) {\n\t\treturn n;\n\t} else {\n\t\treturn m;\n\t}\n}"
  },
  {
    "function_name": "nfix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
    "lines": "95-102",
    "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"unixpw.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfix(int i, int n);",
      "int nabs(int n);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
  }
]