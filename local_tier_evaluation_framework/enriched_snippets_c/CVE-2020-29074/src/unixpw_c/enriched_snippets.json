[
  {
    "function_name": "unixpw_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "2260-2281",
    "snippet": "void unixpw_msg(char *msg, int delay) {\n\tint x, y, i;\n\n\tchar_row += 2;\n\tchar_col = 0;\n\tx = char_x + char_col * char_w;\n\ty = char_y + char_row * char_h;\n\n\trfbDrawString(pscreen, &default8x16Font, x, y, msg, white_pixel());\n\tunixpw_mark();\n\n\tfor (i=0; i<5; i++) {\n\t\trfbPE(-1);\n\t\trfbPE(-1);\n\t\trfbPE(50 * 1000);\n\t\trfbPE(-1);\n\t\tusleep(500 * 1000);\n\t\tif (i >= delay) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int white_pixel(void);",
      "void unixpw_msg(char *msg, int delay);",
      "static int char_row = 0, char_col = 0;",
      "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
      "static rfbScreenInfoPtr pscreen;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500 * 1000"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_mark",
          "args": [],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "402-408",
          "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "msg",
            "white_pixel()"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_msg(char *msg, int delay);\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_msg(char *msg, int delay) {\n\tint x, y, i;\n\n\tchar_row += 2;\n\tchar_col = 0;\n\tx = char_x + char_col * char_w;\n\ty = char_y + char_row * char_h;\n\n\trfbDrawString(pscreen, &default8x16Font, x, y, msg, white_pixel());\n\tunixpw_mark();\n\n\tfor (i=0; i<5; i++) {\n\t\trfbPE(-1);\n\t\trfbPE(-1);\n\t\trfbPE(50 * 1000);\n\t\trfbPE(-1);\n\t\tusleep(500 * 1000);\n\t\tif (i >= delay) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "unixpw_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "2218-2258",
    "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int white_pixel(void);",
      "void unixpw_deny(void);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int unixpw_in_progress = 0;",
      "int unixpw_denied = 0;",
      "int unixpw_tightvnc_xfer_save = 0;",
      "rfbBool unixpw_file_xfer_save = FALSE;",
      "rfbClientPtr unixpw_client = NULL;",
      "static int char_row = 0, char_col = 0;",
      "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
      "static rfbScreenInfoPtr pscreen;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_screen",
          "args": [],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "copy_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2412-2455",
          "snippet": "int copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "int copy_screen(void);",
            "static void blackout_regions(void);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_screen(void);\nstatic void blackout_regions(void);\nstatic int fs_factor = 0;\n\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbRegisterTightVNCFileTransferExtension",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbRegisterTightVNCFileTransferExtension: 2\\n\""
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientConnectionGone",
          "args": [
            "unixpw_client"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "unixpw_client"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500 * 1000"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_mark",
          "args": [],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "402-408",
          "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "pd",
            "white_pixel()"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_deny: %d, %d\\n\"",
            "unixpw_denied",
            "unixpw_in_progress"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
  },
  {
    "function_name": "unixpw_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "2145-2216",
    "snippet": "void unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "void unixpw_deny(void);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int unixpw_in_progress = 0;",
      "int unixpw_login_viewonly = 0;",
      "int unixpw_tightvnc_xfer_save = 0;",
      "rfbBool unixpw_file_xfer_save = FALSE;",
      "rfbClientPtr unixpw_client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refresh_screen",
          "args": [
            "1"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "517-526",
          "snippet": "void refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void refresh_screen(int push);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid refresh_screen(int push);\n\nvoid refresh_screen(int push) {\n\tint i;\n\tif (!screen) {\n\t\treturn;\n\t}\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tfor (i=0; i<push; i++) {\n\t\trfbPE(-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "0"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbRegisterTightVNCFileTransferExtension",
          "args": [],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbRegisterTightVNCFileTransferExtension: 1\\n\""
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "u"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept failed to switch to user: %s\\n\"",
            "user"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept switched to user: %s\\n\"",
            "user"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_user",
          "args": [
            "u",
            "0"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "immediate_switch_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1276-1329",
          "snippet": "static void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_rcfile(int argc, char **argv);",
            "static void immediate_switch_user(int argc, char* argv[]);",
            "static void check_loop_mode(int argc, char* argv[], int force);",
            "static void check_appshare_mode(int argc, char* argv[]);",
            "extern int appshare_main(int argc, char* argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void check_rcfile(int argc, char **argv);\nstatic void immediate_switch_user(int argc, char* argv[]);\nstatic void check_loop_mode(int argc, char* argv[], int force);\nstatic void check_appshare_mode(int argc, char* argv[]);\nextern int appshare_main(int argc, char* argv[]);\n\nstatic void immediate_switch_user(int argc, char* argv[]) {\n\tint i, bequiet = 0;\n\tfor (i=1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-inetd\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-quiet\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t\tif (strcmp(argv[i], \"-q\")) {\n\t\t\tbequiet = 1;\n\t\t}\n\t}\n\tfor (i=1; i < argc; i++) {\n\t\tchar *u, *q;\n\n\t\tif (strcmp(argv[i], \"-users\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == argc - 1) {\n\t\t\tfprintf(stderr, \"not enough arguments for: -users\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (*(argv[i+1]) != '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wants an immediate switch: =bob */\n\t\tu = strdup(argv[i+1]);\n\t\t*u = '+';\n\t\tq = strchr(u, '.');\n\t\tif (q) {\n\t\t\tuser2group = (char **) malloc(2*sizeof(char *));\n\t\t\tuser2group[0] = strdup(u+1);\n\t\t\tuser2group[1] = NULL;\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(u, \"+guess\") == u) {\n\t\t\tfprintf(stderr, \"invalid user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (!switch_user(u, 0)) {\n\t\t\tfprintf(stderr, \"Could not switch to user: %s\\n\", u+1);\n\t\t\texit(1);\n\t\t} else {\n\t\t\tif (!bequiet) {\n\t\t\t\tfprintf(stderr, \"Switched to user: %s\\n\", u+1);\n\t\t\t}\n\t\t\tstarted_as_root = 2;\n\t\t}\n\t\tfree(u);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept skipping switch to user: %s\\n\"",
            "user"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "user"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "user"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str + strlen(\"unixpw=\")",
            "\",\""
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"unixpw=\""
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "users_list"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "u",
            "\"+%s\"",
            "user"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "users_list",
            "\"unixpw=\""
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(user)+1"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_accept: unixpw= but not root\\n\""
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "users_list",
            "\"unixpw=\""
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept_client",
          "args": [
            "unixpw_client"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "accept_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1592-1744",
          "snippet": "int accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static void ugly_geom(char *p, int *x, int *y);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"WAIT:\""
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "accept_cmd",
            "\"popup\""
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "0",
            "-2"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_opts",
          "args": [
            "user"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "apply_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2057-2143",
          "snippet": "static void apply_opts (char *user) {\n\tchar *p, *q, *str, *opts = NULL, *opts_star = NULL;\n\trfbClientPtr cl;\n\tClientData *cd;\n\tint i, notmode = 0;\n\n\tif (! unixpw_client) {\n\t\trfbLog(\"apply_opts: unixpw_client is NULL\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tcd = (ClientData *) unixpw_client->clientData;\n\tcl = unixpw_client;\n\n\tif (! cd) {\n\t\trfbLog(\"apply_opts: no ClientData\\n\");\n\t}\n\t\n\tif (user && cd) {\n\t\tif (cd->unixname) {\n\t\t\tfree(cd->unixname);\n\t\t}\n\t\tcd->unixname = strdup(user);\n\t\trfbLog(\"apply_opts: set unixname to: %s\\n\", cd->unixname);\n\t}\n\n\tif (! unixpw_list) {\n\t\treturn;\n\t}\n\tstr = strdup(unixpw_list);\n\n\t/* apply any per-user options. */\n\tif (str[0] == '!') {\n\t\tp = strtok(str+1, \",\");\n\t\tnotmode = 1;\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\twhile (p) {\n\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t} else {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (user && !strcmp(user, p)) {\n\t\t\t/* will not happen in notmode */\n\t\t\topts = strdup(q+1);\n\t\t}\n\t\tif (!strcmp(\"*\", p)) {\n\t\t\topts_star = strdup(q+1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tfor (i=0; i < 2; i++) {\n\t\tchar *s = (i == 0) ? opts_star : opts;\n\t\tif (s == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tp = strtok(s, \"+\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, \"viewonly\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"fullaccess\")) {\n\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if ((q = strstr(p, \"input=\")) == p) {\n\t\t\t\tq += strlen(\"input=\");\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, q, CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"deny\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tunixpw_deny();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \"+\");\n\t\t}\n\t\tfree(s);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nrfbClientPtr unixpw_client = NULL;\n\nstatic void apply_opts (char *user) {\n\tchar *p, *q, *str, *opts = NULL, *opts_star = NULL;\n\trfbClientPtr cl;\n\tClientData *cd;\n\tint i, notmode = 0;\n\n\tif (! unixpw_client) {\n\t\trfbLog(\"apply_opts: unixpw_client is NULL\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tcd = (ClientData *) unixpw_client->clientData;\n\tcl = unixpw_client;\n\n\tif (! cd) {\n\t\trfbLog(\"apply_opts: no ClientData\\n\");\n\t}\n\t\n\tif (user && cd) {\n\t\tif (cd->unixname) {\n\t\t\tfree(cd->unixname);\n\t\t}\n\t\tcd->unixname = strdup(user);\n\t\trfbLog(\"apply_opts: set unixname to: %s\\n\", cd->unixname);\n\t}\n\n\tif (! unixpw_list) {\n\t\treturn;\n\t}\n\tstr = strdup(unixpw_list);\n\n\t/* apply any per-user options. */\n\tif (str[0] == '!') {\n\t\tp = strtok(str+1, \",\");\n\t\tnotmode = 1;\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\twhile (p) {\n\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t} else {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (user && !strcmp(user, p)) {\n\t\t\t/* will not happen in notmode */\n\t\t\topts = strdup(q+1);\n\t\t}\n\t\tif (!strcmp(\"*\", p)) {\n\t\t\topts_star = strdup(q+1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tfor (i=0; i < 2; i++) {\n\t\tchar *s = (i == 0) ? opts_star : opts;\n\t\tif (s == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tp = strtok(s, \"+\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, \"viewonly\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"fullaccess\")) {\n\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if ((q = strstr(p, \"input=\")) == p) {\n\t\t\t\tq += strlen(\"input=\");\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, q, CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"deny\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tunixpw_deny();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \"+\");\n\t\t}\n\t\tfree(s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_login_viewonly = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\n\nvoid unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}"
  },
  {
    "function_name": "apply_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "2057-2143",
    "snippet": "static void apply_opts (char *user) {\n\tchar *p, *q, *str, *opts = NULL, *opts_star = NULL;\n\trfbClientPtr cl;\n\tClientData *cd;\n\tint i, notmode = 0;\n\n\tif (! unixpw_client) {\n\t\trfbLog(\"apply_opts: unixpw_client is NULL\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tcd = (ClientData *) unixpw_client->clientData;\n\tcl = unixpw_client;\n\n\tif (! cd) {\n\t\trfbLog(\"apply_opts: no ClientData\\n\");\n\t}\n\t\n\tif (user && cd) {\n\t\tif (cd->unixname) {\n\t\t\tfree(cd->unixname);\n\t\t}\n\t\tcd->unixname = strdup(user);\n\t\trfbLog(\"apply_opts: set unixname to: %s\\n\", cd->unixname);\n\t}\n\n\tif (! unixpw_list) {\n\t\treturn;\n\t}\n\tstr = strdup(unixpw_list);\n\n\t/* apply any per-user options. */\n\tif (str[0] == '!') {\n\t\tp = strtok(str+1, \",\");\n\t\tnotmode = 1;\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\twhile (p) {\n\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t} else {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (user && !strcmp(user, p)) {\n\t\t\t/* will not happen in notmode */\n\t\t\topts = strdup(q+1);\n\t\t}\n\t\tif (!strcmp(\"*\", p)) {\n\t\t\topts_star = strdup(q+1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tfor (i=0; i < 2; i++) {\n\t\tchar *s = (i == 0) ? opts_star : opts;\n\t\tif (s == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tp = strtok(s, \"+\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, \"viewonly\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"fullaccess\")) {\n\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if ((q = strstr(p, \"input=\")) == p) {\n\t\t\t\tq += strlen(\"input=\");\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, q, CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"deny\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tunixpw_deny();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \"+\");\n\t\t}\n\t\tfree(s);\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "void unixpw_deny(void);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "rfbClientPtr unixpw_client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"+\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"deny\""
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cd->input",
            "q",
            "CILEN"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"input=\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"input=\""
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cd->input",
            "\"-\"",
            "CILEN"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"fullaccess\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cd->input",
            "\"-\"",
            "CILEN"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"viewonly\""
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\"+\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"*\"",
            "p"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "p"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str+1",
            "\",\""
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "unixpw_list"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"apply_opts: set unixname to: %s\\n\"",
            "cd->unixname"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"apply_opts: no ClientData\\n\""
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"apply_opts: unixpw_client is NULL\\n\""
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nrfbClientPtr unixpw_client = NULL;\n\nstatic void apply_opts (char *user) {\n\tchar *p, *q, *str, *opts = NULL, *opts_star = NULL;\n\trfbClientPtr cl;\n\tClientData *cd;\n\tint i, notmode = 0;\n\n\tif (! unixpw_client) {\n\t\trfbLog(\"apply_opts: unixpw_client is NULL\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tcd = (ClientData *) unixpw_client->clientData;\n\tcl = unixpw_client;\n\n\tif (! cd) {\n\t\trfbLog(\"apply_opts: no ClientData\\n\");\n\t}\n\t\n\tif (user && cd) {\n\t\tif (cd->unixname) {\n\t\t\tfree(cd->unixname);\n\t\t}\n\t\tcd->unixname = strdup(user);\n\t\trfbLog(\"apply_opts: set unixname to: %s\\n\", cd->unixname);\n\t}\n\n\tif (! unixpw_list) {\n\t\treturn;\n\t}\n\tstr = strdup(unixpw_list);\n\n\t/* apply any per-user options. */\n\tif (str[0] == '!') {\n\t\tp = strtok(str+1, \",\");\n\t\tnotmode = 1;\n\t} else {\n\t\tp = strtok(str, \",\");\n\t}\n\twhile (p) {\n\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t} else {\n\t\t\tp = strtok(NULL, \",\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (user && !strcmp(user, p)) {\n\t\t\t/* will not happen in notmode */\n\t\t\topts = strdup(q+1);\n\t\t}\n\t\tif (!strcmp(\"*\", p)) {\n\t\t\topts_star = strdup(q+1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\n\tfor (i=0; i < 2; i++) {\n\t\tchar *s = (i == 0) ? opts_star : opts;\n\t\tif (s == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tp = strtok(s, \"+\");\n\t\twhile (p) {\n\t\t\tif (!strcmp(p, \"viewonly\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"fullaccess\")) {\n\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, \"-\", CILEN);\n\t\t\t\t}\n\t\t\t} else if ((q = strstr(p, \"input=\")) == p) {\n\t\t\t\tq += strlen(\"input=\");\n\t\t\t\tif (cd) {\n\t\t\t\t\tstrncpy(cd->input, q, CILEN);\n\t\t\t\t}\n\t\t\t} else if (!strcmp(p, \"deny\")) {\n\t\t\t\tcl->viewOnly = TRUE;\n\t\t\t\tunixpw_deny();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \"+\");\n\t\t}\n\t\tfree(s);\n\t}\n}"
  },
  {
    "function_name": "unixpw_keystroke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1666-2055",
    "snippet": "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int white_pixel(void);",
      "void unixpw_screen(int init);",
      "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);",
      "void unixpw_accept(char *user);",
      "void unixpw_deny(void);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);",
      "static int text_x(void);",
      "static int text_y(void);",
      "static void set_db(void);",
      "int unixpw_denied = 0;",
      "time_t unixpw_last_try_time = 0;",
      "int keep_unixpw = 0;",
      "char *keep_unixpw_user = NULL;",
      "char *keep_unixpw_pass = NULL;",
      "char *keep_unixpw_opts = NULL;",
      "static rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};",
      "static int in_login = 0, in_passwd = 0, tries = 0;",
      "static int char_row = 0, char_col = 0;",
      "static int db = 0;",
      "static rfbScreenInfoPtr pscreen;",
      "static int f1_help = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_deny: password too long: %d\\n\"",
            "p_cnt"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_verify_screen",
          "args": [
            "user",
            "pass"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_verify_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1568-1657",
          "snippet": "void unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int text_x(void);",
            "static int text_y(void);",
            "time_t unixpw_last_try_time = 0;",
            "rfbClientPtr unixpw_client = NULL;",
            "int keep_unixpw = 0;",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_pass = NULL;",
            "char *keep_unixpw_opts = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int db = 0;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\ntime_t unixpw_last_try_time = 0;\nrfbClientPtr unixpw_client = NULL;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress_skippy",
          "args": [],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "progress_skippy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1498-1519",
          "snippet": "static void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_mark",
          "args": [],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "402-408",
          "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "text_x()",
            "text_y()",
            "msg",
            "white_pixel()"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_y",
          "args": [],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "text_y",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "414-416",
          "snippet": "static int text_y(void) {\n\treturn char_y + char_row * char_h;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int text_y(void);",
            "static int char_row = 0, char_col = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_y(void);\nstatic int char_row = 0, char_col = 0;\n\nstatic int text_y(void) {\n\treturn char_y + char_row * char_h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_x",
          "args": [],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "text_x",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "410-412",
          "snippet": "static int text_x(void) {\n\treturn char_x + char_col * char_w;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int text_x(void);",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_x(void);\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\n\nstatic int text_x(void) {\n\treturn char_x + char_col * char_w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x",
            "y-char_h",
            "x+char_w",
            "y",
            "scaling"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "keystr",
            "white_pixel()"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\"",
            "u_cnt",
            "x",
            "y",
            "keysym",
            "keystr"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_deny: username too long: %d\\n\"",
            "u_cnt"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: bad keysym4: 0x%x\\n\"",
            "(int) keysym"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "str",
            "white_pixel()"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "pw",
            "white_pixel()"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "x - char_w",
            "y - char_h",
            "x",
            "y"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: echo off.\\n\""
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "u"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_accept",
          "args": [
            "u"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2145-2216",
          "snippet": "void unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_login_viewonly = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_login_viewonly = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\n\nvoid unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "text_x()",
            "text_y()",
            "msg",
            "white_pixel()"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\""
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\""
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\""
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"X11VNC_XDM_ONLY\"",
            "\"1\""
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_unixpw_userprefs",
          "args": [],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "check_unixpw_userprefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1521-1565",
          "snippet": "void check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_opts = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_opts = NULL;\n\nvoid check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "colon+1"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "u"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "user",
            "':'"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_name",
          "args": [],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "271-293",
          "snippet": "char *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_user_name(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_user_name(void);\n\nchar *get_user_name(void) {\n\tchar *user = NULL;\n\n\tuser = getenv(\"USER\");\n\tif (user == NULL) {\n\t\tuser = getenv(\"LOGNAME\");\n\t}\n\n#if HAVE_PWD_H\n\tif (user == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\tuser = pw->pw_name;\n\t\t}\n\t}\n#endif\n\n\tif (user) {\n\t\treturn(strdup(user));\n\t} else {\n\t\treturn(strdup(\"unknown-user\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+1*ch",
            "\"F1-Help:\"",
            "white_pixel()"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+7*ch",
            "h6",
            "p"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+6*ch",
            "h5",
            "p"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+5*ch",
            "h4",
            "p"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+4*ch",
            "h3",
            "p"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+3*ch",
            "h2",
            "p"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+2*ch",
            "hc",
            "p"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+2*ch",
            "hx",
            "p"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"xdmcp\""
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"cmd=FINDCREATEDISPLAY\""
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+2*ch",
            "hf",
            "p"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"cmd=FINDDISPLAY\""
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+1*ch",
            "h1",
            "p"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "black_pixel",
          "args": [],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "black_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "381-400",
          "snippet": "int black_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0x000000)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) black_pix;\n\t} else if (depth < 24) {\n\t\treturn 0x0000;\n\t} else {\n\t\treturn 0x000000;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint black_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0x000000)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) black_pix;\n\t} else if (depth < 24) {\n\t\treturn 0x0000;\n\t} else {\n\t\treturn 0x000000;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s / %s  0x%x %s\\n\"",
            "in_login ? \"login\":\"pass \"",
            "down ? \"down\":\"up  \"",
            "keysym",
            "keystr"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: bad keysym3: 0x%x\\n\"",
            "(int) keysym"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "keystr",
            "sizeof keystr",
            "\"%s\"",
            "str"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: bad keysym2: 0x%x\\n\"",
            "(int) keysym"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XKeysymToString",
          "args": [
            "keysym"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "XKeysymToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "1449-2807",
          "snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: bad keysym1: 0x%x\\n\"",
            "(int) keysym"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\"",
            "(int) keysym"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strzero",
          "args": [
            "keep_unixpw_opts"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "strzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "171-179",
          "snippet": "void strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid strzero(char *str) {\n\tchar *p = str;\n\tif (p != NULL) {\n\t\twhile (*p != '\\0') {\n\t\t\t*p = '\\0';\n\t\t\tp++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_db",
          "args": [],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "set_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1659-1664",
          "snippet": "static void set_db(void) {\n\tif (getenv(\"DEBUG_UNIXPW\")) {\n\t\tdb = atoi(getenv(\"DEBUG_UNIXPW\"));\n\t\trfbLog(\"DEBUG_UNIXPW: %d\\n\", db);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "static void set_db(void);",
            "static int db = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nstatic void set_db(void);\nstatic int db = 0;\n\nstatic void set_db(void) {\n\tif (getenv(\"DEBUG_UNIXPW\")) {\n\t\tdb = atoi(getenv(\"DEBUG_UNIXPW\"));\n\t\trfbLog(\"DEBUG_UNIXPW: %d\\n\", db);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_screen(int init);\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\nstatic void set_db(void);\nint unixpw_denied = 0;\ntime_t unixpw_last_try_time = 0;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};\nstatic int in_login = 0, in_passwd = 0, tries = 0;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\nstatic int f1_help = 0;\n\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "set_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1659-1664",
    "snippet": "static void set_db(void) {\n\tif (getenv(\"DEBUG_UNIXPW\")) {\n\t\tdb = atoi(getenv(\"DEBUG_UNIXPW\"));\n\t\trfbLog(\"DEBUG_UNIXPW: %d\\n\", db);\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "static void set_db(void);",
      "static int db = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"DEBUG_UNIXPW: %d\\n\"",
            "db"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"DEBUG_UNIXPW\")"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_UNIXPW\""
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_UNIXPW\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nstatic void set_db(void);\nstatic int db = 0;\n\nstatic void set_db(void) {\n\tif (getenv(\"DEBUG_UNIXPW\")) {\n\t\tdb = atoi(getenv(\"DEBUG_UNIXPW\"));\n\t\trfbLog(\"DEBUG_UNIXPW: %d\\n\", db);\n\t}\n}"
  },
  {
    "function_name": "unixpw_verify_screen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1568-1657",
    "snippet": "void unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int white_pixel(void);",
      "void unixpw_accept(char *user);",
      "void unixpw_deny(void);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);",
      "static int text_x(void);",
      "static int text_y(void);",
      "time_t unixpw_last_try_time = 0;",
      "rfbClientPtr unixpw_client = NULL;",
      "int keep_unixpw = 0;",
      "char *keep_unixpw_user = NULL;",
      "char *keep_unixpw_pass = NULL;",
      "char *keep_unixpw_opts = NULL;",
      "static int char_row = 0, char_col = 0;",
      "static int db = 0;",
      "static rfbScreenInfoPtr pscreen;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_keystroke",
          "args": [
            "0",
            "0",
            "2"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_keystroke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1666-2055",
          "snippet": "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_screen(int init);",
            "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);",
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int text_x(void);",
            "static int text_y(void);",
            "static void set_db(void);",
            "int unixpw_denied = 0;",
            "time_t unixpw_last_try_time = 0;",
            "int keep_unixpw = 0;",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_pass = NULL;",
            "char *keep_unixpw_opts = NULL;",
            "static rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};",
            "static int in_login = 0, in_passwd = 0, tries = 0;",
            "static int char_row = 0, char_col = 0;",
            "static int db = 0;",
            "static rfbScreenInfoPtr pscreen;",
            "static int f1_help = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_screen(int init);\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\nstatic void set_db(void);\nint unixpw_denied = 0;\ntime_t unixpw_last_try_time = 0;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};\nstatic int in_login = 0, in_passwd = 0, tries = 0;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\nstatic int f1_help = 0;\n\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_mark",
          "args": [],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "402-408",
          "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "log"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "log",
            "white_pixel()"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_y",
          "args": [],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "text_y",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "414-416",
          "snippet": "static int text_y(void) {\n\treturn char_y + char_row * char_h;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int text_y(void);",
            "static int char_row = 0, char_col = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_y(void);\nstatic int char_row = 0, char_col = 0;\n\nstatic int text_y(void) {\n\treturn char_y + char_row * char_h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_x",
          "args": [],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "text_x",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "410-412",
          "snippet": "static int text_x(void) {\n\treturn char_x + char_col * char_w;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int text_x(void);",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_x(void);\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\n\nstatic int text_x(void) {\n\treturn char_x + char_col * char_w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "li",
            "white_pixel()"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_unixpw_userprefs",
          "args": [],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "check_unixpw_userprefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1521-1565",
          "snippet": "void check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_opts = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_opts = NULL;\n\nvoid check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "colon+1"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pass"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_accept",
          "args": [
            "user"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2145-2216",
          "snippet": "void unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_login_viewonly = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_login_viewonly = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\n\nvoid unixpw_accept(char *user) {\n\tapply_opts(user);\n\n\tif (!use_stunnel) {\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (accept_cmd && strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\tif (use_dpy && strstr(use_dpy, \"WAIT:\") == use_dpy &&\n\t\t    dpy == NULL) {\n\t\t\t/* handled in main() */\n\t\t\tunixpw_client->onHold = TRUE;\n\t\t} else if (! accept_client(unixpw_client)) {\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (started_as_root == 1 && users_list\n\t    && strstr(users_list, \"unixpw=\") == users_list) {\n\t\tif (getuid() && geteuid()) {\n\t\t\trfbLog(\"unixpw_accept: unixpw= but not root\\n\");\n\t\t\tstarted_as_root = 2;\n\t\t} else {\n\t\t\tchar *u = (char *)malloc(strlen(user)+1); \n\n\t\t\tu[0] = '\\0';\n\t\t\tif (!strcmp(users_list, \"unixpw=\")) {\n\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t} else {\n\t\t\t\tchar *p, *str = strdup(users_list);\n\t\t\t\tp = strtok(str + strlen(\"unixpw=\"), \",\");\n\t\t\t\twhile (p) {\n\t\t\t\t\tif (!strcmp(p, user)) {\n\t\t\t\t\t\tsprintf(u, \"+%s\", user);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = strtok(NULL, \",\");\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\t\n\t\t\tif (u[0] == '\\0') {\n\t\t\t\trfbLog(\"unixpw_accept skipping switch to user: %s\\n\", user);\n\t\t\t} else if (switch_user(u, 0)) {\n\t\t\t\trfbLog(\"unixpw_accept switched to user: %s\\n\", user);\n\t\t\t} else {\n\t\t\t\trfbLog(\"unixpw_accept failed to switch to user: %s\\n\", user);\n\t\t\t}\n\t\t\tfree(u);\n\t\t}\n\t}\n\n\tif (unixpw_login_viewonly) {\n\t\tunixpw_client->viewOnly = TRUE;\n\t}\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n\t\t/* this doesn't work: the current client is never registered! */\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 1\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\tif (macosx_console) {\n\t\trefresh_screen(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "progress_skippy",
          "args": [],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "progress_skippy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1498-1519",
          "snippet": "static void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "ls",
            "white_pixel()"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_verify",
          "args": [
            "user",
            "pass"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_verify_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1568-1657",
          "snippet": "void unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cd->username"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"UNIX:%s\"",
            "user"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"UNIX:\""
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: colon: '%s'\\n\"",
            "user"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "user",
            "':'"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: '%s'\\n\"",
            "user ? user : \"(null)\""
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unixpw_verify: '%s' '%s'\\n\"",
            "user",
            "db > 1 ? pass : \"********\""
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\ntime_t unixpw_last_try_time = 0;\nrfbClientPtr unixpw_client = NULL;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}"
  },
  {
    "function_name": "check_unixpw_userprefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1521-1565",
    "snippet": "void check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "char *keep_unixpw_user = NULL;",
      "char *keep_unixpw_opts = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not read user prefs %s\\n\"",
            "file"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "t",
            "\"%s,%s\"",
            "keep_unixpw_opts",
            "buf"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "keep_unixpw_opts"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read user prefs %s: %s\\n\"",
            "file",
            "buf"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\r'"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "1024",
            "f"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "file",
            "\"%s/%s\"",
            "pw->pw_dir",
            "prefs"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(pw->pw_dir) + 1 + strlen(prefs) + 1"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefs"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pw->pw_dir"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "keep_unixpw_user"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "prefs",
            "'/'"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FD_USERPREFS\""
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_opts = NULL;\n\nvoid check_unixpw_userprefs(void) {\n\tchar *prefs = getenv(\"FD_USERPREFS\");\n\tif (keep_unixpw_user == NULL || keep_unixpw_opts == NULL) {\n\t\treturn;\n\t}\n#if HAVE_PWD_H\n\tif (prefs != NULL && !strchr(prefs, '/')) {\n\t\tstruct passwd *pw = getpwnam(keep_unixpw_user);\n\t\tif (pw != NULL) {\n\t\t\tchar *file;\n\t\t\tFILE *f;\n\n\t\t\tfile = (char *) malloc(strlen(pw->pw_dir) + 1 + strlen(prefs) + 1);\n\t\t\tsprintf(file, \"%s/%s\", pw->pw_dir, prefs);\n\n\t\t\tf = fopen(file, \"r\");\n\t\t\tif (f) {\n\t\t\t\tchar *t, *q, buf[1024];\n\t\t\t\tmemset(buf, 0, sizeof(buf));\n\n\t\t\t\tfgets(buf, 1024, f);\n\t\t\t\tfclose(f);\n\n\t\t\t\tq = strchr(buf, '\\n');\n\t\t\t\tif (q) *q = '\\0';\n\t\t\t\tq = strchr(buf, '\\r');\n\t\t\t\tif (q) *q = '\\0';\n\n\t\t\t\trfbLog(\"read user prefs %s: %s\\n\", file, buf);\n\n\t\t\t\tif (buf[0] == '#') buf[0] = '\\0';\n\n\t\t\t\tt = (char *) malloc(strlen(keep_unixpw_opts) + 1 + strlen(buf) + 1);\n\t\t\t\tsprintf(t, \"%s,%s\", keep_unixpw_opts, buf); \n\t\t\t\tfree(keep_unixpw_opts);\n\t\t\t\tkeep_unixpw_opts = t;\n\t\t\t} else {\n\t\t\t\trfbLog(\"could not read user prefs %s\\n\", file);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t}\n\t\t\tfree(file);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "progress_skippy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1498-1519",
    "snippet": "static void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net_latency",
          "args": [],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "323-335",
          "snippet": "int get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_latency = 0;",
            "int speeds_net_latency_measured = 0;",
            "int get_net_latency(void);",
            "static int get_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_latency = 0;\nint speeds_net_latency_measured = 0;\nint get_net_latency(void);\nstatic int get_latency(void);\n\nint get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void progress_skippy(void) {\n\tint i, msec = get_net_latency();\t/* probabaly not set yet.. */\n\n\tif (msec > 300) {\n\t\tmsec = 300;\n\t} else if (msec <= 100) {\n\t\tmsec = 100;\n\t}\n\n\tskip_it = 1;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (i == 2) {\n\t\t\trfbPE(msec * 1000);\n\t\t} else {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tusleep(10*1000);\n\t}\n\tskip_it = 0;\n\n\tusleep(50*1000);\n}"
  },
  {
    "function_name": "unixpw_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "1451-1494",
    "snippet": "int unixpw_verify(char *user, char *pass) {\n\tint ok = 0;\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(user, pass)) {\n\t\t\trfbLog(\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tusleep(3000*1000);\n\t\t\tok = 0;\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(user, pass)) {\n\t\t\trfbLog(\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tusleep(3000*1000);\n\t\t\tok = 0;\n\t\t}\n\t} else {\n\t\tif (su_verify(user, pass, NULL, NULL, NULL, 1)) {\n\t\t\trfbLog(\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\t/* use su(1)'s sleep */\n\t\t\tok = 0;\n\t\t}\n\t}\n\treturn ok;\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" failed.\\n\"",
            "user"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\"",
            "user"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "su_verify",
          "args": [
            "user",
            "pass",
            "NULL",
            "NULL",
            "NULL",
            "1"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "3000*1000"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" failed.\\n\"",
            "user"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\"",
            "user"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt_verify",
          "args": [
            "user",
            "pass"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "759-822",
          "snippet": "int crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UNIXPW_CRYPT",
            "#define HAVE_GETSPNAM 0"
          ],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int db = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define UNIXPW_CRYPT\n#define HAVE_GETSPNAM 0\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int db = 0;\n\nint crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "3000*1000"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" failed.\\n\"",
            "user"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\"",
            "user"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_verify",
          "args": [
            "user",
            "pass"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "900-954",
          "snippet": "int cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "rfbClientPtr unixpw_client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nrfbClientPtr unixpw_client = NULL;\n\nint cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\n\nint unixpw_verify(char *user, char *pass) {\n\tint ok = 0;\n\tif (unixpw_cmd) {\n\t\tif (cmd_verify(user, pass)) {\n\t\t\trfbLog(\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: cmd_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tusleep(3000*1000);\n\t\t\tok = 0;\n\t\t}\n\t} else if (unixpw_nis) {\n\t\tif (crypt_verify(user, pass)) {\n\t\t\trfbLog(\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: crypt_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tusleep(3000*1000);\n\t\t\tok = 0;\n\t\t}\n\t} else {\n\t\tif (su_verify(user, pass, NULL, NULL, NULL, 1)) {\n\t\t\trfbLog(\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" succeeded.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\tok = 1;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_verify: su_verify login for '%s'\"\n\t\t\t    \" failed.\\n\", user);\n\t\t\tfflush(stderr);\n\t\t\t/* use su(1)'s sleep */\n\t\t\tok = 0;\n\t\t}\n\t}\n\treturn ok;\n}"
  },
  {
    "function_name": "cmd_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "900-954",
    "snippet": "int cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);",
      "rfbClientPtr unixpw_client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "unixpw_cmd",
            "unixpw_client",
            "\"cmd_verify\"",
            "str",
            "strlen(str)",
            "NULL"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pass",
            "'\\n'"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "pass"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "user"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_list_match",
          "args": [
            "user"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "715-757",
          "snippet": "int unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nint unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scheck",
          "args": [
            "pass",
            "100",
            "\"password\""
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "scheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "686-713",
          "snippet": "static int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nstatic int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nrfbClientPtr unixpw_client = NULL;\n\nint cmd_verify(char *user, char *pass) {\n\tint i, len, rc;\n\tchar *str;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tif (unixpw_client) {\n\t\tClientData *cd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tcd->username = strdup(user);\n\t\t}\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), NULL);\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "unixpw_cmd_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "824-897",
    "snippet": "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n) {\n\tint i, len, rc;\n\tchar *str;\n\tFILE *out;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\tif (cmd == NULL) {\n\t\tcmd = \"\";\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\tout = tmpfile();\n\tif (out == NULL) {\n\t\trfbLog(\"unixpw_cmd_run tmpfile() failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", cmd);\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), out);\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", \"\");\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tfflush(out);\n\trewind(out);\n\tfor (i=0; i < (*n) - 1; i++) {\n\t\tint c = fgetc(out);\n\t\tif (c == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tline[i] = (char) c;\n\t}\n\tfclose(out);\n\t*n = i;\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);",
      "rfbClientPtr unixpw_client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "out"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewind",
          "args": [
            "out"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "out"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"RFB_UNIXPW_CMD_RUN\"",
            "\"\""
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "unixpw_cmd",
            "unixpw_client",
            "\"cmd_verify\"",
            "str",
            "strlen(str)",
            "out"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_cmd_run tmpfile() failed.\\n\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpfile",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pass",
            "'\\n'"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "pass"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "str",
            "user"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_list_match",
          "args": [
            "user"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "715-757",
          "snippet": "int unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nint unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scheck",
          "args": [
            "pass",
            "100",
            "\"password\""
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "scheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "686-713",
          "snippet": "static int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nstatic int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nrfbClientPtr unixpw_client = NULL;\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n) {\n\tint i, len, rc;\n\tchar *str;\n\tFILE *out;\n\n\tif (! user || ! pass) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_cmd || *unixpw_cmd == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\tif (cmd == NULL) {\n\t\tcmd = \"\";\n\t}\n\n\tlen = strlen(user) + 1 + strlen(pass) + 1 + 1;\n\tstr = (char *) malloc(len);\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tstr[0] = '\\0';\n\tstrcat(str, user);\n\tstrcat(str, \"\\n\");\n\tstrcat(str, pass);\n\tif (!strchr(pass, '\\n')) {\n\t\tstrcat(str, \"\\n\");\n\t}\n\n\tout = tmpfile();\n\tif (out == NULL) {\n\t\trfbLog(\"unixpw_cmd_run tmpfile() failed.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", cmd);\n\n\trc = run_user_command(unixpw_cmd, unixpw_client, \"cmd_verify\",\n\t    str, strlen(str), out);\n\n\tset_env(\"RFB_UNIXPW_CMD_RUN\", \"\");\n\n\tfor (i=0; i < len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tfree(str);\n\n\tfflush(out);\n\trewind(out);\n\tfor (i=0; i < (*n) - 1; i++) {\n\t\tint c = fgetc(out);\n\t\tif (c == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\tline[i] = (char) c;\n\t}\n\tfclose(out);\n\t*n = i;\n\n\tif (rc == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "crypt_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "759-822",
    "snippet": "int crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define UNIXPW_CRYPT",
      "#define HAVE_GETSPNAM 0"
    ],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "int crypt_verify(char *user, char *pass);",
      "int cmd_verify(char *user, char *pass);",
      "void unixpw_verify_screen(char *user, char *pass);",
      "static int db = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cr",
            "realpw"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"user='%s' pass='%s' realpw='%s' cr='%s'\\n\"",
            "user",
            "pass",
            "realpw",
            "cr ? cr : \"(null)\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypt",
          "args": [
            "pass",
            "realpw"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "759-822",
          "snippet": "int crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pass"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skipping getspnam()\\n\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"using getspnam()\\n\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getspnam",
          "args": [
            "user"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realpw"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"realpw='%s'\\n\"",
            "realpw"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "user"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_list_match",
          "args": [
            "user"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_list_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "715-757",
          "snippet": "int unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unixpw_accept(char *user);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nint unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scheck",
          "args": [
            "pass",
            "100",
            "\"password\""
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "scheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "686-713",
          "snippet": "static int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nstatic int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define UNIXPW_CRYPT\n#define HAVE_GETSPNAM 0\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int db = 0;\n\nint crypt_verify(char *user, char *pass) {\n#if !defined UNIXPW_CRYPT || !defined HAVE_LIBCRYPT\n\treturn 0;\n#else\n\tstruct passwd *pwd;\n\tchar *realpw, *cr;\n\tint n;\n\n\tif (! scheck(user, 100, \"username\")) {\n\t\treturn 0;\n\t}\n\tif (! scheck(pass, 100, \"password\")) {\n\t\treturn 0;\n\t}\n\tif (! unixpw_list_match(user)) {\n\t\treturn 0;\n\t}\n\n\tpwd = getpwnam(user);\n\tif (! pwd) {\n\t\treturn 0;\n\t}\n\n\trealpw = pwd->pw_passwd;\n\tif (realpw == NULL || realpw[0] == '\\0') {\n\t\treturn 0;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"realpw='%s'\\n\", realpw);\n\n\tif (strlen(realpw) < 12) {\n\t\t/* e.g. \"x\", try getspnam(), sometimes root for inetd, etc */\n#if HAVE_GETSPNAM\n\t\tstruct spwd *sp = getspnam(user);\n\t\tif (sp != NULL && sp->sp_pwdp != NULL) {\n\t\t\tif (db) fprintf(stderr, \"using getspnam()\\n\");\n\t\t\trealpw = sp->sp_pwdp;\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skipping getspnam()\\n\");\n\t\t}\n#endif\n\t}\n\n\tn = strlen(pass);\n\tif (pass[n-1] == '\\n') {\n\t\tpass[n-1] = '\\0';\n\t}\n\n\t/* XXX remove need for cast */\n\tcr = (char *) crypt(pass, realpw);\n\tif (db > 1) {\n\t\tfprintf(stderr, \"user='%s' pass='%s' realpw='%s' cr='%s'\\n\",\n\t\t    user, pass, realpw, cr ? cr : \"(null)\");\n\t}\n\tif (cr == NULL || cr[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (!strcmp(cr, realpw)) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* UNIXPW_CRYPT */\n}"
  },
  {
    "function_name": "unixpw_list_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "715-757",
    "snippet": "int unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unixpw_accept(char *user);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_list_match: OK for '%s'\\n\"",
            "user"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_list_match: fail for '%s'\\n\"",
            "user"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"*\"",
            "p"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "p"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str+1",
            "\",\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "unixpw_list"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid unixpw_accept(char *user);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nint unixpw_list_match(char *user) {\n\tif (! unixpw_list || unixpw_list[0] == '\\0') {\n\t\treturn 1;\n\t} else {\n\t\tchar *p, *q, *str = strdup(unixpw_list);\n\t\tint ok = 0;\n\t\tint notmode = 0;\n\n\t\tif (str[0] == '!') {\n\t\t\tnotmode = 1;\n\t\t\tok = 1;\n\t\t\tp = strtok(str+1, \",\");\n\t\t} else {\n\t\t\tp = strtok(str, \",\");\n\t\t}\n\t\twhile (p) {\n\t\t\tif ( (q = strchr(p, ':')) != NULL ) {\n\t\t\t\t*q = '\\0';\t/* get rid of options. */\n\t\t\t}\n\t\t\tif (!strcmp(user, p)) {\n\t\t\t\tif (notmode) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!notmode && !strcmp(\"*\", p)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t\tif (! ok) {\n\t\t\trfbLog(\"unixpw_list_match: fail for '%s'\\n\", user);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\trfbLog(\"unixpw_list_match: OK for '%s'\\n\", user);\n\t\t\treturn 1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "scheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "686-713",
    "snippet": "static int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"scheck: unterminated string in %s.\\n\"",
            "name"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"scheck: invalid character in %s.\\n\"",
            "name"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"password\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nstatic int scheck(char *str, int n, char *name) {\n\tint j, i;\n\n\tif (! str) {\n\t\treturn 0;\n\t}\n\tj = 0;\n\tfor (i=0; i<n; i++) {\n\t\tif (str[i] == '\\0') {\n\t\t\tj = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(name, \"password\")) {\n\t\t\tif (str[i] == '\\n') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (str[i] < ' ' || str[i] >= 0x7f) {\n\t\t\trfbLog(\"scheck: invalid character in %s.\\n\", name);\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (j == 0) {\n\t\trfbLog(\"scheck: unterminated string in %s.\\n\", name);\t\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "kill_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "674-684",
    "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int slave_fd = -1, alarm_fired = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
  },
  {
    "function_name": "close_alarm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "666-672",
    "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int slave_fd = -1, alarm_fired = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "slave_fd"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
  },
  {
    "function_name": "try_to_be_nobody",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "640-661",
    "snippet": "void try_to_be_nobody(void) {\n\n#if HAVE_PWD_H\n\tstruct passwd *pw;\n\tpw = getpwnam(\"nobody\");\n\n\tif (pw) {\n#if HAVE_SETUID\n\t\tsetuid(pw->pw_uid);\n#endif\n#if HAVE_SETEUID\n\t\tseteuid(pw->pw_uid);\n#endif\n#if HAVE_SETGID\n\t\tsetgid(pw->pw_gid);\n#endif\n#if HAVE_SETEGID\n\t\tsetegid(pw->pw_gid);\n#endif\n\t}\n#endif\t/* PWD_H */\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setegid",
          "args": [
            "pw->pw_gid"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setgid",
          "args": [
            "pw->pw_gid"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seteuid",
          "args": [
            "pw->pw_uid"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setuid",
          "args": [
            "pw->pw_uid"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpwnam",
          "args": [
            "\"nobody\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nvoid try_to_be_nobody(void) {\n\n#if HAVE_PWD_H\n\tstruct passwd *pw;\n\tpw = getpwnam(\"nobody\");\n\n\tif (pw) {\n#if HAVE_SETUID\n\t\tsetuid(pw->pw_uid);\n#endif\n#if HAVE_SETEUID\n\t\tseteuid(pw->pw_uid);\n#endif\n#if HAVE_SETGID\n\t\tsetgid(pw->pw_gid);\n#endif\n#if HAVE_SETEGID\n\t\tsetegid(pw->pw_gid);\n#endif\n\t}\n#endif\t/* PWD_H */\n}"
  },
  {
    "function_name": "get_pty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "623-638",
    "snippet": "char *get_pty(int *fd_p) {\n\tused_get_pty_ptmx = 0;\n\tif (getenv(\"BSD_PTY\")) {\n\t\treturn get_pty_loop(fd_p);\n\t}\n#ifdef IS_BSD\n\treturn get_pty_loop(fd_p);\n#else\n#if HAVE_GRANTPT\n\tused_get_pty_ptmx = 1;\n\treturn get_pty_ptmx(fd_p);\n#else\n\treturn get_pty_loop(fd_p);\n#endif\n#endif\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define IS_BSD",
      "#define IS_BSD"
    ],
    "globals_used": [
      "static int used_get_pty_ptmx = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pty_loop",
          "args": [
            "fd_p"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "get_pty_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "585-621",
          "snippet": "char *get_pty_loop(int *fd_p) {\n\tchar master_str[16];\n\tint fd = -1, i;\n\tchar c;\n\n\t*fd_p = -1;\n\n\t/* for *BSD loop over /dev/ptyXY */\n\n\tfor (c = 'p'; c <= 'z'; c++) {\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tsprintf(master_str, \"/dev/pty%c%x\", c, i);\n#ifdef O_NOCTTY\n\t\t\tfd = open(master_str, O_RDWR|O_NOCTTY);\n#else\n\t\t\tfd = open(master_str, O_RDWR);\n#endif\n\t\t\tif (fd >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tsprintf(slave_str, \"/dev/tty%c%x\", c, i);\n\t*fd_p = fd;\n\treturn slave_str;\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nchar *get_pty_loop(int *fd_p) {\n\tchar master_str[16];\n\tint fd = -1, i;\n\tchar c;\n\n\t*fd_p = -1;\n\n\t/* for *BSD loop over /dev/ptyXY */\n\n\tfor (c = 'p'; c <= 'z'; c++) {\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tsprintf(master_str, \"/dev/pty%c%x\", c, i);\n#ifdef O_NOCTTY\n\t\t\tfd = open(master_str, O_RDWR|O_NOCTTY);\n#else\n\t\t\tfd = open(master_str, O_RDWR);\n#endif\n\t\t\tif (fd >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tsprintf(slave_str, \"/dev/tty%c%x\", c, i);\n\t*fd_p = fd;\n\treturn slave_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pty_ptmx",
          "args": [
            "fd_p"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "get_pty_ptmx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "511-582",
          "snippet": "char *get_pty_ptmx(int *fd_p) {\n\tchar *slave;\n\tint fd = -1, i, ndevs = 4, tmp;\n\tchar *devs[] = { \n\t\t\"/dev/ptmx\",\n\t\t\"/dev/ptm/clone\",\n\t\t\"/dev/ptc\",\n\t\t\"/dev/ptmx_bsd\"\n\t};\n\n\t*fd_p = -1;\n\n#if HAVE_GRANTPT\n\n\tfor (i=0; i < ndevs; i++) {\n#ifdef O_NOCTTY\n\t\tfd = open(devs[i], O_RDWR|O_NOCTTY);\n#else\n\t\tfd = open(devs[i], O_RDWR);\n#endif\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd < 0) {\n\t\trfbLogPerror(\"open /dev/ptmx\");\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCPKT)\n\ttmp = 0;\n\tioctl(fd, TIOCPKT, (char *) &tmp);\n#endif\n\n\tif (grantpt(fd) != 0) {\n\t\trfbLogPerror(\"grantpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (unlockpt(fd) != 0) {\n\t\trfbLogPerror(\"unlockpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tslave = ptsname(fd);\n\tif (! slave)  {\n\t\trfbLogPerror(\"ptsname\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tif (strlen(slave) > sizeof(slave_str)/2) {\n\t\trfbLog(\"get_pty_ptmx: slave string length too long.\\n\");\t\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(slave_str, slave);\n\t*fd_p = fd;\n\treturn slave_str;\n\n#else\n\treturn NULL;\n\n#endif /* GRANTPT */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nchar *get_pty_ptmx(int *fd_p) {\n\tchar *slave;\n\tint fd = -1, i, ndevs = 4, tmp;\n\tchar *devs[] = { \n\t\t\"/dev/ptmx\",\n\t\t\"/dev/ptm/clone\",\n\t\t\"/dev/ptc\",\n\t\t\"/dev/ptmx_bsd\"\n\t};\n\n\t*fd_p = -1;\n\n#if HAVE_GRANTPT\n\n\tfor (i=0; i < ndevs; i++) {\n#ifdef O_NOCTTY\n\t\tfd = open(devs[i], O_RDWR|O_NOCTTY);\n#else\n\t\tfd = open(devs[i], O_RDWR);\n#endif\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd < 0) {\n\t\trfbLogPerror(\"open /dev/ptmx\");\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCPKT)\n\ttmp = 0;\n\tioctl(fd, TIOCPKT, (char *) &tmp);\n#endif\n\n\tif (grantpt(fd) != 0) {\n\t\trfbLogPerror(\"grantpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (unlockpt(fd) != 0) {\n\t\trfbLogPerror(\"unlockpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tslave = ptsname(fd);\n\tif (! slave)  {\n\t\trfbLogPerror(\"ptsname\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tif (strlen(slave) > sizeof(slave_str)/2) {\n\t\trfbLog(\"get_pty_ptmx: slave string length too long.\\n\");\t\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(slave_str, slave);\n\t*fd_p = fd;\n\treturn slave_str;\n\n#else\n\treturn NULL;\n\n#endif /* GRANTPT */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"BSD_PTY\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define IS_BSD\n#define IS_BSD\n\nstatic int used_get_pty_ptmx = 0;\n\nchar *get_pty(int *fd_p) {\n\tused_get_pty_ptmx = 0;\n\tif (getenv(\"BSD_PTY\")) {\n\t\treturn get_pty_loop(fd_p);\n\t}\n#ifdef IS_BSD\n\treturn get_pty_loop(fd_p);\n#else\n#if HAVE_GRANTPT\n\tused_get_pty_ptmx = 1;\n\treturn get_pty_ptmx(fd_p);\n#else\n\treturn get_pty_loop(fd_p);\n#endif\n#endif\n}"
  },
  {
    "function_name": "get_pty_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "585-621",
    "snippet": "char *get_pty_loop(int *fd_p) {\n\tchar master_str[16];\n\tint fd = -1, i;\n\tchar c;\n\n\t*fd_p = -1;\n\n\t/* for *BSD loop over /dev/ptyXY */\n\n\tfor (c = 'p'; c <= 'z'; c++) {\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tsprintf(master_str, \"/dev/pty%c%x\", c, i);\n#ifdef O_NOCTTY\n\t\t\tfd = open(master_str, O_RDWR|O_NOCTTY);\n#else\n\t\t\tfd = open(master_str, O_RDWR);\n#endif\n\t\t\tif (fd >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tsprintf(slave_str, \"/dev/tty%c%x\", c, i);\n\t*fd_p = fd;\n\treturn slave_str;\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "slave_str",
            "\"/dev/tty%c%x\"",
            "c",
            "i"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCFLUSH",
            "(char *) 0"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "master_str",
            "O_RDWR"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "master_str",
            "\"/dev/pty%c%x\"",
            "c",
            "i"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nchar *get_pty_loop(int *fd_p) {\n\tchar master_str[16];\n\tint fd = -1, i;\n\tchar c;\n\n\t*fd_p = -1;\n\n\t/* for *BSD loop over /dev/ptyXY */\n\n\tfor (c = 'p'; c <= 'z'; c++) {\n\t\tfor (i=0; i < 16; i++) {\n\t\t\tsprintf(master_str, \"/dev/pty%c%x\", c, i);\n#ifdef O_NOCTTY\n\t\t\tfd = open(master_str, O_RDWR|O_NOCTTY);\n#else\n\t\t\tfd = open(master_str, O_RDWR);\n#endif\n\t\t\tif (fd >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tsprintf(slave_str, \"/dev/tty%c%x\", c, i);\n\t*fd_p = fd;\n\treturn slave_str;\n}"
  },
  {
    "function_name": "get_pty_ptmx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "511-582",
    "snippet": "char *get_pty_ptmx(int *fd_p) {\n\tchar *slave;\n\tint fd = -1, i, ndevs = 4, tmp;\n\tchar *devs[] = { \n\t\t\"/dev/ptmx\",\n\t\t\"/dev/ptm/clone\",\n\t\t\"/dev/ptc\",\n\t\t\"/dev/ptmx_bsd\"\n\t};\n\n\t*fd_p = -1;\n\n#if HAVE_GRANTPT\n\n\tfor (i=0; i < ndevs; i++) {\n#ifdef O_NOCTTY\n\t\tfd = open(devs[i], O_RDWR|O_NOCTTY);\n#else\n\t\tfd = open(devs[i], O_RDWR);\n#endif\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd < 0) {\n\t\trfbLogPerror(\"open /dev/ptmx\");\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCPKT)\n\ttmp = 0;\n\tioctl(fd, TIOCPKT, (char *) &tmp);\n#endif\n\n\tif (grantpt(fd) != 0) {\n\t\trfbLogPerror(\"grantpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (unlockpt(fd) != 0) {\n\t\trfbLogPerror(\"unlockpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tslave = ptsname(fd);\n\tif (! slave)  {\n\t\trfbLogPerror(\"ptsname\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tif (strlen(slave) > sizeof(slave_str)/2) {\n\t\trfbLog(\"get_pty_ptmx: slave string length too long.\\n\");\t\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(slave_str, slave);\n\t*fd_p = fd;\n\treturn slave_str;\n\n#else\n\treturn NULL;\n\n#endif /* GRANTPT */\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "slave_str",
            "slave"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_pty_ptmx: slave string length too long.\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "slave"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCFLUSH",
            "(char *) 0"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"ptsname\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptsname",
          "args": [
            "fd"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"unlockpt\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlockpt",
          "args": [
            "fd"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"grantpt\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grantpt",
          "args": [
            "fd"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "TIOCPKT",
            "(char *) &tmp"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open /dev/ptmx\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "devs[i]",
            "O_RDWR"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\n\nchar *get_pty_ptmx(int *fd_p) {\n\tchar *slave;\n\tint fd = -1, i, ndevs = 4, tmp;\n\tchar *devs[] = { \n\t\t\"/dev/ptmx\",\n\t\t\"/dev/ptm/clone\",\n\t\t\"/dev/ptc\",\n\t\t\"/dev/ptmx_bsd\"\n\t};\n\n\t*fd_p = -1;\n\n#if HAVE_GRANTPT\n\n\tfor (i=0; i < ndevs; i++) {\n#ifdef O_NOCTTY\n\t\tfd = open(devs[i], O_RDWR|O_NOCTTY);\n#else\n\t\tfd = open(devs[i], O_RDWR);\n#endif\n\t\tif (fd >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fd < 0) {\n\t\trfbLogPerror(\"open /dev/ptmx\");\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCPKT)\n\ttmp = 0;\n\tioctl(fd, TIOCPKT, (char *) &tmp);\n#endif\n\n\tif (grantpt(fd) != 0) {\n\t\trfbLogPerror(\"grantpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (unlockpt(fd) != 0) {\n\t\trfbLogPerror(\"unlockpt\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tslave = ptsname(fd);\n\tif (! slave)  {\n\t\trfbLogPerror(\"ptsname\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n#if HAVE_SYS_IOCTL_H && defined(TIOCFLUSH)\n\tioctl(fd, TIOCFLUSH, (char *) 0);\n#endif\n\n\tif (strlen(slave) > sizeof(slave_str)/2) {\n\t\trfbLog(\"get_pty_ptmx: slave string length too long.\\n\");\t\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(slave_str, slave);\n\t*fd_p = fd;\n\treturn slave_str;\n\n#else\n\treturn NULL;\n\n#endif /* GRANTPT */\n}"
  },
  {
    "function_name": "unixpw_screen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "423-500",
    "snippet": "void unixpw_screen(int init) {\n\tif (unixpw_cmd) {\n\t\t;\t/* OK */\n\t} else if (unixpw_nis) {\n#ifndef UNIXPW_CRYPT\n\trfbLog(\"-unixpw_nis is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t} else {\n#ifndef UNIXPW_SU\n\trfbLog(\"-unixpw is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t}\n\tif (init) {\n\t\tint x, y;\n\t\tchar log[] = \"login: \";\n\n\t\tzero_fb(0, 0, dpy_x, dpy_y);\n\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\n\t\tx = nfix(dpy_x / 2 -  strlen(log) * char_w, dpy_x);\n\t\ty = (int) (dpy_y / 3.5);\n\t\tif (unixpw_system_greeter) {\n\t\t\ty = (int) (dpy_y / 3);\n\t\t}\n\n\t\tif (scaling) {\n\t\t\tx = (int) (x * scale_fac_x);\n\t\t\ty = (int) (y * scale_fac_y);\n\t\t\tx = nfix(x, scaled_x);\n\t\t\ty = nfix(y, scaled_y);\n\t\t}\n\n\t\tif (rotating) {\n\t\t\tfscreen.serverFormat.bitsPerPixel = bpp;\n\t\t\tfscreen.paddedWidthInBytes = rfb_bytes_per_line;\n\t\t\tfscreen.frameBuffer = rfb_fb;\n\t\t\tpscreen = &fscreen;\n\t\t} else {\n\t\t\tpscreen = screen;\n\t\t}\n\n\t\tif (pscreen && pscreen->width >= 640 && pscreen->height >= 480) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*13, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tf1_help = 0;\n\n\t\tif (unixpw_system_greeter) {\n\t\t\tunixpw_system_greeter_active = 0;\n\t\t\tif (use_dpy && strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\tif (getenv(\"X11VNC_SYSTEM_GREETER1\")) {\n\t\t\t\t\tchar moo[] = \"Press 'Escape' for System Greeter\";\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x-90, y-30, moo, white_pixel());\n\t\t\t\t} else {\n\t\t\t\t\tchar moo1[] = \"Press 'Escape' for a New Session via System Greeter, or\";\n\t\t\t\t\tchar moo2[] = \"otherwise login here to connect to an Existing Session:\";\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-38, moo1, white_pixel());\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-25, moo2, white_pixel());\n\t\t\t\t}\n\t\t\t\tset_env(\"X11VNC_XDM_ONLY\", \"0\");\n\t\t\t\tunixpw_system_greeter_active = 1;\n\t\t\t}\n\t\t}\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_x = x;\n\t\tchar_y = y;\n\t\tchar_col = strlen(log);\n\t\tchar_row = 0;\n\n\t\tset_warrow_cursor();\n\t}\n\n\tunixpw_mark();\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define UNIXPW_CRYPT",
      "#define UNIXPW_SU"
    ],
    "globals_used": [
      "int white_pixel(void);",
      "void unixpw_screen(int init);",
      "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);",
      "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
      "static rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};",
      "static int char_row = 0, char_col = 0;",
      "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
      "static rfbScreenInfo fscreen;",
      "static rfbScreenInfoPtr pscreen;",
      "static int f1_help = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unixpw_mark",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "402-408",
          "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_warrow_cursor",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "set_warrow_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1959-1961",
          "snippet": "void set_warrow_cursor(void) {\n\tset_rfb_cursor(CURS_WARROW);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_warrow_cursor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_warrow_cursor(void);\n\nvoid set_warrow_cursor(void) {\n\tset_rfb_cursor(CURS_WARROW);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "log"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x",
            "y",
            "log",
            "white_pixel()"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "white_pixel",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "white_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "360-379",
          "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"X11VNC_XDM_ONLY\"",
            "\"0\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "x-110",
            "y-25",
            "moo2",
            "white_pixel()"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "x-110",
            "y-38",
            "moo1",
            "white_pixel()"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default8x16Font",
            "x-90",
            "y-30",
            "moo",
            "white_pixel()"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SYSTEM_GREETER1\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"xdmcp\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbDrawString",
          "args": [
            "pscreen",
            "&default6x13Font",
            "8",
            "2+1*13",
            "\"F1-Help:\"",
            "white_pixel()"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y",
            "scaled_y"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "log"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "0"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fb",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "531-561",
          "snippet": "void zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void zero_fb(int x1, int y1, int x2, int y2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid zero_fb(int x1, int y1, int x2, int y2);\n\nvoid zero_fb(int x1, int y1, int x2, int y2) {\n\tint pixelsize = bpp/8;\n\tint line, fill = 0, yfac = 1;\n\tchar *dst;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tyfac = 1+ncache;\n\t\tif (ncache_xrootpmap) {\n\t\t\tyfac++;\n\t\t}\n\t}\n#endif\n\t\n\tif (x1 < 0 || x2 <= x1 || x2 > dpy_x) {\n\t\treturn;\n\t}\n\tif (y1 < 0 || y2 <= y1 || y2 > yfac * dpy_y) {\n\t\treturn;\n\t}\n\tif (! main_fb) {\n\t\treturn;\n\t}\n\n\tdst = main_fb + y1 * main_bytes_per_line + x1 * pixelsize;\n\tline = y1;\n\twhile (line++ < y2) {\n\t\tmemset(dst, fill, (size_t) (x2 - x1) * pixelsize);\n\t\tdst += main_bytes_per_line;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-unixpw is not supported on this OS/machine\\n\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-unixpw_nis is not supported on this OS/machine\\n\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define UNIXPW_CRYPT\n#define UNIXPW_SU\n\nint white_pixel(void);\nvoid unixpw_screen(int init);\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nstatic rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfo fscreen;\nstatic rfbScreenInfoPtr pscreen;\nstatic int f1_help = 0;\n\nvoid unixpw_screen(int init) {\n\tif (unixpw_cmd) {\n\t\t;\t/* OK */\n\t} else if (unixpw_nis) {\n#ifndef UNIXPW_CRYPT\n\trfbLog(\"-unixpw_nis is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t} else {\n#ifndef UNIXPW_SU\n\trfbLog(\"-unixpw is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t}\n\tif (init) {\n\t\tint x, y;\n\t\tchar log[] = \"login: \";\n\n\t\tzero_fb(0, 0, dpy_x, dpy_y);\n\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\n\t\tx = nfix(dpy_x / 2 -  strlen(log) * char_w, dpy_x);\n\t\ty = (int) (dpy_y / 3.5);\n\t\tif (unixpw_system_greeter) {\n\t\t\ty = (int) (dpy_y / 3);\n\t\t}\n\n\t\tif (scaling) {\n\t\t\tx = (int) (x * scale_fac_x);\n\t\t\ty = (int) (y * scale_fac_y);\n\t\t\tx = nfix(x, scaled_x);\n\t\t\ty = nfix(y, scaled_y);\n\t\t}\n\n\t\tif (rotating) {\n\t\t\tfscreen.serverFormat.bitsPerPixel = bpp;\n\t\t\tfscreen.paddedWidthInBytes = rfb_bytes_per_line;\n\t\t\tfscreen.frameBuffer = rfb_fb;\n\t\t\tpscreen = &fscreen;\n\t\t} else {\n\t\t\tpscreen = screen;\n\t\t}\n\n\t\tif (pscreen && pscreen->width >= 640 && pscreen->height >= 480) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*13, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tf1_help = 0;\n\n\t\tif (unixpw_system_greeter) {\n\t\t\tunixpw_system_greeter_active = 0;\n\t\t\tif (use_dpy && strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\tif (getenv(\"X11VNC_SYSTEM_GREETER1\")) {\n\t\t\t\t\tchar moo[] = \"Press 'Escape' for System Greeter\";\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x-90, y-30, moo, white_pixel());\n\t\t\t\t} else {\n\t\t\t\t\tchar moo1[] = \"Press 'Escape' for a New Session via System Greeter, or\";\n\t\t\t\t\tchar moo2[] = \"otherwise login here to connect to an Existing Session:\";\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-38, moo1, white_pixel());\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-25, moo2, white_pixel());\n\t\t\t\t}\n\t\t\t\tset_env(\"X11VNC_XDM_ONLY\", \"0\");\n\t\t\t\tunixpw_system_greeter_active = 1;\n\t\t\t}\n\t\t}\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_x = x;\n\t\tchar_y = y;\n\t\tchar_col = strlen(log);\n\t\tchar_row = 0;\n\n\t\tset_warrow_cursor();\n\t}\n\n\tunixpw_mark();\n}"
  },
  {
    "function_name": "text_y",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "414-416",
    "snippet": "static int text_y(void) {\n\treturn char_y + char_row * char_h;\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int text_y(void);",
      "static int char_row = 0, char_col = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_y(void);\nstatic int char_row = 0, char_col = 0;\n\nstatic int text_y(void) {\n\treturn char_y + char_row * char_h;\n}"
  },
  {
    "function_name": "text_x",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "410-412",
    "snippet": "static int text_x(void) {\n\treturn char_x + char_col * char_w;\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int text_x(void);",
      "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int text_x(void);\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\n\nstatic int text_x(void) {\n\treturn char_x + char_col * char_w;\n}"
  },
  {
    "function_name": "unixpw_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "402-408",
    "snippet": "static void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "0"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic void unixpw_mark(void) {\n\tif (scaling) {\n\t\tmark_rect_as_modified(0, 0, scaled_x, scaled_y, 1);\n\t} else {\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\t}\n}"
  },
  {
    "function_name": "black_pixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "381-400",
    "snippet": "int black_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0x000000)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) black_pix;\n\t} else if (depth < 24) {\n\t\treturn 0x0000;\n\t} else {\n\t\treturn 0x000000;\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WhitePixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0x000000"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint black_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0x000000)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) black_pix;\n\t} else if (depth < 24) {\n\t\treturn 0x0000;\n\t} else {\n\t\treturn 0x000000;\n\t}\n}"
  },
  {
    "function_name": "white_pixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
    "lines": "360-379",
    "snippet": "int white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}",
    "includes": [
      "#include <sys/stropts.h>",
      "#include <termios.h>",
      "#include <sys/ioctl.h>",
      "#include <shadow.h>",
      "#include \"default8x16.h\"",
      "#include \"rates.h\"",
      "#include \"cursor.h\"",
      "#include \"sslhelper.h\"",
      "#include \"connections.h\"",
      "#include \"user.h\"",
      "#include \"connections.h\"",
      "#include \"xinerama.h\"",
      "#include \"cleanup.h\"",
      "#include \"scan.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int white_pixel(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WhitePixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0xffffff"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\n\nint white_pixel(void) {\n\tstatic unsigned long black_pix = 0, white_pix = 1, set = 0;\n\n\tRAWFB_RET(0xffffff)\n\n\tif (depth <= 8 && ! set) {\n\t\tX_LOCK;\n\t\tblack_pix = BlackPixel(dpy, scr);\n\t\twhite_pix = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tset = 1;\n\t}\n\tif (depth <= 8) {\n\t\treturn (int) white_pix;\n\t} else if (depth < 24) {\n\t\treturn 0xffff;\n\t} else {\n\t\treturn 0xffffff;\n\t}\n}"
  }
]