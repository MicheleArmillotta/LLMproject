[
  {
    "function_name": "setXIClientPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "386-435",
    "snippet": "int setXIClientPointer(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n\n  XErrorHandler old_handler;\n  \n  Window root_return;\n  Window child_return;\n  double root_x_return;\n  double root_y_return;\n  double win_x_return;\n  double win_y_return;\n  XIButtonState buttons_return;\n  XIModifierState modifiers_return;\n  XIGroupState group_return;\n\n  if(dev_id < 0)\n    return 0;\n \n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n \n  /* get window the pointer is in */\n  XIQueryPointer(dpy, dev_id, rootwin, &root_return, &child_return,\n\t\t &root_x_return, &root_y_return, &win_x_return, &win_y_return,\n\t\t &buttons_return, &modifiers_return, &group_return);\n\n  XISetClientPointer(dpy, find_client(dpy, root_return, child_return), dev_id);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    fprintf(stderr, \"got x error\\n\");\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return 0;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  X_UNLOCK;\n\n  return 1;\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got x error\\n\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XISetClientPointer",
          "args": [
            "dpy",
            "find_client(dpy, root_return, child_return)",
            "dev_id"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_client",
          "args": [
            "dpy",
            "root_return",
            "child_return"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "860-885",
          "snippet": "Window find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Atom atom_wm_state = None;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic Atom atom_wm_state = None;\n\nWindow find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XIQueryPointer",
          "args": [
            "dpy",
            "dev_id",
            "rootwin",
            "&root_return",
            "&child_return",
            "&root_x_return",
            "&root_y_return",
            "&win_x_return",
            "&win_y_return",
            "&buttons_return",
            "&modifiers_return",
            "&group_return"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "XIQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1567-1602",
          "snippet": "Bool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nBool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint setXIClientPointer(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n\n  XErrorHandler old_handler;\n  \n  Window root_return;\n  Window child_return;\n  double root_x_return;\n  double root_y_return;\n  double win_x_return;\n  double win_y_return;\n  XIButtonState buttons_return;\n  XIModifierState modifiers_return;\n  XIGroupState group_return;\n\n  if(dev_id < 0)\n    return 0;\n \n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n \n  /* get window the pointer is in */\n  XIQueryPointer(dpy, dev_id, rootwin, &root_return, &child_return,\n\t\t &root_x_return, &root_y_return, &win_x_return, &win_y_return,\n\t\t &buttons_return, &modifiers_return, &group_return);\n\n  XISetClientPointer(dpy, find_client(dpy, root_return, child_return), dev_id);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    fprintf(stderr, \"got x error\\n\");\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return 0;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  X_UNLOCK;\n\n  return 1;\n#endif\n}"
  },
  {
    "function_name": "setDeviceFocus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "320-378",
    "snippet": "int setDeviceFocus(Display* dpy, int ptr_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n\n  XErrorHandler old_handler;\n  \n  Window root_return;\n  Window child_return;\n  double root_x_return;\n  double root_y_return;\n  double win_x_return;\n  double win_y_return;\n  XIButtonState buttons_return;\n  XIModifierState modifiers_return;\n  XIGroupState group_return;\n\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n  int paired = -1;\n\n  if(ptr_id < 0)\n    return 0;\n \n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n \n  /* get window the pointer is in */\n  XIQueryPointer(dpy, ptr_id, rootwin, &root_return, &child_return,\n\t\t &root_x_return, &root_y_return, &win_x_return, &win_y_return,\n\t\t &buttons_return, &modifiers_return, &group_return);\n\n  /* get paired keyboard */\n  devinfo = XIQueryDevice(dpy, ptr_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  XISetFocus(dpy, paired, find_client(dpy, root_return, child_return), CurrentTime);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return 0;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  X_UNLOCK;\n\n  return 1;\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XISetFocus",
          "args": [
            "dpy",
            "paired",
            "find_client(dpy, root_return, child_return)",
            "CurrentTime"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_client",
          "args": [
            "dpy",
            "root_return",
            "child_return"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "860-885",
          "snippet": "Window find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Atom atom_wm_state = None;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic Atom atom_wm_state = None;\n\nWindow find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XIFreeDeviceInfo",
          "args": [
            "devinfo"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryDevice",
          "args": [
            "dpy",
            "ptr_id",
            "&devicecount"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryPointer",
          "args": [
            "dpy",
            "ptr_id",
            "rootwin",
            "&root_return",
            "&child_return",
            "&root_x_return",
            "&root_y_return",
            "&win_x_return",
            "&win_y_return",
            "&buttons_return",
            "&modifiers_return",
            "&group_return"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "XIQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1567-1602",
          "snippet": "Bool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nBool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint setDeviceFocus(Display* dpy, int ptr_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n\n  XErrorHandler old_handler;\n  \n  Window root_return;\n  Window child_return;\n  double root_x_return;\n  double root_y_return;\n  double win_x_return;\n  double win_y_return;\n  XIButtonState buttons_return;\n  XIModifierState modifiers_return;\n  XIGroupState group_return;\n\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n  int paired = -1;\n\n  if(ptr_id < 0)\n    return 0;\n \n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n \n  /* get window the pointer is in */\n  XIQueryPointer(dpy, ptr_id, rootwin, &root_return, &child_return,\n\t\t &root_x_return, &root_y_return, &win_x_return, &win_y_return,\n\t\t &buttons_return, &modifiers_return, &group_return);\n\n  /* get paired keyboard */\n  devinfo = XIQueryDevice(dpy, ptr_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  XISetFocus(dpy, paired, find_client(dpy, root_return, child_return), CurrentTime);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return 0;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  X_UNLOCK;\n\n  return 1;\n#endif\n}"
  },
  {
    "function_name": "setClientCursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "208-312",
    "snippet": "rfbCursorPtr setClientCursor(Display *dpy, int dev_id, float r, float g, float b, char *label)\n{\n#ifndef HAVE_LIBXCURSOR\n  return NULL;\n#else\n#ifndef HAVE_CAIRO\n  return NULL;\n#else\n\n  /* label setup */\n  const int idFontSize = 18;\n  const int idXOffset = 11;\n  const int idYOffset = 25;\n  const size_t textsz = 64;\n  char text[textsz];\n  int total_width, total_height;\n  cairo_surface_t* main_surface;\n  cairo_surface_t* dummy_surface;\n  cairo_surface_t* barecursor_surface;\n  cairo_t* cr;\n  cairo_text_extents_t est;\n  Cursor cursor;\n  XcursorImage *cursor_image = NULL;\n  rfbCursorPtr rfbcursor = NULL;\n\n  if(dev_id < 0)\n    return NULL;\n\n  if(label)\n    snprintf(text, textsz, \"%s\", label);\n  else\n    snprintf(text, textsz, \"%i\", (int) dev_id);\n \n  /* simple cursor w/o label */\n  barecursor_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 24, 24);\n  cr = cairo_create(barecursor_surface);\n  cairo_move_to (cr, 1, 1);\n  cairo_line_to (cr, 12, 8);\n  cairo_line_to (cr, 5, 15);\n  cairo_close_path (cr);\n  cairo_set_source_rgba(cr, r, g, b, 0.9);\n  cairo_fill_preserve (cr);\n  cairo_set_source_rgba(cr, 0, 0, 0, 0.8);\n  cairo_set_line_width (cr, 0.8);\n  cairo_stroke (cr);\n\n    \n  /* get estimated text extents */\n  dummy_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 500, 10);/* ah well, but should fit */\n  cr = cairo_create(dummy_surface);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_text_extents(cr, text, &est);\n\n  /* an from these calculate our final size */\n  total_width = (int)(idXOffset + est.width + est.x_bearing);\t\n  total_height = (int)(idYOffset + est.height + est.y_bearing);\t\n\n  /* draw evrything */\n  main_surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32, total_width, total_height );\n  cr = cairo_create(main_surface);\n  cairo_set_source_surface(cr, barecursor_surface, 0, 0);\n  cairo_paint (cr);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_set_source_rgba (cr, r, g, b, 0.8);\n  cairo_move_to(cr, idXOffset, idYOffset);\n  cairo_show_text(cr,text);\n    \n  X_LOCK;\n  /* copy cairo surface to cursor image */\n  cursor_image = XcursorImageCreate(total_width, total_height);\n  /* this is important! otherwise we get badmatch, badcursor xerrrors galore... */\n  cursor_image->xhot = cursor_image->yhot = 0; \n  memcpy(cursor_image->pixels, cairo_image_surface_get_data (main_surface), sizeof(CARD32) * total_width * total_height);\n  X_UNLOCK;\n\n  /* convert to rfb cursor which we return later */\n  rfbcursor = pixels2curs(cursor_image->pixels,\n\t\t\t  cursor_image->width,\n\t\t\t  cursor_image->height,\n\t\t\t  cursor_image->xhot,\n\t\t\t  cursor_image->yhot,\n\t\t\t  bpp/8);\n  \n  X_LOCK;\n\n  /* and display  */\n  cursor = XcursorImageLoadCursor(dpy, cursor_image);\n  XIDefineCursor(dpy, dev_id, RootWindow(dpy, DefaultScreen(dpy)), cursor);\n  XFreeCursor(dpy, cursor);\n\n  /* clean up */\n  cairo_destroy(cr);\n  cairo_surface_destroy(dummy_surface);\n  cairo_surface_destroy(main_surface);\n  cairo_surface_destroy(barecursor_surface);\n  XcursorImageDestroy(cursor_image);\n\n  X_UNLOCK;\n\n  return rfbcursor;\n#endif\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XcursorImageDestroy",
          "args": [
            "cursor_image"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_surface_destroy",
          "args": [
            "barecursor_surface"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_surface_destroy",
          "args": [
            "main_surface"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_surface_destroy",
          "args": [
            "dummy_surface"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_destroy",
          "args": [
            "cr"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFreeCursor",
          "args": [
            "dpy",
            "cursor"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIDefineCursor",
          "args": [
            "dpy",
            "dev_id",
            "RootWindow(dpy, DefaultScreen(dpy))",
            "cursor"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "DefaultScreen(dpy)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XcursorImageLoadCursor",
          "args": [
            "dpy",
            "cursor_image"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pixels2curs",
          "args": [
            "cursor_image->pixels",
            "cursor_image->width",
            "cursor_image->height",
            "cursor_image->xhot",
            "cursor_image->yhot",
            "bpp/8"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pixels2curs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1008-1238",
          "snippet": "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int alpha_threshold = 240;",
            "double alpha_frac = 0.33;",
            "int alpha_remove = 0;",
            "int alpha_blend = 1;",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint alpha_threshold = 240;\ndouble alpha_frac = 0.33;\nint alpha_remove = 0;\nint alpha_blend = 1;\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);\n\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cursor_image->pixels",
            "cairo_image_surface_get_data (main_surface)",
            "sizeof(CARD32) * total_width * total_height"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_image_surface_get_data",
          "args": [
            "main_surface"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XcursorImageCreate",
          "args": [
            "total_width",
            "total_height"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_show_text",
          "args": [
            "cr",
            "text"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_move_to",
          "args": [
            "cr",
            "idXOffset",
            "idYOffset"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_source_rgba",
          "args": [
            "cr",
            "r",
            "g",
            "b",
            "0.8"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_font_size",
          "args": [
            "cr",
            "idFontSize"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_select_font_face",
          "args": [
            "cr",
            "\"Sans\"",
            "CAIRO_FONT_SLANT_NORMAL",
            "CAIRO_FONT_WEIGHT_BOLD"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_paint",
          "args": [
            "cr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_source_surface",
          "args": [
            "cr",
            "barecursor_surface",
            "0",
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_create",
          "args": [
            "main_surface"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_image_surface_create",
          "args": [
            "CAIRO_FORMAT_ARGB32",
            "total_width",
            "total_height"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_text_extents",
          "args": [
            "cr",
            "text",
            "&est"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_font_size",
          "args": [
            "cr",
            "idFontSize"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_select_font_face",
          "args": [
            "cr",
            "\"Sans\"",
            "CAIRO_FONT_SLANT_NORMAL",
            "CAIRO_FONT_WEIGHT_BOLD"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_create",
          "args": [
            "dummy_surface"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_image_surface_create",
          "args": [
            "CAIRO_FORMAT_ARGB32",
            "500",
            "10"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_stroke",
          "args": [
            "cr"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_line_width",
          "args": [
            "cr",
            "0.8"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_source_rgba",
          "args": [
            "cr",
            "0",
            "0",
            "0",
            "0.8"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_fill_preserve",
          "args": [
            "cr"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_set_source_rgba",
          "args": [
            "cr",
            "r",
            "g",
            "b",
            "0.9"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_close_path",
          "args": [
            "cr"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_line_to",
          "args": [
            "cr",
            "5",
            "15"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_line_to",
          "args": [
            "cr",
            "12",
            "8"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_move_to",
          "args": [
            "cr",
            "1",
            "1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_create",
          "args": [
            "barecursor_surface"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cairo_image_surface_create",
          "args": [
            "CAIRO_FORMAT_ARGB32",
            "24",
            "24"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "text",
            "textsz",
            "\"%i\"",
            "(int) dev_id"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "text",
            "textsz",
            "\"%s\"",
            "label"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nrfbCursorPtr setClientCursor(Display *dpy, int dev_id, float r, float g, float b, char *label)\n{\n#ifndef HAVE_LIBXCURSOR\n  return NULL;\n#else\n#ifndef HAVE_CAIRO\n  return NULL;\n#else\n\n  /* label setup */\n  const int idFontSize = 18;\n  const int idXOffset = 11;\n  const int idYOffset = 25;\n  const size_t textsz = 64;\n  char text[textsz];\n  int total_width, total_height;\n  cairo_surface_t* main_surface;\n  cairo_surface_t* dummy_surface;\n  cairo_surface_t* barecursor_surface;\n  cairo_t* cr;\n  cairo_text_extents_t est;\n  Cursor cursor;\n  XcursorImage *cursor_image = NULL;\n  rfbCursorPtr rfbcursor = NULL;\n\n  if(dev_id < 0)\n    return NULL;\n\n  if(label)\n    snprintf(text, textsz, \"%s\", label);\n  else\n    snprintf(text, textsz, \"%i\", (int) dev_id);\n \n  /* simple cursor w/o label */\n  barecursor_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 24, 24);\n  cr = cairo_create(barecursor_surface);\n  cairo_move_to (cr, 1, 1);\n  cairo_line_to (cr, 12, 8);\n  cairo_line_to (cr, 5, 15);\n  cairo_close_path (cr);\n  cairo_set_source_rgba(cr, r, g, b, 0.9);\n  cairo_fill_preserve (cr);\n  cairo_set_source_rgba(cr, 0, 0, 0, 0.8);\n  cairo_set_line_width (cr, 0.8);\n  cairo_stroke (cr);\n\n    \n  /* get estimated text extents */\n  dummy_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 500, 10);/* ah well, but should fit */\n  cr = cairo_create(dummy_surface);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_text_extents(cr, text, &est);\n\n  /* an from these calculate our final size */\n  total_width = (int)(idXOffset + est.width + est.x_bearing);\t\n  total_height = (int)(idYOffset + est.height + est.y_bearing);\t\n\n  /* draw evrything */\n  main_surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32, total_width, total_height );\n  cr = cairo_create(main_surface);\n  cairo_set_source_surface(cr, barecursor_surface, 0, 0);\n  cairo_paint (cr);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_set_source_rgba (cr, r, g, b, 0.8);\n  cairo_move_to(cr, idXOffset, idYOffset);\n  cairo_show_text(cr,text);\n    \n  X_LOCK;\n  /* copy cairo surface to cursor image */\n  cursor_image = XcursorImageCreate(total_width, total_height);\n  /* this is important! otherwise we get badmatch, badcursor xerrrors galore... */\n  cursor_image->xhot = cursor_image->yhot = 0; \n  memcpy(cursor_image->pixels, cairo_image_surface_get_data (main_surface), sizeof(CARD32) * total_width * total_height);\n  X_UNLOCK;\n\n  /* convert to rfb cursor which we return later */\n  rfbcursor = pixels2curs(cursor_image->pixels,\n\t\t\t  cursor_image->width,\n\t\t\t  cursor_image->height,\n\t\t\t  cursor_image->xhot,\n\t\t\t  cursor_image->yhot,\n\t\t\t  bpp/8);\n  \n  X_LOCK;\n\n  /* and display  */\n  cursor = XcursorImageLoadCursor(dpy, cursor_image);\n  XIDefineCursor(dpy, dev_id, RootWindow(dpy, DefaultScreen(dpy)), cursor);\n  XFreeCursor(dpy, cursor);\n\n  /* clean up */\n  cairo_destroy(cr);\n  cairo_surface_destroy(dummy_surface);\n  cairo_surface_destroy(main_surface);\n  cairo_surface_destroy(barecursor_surface);\n  XcursorImageDestroy(cursor_image);\n\n  X_UNLOCK;\n\n  return rfbcursor;\n#endif\n#endif\n}"
  },
  {
    "function_name": "getPairedMD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "174-197",
    "snippet": "int getPairedMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int paired = -1;\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n\n  if(dev_id < 0)\n    return paired;\n\n  X_LOCK;\n\n  devinfo = XIQueryDevice(dpy, dev_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return paired;\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XIFreeDeviceInfo",
          "args": [
            "devinfo"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryDevice",
          "args": [
            "dpy",
            "dev_id",
            "&devicecount"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint getPairedMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int paired = -1;\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n\n  if(dev_id < 0)\n    return paired;\n\n  X_LOCK;\n\n  devinfo = XIQueryDevice(dpy, dev_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return paired;\n#endif\n}"
  },
  {
    "function_name": "removeAllMDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "158-169",
    "snippet": "void removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cleanup: removed XInput2 MD for client %s.\\n\"",
            "cl->host"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "removeMD",
          "args": [
            "dpy",
            "cd->ptr_id"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "removeMD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "114-155",
          "snippet": "int removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nvoid removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "removeMD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "114-155",
    "snippet": "int removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIChangeHierarchy",
          "args": [
            "dpy",
            "(XIAnyHierarchyChangeInfo*)&r",
            "1"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XISetClientPointer",
          "args": [
            "dpy",
            "None",
            "dev_id"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIFreeDeviceInfo",
          "args": [
            "devinfo"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryDevice",
          "args": [
            "dpy",
            "XIAllMasterDevices",
            "&num_devices"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}"
  },
  {
    "function_name": "createMD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
    "lines": "54-106",
    "snippet": "int createMD(Display* dpy, char* name)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int dev_id = -1;\n  XErrorHandler old_handler;\n  XIAddMasterInfo c;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n  char handle[256]; /* device name */\n  snprintf(handle, sizeof handle, \"%s pointer\", name);\n\n  c.type = XIAddMaster;\n  c.name = name;\n  c.send_core = 1;\n  c.enable = 1;\n\n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n\t\n  XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&c, 1);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return -1;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  /* find newly created dev by name\n     FIXME: better wait for XIHierarchy event here? */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = num_devices-1; i >= 0; --i) \n    if(strcmp(devinfo[i].name, handle) == 0)\n      {\n\tdev_id = devinfo[i].deviceid;\n\tbreak;\n      }\n \n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return dev_id;\n#endif\n}",
    "includes": [
      "#include <cairo.h>",
      "#include <X11/Xcursor/Xcursor.h>",
      "#include \"xi2_devices.h\"",
      "#include \"win_utils.h\"",
      "#include \"cleanup.h\"",
      "#include \"cursor.h\"",
      "#include \"x11vnc.h\"",
      "#include <X11/keysym.h>",
      "#include <X11/Xproto.h>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XIFreeDeviceInfo",
          "args": [
            "devinfo"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "devinfo[i].name",
            "handle"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryDevice",
          "args": [
            "dpy",
            "XIAllMasterDevices",
            "&num_devices"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIChangeHierarchy",
          "args": [
            "dpy",
            "(XIAnyHierarchyChangeInfo*)&c",
            "1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "handle",
            "sizeof handle",
            "\"%s pointer\"",
            "name"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint createMD(Display* dpy, char* name)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int dev_id = -1;\n  XErrorHandler old_handler;\n  XIAddMasterInfo c;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n  char handle[256]; /* device name */\n  snprintf(handle, sizeof handle, \"%s pointer\", name);\n\n  c.type = XIAddMaster;\n  c.name = name;\n  c.send_core = 1;\n  c.enable = 1;\n\n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n\t\n  XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&c, 1);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return -1;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  /* find newly created dev by name\n     FIXME: better wait for XIHierarchy event here? */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = num_devices-1; i >= 0; --i) \n    if(strcmp(devinfo[i].name, handle) == 0)\n      {\n\tdev_id = devinfo[i].deviceid;\n\tbreak;\n      }\n \n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return dev_id;\n#endif\n}"
  }
]