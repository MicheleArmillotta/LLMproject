[
  {
    "function_name": "watch_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "4395-4775",
    "snippet": "void watch_loop(void) {\n\tint cnt = 0, tile_diffs = 0, skip_pe = 0, wait;\n\tdouble tm, dtr, dt = 0.0;\n\ttime_t start = time(NULL);\n\n\tif (use_threads && !started_rfbRunEventLoop) {\n\t\tstarted_rfbRunEventLoop = 1;\n\t\trfbRunEventLoop(screen, -1, TRUE);\n\t}\n\n\twhile (1) {\n\t\tchar msg[] = \"new client: %s taking unixpw client off hold.\\n\";\n\t\tint skip_scan_for_updates = 0;\n\n\t\tgot_user_input = 0;\n\t\tgot_pointer_input = 0;\n\t\tgot_local_pointer_input = 0;\n\t\tgot_pointer_calls = 0;\n\t\tgot_keyboard_input = 0;\n\t\tgot_keyboard_calls = 0;\n\t\turgent_update = 0;\n\n\t\tx11vnc_current = dnow();\n\n\t\tif (! use_threads) {\n\t\t\tdtime0(&tm);\n\t\t\tif (! skip_pe) {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(1);\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 1;\n\n\t\t\t\t/*\n\t\t\t\t * do a few more since a key press may\n\t\t\t\t * have induced a small change we want to\n\t\t\t\t * see quickly (just 1 rfbPE will likely\n\t\t\t\t * only process the subsequent \"up\" event)\n\t\t\t\t */\n\t\t\t\tif (tm < last_keyboard_time + 0.20) {\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (extra_fbur > 0) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i=0; i < extra_fbur; i++) {\n\t\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tif (x11vnc_current < last_new_client + 0.5) {\n\t\t\t\t\turgent_update = 1;\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 0;\n\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\t/* rfbPE loop until logged in. */\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(0);\n\t\t\t\t\tfb_update_sent(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdtr = dtime(&tm);\n\n\t\t\tif (! cursor_shape_updates) {\n\t\t\t\t/* undo any cursor shape requests */\n\t\t\t\tdisable_cursor_shape_updates(screen);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint ret = check_user_input(dt, dtr, tile_diffs, &cnt);\n\t\t\t\t/* true: loop back for more input */\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\tskip_pe = 1;\n\t\t\t\t}\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (debug_scroll) fprintf(stderr, \"watch_loop: LOOP-BACK: %d\\n\", ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* watch for viewonly input piling up: */\n\t\t\tif ((got_pointer_calls > got_pointer_input) ||\n\t\t\t    (got_keyboard_calls > got_keyboard_input)) {\n\t\t\t\teat_viewonly_input(10, 3);\n\t\t\t}\n\t\t} else {\n\t\t\t/* -threads here. */\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_xrecord) {\n\t\t\t\tcheck_xrecord();\n\t\t\t}\n\t\t\tif (wireframe && button_mask) {\n\t\t\t\tcheck_wireframe();\n\t\t\t}\n\t\t}\n\t\tskip_pe = 0;\n\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\n\t\tif (unixpw_in_progress) {\n\t\t\tcheck_new_clients();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! urgent_update) {\n\t\t\tif (do_copy_screen) {\n\t\t\t\tdo_copy_screen = 0;\n\t\t\t\tcopy_screen();\n\t\t\t}\n\n\t\t\tcheck_new_clients();\n\t\t\tcheck_ncache(0, 0);\n\t\t\tcheck_xevents(0);\n\t\t\tcheck_autorepeat();\n\t\t\tcheck_pm();\n\t\t\tcheck_filexfer();\n\t\t\tcheck_keycode_state();\n\t\t\tcheck_connect_inputs();\n\t\t\tcheck_gui_inputs();\n\t\t\tcheck_stunnel();\n\t\t\tcheck_openssl();\n\t\t\tcheck_https();\n\t\t\trecord_last_fb_update();\n\t\t\tcheck_padded_fb();\n\t\t\tcheck_fixscreen();\n\t\t\tcheck_xdamage_state();\n\t\t\tcheck_xrecord_reset(0);\n\t\t\tcheck_add_keysyms();\n\t\t\tcheck_new_passwds(0);\n#ifdef ENABLE_GRABLOCAL\n\t\t\tif (grab_local) {\n\t\t\t\tcheck_local_grab();\n\t\t\t}\n#endif\n\t\t\tif (started_as_root) {\n\t\t\t\tcheck_switched_user();\n\t\t\t}\n\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tstart = time(NULL);\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t}\n\n\t\tif (rawfb_vnc_reflect) {\n\t\t\tstatic time_t lastone = 0;\n\t\t\tif (time(NULL) > lastone + 10) {\n\t\t\t\tlastone = time(NULL);\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\t\t}\n\n\t\tif (first_conn_timeout) {\n\t\t\tint t = first_conn_timeout;\n\t\t\tif (!clients_served) {\n\t\t\t\tif (time(NULL) - start > first_conn_timeout) {\n\t\t\t\t\trfbLog(\"No client after %d secs.\\n\", t);\n\t\t\t\t\tshut_down = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!client_normal_count) {\n\t\t\t\t\tif (time(NULL) - start > t + 3) {\n\t\t\t\t\t\trfbLog(\"No valid client after %d secs.\\n\", t + 3);\n\t\t\t\t\t\tshut_down = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\t/* waiting for a client */\n\t\t\tusleep(200 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (first_conn_timeout && all_clients_initialized()) {\n\t\t\tfirst_conn_timeout = 0;\n\t\t}\n\n\t\tif (nofb) {\n\t\t\t/* no framebuffer polling needed */\n\t\t\tif (cursor_pos_updates) {\n\t\t\t\tcheck_x11_pointer();\n\t\t\t}\n#ifdef MACOSX\n\t\t\telse check_x11_pointer();\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (x11vnc_current < last_new_client + 0.5 && !all_clients_initialized()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\t/* XXX not working */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tcheck_xevents(0);\n\t\t\tif (subwin_obscured) {\n\t\t\t\tskip_scan_for_updates = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_scan_for_updates || nofb) {\n\t\t\t;\n\t\t} else if (button_mask && (!show_dragging || pointer_mode == 0)) {\n\t\t\t/*\n\t\t\t * if any button is pressed in this mode do\n\t\t\t * not update rfb screen, but do flush the\n\t\t\t * X11 display.\n\t\t\t */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tdt = 0.0;\n\t\t} else { /* scan for updates case */\n\t\t\tstatic double last_dt = 0.0;\n\t\t\tdouble xdamage_thrash = 0.4; \n\t\t\tstatic int tilecut = -1;\n\n\t\t\t/* for timing the scan to try to detect thrashing */\n\n\t\t\tif (use_xdamage && last_dt > xdamage_thrash)  {\n\t\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t\t}\n\n\t\t\tif (unixpw_in_progress) continue;\n\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\n\t\t\tdtime0(&tm);\n\n#if !NO_X11\n\t\t\tif (xrandr_present && !xrandr && xrandr_maybe) {\n\t\t\t\tint delay = 180;\n\t\t\t\t/*  there may be xrandr right after xsession start */\n\t\t\t\tif (tm < x11vnc_start + delay || tm < last_client + delay) {\n\t\t\t\t\tint tw = 20;\n\t\t\t\t\tif (auth_file != NULL) {\n\t\t\t\t\t\ttw = 120;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tif (tm < x11vnc_start + tw || tm < last_client + tw) {\n\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t\t}\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tcheck_xrandr_event(\"before-scan\");\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n#endif\n\t\t\t/* Now, for scanning and drawing soft cursors (i.e. writing to the framebuffer),\n\t\t\t   make sure we're not sending any updates to clients (i.e. reading the framebuffer).\n\t\t\t   Otherwise we get flicker! */\n\n\t\t\t/* Update offset in case local framebuffer is double buffered */\n\t\t\tif (rawfb_double_buffer) {\n\t\t\t\traw_fb_offset = rawfb_get_offset(&raw_fb_fd);\n\t\t\t}\n\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    LOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\n\t\t\tif (use_snapfb) {\n\t\t\t\tint t, tries = 3;\n\t\t\t\tcopy_snap();\n\t\t\t\tfor (t=0; t < tries; t++) {\n\t\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tif (! nap_ok) {\n\t\t\t\tlast_dt = dt;\n\t\t\t}\n\n\t\t\tif (tilecut < 0) {\n\t\t\t\tif (getenv(\"TILECUT\")) {\n\t\t\t\t\ttilecut = atoi(getenv(\"TILECUT\"));\n\t\t\t\t}\n\t\t\t\tif (tilecut < 0) tilecut = 4;\n\t\t\t}\n\n\t\t\tif ((debug_tiles || debug_scroll > 1 || debug_wireframe > 1)\n\t\t\t    && (tile_diffs > tilecut || debug_tiles > 1)) {\n\t\t\t\tdouble rate = (tile_x * tile_y * bpp/8 * tile_diffs) / dt;\n\t\t\t\tfprintf(stderr, \"============================= TILES: %d  dt: %.4f\"\n\t\t\t\t    \"  t: %.4f  %.2f MB/s nap_ok: %d\\n\", tile_diffs, dt,\n\t\t\t\t    tm - x11vnc_start, rate/1000000.0, nap_ok);\n\t\t\t}\n\n\t\t\t/* important to have this here since it draws cursors into framebuffer */\n\t\t\tcheck_cursor_changes();\n\n\t\t\t/* \n\t\t\t   Release the send ban again.\n\t\t\t*/\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    UNLOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\t\t\t\n\t\t} /* END scan for updates case */\n\n\t\t/* sleep a bit to lessen load */\n\t\twait = choose_delay(dt);\n\n\t\tif (urgent_update) {\n\t\t\t;\n\t\t} else if (wait > 2*waitms) {\n\t\t\t/* bog case, break it up */\n\t\t\tnap_sleep(wait, 10);\n\t\t} else {\n\t\t\tdouble t1, t2;\n\t\t\tint idt;\n\t\t\tif (extra_fbur > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i <= extra_fbur; i++) {\n\t\t\t\t\tint r = rfbPE(0);\n\t\t\t\t\tif (!r) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* sometimes the sleep is too short, so measure it: */\n\t\t\tt1 = dnow();\n\t\t\tusleep(wait * 1000);\n\t\t\tt2 = dnow();\n\n\t\t\tidt = (int) (1000. * (t2 - t1));\n\t\t\tif (idt > 0 && idt < wait) {\n\t\t\t\t/* try to sleep the remainder */\n\t\t\t\tusleep((wait - idt) * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_padded_fb(void);",
      "int parse_rotate_string(char *str, int *mode);",
      "void vnc_reflect_process_client(void);",
      "static void nofb_hook(rfbClientPtr cl);",
      "static void install_fake_fb(int w, int h, int bpp);",
      "static void check_filexfer(void);",
      "static void record_last_fb_update(void);",
      "static void check_cursor_changes(void);",
      "static int choose_delay(double dt);",
      "int rawfb_vnc_reflect = 0;",
      "int rawfb_double_buffer = 0;",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(wait - idt) * 1000"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4764
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "wait * 1000"
          ],
          "line": 4763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "0"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nap_sleep",
          "args": [
            "wait",
            "10"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "nap_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2912-2928",
          "snippet": "void nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void nap_sleep(int ms, int split);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid nap_sleep(int ms, int split);\n\nvoid nap_sleep(int ms, int split) {\n\tint i, input = got_user_input;\n\tint gd = got_local_pointer_input;\n\n\tfor (i=0; i<split; i++) {\n\t\tusleep(ms * 1000 / split);\n\t\tif (! use_threads && i != split - 1) {\n\t\t\trfbPE(-1);\n\t\t}\n\t\tif (input != got_user_input) {\n\t\t\tbreak;\n\t\t}\n\t\tif (gd != got_local_pointer_input) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_delay",
          "args": [
            "dt"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "choose_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "4199-4390",
          "snippet": "static int choose_delay(double dt) {\n\tstatic double t0 = 0.0, t1 = 0.0, t2 = 0.0, now; \n\tstatic int x0, y0, x1, y1, x2, y2, first = 1;\n\tint dx0, dy0, dx1, dy1, dm, i, msec = waitms;\n\tdouble cut1 = 0.15, cut2 = 0.075, cut3 = 0.25;\n\tdouble bogdown_time = 0.25, bave = 0.0;\n\tint bogdown = 1, bcnt = 0;\n\tint ndt = 8, nave = 3;\n\tdouble fac = 1.0;\n\tstatic int db = 0, did_set_defer = 0;\n\tstatic double dts[8];\n\tstatic int link = LR_UNSET, latency = -1, netrate = -1;\n\tstatic double last_link = 0.0;\n\n\tif (screen && did_set_defer) {\n\t\t/* reset defer in case we changed it */\n\t\tscreen->deferUpdateTime = defer_update;\n\t}\n\tif (waitms == 0) {\n\t\treturn waitms;\n\t}\n\tif (nofb) {\n\t\treturn waitms;\n\t}\n\n\tif (first) {\n\t\tfor(i=0; i<ndt; i++) {\n\t\t\tdts[i] = 0.0;\n\t\t}\n\t\tif (getenv(\"DEBUG_DELAY\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_DELAY\"));\n\t\t}\n\t\tif (getenv(\"SET_DEFER\")) {\n\t\t\tset_defer = atoi(getenv(\"SET_DEFER\"));\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now > last_link + 30.0 || link == LR_UNSET) {\n\t\tlink = link_rate(&latency, &netrate);\n\t\tlast_link = now;\n\t}\n\n\t/*\n\t * first check for bogdown, e.g. lots of activity, scrolling text\n\t * from command output, etc.\n\t */\n\tif (nap_ok) {\n\t\tdt = 0.0;\n\t}\n\tif (! wait_bog) {\n\t\tbogdown = 0;\n\n\t} else if (button_mask || now < last_keyboard_time + 2*bogdown_time) {\n\t\t/*\n\t\t * let scrolls & keyboard input through the normal way\n\t\t * otherwise, it will likely just annoy them.\n\t\t */\n\t\tbogdown = 0;\n\n\t} else if (dt > 0.0) {\n\t\t/*\n\t\t * inspect recent dt's:\n\t\t * 0 1 2 3 4 5 6 7 dt\n\t\t *             ^ ^ ^\n\t\t */\n\t\tfor (i = ndt - (nave - 1); i < ndt; i++) {\n\t\t\tbave += dts[i];\n\t\t\tbcnt++;\n\t\t\tif (dts[i] < bogdown_time) {\n\t\t\t\tbogdown = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbave += dt;\n\t\tbcnt++;\n\t\tbave = bave / bcnt;\n\t\tif (dt < bogdown_time) {\n\t\t\tbogdown = 0;\n\t\t}\n\t} else {\n\t\tbogdown = 0;\n\t}\n\t/* shift for next time */\n\tfor (i = 0; i < ndt-1; i++) {\n\t\tdts[i] = dts[i+1];\n\t}\n\tdts[ndt-1] = dt;\n\nif (0 && dt > 0.0) fprintf(stderr, \"dt: %.5f %.4f\\n\", dt, dnowx());\n\tif (bogdown) {\n\t\tif (use_xdamage) {\n\t\t\t/* DAMAGE can queue ~1000 rectangles for a scroll */\n\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t}\n\t\tmsec = (int) (1000 * 1.75 * bave);\n\t\tif (dts[ndt - nave - 1] > 0.75 * bave) {\n\t\t\tmsec = 1.5 * msec;\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t}\n\t\tif (msec > 1500) {\n\t\t\tmsec = 1500;\n\t\t}\n\t\tif (msec < waitms) {\n\t\t\tmsec = waitms;\n\t\t}\n\t\tdb = (db || debug_tiles);\n\t\tif (db) fprintf(stderr, \"bogg[%d] %.3f %.3f %.3f %.3f\\n\",\n\t\t    msec, dts[ndt-4], dts[ndt-3], dts[ndt-2], dts[ndt-1]);\n\n\t\treturn msec;\n\t}\n\n\t/* next check for pointer motion, keystrokes, to speed up */\n\tt2 = dnow();\n\tx2 = cursor_x;\n\ty2 = cursor_y;\n\n\tdx0 = nabs(x1 - x0);\n\tdy0 = nabs(y1 - y0);\n\tdx1 = nabs(x2 - x1);\n\tdy1 = nabs(y2 - y1);\n\n\t/* bigger displacement for most recent dt: */\n\tif (dx1 > dy1) {\n\t\tdm = dx1;\n\t} else {\n\t\tdm = dy1;\n\t}\n\n\tif ((dx0 || dy0) && (dx1 || dy1)) {\n\t\t/* if mouse moved the previous two times: */\n\t\tif (t2 < t0 + cut1 || t2 < t1 + cut2 || dm > 20) {\n\t\t\t/*\n\t\t\t * if within 0.15s(0) or 0.075s(1) or mouse\n\t\t\t * moved > 20pixels, set and bump up the cut\n\t\t\t * down factor.\n\t\t\t */\n\t\t\tfac = wait_ui * 1.5;\n\t\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t\tfac = wait_ui;\n\t\t} else {\n\t\t\t/* still 1.0? */\n\t\t\tif (db > 1) fprintf(stderr, \"wait_ui: still 1.0\\n\");\n\t\t}\n\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t/* if mouse moved > 40 last time: */\n\t\tfac = wait_ui;\n\t}\n\n\tif (fac == 1.0 && t2 < last_keyboard_time + cut3) {\n\t\t/* if typed in last 0.25s set wait_ui */\n\t\tfac = wait_ui;\n\t}\n\tif (fac != 1.0) {\n\t\tif (link == LR_LAN || latency <= 3) {\n\t\t\tfac *= 1.5;\n\t\t}\n\t}\n\n\tmsec = (int) (((double) waitms) / fac);\n\tif (msec == 0) {\n\t\tmsec = 1;\n\t}\n\n\tif (set_defer && fac != 1.0 && screen) {\n\t\t/* this is wait_ui mode, set defer to match wait: */\n\t\tif (set_defer >= 1) {\n\t\t\tscreen->deferUpdateTime = msec;\n\t\t} else if (set_defer <= -1) {\n\t\t\tscreen->deferUpdateTime = 0;\n\t\t}\n\t\tif (nabs(set_defer) == 2) {\n\t\t\turgent_update = 1;\n\t\t}\n\t\tdid_set_defer = 1;\n\t}\n\n\tx0 = x1;\n\ty0 = y1;\n\tt0 = t1;\n\n\tx1 = x2;\n\ty1 = y2;\n\tt1 = t2;\n\n\tif (db > 1) fprintf(stderr, \"wait: %2d defer[%02d]: %2d\\n\", msec, defer_update, screen->deferUpdateTime);\n\n\treturn msec;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_colormap(int reset);",
            "int parse_rotate_string(char *str, int *mode);",
            "int scale_round(int len, double fac);",
            "rfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);",
            "static int choose_delay(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_colormap(int reset);\nint parse_rotate_string(char *str, int *mode);\nint scale_round(int len, double fac);\nrfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);\nstatic int choose_delay(double dt);\n\nstatic int choose_delay(double dt) {\n\tstatic double t0 = 0.0, t1 = 0.0, t2 = 0.0, now; \n\tstatic int x0, y0, x1, y1, x2, y2, first = 1;\n\tint dx0, dy0, dx1, dy1, dm, i, msec = waitms;\n\tdouble cut1 = 0.15, cut2 = 0.075, cut3 = 0.25;\n\tdouble bogdown_time = 0.25, bave = 0.0;\n\tint bogdown = 1, bcnt = 0;\n\tint ndt = 8, nave = 3;\n\tdouble fac = 1.0;\n\tstatic int db = 0, did_set_defer = 0;\n\tstatic double dts[8];\n\tstatic int link = LR_UNSET, latency = -1, netrate = -1;\n\tstatic double last_link = 0.0;\n\n\tif (screen && did_set_defer) {\n\t\t/* reset defer in case we changed it */\n\t\tscreen->deferUpdateTime = defer_update;\n\t}\n\tif (waitms == 0) {\n\t\treturn waitms;\n\t}\n\tif (nofb) {\n\t\treturn waitms;\n\t}\n\n\tif (first) {\n\t\tfor(i=0; i<ndt; i++) {\n\t\t\tdts[i] = 0.0;\n\t\t}\n\t\tif (getenv(\"DEBUG_DELAY\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_DELAY\"));\n\t\t}\n\t\tif (getenv(\"SET_DEFER\")) {\n\t\t\tset_defer = atoi(getenv(\"SET_DEFER\"));\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now > last_link + 30.0 || link == LR_UNSET) {\n\t\tlink = link_rate(&latency, &netrate);\n\t\tlast_link = now;\n\t}\n\n\t/*\n\t * first check for bogdown, e.g. lots of activity, scrolling text\n\t * from command output, etc.\n\t */\n\tif (nap_ok) {\n\t\tdt = 0.0;\n\t}\n\tif (! wait_bog) {\n\t\tbogdown = 0;\n\n\t} else if (button_mask || now < last_keyboard_time + 2*bogdown_time) {\n\t\t/*\n\t\t * let scrolls & keyboard input through the normal way\n\t\t * otherwise, it will likely just annoy them.\n\t\t */\n\t\tbogdown = 0;\n\n\t} else if (dt > 0.0) {\n\t\t/*\n\t\t * inspect recent dt's:\n\t\t * 0 1 2 3 4 5 6 7 dt\n\t\t *             ^ ^ ^\n\t\t */\n\t\tfor (i = ndt - (nave - 1); i < ndt; i++) {\n\t\t\tbave += dts[i];\n\t\t\tbcnt++;\n\t\t\tif (dts[i] < bogdown_time) {\n\t\t\t\tbogdown = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbave += dt;\n\t\tbcnt++;\n\t\tbave = bave / bcnt;\n\t\tif (dt < bogdown_time) {\n\t\t\tbogdown = 0;\n\t\t}\n\t} else {\n\t\tbogdown = 0;\n\t}\n\t/* shift for next time */\n\tfor (i = 0; i < ndt-1; i++) {\n\t\tdts[i] = dts[i+1];\n\t}\n\tdts[ndt-1] = dt;\n\nif (0 && dt > 0.0) fprintf(stderr, \"dt: %.5f %.4f\\n\", dt, dnowx());\n\tif (bogdown) {\n\t\tif (use_xdamage) {\n\t\t\t/* DAMAGE can queue ~1000 rectangles for a scroll */\n\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t}\n\t\tmsec = (int) (1000 * 1.75 * bave);\n\t\tif (dts[ndt - nave - 1] > 0.75 * bave) {\n\t\t\tmsec = 1.5 * msec;\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t}\n\t\tif (msec > 1500) {\n\t\t\tmsec = 1500;\n\t\t}\n\t\tif (msec < waitms) {\n\t\t\tmsec = waitms;\n\t\t}\n\t\tdb = (db || debug_tiles);\n\t\tif (db) fprintf(stderr, \"bogg[%d] %.3f %.3f %.3f %.3f\\n\",\n\t\t    msec, dts[ndt-4], dts[ndt-3], dts[ndt-2], dts[ndt-1]);\n\n\t\treturn msec;\n\t}\n\n\t/* next check for pointer motion, keystrokes, to speed up */\n\tt2 = dnow();\n\tx2 = cursor_x;\n\ty2 = cursor_y;\n\n\tdx0 = nabs(x1 - x0);\n\tdy0 = nabs(y1 - y0);\n\tdx1 = nabs(x2 - x1);\n\tdy1 = nabs(y2 - y1);\n\n\t/* bigger displacement for most recent dt: */\n\tif (dx1 > dy1) {\n\t\tdm = dx1;\n\t} else {\n\t\tdm = dy1;\n\t}\n\n\tif ((dx0 || dy0) && (dx1 || dy1)) {\n\t\t/* if mouse moved the previous two times: */\n\t\tif (t2 < t0 + cut1 || t2 < t1 + cut2 || dm > 20) {\n\t\t\t/*\n\t\t\t * if within 0.15s(0) or 0.075s(1) or mouse\n\t\t\t * moved > 20pixels, set and bump up the cut\n\t\t\t * down factor.\n\t\t\t */\n\t\t\tfac = wait_ui * 1.5;\n\t\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t\tfac = wait_ui;\n\t\t} else {\n\t\t\t/* still 1.0? */\n\t\t\tif (db > 1) fprintf(stderr, \"wait_ui: still 1.0\\n\");\n\t\t}\n\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t/* if mouse moved > 40 last time: */\n\t\tfac = wait_ui;\n\t}\n\n\tif (fac == 1.0 && t2 < last_keyboard_time + cut3) {\n\t\t/* if typed in last 0.25s set wait_ui */\n\t\tfac = wait_ui;\n\t}\n\tif (fac != 1.0) {\n\t\tif (link == LR_LAN || latency <= 3) {\n\t\t\tfac *= 1.5;\n\t\t}\n\t}\n\n\tmsec = (int) (((double) waitms) / fac);\n\tif (msec == 0) {\n\t\tmsec = 1;\n\t}\n\n\tif (set_defer && fac != 1.0 && screen) {\n\t\t/* this is wait_ui mode, set defer to match wait: */\n\t\tif (set_defer >= 1) {\n\t\t\tscreen->deferUpdateTime = msec;\n\t\t} else if (set_defer <= -1) {\n\t\t\tscreen->deferUpdateTime = 0;\n\t\t}\n\t\tif (nabs(set_defer) == 2) {\n\t\t\turgent_update = 1;\n\t\t}\n\t\tdid_set_defer = 1;\n\t}\n\n\tx0 = x1;\n\ty0 = y1;\n\tt0 = t1;\n\n\tx1 = x2;\n\ty1 = y2;\n\tt1 = t2;\n\n\tif (db > 1) fprintf(stderr, \"wait: %2d defer[%02d]: %2d\\n\", msec, defer_update, screen->deferUpdateTime);\n\n\treturn msec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->sendMutex"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cursor_changes",
          "args": [],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "check_cursor_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "4057-4102",
          "snippet": "static void check_cursor_changes(void) {\n\tstatic double last_push = 0.0;\n\n\tif (unixpw_in_progress) return;\n\n\tcursor_changes += check_x11_pointer();\n\n\tif (cursor_changes) {\n\t\tdouble tm, max_push = 0.125, multi_push = 0.01, wait = 0.02;\n\t\tint dopush = 0, link, latency, netrate;\n\n\t\tif (! all_clients_initialized()) {\n\t\t\t/* play it safe */\n\t\t\treturn;\n\t\t}\n\t\n\t\tdtime0(&tm);\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP) {\n\t\t\tmax_push = 0.2;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tmax_push = 0.075;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_LAN) {\n\t\t\tmax_push = 0.01;\n\t\t} else if (latency < 5 && netrate > 200) {\n\t\t\tmax_push = 0.01;\n\t\t}\n\t\t\n\t\tif (tm > last_push + max_push) {\n\t\t\tdopush = 1;\n\t\t} else if (cursor_changes > 1 && tm > last_push + multi_push) {\n\t\t\tdopush = 1;\n\t\t}\n\n\t\tif (dopush) { \n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tfb_push_wait(wait, FB_MOD);\n\t\t\tlast_push = tm;\n\t\t} else {\n\t\t\trfbPE(0);\n\t\t}\n\t}\n\tcursor_changes = 0;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_cursor_changes(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void check_cursor_changes(void);\n\nstatic void check_cursor_changes(void) {\n\tstatic double last_push = 0.0;\n\n\tif (unixpw_in_progress) return;\n\n\tcursor_changes += check_x11_pointer();\n\n\tif (cursor_changes) {\n\t\tdouble tm, max_push = 0.125, multi_push = 0.01, wait = 0.02;\n\t\tint dopush = 0, link, latency, netrate;\n\n\t\tif (! all_clients_initialized()) {\n\t\t\t/* play it safe */\n\t\t\treturn;\n\t\t}\n\t\n\t\tdtime0(&tm);\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP) {\n\t\t\tmax_push = 0.2;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tmax_push = 0.075;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_LAN) {\n\t\t\tmax_push = 0.01;\n\t\t} else if (latency < 5 && netrate > 200) {\n\t\t\tmax_push = 0.01;\n\t\t}\n\t\t\n\t\tif (tm > last_push + max_push) {\n\t\t\tdopush = 1;\n\t\t} else if (cursor_changes > 1 && tm > last_push + multi_push) {\n\t\t\tdopush = 1;\n\t\t}\n\n\t\tif (dopush) { \n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tfb_push_wait(wait, FB_MOD);\n\t\t\tlast_push = tm;\n\t\t} else {\n\t\t\trfbPE(0);\n\t\t}\n\t}\n\tcursor_changes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"============================= TILES: %d  dt: %.4f\"\n\t\t\t\t    \"  t: %.4f  %.2f MB/s nap_ok: %d\\n\"",
            "tile_diffs",
            "dt",
            "tm - x11vnc_start",
            "rate/1000000.0",
            "nap_ok"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"TILECUT\")"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TILECUT\""
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"TILECUT\""
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 4705
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan_for_updates",
          "args": [
            "0"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "scan_for_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3356-3674",
          "snippet": "int scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int copy_screen(void);",
            "void set_offset(void);",
            "int scan_for_updates(int count_only);",
            "static void hint_updates(void);",
            "static int copy_all_tiles(void);",
            "static int copy_all_tile_runs(void);",
            "static int copy_tiles_backward_pass(void);",
            "static int copy_tiles_additional_pass(void);",
            "static int fill_tile_gaps(void);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int grow_islands(void);",
            "static int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);",
            "static int scan_display(int ystart, int rescan);",
            "static int scan_count = 0;",
            "static int scan_in_progress = 0;",
            "static int fs_factor = 0;",
            "static int xd_samples = 0, xd_misses = 0, xd_do_check = 0;",
            "int scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint copy_screen(void);\nvoid set_offset(void);\nint scan_for_updates(int count_only);\nstatic void hint_updates(void);\nstatic int copy_all_tiles(void);\nstatic int copy_all_tile_runs(void);\nstatic int copy_tiles_backward_pass(void);\nstatic int copy_tiles_additional_pass(void);\nstatic int fill_tile_gaps(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int grow_islands(void);\nstatic int blackout_line_skip(int n, int x, int y, int rescan,\n    int *tile_count);\nstatic int scan_display(int ystart, int rescan);\nstatic int scan_count = 0;\nstatic int scan_in_progress = 0;\nstatic int fs_factor = 0;\nstatic int xd_samples = 0, xd_misses = 0, xd_do_check = 0;\nint scanlines[NSCAN] = {\n\t 0, 16,  8, 24,  4, 20, 12, 28,\n\t10, 26, 18,  2, 22,  6, 30, 14,\n\t 1, 17,  9, 25,  7, 23, 15, 31,\n\t19,  3, 27, 11, 29, 13,  5, 21\n};\n\nint scan_for_updates(int count_only) {\n\tint i, tile_count, tile_diffs;\n\tint old_copy_tile;\n\tdouble frac1 = 0.1;   /* tweak parameter to try a 2nd scan_display() */\n\tdouble frac2 = 0.35;  /* or 3rd */\n\tdouble frac3 = 0.02;  /* do scan_display() again after copy_tiles() */\n\tstatic double last_poll = 0.0;\n\n\tif (unixpw_in_progress) return 0;\n \n\tif (slow_fb > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_poll + slow_fb) {\n\t\t\treturn 0;\n\t\t}\n\t\tlast_poll = now;\n\t}\n\n\tfor (i=0; i < ntiles; i++) {\n\t\ttile_has_diff[i] = 0;\n\t\ttile_has_xdamage_diff[i] = 0;\n\t\ttile_tried[i] = 0;\n\t\ttile_copied[i] = 0;\n\t}\n\tfor (i=0; i < ntiles_y; i++) {\n\t\t/* could be useful, currently not used */\n\t\ttile_row_has_xdamage_diff[i] = 0;\n\t}\n\txdamage_tile_count = 0;\n\n\t/*\n\t * n.b. this program has only been tested so far with\n\t * tile_x = tile_y = NSCAN = 32!\n\t */\n\n\tif (!count_only) {\n\t\tscan_count++;\n\t\tscan_count %= NSCAN;\n\n\t\t/* some periodic maintenance */\n\t\tif (subwin && scan_count % 4 == 0) {\n\t\t\tset_offset();\t/* follow the subwindow */\n\t\t}\n\t\tif (indexed_color && scan_count % 4 == 0) {\n\t\t\t/* check for changed colormap */\n\t\t\tset_colormap(0);\n\t\t}\n\t\tif (cmap8to24 && scan_count % 1 == 0) {\n\t\t\tcheck_for_multivis();\n\t\t}\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\tmacosx_event_loop();\n\t\t}\n#endif\n\t\tif (use_xdamage) {\n\t\t\t/* first pass collecting DAMAGE events: */\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t} else \n#endif\n\t\t\t{\n\t\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcollect_xdamage(scan_count, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#define SCAN_FATAL(x) \\\n\tif (x < 0) { \\\n\t\tscan_in_progress = 0; \\\n\t\tfb_copy_in_progress = 0; \\\n\t\treturn 0; \\\n\t}\n\n\t/* scan with the initial y to the jitter value from scanlines: */\n\tscan_in_progress = 1;\n\ttile_count = scan_display(scanlines[scan_count], 0);\n\tSCAN_FATAL(tile_count);\n\n\t/*\n\t * we do the XDAMAGE here too since after scan_display()\n\t * there is a better chance we have received the events from\n\t * the X server (otherwise the DAMAGE events will be processed\n\t * in the *next* call, usually too late and wasteful since\n\t * the unchanged tiles are read in again).\n\t */\n\tif (use_xdamage) {\n#ifdef MACOSX\n\t\tif (macosx_console) {\n\t\t\t;\n\t\t} else \n#endif\n\t\t{\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tcollect_xdamage(scan_count, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (count_only) {\n\t\tscan_in_progress = 0;\n\t\tfb_copy_in_progress = 0;\n\t\treturn tile_count;\n\t}\n\n\tif (xdamage_tile_count) {\n\t\t/* pick up \"known\" damaged tiles we missed in scan_display() */\n\t\tfor (i=0; i < ntiles; i++) {\n\t\t\tif (tile_has_diff[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tile_has_xdamage_diff[i]) {\n\t\t\t\ttile_has_diff[i] = 1;\n\t\t\t\tif (tile_has_xdamage_diff[i] == 1) {\n\t\t\t\t\ttile_has_xdamage_diff[i] = 2;\n\t\t\t\t\ttile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (dpy && use_xdamage == 1) {\n\t\tstatic time_t last_xd_check = 0;\n\t\tif (time(NULL) > last_xd_check + 2) {\n\t\t\tint cp = (scan_count + 3) % NSCAN;\n\t\t\txd_do_check = 1;\n\t\t\ttile_count = scan_display(scanlines[cp], 0);\n\t\t\txd_do_check = 0;\n\t\t\tSCAN_FATAL(tile_count);\n\t\t\tlast_xd_check = time(NULL);\n\t\t\tif (xd_samples > 200) {\n\t\t\t\tstatic int bad = 0;\n\t\t\t\tif (xd_misses > (20 * xd_samples) / 100) {\n\t\t\t\t\trfbLog(\"XDAMAGE is not working well... misses: %d/%d\\n\", xd_misses, xd_samples);\n\t\t\t\t\trfbLog(\"Maybe an OpenGL app like Beryl or Compiz is the problem?\\n\");\n\t\t\t\t\trfbLog(\"Use x11vnc -noxdamage or disable the Beryl/Compiz app.\\n\");\n\t\t\t\t\trfbLog(\"To disable this check and warning specify -xdamage twice.\\n\");\n\t\t\t\t\tif (++bad >= 10) {\n\t\t\t\t\t\trfbLog(\"XDAMAGE appears broken (OpenGL app?), turning it off.\\n\");\n\t\t\t\t\t\tuse_xdamage = 0;\n\t\t\t\t\t\tinitialize_xdamage();\n\t\t\t\t\t\tdestroy_xdamage_if_needed();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txd_samples = 0;\n\t\t\t\txd_misses = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tnap_set(tile_count);\n\n\tif (fs_factor && frac1 >= fs_frac) {\n\t\t/* make frac1 < fs_frac if fullscreen updates are enabled */\n\t\tfrac1 = fs_frac/2.0;\n\t}\n\n\tif (tile_count > frac1 * ntiles) {\n\t\t/*\n\t\t * many tiles have changed, so try a rescan (since it should\n\t\t * be short compared to the many upcoming copy_tiles() calls)\n\t\t */\n\n\t\t/* this check is done to skip the extra scan_display() call */\n\t\tif (! fs_factor || tile_count <= fs_frac * ntiles) {\n\t\t\tint cp, tile_count_old = tile_count;\n\t\t\t\n\t\t\t/* choose a different y shift for the 2nd scan: */\n\t\t\tcp = (NSCAN - scan_count) % NSCAN;\n\n\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\tSCAN_FATAL(tile_count);\n\n\t\t\tif (tile_count >= (1 + frac2) * tile_count_old) {\n\t\t\t\t/* on a roll... do a 3rd scan */\n\t\t\t\tcp = (NSCAN - scan_count + 7) % NSCAN;\n\t\t\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\t\t\tSCAN_FATAL(tile_count);\n\t\t\t}\n\t\t}\n\t\tscan_in_progress = 0;\n\n\t\t/*\n\t\t * At some number of changed tiles it is better to just\n\t\t * copy the full screen at once.  I.e. time = c1 + m * r1\n\t\t * where m is number of tiles, r1 is the copy_tiles()\n\t\t * time, and c1 is the scan_display() time: for some m\n\t\t * it crosses the full screen update time.\n\t\t *\n\t\t * We try to predict that crossover with the fs_frac\n\t\t * fudge factor... seems to be about 1/2 the total number\n\t\t * of tiles.  n.b. this ignores network bandwidth,\n\t\t * compression time etc...\n\t\t *\n\t\t * Use -fs 1.0 to disable on slow links.\n\t\t */\n\t\tif (fs_factor && tile_count > fs_frac * ntiles) {\n\t\t\tint cs;\n\t\t\tfb_copy_in_progress = 1;\n\t\t\tcs = copy_screen();\n\t\t\tfb_copy_in_progress = 0;\n\t\t\tSCAN_FATAL(cs);\n\t\t\tif (use_threads && pointer_mode != 1) {\n\t\t\t\tpointer_event(-1, 0, 0, NULL);\n\t\t\t}\n\t\t\tnap_check(tile_count);\n\t\t\treturn tile_count;\n\t\t}\n\t}\n\tscan_in_progress = 0;\n\n\t/* copy all tiles with differences from display to rfb framebuffer: */\n\tfb_copy_in_progress = 1;\n\n\tif (single_copytile || tile_shm_count < ntiles_x) {\n\t\t/*\n\t\t * Old way, copy I/O one tile at a time.\n\t\t */\n\t\told_copy_tile = 1;\n\t} else {\n\t\t/* \n\t\t * New way, does runs of horizontal tiles at once.\n\t\t * Note that below, for simplicity, the extra tile finding\n\t\t * (e.g. copy_tiles_backward_pass) is done the old way.\n\t\t */\n\t\told_copy_tile = 0;\n\t}\n\n\tif (unixpw_in_progress) return 0;\n\n\tif (old_copy_tile) {\n\t\ttile_diffs = copy_all_tiles();\n\t} else {\n\t\ttile_diffs = copy_all_tile_runs();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/*\n\t * This backward pass for upward and left tiles complements what\n\t * was done in copy_all_tiles() for downward and right tiles.\n\t */\n\ttile_diffs = copy_tiles_backward_pass();\n\tSCAN_FATAL(tile_diffs);\n\n\tif (tile_diffs > frac3 * ntiles) {\n\t\t/*\n\t\t * we spent a lot of time in those copy_tiles, run\n\t\t * another scan, maybe more of the screen changed.\n\t\t */\n\t\tint cp = (NSCAN - scan_count + 13) % NSCAN;\n\n\t\tscan_in_progress = 1;\n\t\ttile_count = scan_display(scanlines[cp], 1);\n\t\tSCAN_FATAL(tile_count);\n\t\tscan_in_progress = 0;\n\n\t\ttile_diffs = copy_tiles_additional_pass();\n\t\tSCAN_FATAL(tile_diffs);\n\t}\n\n\t/* Given enough tile diffs, try the islands: */\n\tif (grow_fill && tile_diffs > 4) {\n\t\ttile_diffs = grow_islands();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\t/* Given enough tile diffs, try the gaps: */\n\tif (gaps_fill && tile_diffs > 4) {\n\t\ttile_diffs = fill_tile_gaps();\n\t}\n\tSCAN_FATAL(tile_diffs);\n\n\tfb_copy_in_progress = 0;\n\tif (use_threads && pointer_mode != 1) {\n\t\t/*\n\t\t * tell the pointer handler it can process any queued\n\t\t * pointer events:\n\t\t */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (blackouts) {\n\t\t/* ignore any diffs in completely covered tiles */\n\t\tint x, y, n;\n\t\tfor (y=0; y < ntiles_y; y++) {\n\t\t\tfor (x=0; x < ntiles_x; x++) {\n\t\t\t\tn = x + y * ntiles_x;\n\t\t\t\tif (tile_blackout[n].cover == 2) {\n\t\t\t\t\ttile_has_diff[n] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thint_updates();\t/* use x0rfbserver hints algorithm */\n\n\t/* Work around threaded rfbProcessClientMessage() calls timeouts */\n\tif (use_threads) {\n\t\tping_clients(tile_diffs);\n\t} else if (saw_ultra_chat || saw_ultra_file) {\n\t\tping_clients(-1);\n\t} else if (use_openssl && !tile_diffs) {\n\t\tping_clients(0);\n\t}\n\t/* -ping option: */\n\tif (ping_interval) {\n\t\tint td = ping_interval > 0 ? ping_interval : -ping_interval;\n\t\tping_clients(-td);\n\t}\n\n\n\tnap_check(tile_diffs);\n\treturn tile_diffs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_snap",
          "args": [],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "copy_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2742-2820",
          "snippet": "int copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "int copy_snap(void);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_snap(void);\nstatic int fs_factor = 0;\n\nint copy_snap(void) {\n\tint db = 1;\n\tchar *fbp;\n\tint i, y, block_size;\n\tdouble dt;\n\tstatic int first = 1, snapcnt = 0;\n\n\tif (raw_fb_str) {\n\t\tint read_all_at_once = 1;\n\t\tdouble start = dnow();\n\t\tif (rawfb_reset < 0) {\n\t\t\tif (getenv(\"SNAPFB_RAWFB_RESET\")) {\n\t\t\t\trawfb_reset = 1;\n\t\t\t} else {\n\t\t\t\trawfb_reset = 0;\n\t\t\t}\n\t\t}\n\t\tif (snap_fb == NULL || snap == NULL) {\n\t\t\trfbLog(\"copy_snap: rawfb mode and null snap fb\\n\"); \n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (rawfb_reset) {\n\t\t\tinitialize_raw_fb(1);\n\t\t}\n\t\tif (raw_fb_bytes_per_line != snap->bytes_per_line) {\n\t\t\tread_all_at_once = 0;\n\t\t}\n\t\tif (raw_fb_full_str && strstr(raw_fb_full_str, \"/dev/vcsa\")) {\n\t\t\tsnap_vcsa_rawfb();\n\t\t} else if (read_all_at_once) {\n\t\t\tsnap_all_rawfb();\n\t\t} else {\n\t\t\t/* this goes line by line, XXX not working for video */\n\t\t\tcopy_raw_fb(snap, 0, 0, dpy_x, dpy_y);\n\t\t}\nif (db && snapcnt++ < 5) rfbLog(\"rawfb copy_snap took: %.5f secs\\n\", dnow() - start);\n\n\t\treturn 0;\n\t}\n\t\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\n\n\tif (! snap_fb || ! snap || ! snaprect) {\n\t\treturn 0;\n\t}\n\tblock_size = ((dpy_y/fs_factor) * snap->bytes_per_line);\n\n\tfbp = snap_fb;\n\ty = 0;\n\n\n\tdtime0(&dt);\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_snap-set\");\n\t\tcopy_image(snaprect, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_snap-chk\");\n\n\t\tmemcpy(fbp, snaprect->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tdt = dtime(&dt);\n\tif (first) {\n\t\trfbLog(\"copy_snap: time for -snapfb snapshot: %.3f sec\\n\", dt);\n\t\tfirst = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 4693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->sendMutex"
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rawfb_get_offset",
          "args": [
            "&raw_fb_fd"
          ],
          "line": 4684
        },
        "resolved": true,
        "details": {
          "function_name": "rawfb_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/linuxfb.c",
          "lines": "59-80",
          "snippet": "int rawfb_get_offset(int *fd)\n{\n#if HAVE_LINUX_FB_H\n\tint offset;\n\tstruct fb_var_screeninfo var_info;\n\tif (ioctl(*fd, FBIOGET_VSCREENINFO, &var_info)) {\n\t\tperror(\"ioctl\");\n\t\treturn 0;\n\t}\n\n\t/* todo: How should x offset be handled? */\n\tif (var_info.xoffset != 0) {\n\t\trfbLog(\"rawfb xoffset handling not implemented\");\n\t}\n\n\tif (var_info.yoffset != 0) {\n\t\toffset = main_bytes_per_line * var_info.yoffset;\n\t\treturn offset;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fb.h>",
            "#include <sys/ioctl.h>",
            "#include \"macosx.h\"",
            "#include \"keyboard.h\"",
            "#include \"uinput.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *console_guess(char *str, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fb.h>\n#include <sys/ioctl.h>\n#include \"macosx.h\"\n#include \"keyboard.h\"\n#include \"uinput.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *console_guess(char *str, int *fd);\n\nint rawfb_get_offset(int *fd)\n{\n#if HAVE_LINUX_FB_H\n\tint offset;\n\tstruct fb_var_screeninfo var_info;\n\tif (ioctl(*fd, FBIOGET_VSCREENINFO, &var_info)) {\n\t\tperror(\"ioctl\");\n\t\treturn 0;\n\t}\n\n\t/* todo: How should x offset be handled? */\n\tif (var_info.xoffset != 0) {\n\t\trfbLog(\"rawfb xoffset handling not implemented\");\n\t}\n\n\tif (var_info.yoffset != 0) {\n\t\toffset = main_bytes_per_line * var_info.yoffset;\n\t\treturn offset;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xrandr_event",
          "args": [
            "\"before-scan\""
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrandr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "184-290",
          "snippet": "int check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "Time xrandr_timestamp = 0;",
            "Time xrandr_cfg_time = 0;",
            "int check_xrandr_event(char *msg);",
            "int known_xrandr_mode(char *s);",
            "static int handle_subwin_resize(char *msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nTime xrandr_timestamp = 0;\nTime xrandr_cfg_time = 0;\nint check_xrandr_event(char *msg);\nint known_xrandr_mode(char *s);\nstatic int handle_subwin_resize(char *msg);\n\nint check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_reflect_process_client",
          "args": [],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_reflect_process_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1604-1616",
          "snippet": "void vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vnc_reflect_process_client(void);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid vnc_reflect_process_client(void);\nstatic rfbClient* client = NULL;\n\nvoid vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_xdamage_mark_region",
          "args": [
            "NULL",
            "0"
          ],
          "line": 4645
        },
        "resolved": true,
        "details": {
          "function_name": "clear_xdamage_mark_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "212-258",
          "snippet": "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush);\n\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xevents",
          "args": [
            "0"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "check_xevents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1203-1675",
          "snippet": "void check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DEBUG_XEVENTS 1"
          ],
          "globals_used": [
            "int sync_tod_delay = 20;",
            "void sync_tod_with_servertime(void);",
            "void set_prop_atom(Atom atom);",
            "void check_xevents(int reset);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "void set_text_chat(rfbClientPtr cl, int l, char *t);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static void initialize_xevents(int reset);",
            "static void print_xevent_bases(void);",
            "static void bust_grab(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DEBUG_XEVENTS 1\n\nint sync_tod_delay = 20;\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nvoid set_text_chat(rfbClientPtr cl, int l, char *t);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void print_xevent_bases(void);\nstatic void bust_grab(int reset);\n\nvoid check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 4611
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_x11_pointer",
          "args": [],
          "line": 4604
        },
        "resolved": true,
        "details": {
          "function_name": "check_x11_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1985-2112",
          "snippet": "int check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_which_cursor(void);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "int check_x11_pointer(void);",
            "unsigned long get_cursor_serial(int mode);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_which_cursor(void);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nint check_x11_pointer(void);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nint check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "200 * 1000"
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"No valid client after %d secs.\\n\"",
            "t + 3"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"No client after %d secs.\\n\"",
            "t"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_switched_user",
          "args": [],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "check_switched_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "85-138",
          "snippet": "void check_switched_user(void) {\n\tstatic time_t sched_switched_user = 0;\n\tstatic int did_solid = 0;\n\tstatic int did_dummy = 0;\n\tint delay = 15;\n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (started_as_root == 1 && users_list) {\n\t\ttry_to_switch_users();\n\t\tif (started_as_root == 2) {\n\t\t\t/*\n\t\t\t * schedule the switch_user_tasks() call\n\t\t\t * 15 secs is for piggy desktops to start up.\n\t\t\t * might not be enough for slow machines...\n\t\t\t */\n\t\t\tsched_switched_user = now;\n\t\t\tdid_dummy = 0;\n\t\t\tdid_solid = 0;\n\t\t\t/* add other activities */\n\t\t}\n\t}\n\tif (! sched_switched_user) {\n\t\treturn;\n\t}\n\n\tif (! did_dummy) {\n\t\tswitch_user_task_dummy();\n\t\tdid_dummy = 1;\n\t}\n\tif (! did_solid) {\n\t\tint doit = 0;\n\t\tchar *ss = solid_str;\n\t\tif (now >= sched_switched_user + delay) {\n\t\t\tdoit = 1;\n\t\t} else if (ss && strstr(ss, \"root:\") == ss) {\n\t\t    \tif (now >= sched_switched_user + 3) {\n\t\t\t\tdoit = 1;\n\t\t\t}\n\t\t} else if (strcmp(\"root\", guess_desktop())) {\n\t\t\tusleep(1000 * 1000);\n\t\t\tdoit = 1;\n\t\t}\n\t\tif (doit) {\n\t\t\tswitch_user_task_solid_bg();\n\t\t\tdid_solid = 1;\n\t\t}\n\t}\n\n\tif (did_dummy && did_solid) {\n\t\tsched_switched_user = 0;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_switched_user(void);",
            "static void switch_user_task_dummy(void);",
            "static void switch_user_task_solid_bg(void);",
            "static void try_to_switch_users(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid check_switched_user(void);\nstatic void switch_user_task_dummy(void);\nstatic void switch_user_task_solid_bg(void);\nstatic void try_to_switch_users(void);\n\nvoid check_switched_user(void) {\n\tstatic time_t sched_switched_user = 0;\n\tstatic int did_solid = 0;\n\tstatic int did_dummy = 0;\n\tint delay = 15;\n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (started_as_root == 1 && users_list) {\n\t\ttry_to_switch_users();\n\t\tif (started_as_root == 2) {\n\t\t\t/*\n\t\t\t * schedule the switch_user_tasks() call\n\t\t\t * 15 secs is for piggy desktops to start up.\n\t\t\t * might not be enough for slow machines...\n\t\t\t */\n\t\t\tsched_switched_user = now;\n\t\t\tdid_dummy = 0;\n\t\t\tdid_solid = 0;\n\t\t\t/* add other activities */\n\t\t}\n\t}\n\tif (! sched_switched_user) {\n\t\treturn;\n\t}\n\n\tif (! did_dummy) {\n\t\tswitch_user_task_dummy();\n\t\tdid_dummy = 1;\n\t}\n\tif (! did_solid) {\n\t\tint doit = 0;\n\t\tchar *ss = solid_str;\n\t\tif (now >= sched_switched_user + delay) {\n\t\t\tdoit = 1;\n\t\t} else if (ss && strstr(ss, \"root:\") == ss) {\n\t\t    \tif (now >= sched_switched_user + 3) {\n\t\t\t\tdoit = 1;\n\t\t\t}\n\t\t} else if (strcmp(\"root\", guess_desktop())) {\n\t\t\tusleep(1000 * 1000);\n\t\t\tdoit = 1;\n\t\t}\n\t\tif (doit) {\n\t\t\tswitch_user_task_solid_bg();\n\t\t\tdid_solid = 1;\n\t\t}\n\t}\n\n\tif (did_dummy && did_solid) {\n\t\tsched_switched_user = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_local_grab",
          "args": [],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "check_local_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "984-1064",
          "snippet": "void check_local_grab(void) {\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (grab_local <= 0) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (last_rfb_key_injected <= 0.0 && last_rfb_ptr_injected <= 0.0) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tnow = dnow();\n\n\tif (now > last_check + 0.1)   {\n#if !NO_X11\n\t\tint ret;\n\t\tdouble idle;\n\t\tXScreenSaverInfo info;\n\t\tstatic int save_viewonly = -1, local_is_idle = -1, db = -1;\n\n\t\tif (debug_keyboard) db = debug_keyboard;\n\t\tif (debug_pointer ) db = debug_pointer;\n\n\t\tif (db < 0) {\n\t\t\tif (getenv(\"LOCAL_GRAB_DEBUG\")) {\n\t\t\t\tdb = atoi(getenv(\"LOCAL_GRAB_DEBUG\"));\n\t\t\t} else {\n\t\t\t\tdb = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = XScreenSaverQueryInfo(dpy, RootWindowOfScreen(\n\t\t    ScreenOfDisplay(dpy, 0)), &info);\n\n\t\tif (ret) {\n\t\t\tdouble tlatest_rfb = 0.0;\n\n\t\t\tidle = ((double) info.idle)/1000.0;\n\t\t\tnow = dnow();\n\n\t\t\tif (last_rfb_key_injected > 0.0) {\n\t\t\t\ttlatest_rfb = last_rfb_key_injected;\n\t\t\t}\n\t\t\tif (last_rfb_ptr_injected > tlatest_rfb) {\n\t\t\t\ttlatest_rfb = last_rfb_ptr_injected;\n\t\t\t}\n\t\t\tif (db > 1) fprintf(stderr, \"idle: %.4f latest: %.4f dt: %.4f\\n\", idle, now - tlatest_rfb, idle - (now - tlatest_rfb));\n\n\t\t\tif (now - tlatest_rfb <= idle + 0.005) {\n\t\t\t\t/* 0.005 is 5ms tolerance */\n\t\t\t} else if (idle < grab_local) {\n\t\t\t\tif (local_is_idle < 0 || local_is_idle) {\n\t\t\t\t\tsave_viewonly = view_only;\n\t\t\t\t\tview_only = 1;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: set viewonly\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlocal_is_idle = 0;\n\t\t\t} else {\n\t\t\t\tif (!local_is_idle && save_viewonly >= 0) {\n\t\t\t\t\tview_only = save_viewonly;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: restored viewonly; %d\\n\", view_only);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocal_is_idle = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\tlast_check = dnow();\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int grab_local = 0;",
            "static int process_watch(char *str, int parent, int db);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint grab_local = 0;\nstatic int process_watch(char *str, int parent, int db);\n\nvoid check_local_grab(void) {\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (grab_local <= 0) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (last_rfb_key_injected <= 0.0 && last_rfb_ptr_injected <= 0.0) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tnow = dnow();\n\n\tif (now > last_check + 0.1)   {\n#if !NO_X11\n\t\tint ret;\n\t\tdouble idle;\n\t\tXScreenSaverInfo info;\n\t\tstatic int save_viewonly = -1, local_is_idle = -1, db = -1;\n\n\t\tif (debug_keyboard) db = debug_keyboard;\n\t\tif (debug_pointer ) db = debug_pointer;\n\n\t\tif (db < 0) {\n\t\t\tif (getenv(\"LOCAL_GRAB_DEBUG\")) {\n\t\t\t\tdb = atoi(getenv(\"LOCAL_GRAB_DEBUG\"));\n\t\t\t} else {\n\t\t\t\tdb = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = XScreenSaverQueryInfo(dpy, RootWindowOfScreen(\n\t\t    ScreenOfDisplay(dpy, 0)), &info);\n\n\t\tif (ret) {\n\t\t\tdouble tlatest_rfb = 0.0;\n\n\t\t\tidle = ((double) info.idle)/1000.0;\n\t\t\tnow = dnow();\n\n\t\t\tif (last_rfb_key_injected > 0.0) {\n\t\t\t\ttlatest_rfb = last_rfb_key_injected;\n\t\t\t}\n\t\t\tif (last_rfb_ptr_injected > tlatest_rfb) {\n\t\t\t\ttlatest_rfb = last_rfb_ptr_injected;\n\t\t\t}\n\t\t\tif (db > 1) fprintf(stderr, \"idle: %.4f latest: %.4f dt: %.4f\\n\", idle, now - tlatest_rfb, idle - (now - tlatest_rfb));\n\n\t\t\tif (now - tlatest_rfb <= idle + 0.005) {\n\t\t\t\t/* 0.005 is 5ms tolerance */\n\t\t\t} else if (idle < grab_local) {\n\t\t\t\tif (local_is_idle < 0 || local_is_idle) {\n\t\t\t\t\tsave_viewonly = view_only;\n\t\t\t\t\tview_only = 1;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: set viewonly\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlocal_is_idle = 0;\n\t\t\t} else {\n\t\t\t\tif (!local_is_idle && save_viewonly >= 0) {\n\t\t\t\t\tview_only = save_viewonly;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: restored viewonly; %d\\n\", view_only);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocal_is_idle = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\tlast_check = dnow();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_new_passwds",
          "args": [
            "0"
          ],
          "line": 4550
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_passwds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1105-1128",
          "snippet": "void check_new_passwds(int force) {\n\tstatic time_t last_check = 0;\n\ttime_t now;\n\n\tif (! passwdfile) {\n\t\treturn;\n\t}\n\tif (strstr(passwdfile, \"read:\") != passwdfile) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (force) {\n\t\tlast_check = 0;\n\t}\n\n\tnow = time(NULL);\n\tif (now > last_check + 1) {\n\t\tif (read_passwds(passwdfile)) {\n\t\t\tinstall_passwds();\n\t\t}\n\t\tlast_check = now;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_passwds(void);",
            "void check_new_passwds(int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid install_passwds(void);\nvoid check_new_passwds(int force);\n\nvoid check_new_passwds(int force) {\n\tstatic time_t last_check = 0;\n\ttime_t now;\n\n\tif (! passwdfile) {\n\t\treturn;\n\t}\n\tif (strstr(passwdfile, \"read:\") != passwdfile) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (force) {\n\t\tlast_check = 0;\n\t}\n\n\tnow = time(NULL);\n\tif (now > last_check + 1) {\n\t\tif (read_passwds(passwdfile)) {\n\t\t\tinstall_passwds();\n\t\t}\n\t\tlast_check = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_add_keysyms",
          "args": [],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "check_add_keysyms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "450-470",
          "snippet": "void check_add_keysyms(void) {\n\tstatic time_t last_check = 0;\n\tint clear_freq = 300, quiet = 1, count; \n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (now > last_check + clear_freq) {\n\t\tcount = count_added_keycodes();\n\t\t/*\n\t\t * only really delete if they have not typed recently\n\t\t * and we have added 8 or more.\n\t\t */\n\t\tif (now > last_keyboard_input + 5 && count >= 8) {\n\t\t\tX_LOCK;\n\t\t\tdelete_added_keycodes(quiet);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tlast_check = now;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_add_keysyms(void);",
            "static int count_added_keycodes(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_add_keysyms(void);\nstatic int count_added_keycodes(void);\n\nvoid check_add_keysyms(void) {\n\tstatic time_t last_check = 0;\n\tint clear_freq = 300, quiet = 1, count; \n\ttime_t now = time(NULL);\n\n\tif (unixpw_in_progress) return;\n\n\tif (now > last_check + clear_freq) {\n\t\tcount = count_added_keycodes();\n\t\t/*\n\t\t * only really delete if they have not typed recently\n\t\t * and we have added 8 or more.\n\t\t */\n\t\tif (now > last_keyboard_input + 5 && count >= 8) {\n\t\t\tX_LOCK;\n\t\t\tdelete_added_keycodes(quiet);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tlast_check = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xrecord_reset",
          "args": [
            "0"
          ],
          "line": 4548
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1558-1636",
          "snippet": "void check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecording = 0;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "void check_xrecord_reset(int force);",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecording = 0;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid check_xrecord_reset(int force);\nstatic void check_xrecord_grabserver(void);\n\nvoid check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xdamage_state",
          "args": [],
          "line": 4547
        },
        "resolved": true,
        "details": {
          "function_name": "check_xdamage_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "810-838",
          "snippet": "void check_xdamage_state(void) {\n\tif (! xdamage_present) {\n\t\treturn;\n\t}\n\t/*\n\t * Create or destroy the Damage object as needed, we don't want\n\t * one if no clients are connected.\n\t */\n\tif (xdamage_crazy_time > 0.0 && dnow() < xdamage_crazy_time + xdamage_crazy_delay) {\n\t\treturn;\n\t}\n\tif (client_count && use_xdamage) {\n\t\tcreate_xdamage_if_needed(0);\n\t\tif (xdamage_scheduled_mark > 0.0 && dnow() >\n\t\t    xdamage_scheduled_mark) {\n\t\t\tif (xdamage_scheduled_mark_region) {\n\t\t\t\tmark_region_for_xdamage(\n\t\t\t\t    xdamage_scheduled_mark_region);\n\t\t\t\tsraRgnDestroy(xdamage_scheduled_mark_region);\n\t\t\t\txdamage_scheduled_mark_region = NULL;\n\t\t\t} else {\n\t\t\t\tmark_for_xdamage(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t\txdamage_scheduled_mark = 0.0;\n\t\t}\n\t} else {\n\t\tdestroy_xdamage_if_needed();\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_scheduled_mark = 0.0;",
            "double xdamage_crazy_time = 0.0;",
            "double xdamage_crazy_delay = 300.0;",
            "sraRegionPtr xdamage_scheduled_mark_region = NULL;",
            "void destroy_xdamage_if_needed(void);",
            "void check_xdamage_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_scheduled_mark = 0.0;\ndouble xdamage_crazy_time = 0.0;\ndouble xdamage_crazy_delay = 300.0;\nsraRegionPtr xdamage_scheduled_mark_region = NULL;\nvoid destroy_xdamage_if_needed(void);\nvoid check_xdamage_state(void);\n\nvoid check_xdamage_state(void) {\n\tif (! xdamage_present) {\n\t\treturn;\n\t}\n\t/*\n\t * Create or destroy the Damage object as needed, we don't want\n\t * one if no clients are connected.\n\t */\n\tif (xdamage_crazy_time > 0.0 && dnow() < xdamage_crazy_time + xdamage_crazy_delay) {\n\t\treturn;\n\t}\n\tif (client_count && use_xdamage) {\n\t\tcreate_xdamage_if_needed(0);\n\t\tif (xdamage_scheduled_mark > 0.0 && dnow() >\n\t\t    xdamage_scheduled_mark) {\n\t\t\tif (xdamage_scheduled_mark_region) {\n\t\t\t\tmark_region_for_xdamage(\n\t\t\t\t    xdamage_scheduled_mark_region);\n\t\t\t\tsraRgnDestroy(xdamage_scheduled_mark_region);\n\t\t\t\txdamage_scheduled_mark_region = NULL;\n\t\t\t} else {\n\t\t\t\tmark_for_xdamage(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t\txdamage_scheduled_mark = 0.0;\n\t\t}\n\t} else {\n\t\tdestroy_xdamage_if_needed();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fixscreen",
          "args": [],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "check_fixscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3529-3596",
          "snippet": "void check_fixscreen(void) {\n\tdouble now = dnow();\n\tint didfull = 0, db = 0;\n\n\tif (!client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (screen_fixup_X > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_X) {\n\t\t\tif (db) rfbLog(\"doing screen_fixup_X\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t\t\n\t}\n\tif (screen_fixup_V > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_V) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_V\\n\");\n\t\t\t}\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (screen_fixup_C > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (last_copyrect_fix < last_copyrect &&\n\t\t    now > last_copyrect + screen_fixup_C) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_C\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (scaling && last_copyrect_fix < last_copyrect) {\n\t\tstatic double last = 0.0;\n\t\tdouble delay = 3.0;\n\t\tif (now > last + delay) {\n\t\t\tif (! didfull) {\n\t\t\t\tscale_and_mark_rect(0, 0, dpy_x, dpy_y, 1);\n\t\t\t\tif (db) rfbLog(\"doing scale screen_fixup\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (advertise_truecolor && advertise_truecolor_reset && indexed_color) {\n\t\t/* this will reset framebuffer to correct colors, if needed */\n\t\tstatic double dlast = 0.0;\n\t\tnow = dnow();\n\t\tif (now > last_client + 1.0 && now < last_client + 3.0 && now > dlast + 5.0) {\n\t\t\trfbLog(\"advertise truecolor reset framebuffer\\n\");\n\t\t\tdo_new_fb(1);\n\t\t\tdlast = dnow();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_fixscreen(void);",
            "void batch_push(int ncr, double delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_fixscreen(void);\nvoid batch_push(int ncr, double delay);\n\nvoid check_fixscreen(void) {\n\tdouble now = dnow();\n\tint didfull = 0, db = 0;\n\n\tif (!client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (screen_fixup_X > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_X) {\n\t\t\tif (db) rfbLog(\"doing screen_fixup_X\\n\");\n\t\t\tdo_copy_screen = 1;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t\t\n\t}\n\tif (screen_fixup_V > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (now > last + screen_fixup_V) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_V\\n\");\n\t\t\t}\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (screen_fixup_C > 0.0) {\n\t\tstatic double last = 0.0;\n\t\tif (last_copyrect_fix < last_copyrect &&\n\t\t    now > last_copyrect + screen_fixup_C) {\n\t\t\tif (! didfull) {\n\t\t\t\trefresh_screen(0);\n\t\t\t\tif (db) rfbLog(\"doing screen_fixup_C\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (scaling && last_copyrect_fix < last_copyrect) {\n\t\tstatic double last = 0.0;\n\t\tdouble delay = 3.0;\n\t\tif (now > last + delay) {\n\t\t\tif (! didfull) {\n\t\t\t\tscale_and_mark_rect(0, 0, dpy_x, dpy_y, 1);\n\t\t\t\tif (db) rfbLog(\"doing scale screen_fixup\\n\");\n\t\t\t}\n\t\t\tlast_copyrect_fix = now;\n\t\t\tlast = now;\n\t\t\tdidfull = 1;\n\t\t}\n\t}\n\tif (advertise_truecolor && advertise_truecolor_reset && indexed_color) {\n\t\t/* this will reset framebuffer to correct colors, if needed */\n\t\tstatic double dlast = 0.0;\n\t\tnow = dnow();\n\t\tif (now > last_client + 1.0 && now < last_client + 3.0 && now > dlast + 5.0) {\n\t\t\trfbLog(\"advertise truecolor reset framebuffer\\n\");\n\t\t\tdo_new_fb(1);\n\t\t\tdlast = dnow();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_padded_fb",
          "args": [],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "check_padded_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1118-1127",
          "snippet": "void check_padded_fb(void) {\n\tif (! fake_fb) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (time(NULL) > pad_geometry_time+1 && all_clients_initialized()) {\n\t\tremove_fake_fb();\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_padded_fb(void);",
            "static void remove_fake_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid check_padded_fb(void);\nstatic void remove_fake_fb(void);\n\nvoid check_padded_fb(void) {\n\tif (! fake_fb) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (time(NULL) > pad_geometry_time+1 && all_clients_initialized()) {\n\t\tremove_fake_fb();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_last_fb_update",
          "args": [],
          "line": 4544
        },
        "resolved": true,
        "details": {
          "function_name": "record_last_fb_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "4150-4196",
          "snippet": "static void record_last_fb_update(void) {\n\tstatic int rbs0 = -1;\n\tstatic time_t last_call = 0;\n\ttime_t now = time(NULL);\n\tint rbs = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (last_fb_bytes_sent == 0) {\n\t\tlast_fb_bytes_sent = now;\n\t\tlast_call = now;\n\t}\n\n\tif (now <= last_call + 1) {\n\t\t/* check every second or so */\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tlast_call = now;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n#if 0\n\t\trbs += cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\trbs += rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (rbs != rbs0) {\n\t\trbs0 = rbs;\n\t\tif (debug_tiles > 1) {\n\t\t\tfprintf(stderr, \"record_last_fb_update: %d %d\\n\",\n\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t}\n\t\tlast_fb_bytes_sent = now;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static void record_last_fb_update(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void record_last_fb_update(void);\n\nstatic void record_last_fb_update(void) {\n\tstatic int rbs0 = -1;\n\tstatic time_t last_call = 0;\n\ttime_t now = time(NULL);\n\tint rbs = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (last_fb_bytes_sent == 0) {\n\t\tlast_fb_bytes_sent = now;\n\t\tlast_call = now;\n\t}\n\n\tif (now <= last_call + 1) {\n\t\t/* check every second or so */\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tlast_call = now;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n#if 0\n\t\trbs += cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\trbs += rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (rbs != rbs0) {\n\t\trbs0 = rbs;\n\t\tif (debug_tiles > 1) {\n\t\t\tfprintf(stderr, \"record_last_fb_update: %d %d\\n\",\n\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t}\n\t\tlast_fb_bytes_sent = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_https",
          "args": [],
          "line": 4543
        },
        "resolved": true,
        "details": {
          "function_name": "check_https",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2746-2791",
          "snippet": "void check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4"
          ],
          "globals_used": [
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "void check_https(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid check_https(void);\n\nvoid check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_openssl",
          "args": [],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "check_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2689-2744",
          "snippet": "void check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "void check_openssl(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nvoid check_openssl(void);\n\nvoid check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stunnel",
          "args": [],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "check_stunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "63-88",
          "snippet": "void check_stunnel(void) {\n\tstatic time_t last_check = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_check + 3 >= now) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\t/* double check that stunnel is still running: */\n\n\tif (stunnel_pid > 0) {\n\t\tint status;\n#ifdef SSLCMDS\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\tif (kill(stunnel_pid, 0) != 0) {\n#ifdef SSLCMDS\n\t\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\t\trfbLog(\"stunnel subprocess %d died.\\n\", stunnel_pid); \n\t\t\tstunnel_pid = 0;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSLCMDS"
          ],
          "globals_used": [
            "void check_stunnel(void);",
            "static pid_t stunnel_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid check_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid check_stunnel(void) {\n\tstatic time_t last_check = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_check + 3 >= now) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\t/* double check that stunnel is still running: */\n\n\tif (stunnel_pid > 0) {\n\t\tint status;\n#ifdef SSLCMDS\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\tif (kill(stunnel_pid, 0) != 0) {\n#ifdef SSLCMDS\n\t\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\t\trfbLog(\"stunnel subprocess %d died.\\n\", stunnel_pid); \n\t\t\tstunnel_pid = 0;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_gui_inputs",
          "args": [],
          "line": 4540
        },
        "resolved": true,
        "details": {
          "function_name": "check_gui_inputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3734-3824",
          "snippet": "void check_gui_inputs(void) {\n\tint i, gnmax = 0, n = 0, nfds;\n\tint socks[ICON_MODE_SOCKS];\n\tfd_set fds;\n\tstruct timeval tv;\n\tchar buf[X11VNC_REMOTE_MAX+1];\n\tssize_t nbytes;\n\n\tif (unixpw_in_progress) return;\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] >= 0) {\n\t\t\tsocks[n++] = i;\n\t\t\tif (icon_mode_socks[i] > gnmax) {\n\t\t\t\tgnmax = icon_mode_socks[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! n) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tfor (i=0; i<n; i++) {\n\t\tFD_SET(icon_mode_socks[socks[i]], &fds);\n\t}\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(gnmax+1, &fds, NULL, NULL, &tv);\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i<n; i++) {\n\t\tint k, fd = icon_mode_socks[socks[i]];\n\t\tchar *p;\n\t\tchar **list;\n\t\tint lind;\n\n\t\tif (! FD_ISSET(fd, &fds)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (k=0; k<=X11VNC_REMOTE_MAX; k++) {\n\t\t\tbuf[k] = '\\0';\n\t\t}\n\t\tnbytes = read(fd, buf, X11VNC_REMOTE_MAX);\n\t\tif (nbytes <= 0) {\n\t\t\tclose(fd);\n\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist = (char **) calloc((strlen(buf)+2) * sizeof(char *), 1);\n\n\t\tlind = 0;\n\t\tp = strtok(buf, \"\\r\\n\");\n\t\twhile (p) {\n\t\t\tlist[lind++] = strdup(p);\n\t\t\tp = strtok(NULL, \"\\r\\n\");\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (strstr(p, \"cmd=\") == p ||\n\t\t\t    strstr(p, \"qry=\") == p) {\n\t\t\t\tchar *str = process_remote_cmd(p, 1);\n\t\t\t\tif (! str) {\n\t\t\t\t\tstr = strdup(\"\");\n\t\t\t\t}\n\t\t\t\tnbytes = write(fd, str, strlen(str));\n\t\t\t\twrite(fd, \"\\n\", 1);\n\t\t\t\tfree(str);\n\t\t\t\tif (nbytes < 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (p) free(p);\n\t\t}\n\t\tfree(list);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void check_gui_inputs(void);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid check_gui_inputs(void);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid check_gui_inputs(void) {\n\tint i, gnmax = 0, n = 0, nfds;\n\tint socks[ICON_MODE_SOCKS];\n\tfd_set fds;\n\tstruct timeval tv;\n\tchar buf[X11VNC_REMOTE_MAX+1];\n\tssize_t nbytes;\n\n\tif (unixpw_in_progress) return;\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] >= 0) {\n\t\t\tsocks[n++] = i;\n\t\t\tif (icon_mode_socks[i] > gnmax) {\n\t\t\t\tgnmax = icon_mode_socks[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! n) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tfor (i=0; i<n; i++) {\n\t\tFD_SET(icon_mode_socks[socks[i]], &fds);\n\t}\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(gnmax+1, &fds, NULL, NULL, &tv);\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i<n; i++) {\n\t\tint k, fd = icon_mode_socks[socks[i]];\n\t\tchar *p;\n\t\tchar **list;\n\t\tint lind;\n\n\t\tif (! FD_ISSET(fd, &fds)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (k=0; k<=X11VNC_REMOTE_MAX; k++) {\n\t\t\tbuf[k] = '\\0';\n\t\t}\n\t\tnbytes = read(fd, buf, X11VNC_REMOTE_MAX);\n\t\tif (nbytes <= 0) {\n\t\t\tclose(fd);\n\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist = (char **) calloc((strlen(buf)+2) * sizeof(char *), 1);\n\n\t\tlind = 0;\n\t\tp = strtok(buf, \"\\r\\n\");\n\t\twhile (p) {\n\t\t\tlist[lind++] = strdup(p);\n\t\t\tp = strtok(NULL, \"\\r\\n\");\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (strstr(p, \"cmd=\") == p ||\n\t\t\t    strstr(p, \"qry=\") == p) {\n\t\t\t\tchar *str = process_remote_cmd(p, 1);\n\t\t\t\tif (! str) {\n\t\t\t\t\tstr = strdup(\"\");\n\t\t\t\t}\n\t\t\t\tnbytes = write(fd, str, strlen(str));\n\t\t\t\twrite(fd, \"\\n\", 1);\n\t\t\t\tfree(str);\n\t\t\t\tif (nbytes < 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (p) free(p);\n\t\t}\n\t\tfree(list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_connect_inputs",
          "args": [],
          "line": 4539
        },
        "resolved": true,
        "details": {
          "function_name": "check_connect_inputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3706-3732",
          "snippet": "void check_connect_inputs(void) {\n\n\tif (unixpw_in_progress) return;\n\n\t/* flush any already set: */\n\tsend_client_connect();\n\n\t/* connect file: */\n\tif (client_connect_file != NULL) {\n\t\tcheck_connect_file(client_connect_file);\t\t\n\t}\n\tsend_client_connect();\n\n\t/* VNC_CONNECT property (vncconnect program) */\n\tif (vnc_connect && *vnc_connect_str != '\\0') {\n\t\tclient_connect = strdup(vnc_connect_str);\n\t\tvnc_connect_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n\n\t/* X11VNC_REMOTE property */\n\tif (vnc_connect && *x11vnc_remote_str != '\\0') {\n\t\tclient_connect = strdup(x11vnc_remote_str);\n\t\tx11vnc_remote_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char vnc_connect_str[VNC_CONNECT_MAX+1];",
            "char x11vnc_remote_str[X11VNC_REMOTE_MAX+1];",
            "void check_connect_inputs(void);",
            "static void check_connect_file(char *file);",
            "static void send_client_connect(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar vnc_connect_str[VNC_CONNECT_MAX+1];\nchar x11vnc_remote_str[X11VNC_REMOTE_MAX+1];\nvoid check_connect_inputs(void);\nstatic void check_connect_file(char *file);\nstatic void send_client_connect(void);\n\nvoid check_connect_inputs(void) {\n\n\tif (unixpw_in_progress) return;\n\n\t/* flush any already set: */\n\tsend_client_connect();\n\n\t/* connect file: */\n\tif (client_connect_file != NULL) {\n\t\tcheck_connect_file(client_connect_file);\t\t\n\t}\n\tsend_client_connect();\n\n\t/* VNC_CONNECT property (vncconnect program) */\n\tif (vnc_connect && *vnc_connect_str != '\\0') {\n\t\tclient_connect = strdup(vnc_connect_str);\n\t\tvnc_connect_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n\n\t/* X11VNC_REMOTE property */\n\tif (vnc_connect && *x11vnc_remote_str != '\\0') {\n\t\tclient_connect = strdup(x11vnc_remote_str);\n\t\tx11vnc_remote_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_keycode_state",
          "args": [],
          "line": 4538
        },
        "resolved": true,
        "details": {
          "function_name": "check_keycode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "950-975",
          "snippet": "void check_keycode_state(void) {\n\tstatic time_t last_check = 0;\n\tint delay = 10, noinput = 3;\n\ttime_t now = time(NULL);\n\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\t/*\n\t * periodically update our model of the keycode_state[]\n\t * by correlating with the Xserver.  wait for a pause in\n\t * keyboard input to be on the safe side.  the idea here\n\t * is to remove stale keycode state, not to be perfectly\n\t * in sync with the Xserver at every instant of time.\n\t */\n\tif (now > last_check + delay && now > last_keyboard_input + noinput) {\n\t\tX_LOCK;\n\t\tinit_track_keycode_state();\n\t\tX_UNLOCK;\n\t\tlast_check = now;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_keycode_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_keycode_state(void);\n\nvoid check_keycode_state(void) {\n\tstatic time_t last_check = 0;\n\tint delay = 10, noinput = 3;\n\ttime_t now = time(NULL);\n\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\t/*\n\t * periodically update our model of the keycode_state[]\n\t * by correlating with the Xserver.  wait for a pause in\n\t * keyboard input to be on the safe side.  the idea here\n\t * is to remove stale keycode state, not to be perfectly\n\t * in sync with the Xserver at every instant of time.\n\t */\n\tif (now > last_check + delay && now > last_keyboard_input + noinput) {\n\t\tX_LOCK;\n\t\tinit_track_keycode_state();\n\t\tX_UNLOCK;\n\t\tlast_check = now;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_filexfer",
          "args": [],
          "line": 4537
        },
        "resolved": true,
        "details": {
          "function_name": "check_filexfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "4109-4148",
          "snippet": "static void check_filexfer(void) {\n\tstatic time_t last_check = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint transferring = 0; \n\t\n\tif (time(NULL) <= last_check) {\n\t\treturn;\n\t}\n\n#if 0\n\tif (getenv(\"NOFT\")) {\n\t\treturn;\n\t}\n#endif\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->fileTransfer.receiving) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (cl->fileTransfer.sending) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (transferring) {\n\t\tdouble start = dnow();\n\t\twhile (dnow() < start + 0.5) {\n\t\t\trfbCFD(5000);\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t} else {\n\t\tlast_check = time(NULL);\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static void check_filexfer(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void check_filexfer(void);\n\nstatic void check_filexfer(void) {\n\tstatic time_t last_check = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint transferring = 0; \n\t\n\tif (time(NULL) <= last_check) {\n\t\treturn;\n\t}\n\n#if 0\n\tif (getenv(\"NOFT\")) {\n\t\treturn;\n\t}\n#endif\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->fileTransfer.receiving) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (cl->fileTransfer.sending) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (transferring) {\n\t\tdouble start = dnow();\n\t\twhile (dnow() < start + 0.5) {\n\t\t\trfbCFD(5000);\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t} else {\n\t\tlast_check = time(NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pm",
          "args": [],
          "line": 4536
        },
        "resolved": true,
        "details": {
          "function_name": "check_pm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
          "lines": "51-65",
          "snippet": "void check_pm(void) {\n\tstatic int skip = -1;\n\tif (skip < 0) {\n\t\tskip = 0;\n\t\tif (getenv(\"X11VNC_NO_CHECK_PM\")) {\n\t\t\tskip = 1;\n\t\t}\n\t}\n\tif (skip) {\n\t\treturn;\n\t}\n\tcheck_fbpm();\n\tcheck_dpms();\n\t/* someday dpms activities? */\n}",
          "includes": [
            "#include <X11/extensions/dpms.h>",
            "#include <X11/extensions/fbpm.h>",
            "#include <X11/Xmd.h>",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_pm(void);",
            "static void check_fbpm(void);",
            "static void check_dpms(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid check_pm(void);\nstatic void check_fbpm(void);\nstatic void check_dpms(void);\n\nvoid check_pm(void) {\n\tstatic int skip = -1;\n\tif (skip < 0) {\n\t\tskip = 0;\n\t\tif (getenv(\"X11VNC_NO_CHECK_PM\")) {\n\t\t\tskip = 1;\n\t\t}\n\t}\n\tif (skip) {\n\t\treturn;\n\t}\n\tcheck_fbpm();\n\tcheck_dpms();\n\t/* someday dpms activities? */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_autorepeat",
          "args": [],
          "line": 4535
        },
        "resolved": true,
        "details": {
          "function_name": "check_autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1067-1189",
          "snippet": "void check_autorepeat(void) {\n\tstatic time_t last_check = 0;\n\tstatic int idle_timeout = -300, idle_reset = 0;\n\ttime_t now = time(NULL);\n\tint autorepeat_is_on, autorepeat_initially_on;\n\n\tif (! no_autorepeat || ! client_count) {\n\t\treturn;\n\t}\n\tif (now <= last_check + 1) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tif (idle_timeout < 0) {\n\t\tif (getenv(\"X11VNC_IDLE_TIMEOUT\")) {\n\t\t\tidle_timeout = atoi(getenv(\"X11VNC_IDLE_TIMEOUT\"));\n\t\t}\n\t\tif (idle_timeout < 0) {\n\t\t\tidle_timeout = -idle_timeout;\n\t\t}\n\t}\n\n\tlast_check = now;\n\n\tautorepeat_is_on = get_autorepeat_state();\n\tautorepeat_initially_on = get_initial_autorepeat_state();\n\n\tif (view_only) {\n\t\tif (! autorepeat_is_on) {\n\t\t\tautorepeat(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (now > last_keyboard_input + idle_timeout) {\n\t\t/* autorepeat should be on when idle */\n\t\tif (! autorepeat_is_on && autorepeat_initially_on) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"idle keyboard:   turning X autorepeat\"\n\t\t\t\t    \" back on.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(1, 1);\n\t\t\tidle_reset = 1;\n\t\t}\n\t} else {\n\t\tif (idle_reset) {\n\t\t\tint i, state[256], didmsg = 0, pressed = 0;\n\t\t\tint mwt = 600, mmax = 20;\n\t\t\tstatic int msgcnt = 0;\n\t\t\tstatic double lastmsg = 0.0;\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t\tif (use_threads) {X_LOCK;}\n\t\t\tget_keystate(state);\n\t\t\tif (use_threads) {X_UNLOCK;}\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tif (state[i] != 0) {\n\t\t\t\t\t/* better wait until all keys are up  */\n\t\t\t\t\tpressed++;\n\t\t\t\t\tif (msgcnt < mmax || dnow() > lastmsg + mwt) {\n\t\t\t\t\t\tchar *str = \"unset\";\n#if !NO_X11\n\t\t\t\t\t\tif (use_threads) {X_LOCK;}\n\t\t\t\t\t\tstr = XKeysymToString(XKeycodeToKeysym_wr(dpy, i, 0));\n\t\t\t\t\t\tif (use_threads) {X_UNLOCK;}\n#endif\n\t\t\t\t\t\tstr = str ? str : \"nosymbol\";\n\t\t\t\t\t\tdidmsg++;\n\t\t\t\t\t\trfbLog(\"active keyboard: waiting until \"\n\t\t\t\t\t\t    \"all keys are up. key_down=%d %s.  \"\n\t\t\t\t\t\t    \"If the key is inaccessible via keyboard, \"\n\t\t\t\t\t\t    \"consider 'x11vnc -R clear_all'\\n\", i, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (didmsg > 0) {\n\t\t\t\tmsgcnt++;\n\t\t\t\tif (msgcnt == mmax) {\n\t\t\t\t\trfbLog(\"active keyboard: last such \"\n\t\t\t\t\t    \"message for %d secs.\\n\", mwt);\n\t\t\t\t}\n\t\t\t\tlastmsg = dnow();\n\t\t\t}\n\t\t\tif (pressed > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (idle_reset) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"active keyboard: turning X autorepeat\"\n\t\t\t\t    \" off.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(0, 1);\n\t\t\tidle_reset = 0;\n\n\t\t} else if (no_repeat_countdown && autorepeat_is_on) {\n\t\t\tint n = no_repeat_countdown - 1;\n\t\t\tif (n >= 0) {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!! (%d resets left)\\n\", n);\n\t\t\t} else {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!!\\n\");\n\t\t\t}\n\t\t\tif (no_repeat_countdown > 0) {\n\t\t\t\tno_repeat_countdown--;\n\t\t\t}\n\t\t\tautorepeat(1, 0);\n\t\t\tautorepeat(0, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_autorepeat(void);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_autorepeat(void);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nvoid check_autorepeat(void) {\n\tstatic time_t last_check = 0;\n\tstatic int idle_timeout = -300, idle_reset = 0;\n\ttime_t now = time(NULL);\n\tint autorepeat_is_on, autorepeat_initially_on;\n\n\tif (! no_autorepeat || ! client_count) {\n\t\treturn;\n\t}\n\tif (now <= last_check + 1) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tif (idle_timeout < 0) {\n\t\tif (getenv(\"X11VNC_IDLE_TIMEOUT\")) {\n\t\t\tidle_timeout = atoi(getenv(\"X11VNC_IDLE_TIMEOUT\"));\n\t\t}\n\t\tif (idle_timeout < 0) {\n\t\t\tidle_timeout = -idle_timeout;\n\t\t}\n\t}\n\n\tlast_check = now;\n\n\tautorepeat_is_on = get_autorepeat_state();\n\tautorepeat_initially_on = get_initial_autorepeat_state();\n\n\tif (view_only) {\n\t\tif (! autorepeat_is_on) {\n\t\t\tautorepeat(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (now > last_keyboard_input + idle_timeout) {\n\t\t/* autorepeat should be on when idle */\n\t\tif (! autorepeat_is_on && autorepeat_initially_on) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"idle keyboard:   turning X autorepeat\"\n\t\t\t\t    \" back on.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(1, 1);\n\t\t\tidle_reset = 1;\n\t\t}\n\t} else {\n\t\tif (idle_reset) {\n\t\t\tint i, state[256], didmsg = 0, pressed = 0;\n\t\t\tint mwt = 600, mmax = 20;\n\t\t\tstatic int msgcnt = 0;\n\t\t\tstatic double lastmsg = 0.0;\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t\tif (use_threads) {X_LOCK;}\n\t\t\tget_keystate(state);\n\t\t\tif (use_threads) {X_UNLOCK;}\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tif (state[i] != 0) {\n\t\t\t\t\t/* better wait until all keys are up  */\n\t\t\t\t\tpressed++;\n\t\t\t\t\tif (msgcnt < mmax || dnow() > lastmsg + mwt) {\n\t\t\t\t\t\tchar *str = \"unset\";\n#if !NO_X11\n\t\t\t\t\t\tif (use_threads) {X_LOCK;}\n\t\t\t\t\t\tstr = XKeysymToString(XKeycodeToKeysym_wr(dpy, i, 0));\n\t\t\t\t\t\tif (use_threads) {X_UNLOCK;}\n#endif\n\t\t\t\t\t\tstr = str ? str : \"nosymbol\";\n\t\t\t\t\t\tdidmsg++;\n\t\t\t\t\t\trfbLog(\"active keyboard: waiting until \"\n\t\t\t\t\t\t    \"all keys are up. key_down=%d %s.  \"\n\t\t\t\t\t\t    \"If the key is inaccessible via keyboard, \"\n\t\t\t\t\t\t    \"consider 'x11vnc -R clear_all'\\n\", i, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (didmsg > 0) {\n\t\t\t\tmsgcnt++;\n\t\t\t\tif (msgcnt == mmax) {\n\t\t\t\t\trfbLog(\"active keyboard: last such \"\n\t\t\t\t\t    \"message for %d secs.\\n\", mwt);\n\t\t\t\t}\n\t\t\t\tlastmsg = dnow();\n\t\t\t}\n\t\t\tif (pressed > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (idle_reset) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"active keyboard: turning X autorepeat\"\n\t\t\t\t    \" off.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(0, 1);\n\t\t\tidle_reset = 0;\n\n\t\t} else if (no_repeat_countdown && autorepeat_is_on) {\n\t\t\tint n = no_repeat_countdown - 1;\n\t\t\tif (n >= 0) {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!! (%d resets left)\\n\", n);\n\t\t\t} else {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!!\\n\");\n\t\t\t}\n\t\t\tif (no_repeat_countdown > 0) {\n\t\t\t\tno_repeat_countdown--;\n\t\t\t}\n\t\t\tautorepeat(1, 0);\n\t\t\tautorepeat(0, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "0",
            "0"
          ],
          "line": 4533
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_new_clients",
          "args": [],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "4374-4495",
          "snippet": "void check_new_clients(void) {\n\tstatic int last_count = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint i, send_info = 0;\n\tint run_after_accept = 0;\n\n\tif (unixpw_in_progress) {\n\t\tstatic double lping = 0.0;\n\t\tif (lping < dnow() + 5) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlping = dnow();\n\t\t}\n\t\tif (unixpw_client && unixpw_client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tunixpw_client->viewOnly = FALSE;\n\t\t}\n\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\tunixpw_deny();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (grab_always) {\n\t\t;\n\t} else if (grab_kbd || grab_ptr) {\n\t\tstatic double last_force = 0.0;\n\t\tif (client_count != last_count || dnow() > last_force + 0.25) {\n\t\t\tint q = (client_count == last_count);\n\t\t\tlast_force = dnow();\n\t\t\tX_LOCK;\n\t\t\tif (client_count) {\n\t\t\t\tadjust_grabs(1, q);\n\t\t\t} else {\n\t\t\t\tadjust_grabs(0, q);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n\t\n\tif (last_count == -1) {\n\t\tlast_count = 0;\n\t} else if (client_count == last_count) {\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\treturn;\n\t}\n\n\tif (client_count > last_count) {\n\t\tif (afteraccept_cmd != NULL && afteraccept_cmd[0] != '\\0') {\n\t\t\trun_after_accept = 1;\n\t\t}\n\t}\n\n\tlast_count = client_count;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tif (! client_count) {\n\t\tsend_client_info(\"clients:none\");\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *s;\n\n\t\tclient_set_net(cl);\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cd->login_viewonly < 0) {\n\t\t\t/* this is a general trigger to initialize things */\n\t\t\tif (cl->viewOnly) {\n\t\t\t\tcd->login_viewonly = 1;\n\t\t\t\ts = allowed_input_view_only;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd->login_viewonly = 0;\n\t\t\t\ts = allowed_input_normal;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (run_after_accept) {\n\t\t\t\trun_user_command(afteraccept_cmd, cl,\n\t\t\t\t    \"afteraccept\", NULL, 0, NULL);\n\t\t\t}\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (icon_mode_fh) {\n\t\tsend_info++;\n\t}\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (send_info || icon_mode_socks[i] >= 0) {\n\t\t\tsend_info++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (send_info) {\n\t\tchar *str, *s = list_clients();\n\t\tstr = (char *) malloc(strlen(\"clients:\") + strlen(s) + 1);\n\t\tsprintf(str, \"clients:%s\", s);\n\t\tsend_client_info(str);\n\t\tfree(str);\n\t\tfree(s);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);",
            "char *list_clients(void);",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "void check_new_clients(void);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nvoid check_new_clients(void);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid check_new_clients(void) {\n\tstatic int last_count = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint i, send_info = 0;\n\tint run_after_accept = 0;\n\n\tif (unixpw_in_progress) {\n\t\tstatic double lping = 0.0;\n\t\tif (lping < dnow() + 5) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlping = dnow();\n\t\t}\n\t\tif (unixpw_client && unixpw_client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tunixpw_client->viewOnly = FALSE;\n\t\t}\n\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\tunixpw_deny();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (grab_always) {\n\t\t;\n\t} else if (grab_kbd || grab_ptr) {\n\t\tstatic double last_force = 0.0;\n\t\tif (client_count != last_count || dnow() > last_force + 0.25) {\n\t\t\tint q = (client_count == last_count);\n\t\t\tlast_force = dnow();\n\t\t\tX_LOCK;\n\t\t\tif (client_count) {\n\t\t\t\tadjust_grabs(1, q);\n\t\t\t} else {\n\t\t\t\tadjust_grabs(0, q);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n\t\n\tif (last_count == -1) {\n\t\tlast_count = 0;\n\t} else if (client_count == last_count) {\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\treturn;\n\t}\n\n\tif (client_count > last_count) {\n\t\tif (afteraccept_cmd != NULL && afteraccept_cmd[0] != '\\0') {\n\t\t\trun_after_accept = 1;\n\t\t}\n\t}\n\n\tlast_count = client_count;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tif (! client_count) {\n\t\tsend_client_info(\"clients:none\");\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *s;\n\n\t\tclient_set_net(cl);\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cd->login_viewonly < 0) {\n\t\t\t/* this is a general trigger to initialize things */\n\t\t\tif (cl->viewOnly) {\n\t\t\t\tcd->login_viewonly = 1;\n\t\t\t\ts = allowed_input_view_only;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd->login_viewonly = 0;\n\t\t\t\ts = allowed_input_normal;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (run_after_accept) {\n\t\t\t\trun_user_command(afteraccept_cmd, cl,\n\t\t\t\t    \"afteraccept\", NULL, 0, NULL);\n\t\t\t}\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (icon_mode_fh) {\n\t\tsend_info++;\n\t}\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (send_info || icon_mode_socks[i] >= 0) {\n\t\t\tsend_info++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (send_info) {\n\t\tchar *str, *s = list_clients();\n\t\tstr = (char *) malloc(strlen(\"clients:\") + strlen(s) + 1);\n\t\tsprintf(str, \"clients:%s\", s);\n\t\tsend_client_info(str);\n\t\tfree(str);\n\t\tfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_screen",
          "args": [],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "copy_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2412-2455",
          "snippet": "int copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "int copy_screen(void);",
            "static void blackout_regions(void);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_screen(void);\nstatic void blackout_regions(void);\nstatic int fs_factor = 0;\n\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_wireframe",
          "args": [],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "check_wireframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "4336-5102",
          "snippet": "int check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "void fb_push(void);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int near_wm_edge(int x, int y, int w, int h, int px, int py);",
            "int near_scrollbar_edge(int x, int y, int w, int h, int px, int py);",
            "int check_wireframe(void);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "static void parse_wireframe_str(char *wf);",
            "static void destroy_str_list(char **list);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static int scrollability(Window win, int set);",
            "static int wireframe_mod_state();",
            "static void check_user_input2(double dt);",
            "static double wireframe_frac;",
            "static double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;",
            "void batch_push(int ncr, double delay);",
            "static int NPP_nreg = 0;",
            "static Window NPP_nwin = None;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DB_SET \\\n\tint db  = 0; \\\n\tint db2 = 0; \\\n\tif (debug_wireframe == 1) { \\\n\t\tdb = 1; \\\n\t} \\\n\tif (debug_wireframe == 2) { \\\n\t\tdb2 = 1; \\\n\t} \\\n\tif (debug_wireframe == 3) { \\\n\t\tdb = 1; \\\n\t\tdb2 = 1; \\\n\t}\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nvoid fb_push(void);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint near_wm_edge(int x, int y, int w, int h, int px, int py);\nint near_scrollbar_edge(int x, int y, int w, int h, int px, int py);\nint check_wireframe(void);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nstatic void parse_wireframe_str(char *wf);\nstatic void destroy_str_list(char **list);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\nstatic int wireframe_mod_state();\nstatic void check_user_input2(double dt);\nstatic double wireframe_frac;\nstatic double wireframe_t1, wireframe_t2, wireframe_t3, wireframe_t4;\nvoid batch_push(int ncr, double delay);\nstatic int NPP_nreg = 0;\nstatic Window NPP_nwin = None;\nint clipped(int idx);\n\nint check_wireframe(void) {\n\tWindow frame = None, orig_frame = None;\n\tXWindowAttributes attr;\n\tint dx, dy;\n\n\tint orig_px, orig_py, orig_x, orig_y, orig_w, orig_h;\n\tint px, py, x, y, w, h;\n\tint box_x, box_y, box_w, box_h;\n\tint orig_cursor_x, orig_cursor_y, g, gd;\n\tint already_down = 0, win_gone = 0, win_unmapped = 0;\n\tdouble spin = 0.0, tm, last_ptr = 0.0, last_draw;\n\n\tint frame_changed = 0, drew_box = 0, got_2nd_pointer = 0;\n\tint try_copyrect_drag = 1, do_copyrect_drag = -1;\n\tint now_x = 0, now_y = 0, nidx = -1;\n\tdouble copyrect_drag_delay = -1.0;\n\tint try_batch = 1;\t/* XXX Y */\n\tint mac_skip = 0;\n\n\tint special_t1 = 0, break_reason = 0, last_draw_cnt = 0, gpi = 0;\n\tstatic double first_dt_ave = 0.0;\n\tstatic int first_dt_cnt = 0;\n\tstatic time_t last_save_stacklist = 0;\n\tint bdown0, bdown, gotui, cnt = 0;\n\t\n\t/* heuristics: */\n\tdouble first_event_spin   = wireframe_t1;\n\tdouble frame_changed_spin = wireframe_t2;\n\tdouble max_spin = wireframe_t3;\n\tdouble min_draw = wireframe_t4;\n\tint try_it = 0;\n\tDB_SET\n\n\tif (unixpw_in_progress) return 0;\n\tif (copyrect_drag_delay) {}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\t;\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\tif (subwin) {\n\t\treturn 0;\t/* don't even bother for -id case */\n\t}\n\nif (db > 1 && button_mask) fprintf(stderr, \"check_wireframe: bm: %d  gpi: %d\\n\", button_mask, got_pointer_input);\n\n\tbdown0 = 0;\n\tif (button_mask) {\n\t\tbdown0 = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tbdown0 = 2;\n\t}\n\tif (! bdown0) {\n\t\treturn 0;\t/* no button pressed down */\n\t}\n\n\tgotui = 0;\n\tif (got_pointer_input) {\n\t\tgotui = 1;\n\t} else if (wireframe_local && display_button_mask) {\n\t\tgotui = 2;\n\t}\n\tif (!use_threads && !gotui) {\n\t\treturn 0;\t/* need ptr input, e.g. button down, motion */\n\t}\n\nif (db > 1) fprintf(stderr, \"check_wireframe: %d\\n\", db);\n\nif (db) fprintf(stderr, \"\\n*** button down!!  x: %d  y: %d\\n\", cursor_x, cursor_y);\n\n\t/*\n\t * Query where the pointer is and which child of the root\n\t * window.  We will assume this is the frame the window manager\n\t * makes when it reparents the toplevel window.\n\t */\n\tX_LOCK;\n\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL)) {\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-1: 0x%lx\\n\", frame);\n\t\tX_UNLOCK;\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\tX_UNLOCK;\n\n\tlast_get_wm_frame_time = dnow();\n\tlast_get_wm_frame = frame;\n\nif (db) fprintf(stderr, \"a: %d  wf: %.3f  A: %d  origfrm: 0x%lx\\n\", w*h, wireframe_frac, (dpy_x*dpy_y), frame);\n\n\t/*\n\t * apply the percentage size criterion (allow opaque moves for\n\t * small windows)\n\t */\n\tif ((double) w*h < wireframe_frac * (dpy_x * dpy_y)) {\nif (db) fprintf(stderr, \"small window %.3f\\n\", ((double) w*h)/(dpy_x * dpy_y));\n\t\treturn 0;\n\t}\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\n\n\t/*\n\t * see if the pointer is within range of the assumed wm frame\n\t * decorations on the edge of the window.\n\t */\n\n\ttry_it = near_wm_edge(x, y, w, h, px, py);\n\n\t/* Often Alt+ButtonDown starts a window move: */\n\tif (! try_it && wireframe_mod_state()) {\n\t\ttry_it = 1;\n\t}\n\tif (try_it && clipshift) {\n\t\tsraRegionPtr r1, r2;\n\t\tint xc = off_x + coff_x;\n\t\tint yc = off_y + coff_y;\n\t\tr1 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\tr2 = sraRgnCreateRect(xc, yc, xc+dpy_x, yc+dpy_y);\n\t\tif (!sraRgnAnd(r1, r2)) {\nif (db) fprintf(stderr, \"OUTSIDE CLIPSHIFT\\n\");\n\t\t\ttry_it = 0;\n\t\t}\n\t\tsraRgnDestroy(r1);\n\t\tsraRgnDestroy(r2);\n\t}\n\tif (! try_it) {\nif (db) fprintf(stderr, \"INTERIOR\\n\");\n#ifdef MACOSX\n\t\tcheck_macosx_click_frame();\n#endif\n\t\treturn 0;\n\t}\n\n\twireframe_in_progress = 1;\n\n\tif (button_mask_prev) {\n\t\talready_down = 1;\n\t}\n\t\n\tif (! wireframe_str || !strcmp(wireframe_str, WIREFRAME_PARMS)) {\n\t\tint link, latency, netrate;\n\t\tstatic int didmsg = 0;\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP || link == LR_BROADBAND) {\n\t\t\t/* slow link, e.g. dialup, increase timeouts: */\n\t\t\tfirst_event_spin   *= 2.0;\n\t\t\tframe_changed_spin *= 2.0;\n\t\t\tmax_spin *= 2.0;\n\t\t\tmin_draw *= 1.5;\n\t\t\tif (link == LR_DIALUP) {\n\t\t\t\tmax_spin *= 1.2;\n\t\t\t\tmin_draw *= 1.7;\n\t\t\t}\n\t\t\tif (! didmsg) {\n\t\t\t\trfbLog(\"increased wireframe timeouts for \"\n\t\t\t\t    \"slow network connection.\\n\");\n\t\t\t\trfbLog(\"netrate: %d KB/sec, latency: %d ms\\n\",\n\t\t\t\t    netrate, latency);\n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * pointer() should have snapped the stacking list for us, if\n\t * not, do it now (if the XFakeButtonEvent has been flushed by\n\t * now the stacking order may be incorrect).\n\t */\n\tif (strcmp(wireframe_copyrect, \"never\")) {\n\t\tif (already_down) {\n\t\t\tdouble age = 0.0;\n\t\t\t/*\n\t\t\t * see if we can reuse the stack list (pause\n\t\t\t * with button down)\n\t\t\t */\n\t\t\tif (stack_list_num) {\n\t\t\t\tint k, got_me = 0;\n\t\t\t\tfor (k = stack_list_num -1; k >=0; k--) {\n\t\t\t\t\tif (frame == stack_list[k].win) {\n\t\t\t\t\t\tgot_me = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got_me) {\n\t\t\t\t\tage = 1.0;\n\t\t\t\t}\n\t\t\t\tsnapshot_stack_list(0, age);\n\t\t\t}\n\t\t}\n\t\tif (! stack_list_num) {\n\t\t\tsnapshot_stack_list(0, 0.0);\n\t\t}\n\t}\n\n\n\t/* store initial parameters, we look for changes in them */\n\torig_frame = frame;\n\torig_px = px;\t\t/* pointer position */\n\torig_py = py;\n\torig_x = x;\t\t/* frame position */\n\torig_y = y;\n\torig_w = w;\t\t/* frame size */\n\torig_h = h;\n\n\torig_cursor_x = cursor_x;\n\torig_cursor_y = cursor_y;\n\n\t/* this is the box frame we would draw */\n\tbox_x = x;\n\tbox_y = y; \n\tbox_w = w;\n\tbox_h = h; \n\n\tdtime0(&tm);\n\n\tlast_draw = spin;\n\n\t/* -threads support for check_wireframe() is rough... crash? */\n\tif (use_threads) {\n\t\t/* purge any stored up pointer events: */\n\t\tpointer_event(-1, 0, 0, NULL);\n\t}\n\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\ttry_batch = 0;\n\t}\n\tif (rotating) {\n\t\ttry_batch = 0;\n\t}\n\tif (use_threads && ncache > 0 && ncache_copyrect) {\n\t\ttry_batch = 0;\n\t}\n\n\tg = got_pointer_input;\n\tgd = got_local_pointer_input;\n\n\twhile (1) {\n\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\t/* try to induce/waitfor some more user input */\n\t\tif (use_threads) {\n\t\t\tusleep(1000);\n\t\t} else if (drew_box && do_copyrect_drag != 1) {\n\t\t\trfbPE(1000);\n\t\t} else {\n\t\t\trfbCFD(1000);\n\t\t}\n\t\tif (bdown0 == 2) {\n\t\t\t/*\n\t\t\t * This is to just update display_button_mask\n\t\t\t * which will also update got_local_pointer_input.\n\t\t\t */\n\t\t\tcheck_x11_pointer();\n#if 0\n\t\t\t/* what was this for? */\n\t\t\tWindow frame;\n\t\t\tint px, py, x, y, w, h;\n#ifdef MACOSX\n\t\t\tif (macosx_console) {\n\t\t\t\tmacosx_get_cursor_pos(&x, &y);\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\tget_wm_frame_pos(&px, &py, &x, &y, &w, &h, &frame, NULL);\n#endif\n\t\t}\n\n\t\tcnt++;\n\t\tspin += dtime(&tm);\n\nif (0) fprintf(stderr, \"wf-spin: %.3f\\n\", spin);\n\n\t\t/* check for any timeouts: */\n\t\tif (frame_changed) {\n\t\t\tdouble delay;\n\t\t\t/* max time we play this game: */\n\t\t\tif (spin > max_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-MAX: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* watch for pointer events slowing down: */\n\t\t\tif (special_t1) {\n\t\t\t\tdelay = max_spin;\n\t\t\t} else {\n\t\t\t\tdelay = 2.0* frame_changed_spin;\n\t\t\t\tif (spin > 3.0 * frame_changed_spin) {\n\t\t\t\t\tdelay = 1.5 * delay;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spin > last_ptr + delay) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOT-FAST: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (got_2nd_pointer) {\n\t\t\t/*\n\t\t\t * pointer is moving, max time we wait for wm\n\t\t\t * move or resize to be detected\n\t\t\t */\n\t\t\tif (spin > frame_changed_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NOFRAME-SPIN: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* max time we wait for any pointer input */\n\t\t\tif (spin > first_event_spin) {\nif (db || db2) fprintf(stderr, \" SPIN-OUT-NO2ND_PTR: %.3f\\n\", spin);\n\t\t\t\tbreak_reason = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgpi = 0;\n\t\t/* see if some pointer input occurred: */\n\t\tif (got_pointer_input > g ||\n\t\t    (wireframe_local && (got_local_pointer_input > gd))) {\n\nif (db) fprintf(stderr, \"  ++pointer event!! [%02d]  dt: %.3f  x: %d  y: %d  mask: %d\\n\",\n    got_2nd_pointer+1, spin, cursor_x, cursor_y, button_mask);\t\n\n\t\t\tg = got_pointer_input;\n\t\t\tgd = got_local_pointer_input;\n\t\t\tgpi = 1;\n\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\n\t\t\t/* periodically try to let the wm get moving: */\n\t\t\tif (!frame_changed && got_2nd_pointer % 4 == 0) {\n\t\t\t\tif (got_2nd_pointer == 0) {\n\t\t\t\t\tusleep(50 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(25 * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_2nd_pointer++;\n\t\t\tlast_ptr = spin;\n\n\t\t\t/*\n\t\t\t * see where the pointer currently is.  It may\n\t\t\t * not be our starting frame (i.e. mouse now\n\t\t\t * outside of the moving window).\n\t\t\t */\n\t\t\tframe = 0x0;\n\t\t\tX_LOCK;\n\n\t\t\tif (! get_wm_frame_pos(&px, &py, &x, &y, &w, &h,\n\t\t\t    &frame, NULL)) {\n\t\t\t\tframe = 0x0;\nif (db) fprintf(stderr, \"NO get_wm_frame_pos-2: 0x%lx\\n\", frame);\n\t\t\t}\n\n\t\t\tif (frame != orig_frame) {\n\t\t\t\t/* see if our original frame is still there */\n\t\t\t\tif (!valid_window(orig_frame, &attr, 1)) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame went away! */\n\t\t\t\t\twin_gone = 1;\nif (db) fprintf(stderr, \"FRAME-GONE: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attr.map_state == IsUnmapped) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t/* our window frame is now unmapped! */\n\t\t\t\t\twin_unmapped = 1;\nif (db) fprintf(stderr, \"FRAME-UNMAPPED: 0x%lx\\n\", orig_frame);\n\t\t\t\t\tbreak_reason = 5;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\nif (db) fprintf(stderr, \"OUT-OF-FRAME: old: x: %d  y: %d  px: %d py: %d 0x%lx\\n\", x, y, px, py, frame);\n\n\t\t\t\t/* new parameters for our frame */\n\t\t\t\tx = attr.x;\t/* n.b. rootwin is parent */\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width;\n\t\t\t\th = attr.height;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\nif (db) fprintf(stderr, \"  frame: x: %d  y: %d  w: %d  h: %d  px: %d  py: %d  fr: 0x%lx\\n\", x, y, w, h, px, py, frame);\t\nif (db) fprintf(stderr, \"        MO,PT,FR: %d/%d %d/%d %d/%d\\n\", cursor_x - orig_cursor_x, cursor_y - orig_cursor_y, px - orig_px, py - orig_py, x - orig_x, y - orig_y);\t\n\n\t\t\tif (frame_changed && frame != orig_frame) {\nif (db) fprintf(stderr, \"CHANGED and window switch: 0x%lx\\n\", frame);\n\t\t\t}\n\t\t\tif (frame_changed && px - orig_px != x - orig_x) {\nif (db) fprintf(stderr, \"MOVED and diff DX\\n\");\n\t\t\t}\n\t\t\tif (frame_changed && py - orig_py != y - orig_y) {\nif (db) fprintf(stderr, \"MOVED and diff DY\\n\");\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been resized: */\n\t\t\tif (!frame_changed && (w != orig_w || h != orig_h)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 2;\n\nif (db) fprintf(stderr, \"WIN RESIZE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\n\t\t\t/* check and see if our frame has been moved: */\n\t\t\tif (!frame_changed && (x != orig_x || y != orig_y)) {\n\t\t\t\tint n;\n\t\t\t\tif (!already_down) {\n\t\t\t\t\tfirst_dt_ave += spin;\n\t\t\t\t\tfirst_dt_cnt++;\n\t\t\t\t}\n\t\t\t\tn = first_dt_cnt ? first_dt_cnt : 1;\n\t\t\t\tframe_changed = 1;\nif (db) fprintf(stderr, \"FRAME MOVE  1st-dt: %.3f\\n\", first_dt_ave/n);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * see if it is time to draw any or a new wireframe box\n\t\t */\n\n\t\tif (frame_changed) {\n\t\t\tint drawit = 0;\n\t\t\tif (x != box_x || y != box_y) {\n\t\t\t\t/* moved since last */\nif (0) fprintf(stderr, \"DRAW1 %d %d\\n\", x - box_x, y - box_y);\n\t\t\t\tdrawit = 1;\n\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t/* resize since last */\n\t\t\t\tdrawit = 1;\n\t\t\t}\n\t\t\tif (drawit) {\n\t\t\t\tint doit = 0;\n\t\t\t\t/*\n\t\t\t\t * check time (to avoid too much\n\t\t\t\t * animations on slow machines\n\t\t\t\t * or links).\n\t\t\t\t */\n\t\t\t\tif (gpi) {\n\t\t\t\t\tif (spin > last_draw + min_draw || ! drew_box) {\n\t\t\t\t\t\tdoit = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (macosx_console && doit && !mac_skip) {\n\t\t\t\t\t\tif (x != box_x && y != box_y && w != box_w && h != box_h) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t} else if (!button_mask) {\n\t\t\t\t\t\t\tdoit = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmac_skip++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (drew_box && cnt > last_draw_cnt) \t{\n\t\t\t\t\t\tdoit = 1;\nif (0) fprintf(stderr, \"*** NO GPI DRAW_BOX\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\tif (doit) {\n\t\t\t\t\tif (try_copyrect_drag && ncache > 0) {\n\t\t\t\t\t\tif (!ncache_copyrect) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (w != box_w || h != box_h) {\n\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t} else if (do_copyrect_drag < 0) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = set_copyrect_drag(idx, fr, try_batch);\n\t\t\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\t\t\tmin_draw *= 0.66;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnidx = idx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnow_x = orig_x;\n\t\t\t\t\t\t\tnow_y = orig_y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (do_copyrect_drag) {\n\t\t\t\t\t\t\tif (orig_w != w || orig_h != h) {\n\t\t\t\t\t\t\t\tdo_copyrect_drag = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_copyrect_drag <= 0) {\n\t\t\t\t\t\tif (ncache <= 0) {\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t} else if (!drew_box && ncache_wf_raises) {\n\t\t\t\t\t\t\tWindow fr = orig_frame;\n\t\t\t\t\t\t\tint idx = lookup_win_index(fr);\n\t\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\t\tfr = frame;\n\t\t\t\t\t\t\t\tidx = lookup_win_index(fr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tcheck_copyrect_raise(idx, fr, try_batch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdraw_box(x, y, w, h, 0);\n\t\t\t\t\t\tfb_push(); /* XXX Y */\n\t\t\t\t\t\trfbPE(1000);\n\t\t\t\t\t} else {\n#ifndef NO_NCACHE\n\t\t\t\t\t\tint tb = use_threads ? 0 : try_batch;\n\t\t\t\t\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t\t\t\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h,\n\t\t\t\t\t\t    copyrect_drag_delay);\n\t\t\t\t\t\tnow_x = x;\n\t\t\t\t\t\tnow_y = y;\n\t\t\t\t\t\tif (copyrect_drag_delay == -1.0) {\n\t\t\t\t\t\t\tcopyrect_drag_delay = 0.04;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tdrew_box = 1;\n\t\t\t\t\tlast_wireframe = dnow();\n\n\t\t\t\t\tlast_draw = spin;\n\t\t\t\t\tlast_draw_cnt = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox_x = x;\n\t\t\tbox_y = y;\n\t\t\tbox_w = w;\n\t\t\tbox_h = h;\n\t\t}\n\n\t\t/* \n\t\t * Now (not earlier) check if the button has come back up.\n\t\t * we check here to get a better location and size of\n\t\t * the final window.\n\t\t */\n\t\tbdown = 0;\n\t\tif (button_mask) {\n\t\t\tbdown = 1;\n\t\t} else if (wireframe_local && display_button_mask) {\n\t\t\tbdown = 2;\n\t\t}\n\t\tif (! bdown) {\nif (db || db2) fprintf(stderr, \"NO button_mask\\n\");\n\t\t\tbreak_reason = 6;\n\t\t\tbreak;\t\n\t\t}\n\t}\n\n\tif (! drew_box) {\n\t\t/* nice try, but no move or resize detected.  cleanup. */\n\t\tif (stack_list_num) {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t\twireframe_in_progress = 0;\n\t\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* remove the wireframe */\n\tif (do_copyrect_drag <= 0) {\n\t\tdraw_box(0, 0, 0, 0, 1);\n\t\tfb_push(); /* XXX Y */\n\t} else {\n\t\tint tb = use_threads ? 0 : try_batch;\n\t\tdo_copyrect_drag_move(orig_frame, frame, &nidx,\n\t\t    tb, now_x, now_y, orig_w, orig_h, x, y, w, h, -1.0);\n\t\tfb_push_wait(0.15, FB_COPY|FB_MOD);\n\t}\n\n\tdx = x - orig_x;\n\tdy = y - orig_y;\n\n\t/*\n\t * see if we can apply CopyRect or CopyRegion to the change:\n\t */\n\tif (!strcmp(wireframe_copyrect, \"never\")) {\n\t\t;\n\t} else if (win_gone || win_unmapped) {\n\t\t;\n\t} else if (skip_cr_when_scaling(\"wireframe\")) {\n\t\t;\n\t} else if (w != orig_w || h != orig_h) {\n\t\tif (ncache > 0) {\n\t\t\ttry_to_fix_resize_su(orig_frame, orig_x, orig_y, orig_w, orig_h, x, y, w, h, try_batch);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(orig_frame, 1);\n\t\t\tif (frame != orig_frame) {\n\t\t\t\tclear_win_events(frame, 1);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t} else if (dx == 0 && dy == 0) {\n\t\t;\n\t} else if (do_copyrect_drag > 0) {\n\t\tX_LOCK;\n\t\tclear_win_events(NPP_nwin, 0);\n\t\tX_UNLOCK;\n\t} else {\n\t\tint spin_ms = (int) (spin * 1000 * 1000);\n\t\tint obscured, sent_copyrect = 0;\n\n\t\tint nidx = -1;\n\t\tint use_batch = 0;\n\t\tdouble ntim;\n\n\t\t/*\n\t\t * set a timescale comparable to the spin time,\n\t\t * but not too short or too long.\n\t\t */\n\t\tif (spin_ms < 30) {\n\t\t\tspin_ms = 30;\n\t\t} else if (spin_ms > 400) {\n\t\t\tspin_ms = 400;\n\t\t}\n\t\tntim = dnow();\n\n\t\t/* try to flush the wireframe removal: */\nif (ncdb && ncache) fprintf(stderr, \"\\nSEND_COPYRECT  %.4f %.4f\\n\", dnowx(), dnow() - ntim);\n\n\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED*, try one more... %.4f\", dnow() - ntim);\n\n\t\t\tif (! fb_push_wait(0.15, FB_COPY|FB_MOD)) {\n\nif (ncdb && ncache) fprintf(stderr, \"FB_COPY *FAILED* again! %.4f\", dnow() - ntim);\n\n\t\t\t}\n\t\t}\n\n\t\tncache_pre_portions(orig_frame, frame, &nidx, try_batch, &use_batch,\n\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, ntim);\n\n\t\t/* 2) try to send a clipped copyrect of translation: */\n\n\t\tif (! try_batch) {\n\t\t\tsent_copyrect = try_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, NULL);\n\t\t} else {\n\t\t\ttry_copyrect(orig_frame, frame, x, y, w, h, dx, dy,\n\t\t\t    &obscured, NULL, 0.15, &NPP_nreg);\t/* XXX */\n\t\t\tsent_copyrect = 1;\n\t\t\tuse_batch = 1;\n\t\t}\n\nif ((ncache || db) && ncdb) fprintf(stderr, \"sent_copyrect: %d - obs: %d  frame: 0x%lx\\n\", sent_copyrect, obscured, frame);\n\t\tif (sent_copyrect) {\n\t\t\t/* try to push the changes to viewers: */\n\t\t\tif (use_batch) {\n\t\t\t\t;\n\t\t\t} else if (! obscured) {\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t} else {\n\t\t\t\t/* no diff for now... */\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\t\t\t}\n\t\t\tncache_post_portions(nidx, use_batch,\n\t\t\t    orig_x, orig_y, orig_w, orig_h, x, y, w, h, -1.0, ntim);\n\t\t\tX_LOCK;\n\t\t\tclear_win_events(NPP_nwin, 0);\n\t\t\tX_UNLOCK;\n\n\t\t\tif (scaling && !use_batch) {\n\t\t\t\tstatic double last_time = 0.0;\n\t\t\t\tdouble now = dnow(), delay = 0.35;\n\n\t\t\t\tfb_push_wait(0.1, FB_COPY);\n\n\t\t\t\tif (now > last_time + delay) {\n\t\t\t\t\tint xt = x, yt = y;\n\n\t\t\t\t\tif (clipshift) {\n\t\t\t\t\t\txt -= coff_x;\n\t\t\t\t\t\tyt -= coff_y;\n\t\t\t\t\t}\n\t\t\t\t\tif (subwin) {\n\t\t\t\t\t\txt -= off_x;\n\t\t\t\t\t\tyt -= off_y;\n\t\t\t\t\t}\n\n\t\t\t\t\tscale_mark(xt, yt, xt+w, yt+h, 1);\n\t\t\t\t\tlast_time = now;\n\t\t\t\t\tlast_copyrect_fix = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stack_list_num) {\n\t\t/* clean up stack_list for next time: */\n\t\tif (break_reason == 1 || break_reason == 2) {\n\t\t\t/*\n\t\t\t * save the stack list, perhaps the user has\n\t\t\t * paused with button down.\n\t\t\t */\n\t\t\tlast_save_stacklist = time(NULL);\n\t\t} else {\n\t\t\tstack_list_num = 0;\n\t\t}\n\t}\n\n\t/* final push (for -nowirecopyrect) */\n\trfbPE(1000);\n\twireframe_in_progress = 0;\n\n\tif (1) {\n\t/* In principle no longer needed...  see draw_box() */\n\t    if (frame_changed && cmap8to24 /* && multivis_count */) {\n\t\t/* handle -8to24 kludge, mark area and check 8bpp... */\n\t\tint x1, x2, y1, y2, f = 16;\n\t\tx1 = nmin(box_x, orig_x) - f;\n\t\ty1 = nmin(box_y, orig_y) - f;\n\t\tx2 = nmax(box_x + box_w, orig_x + orig_w) + f;\n\t\ty2 = nmax(box_y + box_h, orig_y + orig_h) + f;\n\t\tx1 = nfix(x1, dpy_x);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty1 = nfix(y1, dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tif (0) {\n\t\t\tcheck_for_multivis();\n\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t} else {\n\t\t\tif (1) {\n\t\t\t\tbpp8to24(x1, y1, x2, y2);\n\t\t\t} else {\n\t\t\t\tbpp8to24(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\turgent_update = 1;\n\tif (use_xdamage) {\n\t\t/* DAMAGE can queue ~1000 rectangles for a move */\n\t\tclear_xdamage_mark_region(NULL, 1);\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (macosx_console && (break_reason == 6 || break_reason == 5)) {\n\t\tcheck_macosx_iconify(orig_frame, frame, drew_box);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xrecord",
          "args": [],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "3066-3118",
          "snippet": "int check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_xrecord(void);",
            "static int check_xrecord_keys(void);",
            "static int check_xrecord_mouse(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nstatic int check_xrecord_keys(void);\nstatic int check_xrecord_mouse(void);\n\nint check_xrecord(void) {\n\tint watch_keys = 0, watch_mouse = 0, consider_mouse;\n\tstatic int mouse_wants_back_in = 0;\n\n\tRAWFB_RET(0)\n\n\tif (! use_xrecord) {\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\tif (skip_cr_when_scaling(\"scroll\")) {\n\t\treturn 0;\n\t}\n\nif (0) fprintf(stderr, \"check_xrecord: IN xrecording: %d\\n\", xrecording);\n\n\tif (! xrecording) {\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(scroll_copyrect, \"always\")) {\n\t\twatch_keys = 1;\n\t\twatch_mouse = 1;\n\t} else if (!strcmp(scroll_copyrect, \"keys\")) {\n\t\twatch_keys = 1;\n\t} else if (!strcmp(scroll_copyrect, \"mouse\")) {\n\t\twatch_mouse = 1;\n\t}\n\n\tif (button_mask || mouse_wants_back_in) {\n\t\tconsider_mouse = 1;\n\t} else {\n\t\tconsider_mouse = 0;\n\t}\nif (0) fprintf(stderr, \"check_xrecord: button_mask: %d  mouse_wants_back_in: %d\\n\", button_mask, mouse_wants_back_in);\n\n\tif (watch_mouse && consider_mouse && xrecord_set_by_mouse) {\n\t\tint ret = check_xrecord_mouse();\n\t\tif (ret == 3) {\n\t\t\tmouse_wants_back_in = 1;\n\t\t} else {\n\t\t\tmouse_wants_back_in = 0;\n\t\t}\n\t\treturn ret;\n\t} else if (watch_keys && xrecord_set_by_keys) {\n\t\tmouse_wants_back_in = 0;\n\t\treturn check_xrecord_keys();\n\t} else {\n\t\tmouse_wants_back_in = 0;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "msg",
            "cl->host"
          ],
          "line": 4504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eat_viewonly_input",
          "args": [
            "10",
            "3"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "eat_viewonly_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2341-2365",
          "snippet": "void eat_viewonly_input(int max_eat, int keep) {\n\tint i, gp, gk;\n\t\n\tfor (i=0; i<max_eat; i++) {\n\t\tint cont = 0;\n\t\tgp = got_pointer_calls;\n\t\tgk = got_keyboard_calls;\n\t\trfbCFD(0);\n\t\tif (got_pointer_calls > gp)  {\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"eat_viewonly_input: pointer: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (got_keyboard_calls > gk)  {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"eat_viewonly_input: keyboard: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (i >= keep - 1 && ! cont) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void eat_viewonly_input(int max_eat, int keep);",
            "static int eat_pointer(int max_ptr_eat, int keep);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid eat_viewonly_input(int max_eat, int keep);\nstatic int eat_pointer(int max_ptr_eat, int keep);\n\nvoid eat_viewonly_input(int max_eat, int keep) {\n\tint i, gp, gk;\n\t\n\tfor (i=0; i<max_eat; i++) {\n\t\tint cont = 0;\n\t\tgp = got_pointer_calls;\n\t\tgk = got_keyboard_calls;\n\t\trfbCFD(0);\n\t\tif (got_pointer_calls > gp)  {\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"eat_viewonly_input: pointer: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (got_keyboard_calls > gk)  {\n\t\t\tif (debug_keyboard) {\n\t\t\t\trfbLog(\"eat_viewonly_input: keyboard: %d\\n\", i);\n\t\t\t}\n\t\t\tcont++;\n\t\t}\n\t\tif (i >= keep - 1 && ! cont) {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_loop: LOOP-BACK: %d\\n\"",
            "ret"
          ],
          "line": 4490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_user_input",
          "args": [
            "dt",
            "dtr",
            "tile_diffs",
            "&cnt"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5631-5710",
          "snippet": "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt) {\n\n\tif (rawfb_vnc_reflect) {\n\t\tif (got_user_input) {\n\t\t\tif (0) vnc_reflect_process_client();\n\t\t}\n\t\tif (got_user_input && *cnt % ui_skip != 0) {\n\t\t\t/* every n-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t}\n\t}\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (use_xrecord) {\n\t\tint rc = check_xrecord();\n\t\t/*\n\t\t * 0: nothing found, proceed to other user input schemes.\n\t\t * 1: events found, want to do a screen update now.\n\t\t * 2: events found, want to loop back for some more.\n\t\t * 3: events found, want to loop back for some more,\n\t\t *    and not have rfbPE() called.\n\t\t *\n\t\t * For 0, we precede below, otherwise return rc-1.\n\t\t */\nif (debug_scroll && rc > 1) fprintf(stderr, \"  CXR: check_user_input ret %d\\n\", rc - 1);\n\t\tif (rc == 0) {\n\t\t\t;\t/* proceed below. */\n\t\t} else {\n\t\t\treturn rc - 1;\n\t\t}\n\t}\n\n\tif (wireframe) {\n\t\tif (check_wireframe()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pointer_mode == 1) {\n\t\tif ((got_user_input || ui_skip < 0) && *cnt % ui_skip != 0) {\n\t\t\t/* every ui_skip-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (pointer_mode >= 2 && pointer_mode <= 4) {\n\t\tif (got_keyboard_input) {\n\t\t\t/*\n\t\t\t * for these modes, short circuit watch_loop on\n\t\t\t * *keyboard* input.\n\t\t\t */\n\t\t\tif (*cnt % ui_skip != 0) {\n\t\t\t\t*cnt = *cnt + 1; \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* otherwise continue below with pointer input method */\n\t}\n\n\tif (pointer_mode == 2) {\n\t\tcheck_user_input2(dt);\n\t} else if (pointer_mode == 3) {\n\t\tcheck_user_input3(dt, dtr, tile_diffs);\n\t} else if (pointer_mode == 4) {\n\t\tcheck_user_input4(dt, dtr, tile_diffs);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_xrecord(void);",
            "int check_wireframe(void);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "static void check_user_input2(double dt);",
            "static void check_user_input3(double dt, double dtr, int tile_diffs);",
            "static void check_user_input4(double dt, double dtr, int tile_diffs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint check_xrecord(void);\nint check_wireframe(void);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nstatic void check_user_input2(double dt);\nstatic void check_user_input3(double dt, double dtr, int tile_diffs);\nstatic void check_user_input4(double dt, double dtr, int tile_diffs);\n\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt) {\n\n\tif (rawfb_vnc_reflect) {\n\t\tif (got_user_input) {\n\t\t\tif (0) vnc_reflect_process_client();\n\t\t}\n\t\tif (got_user_input && *cnt % ui_skip != 0) {\n\t\t\t/* every n-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t}\n\t}\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\tRAWFB_RET(0)\n#endif\n\n\tif (use_xrecord) {\n\t\tint rc = check_xrecord();\n\t\t/*\n\t\t * 0: nothing found, proceed to other user input schemes.\n\t\t * 1: events found, want to do a screen update now.\n\t\t * 2: events found, want to loop back for some more.\n\t\t * 3: events found, want to loop back for some more,\n\t\t *    and not have rfbPE() called.\n\t\t *\n\t\t * For 0, we precede below, otherwise return rc-1.\n\t\t */\nif (debug_scroll && rc > 1) fprintf(stderr, \"  CXR: check_user_input ret %d\\n\", rc - 1);\n\t\tif (rc == 0) {\n\t\t\t;\t/* proceed below. */\n\t\t} else {\n\t\t\treturn rc - 1;\n\t\t}\n\t}\n\n\tif (wireframe) {\n\t\tif (check_wireframe()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (pointer_mode == 1) {\n\t\tif ((got_user_input || ui_skip < 0) && *cnt % ui_skip != 0) {\n\t\t\t/* every ui_skip-th drops thru to scan */\n\t\t\t*cnt = *cnt + 1;\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\treturn 1;\t/* short circuit watch_loop */\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (pointer_mode >= 2 && pointer_mode <= 4) {\n\t\tif (got_keyboard_input) {\n\t\t\t/*\n\t\t\t * for these modes, short circuit watch_loop on\n\t\t\t * *keyboard* input.\n\t\t\t */\n\t\t\tif (*cnt % ui_skip != 0) {\n\t\t\t\t*cnt = *cnt + 1; \n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* otherwise continue below with pointer input method */\n\t}\n\n\tif (pointer_mode == 2) {\n\t\tcheck_user_input2(dt);\n\t} else if (pointer_mode == 3) {\n\t\tcheck_user_input3(dt, dtr, tile_diffs);\n\t} else if (pointer_mode == 4) {\n\t\tcheck_user_input4(dt, dtr, tile_diffs);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_cursor_shape_updates",
          "args": [
            "screen"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "disable_cursor_shape_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1711-1750",
          "snippet": "void disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_update_sent",
          "args": [
            "NULL"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "fb_update_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "5390-5419",
          "snippet": "int fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int fb_update_sent(int *count);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint fb_update_sent(int *count);\n\nint fb_update_sent(int *count) {\n\tstatic int last_count = 0;\n\tint sent = 0, rc = 0;\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (nofb) {\n\t\treturn 0;\n\t}\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n#if 0\n\t\tsent += cl->framebufferUpdateMessagesSent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tsent += rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(i);\n\tif (sent != last_count) {\n\t\trc = 1;\n\t}\n\tif (count != NULL) {\n\t\t*count = sent;\n\t}\n\tlast_count = sent;\n\treturn rc; \n}"
        }
      },
      {
        "call_info": {
          "callee": "measure_send_rates",
          "args": [
            "0"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "measure_send_rates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "337-729",
          "snippet": "void measure_send_rates(int init) {\n\tdouble cmp_rate, raw_rate;\n\tstatic double now, start = 0.0;\n\tstatic rfbDisplayHookPtr orig_display_hook = NULL;\n\tdouble cmp_max = 1.0e+08;\t/* 100 MB/sec */\n\tdouble cmp_min = 1000.0;\t/* 9600baud */\n\tdouble lat_max = 5.0;\t\t/* 5 sec */\n\tdouble lat_min = .0005;\t\t/* 0.5 ms */\n\tint min_cmp = 10000, nclients;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl0, cl;\n\tint msg = 0, clcnt0 = 0, cc;\n\tint db = 0, ouch_db = 0, ouch = 0;\n\n\tif (! measure_speeds) {\n\t\treturn;\n\t}\n\tif (speeds_net_rate && speeds_net_latency) {\n\t\treturn;\n\t}\n\tif (!client_count) {\n\t\treturn;\n\t}\n\n\tif (! orig_display_hook) {\n\t\torig_display_hook = screen->displayHook;\n\t}\n\n\tif (start == 0.0) {\n\t\tdtime(&start);\n\t}\n\n\tdtime0(&now);\n\tif (now < last_client_gone+4.0) {\n\t\treturn;\n\t}\n\tnow = now - start;\n\n\tnclients = 0;\n\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tcl0 = NULL;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate > 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->onHold) {\n\t\t\tcontinue;\n\t\t}\n\t\tnclients++;\n\t\tif (cl0 == NULL)  {\n\t\t\tcl0 = cl;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl = cl0;\n\tcc = 0;\n\n\twhile (cl != NULL && cc++ == 0) {\n\t\tint defer, i, cbs, rbs;\n\t\tchar *httpdir;\n\t\tdouble dt, dt1 = 0.0, dt2, dt3;\n\t\tdouble tm, spin_max = 15.0, spin_lat_max = 1.5;\n\t\tint got_t2 = 0, got_t3 = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n#if 0\n\t\tfor (i=0; i<MAX_ENCODINGS; i++) {\n\t\t\tcbs += cl->bytesSent[i];\n\t\t}\n\t\trbs = cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tcbs = rfbStatGetSentBytes(cl);\n\t\trbs = rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\n\t\tif (init) {\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\t\tcd->timer = dnow();\n\t\t\tcd->cmp_bytes_sent = cbs;\n\t\t\tcd->raw_bytes_sent = rbs;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first part of the bulk transfer of initial screen */\n\t\tdt1 = dtime(&cd->timer);\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\tif (dt1 <= 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcbs = cbs - cd->cmp_bytes_sent;\n\t\trbs = rbs - cd->raw_bytes_sent;\n\n\t\tif (cbs < min_cmp) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ouch_db) fprintf(stderr, \"START-OUCH: %d\\n\", client_count);\n\t\tclcnt0 = client_count;\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\n\t\trfbPE(1000);\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-A\\n\");\n\t\tif (OUCH) continue;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (sraRgnCountRects(cl->modifiedRegion)) {\n\t\t\trfbPE(1000);\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-B\\n\");\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\tif (OUCH) continue;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\tdefer = screen->deferUpdateTime;\n\t\thttpdir = screen->httpDir;\n\t\tscreen->deferUpdateTime = 0;\n\t\tscreen->httpDir = NULL;\n\n\t\t/* mark a small rectangle: */\n\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\n\t\tdtime0(&tm);\n\n\t\tdt2 = 0.0;\n\t\tdt3 = 0.0;\n\n\t\tif (dt1 < 0.25) {\n\t\t\t/* try to cut it down to avoid long pauses. */\n\t\t\tspin_max = 5.0;\n\t\t}\n\n\t\t/* when req1 = 1 mod1 == 0, end of 2nd part of bulk transfer */\n\t\twhile (1) {\n\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C1\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(1000);\n\t\t\t} else {\n\t\t\t\tif (mod0) {\n\t\t\t\t\trfbPE(1000);\n\t\t\t\t} else {\n\t\t\t\t\trfbCFD(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tdt2 += dt;\n\t\t\tif (dt2 > spin_max) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C2\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt2 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt2, tm);\n\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\tgot_t2 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-D\\n\");\n\t\tif (OUCH) goto ouch;\n\n\t\tif (! got_t2) {\n\t\t\tdt2 = 0.0;\n\t\t} else {\n\t\t\tint tr, trm = 3;\n\t\t\tdouble dts[10];\n\t\t\t\n\t\t\t/*\n\t\t\t * Note: since often select(2) cannot sleep\n\t\t\t * less than 1/HZ (e.g. 10ms), the resolution\n\t\t\t * of the latency may be messed up by something\n\t\t\t * of this order.  Effect may occur on both ends,\n\t\t\t * i.e. the viewer may not respond immediately.\n\t\t\t */\n\t\t\n\t\t\tfor (tr = 0; tr < trm; tr++) {\n\t\t\t\tusleep(5000);\n\n\t\t\t\t/* mark a 2nd small rectangle: */\n\t\t\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\t\t\t\ti = 0;\n\t\t\t\tdtime0(&tm);\n\t\t\t\tdt3 = 0.0;\n\n\t\t\t\t/*\n\t\t\t\t * when req1 > 0 and mod1 == 0, we say\n\t\t\t\t * that is the \"ping\" time.\n\t\t\t\t */\n\t\t\t\twhile (1) {\n\t\t\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (use_threads) {\n\t\t\t\t\t\t\tusleep(1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* try to get it all */\n\t\t\t\t\t\t\trfbCFD(1000*1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-E\\n\");\n\t\t\t\t\tif (OUCH) goto ouch;\n\t\t\t\t\tdt = dtime(&tm);\n\t\t\t\t\ti++;\n\n\t\t\t\t\tdt3 += dt;\n\t\t\t\t\tif (dt3 > spin_lat_max) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt3 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt3, tm);\n\n\t\t\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\t\t\tdts[got_t3++] = dt3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (! got_t3) {\n\t\t\t\tdt3 = 0.0;\n\t\t\t} else {\n\t\t\t\tif (got_t3 == 1) {\n\t\t\t\t\tdt3 = dts[0];\n\t\t\t\t} else if (got_t3 == 2) {\n\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t} else {\n\t\t\t\t\tif (dts[2] > 0.0) {\n\t\t\t\t\t\tdouble rat = dts[1]/dts[2];\n\t\t\t\t\t\tif (rat > 0.5 && rat < 2.0) {\n\t\t\t\t\t\t\tdt3 = dts[1]+dts[2];\n\t\t\t\t\t\t\tdt3 *= 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\touch:\n\t\t\n\t\tscreen->deferUpdateTime = defer;\n\t\tscreen->httpDir = httpdir;\n\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-F\\n\");\n\t\tif (OUCH) break;\n\n\t\tdt = dt1 + dt2;\n\n\n\t\tif (dt3 <= dt2/2.0) {\n\t\t\t/* guess only 1/2 a ping for reply... */\n\t\t\tdt = dt - dt3/2.0;\n\t\t}\n\n\t\tcmp_rate = cbs/dt;\n\t\traw_rate = rbs/dt;\n\n\t\tif (cmp_rate > cmp_max) {\n\t\t\tcmp_rate = cmp_max;\n\t\t}\n\t\tif (cmp_rate <= cmp_min) {\n\t\t\tcmp_rate = cmp_min;\n\t\t}\n\n\t\tcd->send_cmp_rate = cmp_rate;\n\t\tcd->send_raw_rate = raw_rate;\n\n\t\tif (dt3 > lat_max) {\n\t\t\tdt3 = lat_max;\n\t\t}\n\t\tif (dt3 <= lat_min) {\n\t\t\tdt3 = lat_min;\n\t\t}\n\n\t\tcd->latency = dt3;\n\t\t\n\t\trfbLog(\"client %d network rate %.1f KB/sec (%.1f eff KB/sec)\\n\",\n\t\t    cd->uid, cmp_rate/1000.0, raw_rate/1000.0);\n\t\trfbLog(\"client %d latency:  %.1f ms\\n\", cd->uid, 1000.0*dt3);\n\t\trfbLog(\"dt1: %.4f, dt2: %.4f dt3: %.4f bytes: %d\\n\",\n\t\t    dt1, dt2, dt3, cbs);\n\t\tmsg = 1;\n\t}\n\n\tif (msg) {\n\t\tint link, latency, netrate;\n\t\tchar *str = \"error\";\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_UNSET) {\n\t\t\tstr = \"LR_UNSET\";\n\t\t} else if (link == LR_UNKNOWN) {\n\t\t\tstr = \"LR_UNKNOWN\";\n\t\t} else if (link == LR_DIALUP) {\n\t\t\tstr = \"LR_DIALUP\";\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tstr = \"LR_BROADBAND\";\n\t\t} else if (link == LR_LAN) {\n\t\t\tstr = \"LR_LAN\";\n\t\t}\n\t\trfbLog(\"link_rate: %s - %d ms, %d KB/s\\n\", str, latency,\n\t\t    netrate);\n\t}\n\n\tif (init) {\n\t\tif (nclients) {\n\t\t\tscreen->displayHook = measure_display_hook;\n\t\t}\n\t} else {\n\t\tscreen->displayHook = orig_display_hook;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )"
          ],
          "globals_used": [
            "int measure_speeds = 1;",
            "int speeds_net_rate = 0;",
            "int speeds_net_latency = 0;",
            "int link_rate(int *latency, int *netrate);",
            "void measure_send_rates(int init);",
            "static void measure_display_hook(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\nint measure_speeds = 1;\nint speeds_net_rate = 0;\nint speeds_net_latency = 0;\nint link_rate(int *latency, int *netrate);\nvoid measure_send_rates(int init);\nstatic void measure_display_hook(rfbClientPtr cl);\n\nvoid measure_send_rates(int init) {\n\tdouble cmp_rate, raw_rate;\n\tstatic double now, start = 0.0;\n\tstatic rfbDisplayHookPtr orig_display_hook = NULL;\n\tdouble cmp_max = 1.0e+08;\t/* 100 MB/sec */\n\tdouble cmp_min = 1000.0;\t/* 9600baud */\n\tdouble lat_max = 5.0;\t\t/* 5 sec */\n\tdouble lat_min = .0005;\t\t/* 0.5 ms */\n\tint min_cmp = 10000, nclients;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl0, cl;\n\tint msg = 0, clcnt0 = 0, cc;\n\tint db = 0, ouch_db = 0, ouch = 0;\n\n\tif (! measure_speeds) {\n\t\treturn;\n\t}\n\tif (speeds_net_rate && speeds_net_latency) {\n\t\treturn;\n\t}\n\tif (!client_count) {\n\t\treturn;\n\t}\n\n\tif (! orig_display_hook) {\n\t\torig_display_hook = screen->displayHook;\n\t}\n\n\tif (start == 0.0) {\n\t\tdtime(&start);\n\t}\n\n\tdtime0(&now);\n\tif (now < last_client_gone+4.0) {\n\t\treturn;\n\t}\n\tnow = now - start;\n\n\tnclients = 0;\n\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tcl0 = NULL;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate > 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->onHold) {\n\t\t\tcontinue;\n\t\t}\n\t\tnclients++;\n\t\tif (cl0 == NULL)  {\n\t\t\tcl0 = cl;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl = cl0;\n\tcc = 0;\n\n\twhile (cl != NULL && cc++ == 0) {\n\t\tint defer, i, cbs, rbs;\n\t\tchar *httpdir;\n\t\tdouble dt, dt1 = 0.0, dt2, dt3;\n\t\tdouble tm, spin_max = 15.0, spin_lat_max = 1.5;\n\t\tint got_t2 = 0, got_t3 = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n#if 0\n\t\tfor (i=0; i<MAX_ENCODINGS; i++) {\n\t\t\tcbs += cl->bytesSent[i];\n\t\t}\n\t\trbs = cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tcbs = rfbStatGetSentBytes(cl);\n\t\trbs = rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\n\t\tif (init) {\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\t\tcd->timer = dnow();\n\t\t\tcd->cmp_bytes_sent = cbs;\n\t\t\tcd->raw_bytes_sent = rbs;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first part of the bulk transfer of initial screen */\n\t\tdt1 = dtime(&cd->timer);\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\tif (dt1 <= 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcbs = cbs - cd->cmp_bytes_sent;\n\t\trbs = rbs - cd->raw_bytes_sent;\n\n\t\tif (cbs < min_cmp) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ouch_db) fprintf(stderr, \"START-OUCH: %d\\n\", client_count);\n\t\tclcnt0 = client_count;\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\n\t\trfbPE(1000);\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-A\\n\");\n\t\tif (OUCH) continue;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (sraRgnCountRects(cl->modifiedRegion)) {\n\t\t\trfbPE(1000);\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-B\\n\");\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\tif (OUCH) continue;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\tdefer = screen->deferUpdateTime;\n\t\thttpdir = screen->httpDir;\n\t\tscreen->deferUpdateTime = 0;\n\t\tscreen->httpDir = NULL;\n\n\t\t/* mark a small rectangle: */\n\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\n\t\tdtime0(&tm);\n\n\t\tdt2 = 0.0;\n\t\tdt3 = 0.0;\n\n\t\tif (dt1 < 0.25) {\n\t\t\t/* try to cut it down to avoid long pauses. */\n\t\t\tspin_max = 5.0;\n\t\t}\n\n\t\t/* when req1 = 1 mod1 == 0, end of 2nd part of bulk transfer */\n\t\twhile (1) {\n\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C1\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(1000);\n\t\t\t} else {\n\t\t\t\tif (mod0) {\n\t\t\t\t\trfbPE(1000);\n\t\t\t\t} else {\n\t\t\t\t\trfbCFD(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tdt2 += dt;\n\t\t\tif (dt2 > spin_max) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C2\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt2 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt2, tm);\n\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\tgot_t2 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-D\\n\");\n\t\tif (OUCH) goto ouch;\n\n\t\tif (! got_t2) {\n\t\t\tdt2 = 0.0;\n\t\t} else {\n\t\t\tint tr, trm = 3;\n\t\t\tdouble dts[10];\n\t\t\t\n\t\t\t/*\n\t\t\t * Note: since often select(2) cannot sleep\n\t\t\t * less than 1/HZ (e.g. 10ms), the resolution\n\t\t\t * of the latency may be messed up by something\n\t\t\t * of this order.  Effect may occur on both ends,\n\t\t\t * i.e. the viewer may not respond immediately.\n\t\t\t */\n\t\t\n\t\t\tfor (tr = 0; tr < trm; tr++) {\n\t\t\t\tusleep(5000);\n\n\t\t\t\t/* mark a 2nd small rectangle: */\n\t\t\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\t\t\t\ti = 0;\n\t\t\t\tdtime0(&tm);\n\t\t\t\tdt3 = 0.0;\n\n\t\t\t\t/*\n\t\t\t\t * when req1 > 0 and mod1 == 0, we say\n\t\t\t\t * that is the \"ping\" time.\n\t\t\t\t */\n\t\t\t\twhile (1) {\n\t\t\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (use_threads) {\n\t\t\t\t\t\t\tusleep(1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* try to get it all */\n\t\t\t\t\t\t\trfbCFD(1000*1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-E\\n\");\n\t\t\t\t\tif (OUCH) goto ouch;\n\t\t\t\t\tdt = dtime(&tm);\n\t\t\t\t\ti++;\n\n\t\t\t\t\tdt3 += dt;\n\t\t\t\t\tif (dt3 > spin_lat_max) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt3 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt3, tm);\n\n\t\t\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\t\t\tdts[got_t3++] = dt3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (! got_t3) {\n\t\t\t\tdt3 = 0.0;\n\t\t\t} else {\n\t\t\t\tif (got_t3 == 1) {\n\t\t\t\t\tdt3 = dts[0];\n\t\t\t\t} else if (got_t3 == 2) {\n\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t} else {\n\t\t\t\t\tif (dts[2] > 0.0) {\n\t\t\t\t\t\tdouble rat = dts[1]/dts[2];\n\t\t\t\t\t\tif (rat > 0.5 && rat < 2.0) {\n\t\t\t\t\t\t\tdt3 = dts[1]+dts[2];\n\t\t\t\t\t\t\tdt3 *= 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\touch:\n\t\t\n\t\tscreen->deferUpdateTime = defer;\n\t\tscreen->httpDir = httpdir;\n\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-F\\n\");\n\t\tif (OUCH) break;\n\n\t\tdt = dt1 + dt2;\n\n\n\t\tif (dt3 <= dt2/2.0) {\n\t\t\t/* guess only 1/2 a ping for reply... */\n\t\t\tdt = dt - dt3/2.0;\n\t\t}\n\n\t\tcmp_rate = cbs/dt;\n\t\traw_rate = rbs/dt;\n\n\t\tif (cmp_rate > cmp_max) {\n\t\t\tcmp_rate = cmp_max;\n\t\t}\n\t\tif (cmp_rate <= cmp_min) {\n\t\t\tcmp_rate = cmp_min;\n\t\t}\n\n\t\tcd->send_cmp_rate = cmp_rate;\n\t\tcd->send_raw_rate = raw_rate;\n\n\t\tif (dt3 > lat_max) {\n\t\t\tdt3 = lat_max;\n\t\t}\n\t\tif (dt3 <= lat_min) {\n\t\t\tdt3 = lat_min;\n\t\t}\n\n\t\tcd->latency = dt3;\n\t\t\n\t\trfbLog(\"client %d network rate %.1f KB/sec (%.1f eff KB/sec)\\n\",\n\t\t    cd->uid, cmp_rate/1000.0, raw_rate/1000.0);\n\t\trfbLog(\"client %d latency:  %.1f ms\\n\", cd->uid, 1000.0*dt3);\n\t\trfbLog(\"dt1: %.4f, dt2: %.4f dt3: %.4f bytes: %d\\n\",\n\t\t    dt1, dt2, dt3, cbs);\n\t\tmsg = 1;\n\t}\n\n\tif (msg) {\n\t\tint link, latency, netrate;\n\t\tchar *str = \"error\";\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_UNSET) {\n\t\t\tstr = \"LR_UNSET\";\n\t\t} else if (link == LR_UNKNOWN) {\n\t\t\tstr = \"LR_UNKNOWN\";\n\t\t} else if (link == LR_DIALUP) {\n\t\t\tstr = \"LR_DIALUP\";\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tstr = \"LR_BROADBAND\";\n\t\t} else if (link == LR_LAN) {\n\t\t\tstr = \"LR_LAN\";\n\t\t}\n\t\trfbLog(\"link_rate: %s - %d ms, %d KB/s\\n\", str, latency,\n\t\t    netrate);\n\t}\n\n\tif (init) {\n\t\tif (nclients) {\n\t\t\tscreen->displayHook = measure_display_hook;\n\t\t}\n\t} else {\n\t\tscreen->displayHook = orig_display_hook;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "msg",
            "cl->host"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbRunEventLoop",
          "args": [
            "screen",
            "-1",
            "TRUE"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid check_padded_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid vnc_reflect_process_client(void);\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void install_fake_fb(int w, int h, int bpp);\nstatic void check_filexfer(void);\nstatic void record_last_fb_update(void);\nstatic void check_cursor_changes(void);\nstatic int choose_delay(double dt);\nint rawfb_vnc_reflect = 0;\nint rawfb_double_buffer = 0;\nstatic rfbClient* client = NULL;\n\nvoid watch_loop(void) {\n\tint cnt = 0, tile_diffs = 0, skip_pe = 0, wait;\n\tdouble tm, dtr, dt = 0.0;\n\ttime_t start = time(NULL);\n\n\tif (use_threads && !started_rfbRunEventLoop) {\n\t\tstarted_rfbRunEventLoop = 1;\n\t\trfbRunEventLoop(screen, -1, TRUE);\n\t}\n\n\twhile (1) {\n\t\tchar msg[] = \"new client: %s taking unixpw client off hold.\\n\";\n\t\tint skip_scan_for_updates = 0;\n\n\t\tgot_user_input = 0;\n\t\tgot_pointer_input = 0;\n\t\tgot_local_pointer_input = 0;\n\t\tgot_pointer_calls = 0;\n\t\tgot_keyboard_input = 0;\n\t\tgot_keyboard_calls = 0;\n\t\turgent_update = 0;\n\n\t\tx11vnc_current = dnow();\n\n\t\tif (! use_threads) {\n\t\t\tdtime0(&tm);\n\t\t\tif (! skip_pe) {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(1);\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 1;\n\n\t\t\t\t/*\n\t\t\t\t * do a few more since a key press may\n\t\t\t\t * have induced a small change we want to\n\t\t\t\t * see quickly (just 1 rfbPE will likely\n\t\t\t\t * only process the subsequent \"up\" event)\n\t\t\t\t */\n\t\t\t\tif (tm < last_keyboard_time + 0.20) {\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (extra_fbur > 0) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i=0; i < extra_fbur; i++) {\n\t\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tif (x11vnc_current < last_new_client + 0.5) {\n\t\t\t\t\turgent_update = 1;\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 0;\n\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\t/* rfbPE loop until logged in. */\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(0);\n\t\t\t\t\tfb_update_sent(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdtr = dtime(&tm);\n\n\t\t\tif (! cursor_shape_updates) {\n\t\t\t\t/* undo any cursor shape requests */\n\t\t\t\tdisable_cursor_shape_updates(screen);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint ret = check_user_input(dt, dtr, tile_diffs, &cnt);\n\t\t\t\t/* true: loop back for more input */\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\tskip_pe = 1;\n\t\t\t\t}\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (debug_scroll) fprintf(stderr, \"watch_loop: LOOP-BACK: %d\\n\", ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* watch for viewonly input piling up: */\n\t\t\tif ((got_pointer_calls > got_pointer_input) ||\n\t\t\t    (got_keyboard_calls > got_keyboard_input)) {\n\t\t\t\teat_viewonly_input(10, 3);\n\t\t\t}\n\t\t} else {\n\t\t\t/* -threads here. */\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_xrecord) {\n\t\t\t\tcheck_xrecord();\n\t\t\t}\n\t\t\tif (wireframe && button_mask) {\n\t\t\t\tcheck_wireframe();\n\t\t\t}\n\t\t}\n\t\tskip_pe = 0;\n\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\n\t\tif (unixpw_in_progress) {\n\t\t\tcheck_new_clients();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! urgent_update) {\n\t\t\tif (do_copy_screen) {\n\t\t\t\tdo_copy_screen = 0;\n\t\t\t\tcopy_screen();\n\t\t\t}\n\n\t\t\tcheck_new_clients();\n\t\t\tcheck_ncache(0, 0);\n\t\t\tcheck_xevents(0);\n\t\t\tcheck_autorepeat();\n\t\t\tcheck_pm();\n\t\t\tcheck_filexfer();\n\t\t\tcheck_keycode_state();\n\t\t\tcheck_connect_inputs();\n\t\t\tcheck_gui_inputs();\n\t\t\tcheck_stunnel();\n\t\t\tcheck_openssl();\n\t\t\tcheck_https();\n\t\t\trecord_last_fb_update();\n\t\t\tcheck_padded_fb();\n\t\t\tcheck_fixscreen();\n\t\t\tcheck_xdamage_state();\n\t\t\tcheck_xrecord_reset(0);\n\t\t\tcheck_add_keysyms();\n\t\t\tcheck_new_passwds(0);\n#ifdef ENABLE_GRABLOCAL\n\t\t\tif (grab_local) {\n\t\t\t\tcheck_local_grab();\n\t\t\t}\n#endif\n\t\t\tif (started_as_root) {\n\t\t\t\tcheck_switched_user();\n\t\t\t}\n\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tstart = time(NULL);\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t}\n\n\t\tif (rawfb_vnc_reflect) {\n\t\t\tstatic time_t lastone = 0;\n\t\t\tif (time(NULL) > lastone + 10) {\n\t\t\t\tlastone = time(NULL);\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\t\t}\n\n\t\tif (first_conn_timeout) {\n\t\t\tint t = first_conn_timeout;\n\t\t\tif (!clients_served) {\n\t\t\t\tif (time(NULL) - start > first_conn_timeout) {\n\t\t\t\t\trfbLog(\"No client after %d secs.\\n\", t);\n\t\t\t\t\tshut_down = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!client_normal_count) {\n\t\t\t\t\tif (time(NULL) - start > t + 3) {\n\t\t\t\t\t\trfbLog(\"No valid client after %d secs.\\n\", t + 3);\n\t\t\t\t\t\tshut_down = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\t/* waiting for a client */\n\t\t\tusleep(200 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (first_conn_timeout && all_clients_initialized()) {\n\t\t\tfirst_conn_timeout = 0;\n\t\t}\n\n\t\tif (nofb) {\n\t\t\t/* no framebuffer polling needed */\n\t\t\tif (cursor_pos_updates) {\n\t\t\t\tcheck_x11_pointer();\n\t\t\t}\n#ifdef MACOSX\n\t\t\telse check_x11_pointer();\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (x11vnc_current < last_new_client + 0.5 && !all_clients_initialized()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\t/* XXX not working */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tcheck_xevents(0);\n\t\t\tif (subwin_obscured) {\n\t\t\t\tskip_scan_for_updates = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_scan_for_updates || nofb) {\n\t\t\t;\n\t\t} else if (button_mask && (!show_dragging || pointer_mode == 0)) {\n\t\t\t/*\n\t\t\t * if any button is pressed in this mode do\n\t\t\t * not update rfb screen, but do flush the\n\t\t\t * X11 display.\n\t\t\t */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tdt = 0.0;\n\t\t} else { /* scan for updates case */\n\t\t\tstatic double last_dt = 0.0;\n\t\t\tdouble xdamage_thrash = 0.4; \n\t\t\tstatic int tilecut = -1;\n\n\t\t\t/* for timing the scan to try to detect thrashing */\n\n\t\t\tif (use_xdamage && last_dt > xdamage_thrash)  {\n\t\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t\t}\n\n\t\t\tif (unixpw_in_progress) continue;\n\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\n\t\t\tdtime0(&tm);\n\n#if !NO_X11\n\t\t\tif (xrandr_present && !xrandr && xrandr_maybe) {\n\t\t\t\tint delay = 180;\n\t\t\t\t/*  there may be xrandr right after xsession start */\n\t\t\t\tif (tm < x11vnc_start + delay || tm < last_client + delay) {\n\t\t\t\t\tint tw = 20;\n\t\t\t\t\tif (auth_file != NULL) {\n\t\t\t\t\t\ttw = 120;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tif (tm < x11vnc_start + tw || tm < last_client + tw) {\n\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t\t}\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tcheck_xrandr_event(\"before-scan\");\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n#endif\n\t\t\t/* Now, for scanning and drawing soft cursors (i.e. writing to the framebuffer),\n\t\t\t   make sure we're not sending any updates to clients (i.e. reading the framebuffer).\n\t\t\t   Otherwise we get flicker! */\n\n\t\t\t/* Update offset in case local framebuffer is double buffered */\n\t\t\tif (rawfb_double_buffer) {\n\t\t\t\traw_fb_offset = rawfb_get_offset(&raw_fb_fd);\n\t\t\t}\n\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    LOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\n\t\t\tif (use_snapfb) {\n\t\t\t\tint t, tries = 3;\n\t\t\t\tcopy_snap();\n\t\t\t\tfor (t=0; t < tries; t++) {\n\t\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tif (! nap_ok) {\n\t\t\t\tlast_dt = dt;\n\t\t\t}\n\n\t\t\tif (tilecut < 0) {\n\t\t\t\tif (getenv(\"TILECUT\")) {\n\t\t\t\t\ttilecut = atoi(getenv(\"TILECUT\"));\n\t\t\t\t}\n\t\t\t\tif (tilecut < 0) tilecut = 4;\n\t\t\t}\n\n\t\t\tif ((debug_tiles || debug_scroll > 1 || debug_wireframe > 1)\n\t\t\t    && (tile_diffs > tilecut || debug_tiles > 1)) {\n\t\t\t\tdouble rate = (tile_x * tile_y * bpp/8 * tile_diffs) / dt;\n\t\t\t\tfprintf(stderr, \"============================= TILES: %d  dt: %.4f\"\n\t\t\t\t    \"  t: %.4f  %.2f MB/s nap_ok: %d\\n\", tile_diffs, dt,\n\t\t\t\t    tm - x11vnc_start, rate/1000000.0, nap_ok);\n\t\t\t}\n\n\t\t\t/* important to have this here since it draws cursors into framebuffer */\n\t\t\tcheck_cursor_changes();\n\n\t\t\t/* \n\t\t\t   Release the send ban again.\n\t\t\t*/\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    UNLOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\t\t\t\n\t\t} /* END scan for updates case */\n\n\t\t/* sleep a bit to lessen load */\n\t\twait = choose_delay(dt);\n\n\t\tif (urgent_update) {\n\t\t\t;\n\t\t} else if (wait > 2*waitms) {\n\t\t\t/* bog case, break it up */\n\t\t\tnap_sleep(wait, 10);\n\t\t} else {\n\t\t\tdouble t1, t2;\n\t\t\tint idt;\n\t\t\tif (extra_fbur > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i <= extra_fbur; i++) {\n\t\t\t\t\tint r = rfbPE(0);\n\t\t\t\t\tif (!r) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* sometimes the sleep is too short, so measure it: */\n\t\t\tt1 = dnow();\n\t\t\tusleep(wait * 1000);\n\t\t\tt2 = dnow();\n\n\t\t\tidt = (int) (1000. * (t2 - t1));\n\t\t\tif (idt > 0 && idt < wait) {\n\t\t\t\t/* try to sleep the remainder */\n\t\t\t\tusleep((wait - idt) * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\t}\n}"
  },
  {
    "function_name": "choose_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "4199-4390",
    "snippet": "static int choose_delay(double dt) {\n\tstatic double t0 = 0.0, t1 = 0.0, t2 = 0.0, now; \n\tstatic int x0, y0, x1, y1, x2, y2, first = 1;\n\tint dx0, dy0, dx1, dy1, dm, i, msec = waitms;\n\tdouble cut1 = 0.15, cut2 = 0.075, cut3 = 0.25;\n\tdouble bogdown_time = 0.25, bave = 0.0;\n\tint bogdown = 1, bcnt = 0;\n\tint ndt = 8, nave = 3;\n\tdouble fac = 1.0;\n\tstatic int db = 0, did_set_defer = 0;\n\tstatic double dts[8];\n\tstatic int link = LR_UNSET, latency = -1, netrate = -1;\n\tstatic double last_link = 0.0;\n\n\tif (screen && did_set_defer) {\n\t\t/* reset defer in case we changed it */\n\t\tscreen->deferUpdateTime = defer_update;\n\t}\n\tif (waitms == 0) {\n\t\treturn waitms;\n\t}\n\tif (nofb) {\n\t\treturn waitms;\n\t}\n\n\tif (first) {\n\t\tfor(i=0; i<ndt; i++) {\n\t\t\tdts[i] = 0.0;\n\t\t}\n\t\tif (getenv(\"DEBUG_DELAY\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_DELAY\"));\n\t\t}\n\t\tif (getenv(\"SET_DEFER\")) {\n\t\t\tset_defer = atoi(getenv(\"SET_DEFER\"));\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now > last_link + 30.0 || link == LR_UNSET) {\n\t\tlink = link_rate(&latency, &netrate);\n\t\tlast_link = now;\n\t}\n\n\t/*\n\t * first check for bogdown, e.g. lots of activity, scrolling text\n\t * from command output, etc.\n\t */\n\tif (nap_ok) {\n\t\tdt = 0.0;\n\t}\n\tif (! wait_bog) {\n\t\tbogdown = 0;\n\n\t} else if (button_mask || now < last_keyboard_time + 2*bogdown_time) {\n\t\t/*\n\t\t * let scrolls & keyboard input through the normal way\n\t\t * otherwise, it will likely just annoy them.\n\t\t */\n\t\tbogdown = 0;\n\n\t} else if (dt > 0.0) {\n\t\t/*\n\t\t * inspect recent dt's:\n\t\t * 0 1 2 3 4 5 6 7 dt\n\t\t *             ^ ^ ^\n\t\t */\n\t\tfor (i = ndt - (nave - 1); i < ndt; i++) {\n\t\t\tbave += dts[i];\n\t\t\tbcnt++;\n\t\t\tif (dts[i] < bogdown_time) {\n\t\t\t\tbogdown = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbave += dt;\n\t\tbcnt++;\n\t\tbave = bave / bcnt;\n\t\tif (dt < bogdown_time) {\n\t\t\tbogdown = 0;\n\t\t}\n\t} else {\n\t\tbogdown = 0;\n\t}\n\t/* shift for next time */\n\tfor (i = 0; i < ndt-1; i++) {\n\t\tdts[i] = dts[i+1];\n\t}\n\tdts[ndt-1] = dt;\n\nif (0 && dt > 0.0) fprintf(stderr, \"dt: %.5f %.4f\\n\", dt, dnowx());\n\tif (bogdown) {\n\t\tif (use_xdamage) {\n\t\t\t/* DAMAGE can queue ~1000 rectangles for a scroll */\n\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t}\n\t\tmsec = (int) (1000 * 1.75 * bave);\n\t\tif (dts[ndt - nave - 1] > 0.75 * bave) {\n\t\t\tmsec = 1.5 * msec;\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t}\n\t\tif (msec > 1500) {\n\t\t\tmsec = 1500;\n\t\t}\n\t\tif (msec < waitms) {\n\t\t\tmsec = waitms;\n\t\t}\n\t\tdb = (db || debug_tiles);\n\t\tif (db) fprintf(stderr, \"bogg[%d] %.3f %.3f %.3f %.3f\\n\",\n\t\t    msec, dts[ndt-4], dts[ndt-3], dts[ndt-2], dts[ndt-1]);\n\n\t\treturn msec;\n\t}\n\n\t/* next check for pointer motion, keystrokes, to speed up */\n\tt2 = dnow();\n\tx2 = cursor_x;\n\ty2 = cursor_y;\n\n\tdx0 = nabs(x1 - x0);\n\tdy0 = nabs(y1 - y0);\n\tdx1 = nabs(x2 - x1);\n\tdy1 = nabs(y2 - y1);\n\n\t/* bigger displacement for most recent dt: */\n\tif (dx1 > dy1) {\n\t\tdm = dx1;\n\t} else {\n\t\tdm = dy1;\n\t}\n\n\tif ((dx0 || dy0) && (dx1 || dy1)) {\n\t\t/* if mouse moved the previous two times: */\n\t\tif (t2 < t0 + cut1 || t2 < t1 + cut2 || dm > 20) {\n\t\t\t/*\n\t\t\t * if within 0.15s(0) or 0.075s(1) or mouse\n\t\t\t * moved > 20pixels, set and bump up the cut\n\t\t\t * down factor.\n\t\t\t */\n\t\t\tfac = wait_ui * 1.5;\n\t\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t\tfac = wait_ui;\n\t\t} else {\n\t\t\t/* still 1.0? */\n\t\t\tif (db > 1) fprintf(stderr, \"wait_ui: still 1.0\\n\");\n\t\t}\n\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t/* if mouse moved > 40 last time: */\n\t\tfac = wait_ui;\n\t}\n\n\tif (fac == 1.0 && t2 < last_keyboard_time + cut3) {\n\t\t/* if typed in last 0.25s set wait_ui */\n\t\tfac = wait_ui;\n\t}\n\tif (fac != 1.0) {\n\t\tif (link == LR_LAN || latency <= 3) {\n\t\t\tfac *= 1.5;\n\t\t}\n\t}\n\n\tmsec = (int) (((double) waitms) / fac);\n\tif (msec == 0) {\n\t\tmsec = 1;\n\t}\n\n\tif (set_defer && fac != 1.0 && screen) {\n\t\t/* this is wait_ui mode, set defer to match wait: */\n\t\tif (set_defer >= 1) {\n\t\t\tscreen->deferUpdateTime = msec;\n\t\t} else if (set_defer <= -1) {\n\t\t\tscreen->deferUpdateTime = 0;\n\t\t}\n\t\tif (nabs(set_defer) == 2) {\n\t\t\turgent_update = 1;\n\t\t}\n\t\tdid_set_defer = 1;\n\t}\n\n\tx0 = x1;\n\ty0 = y1;\n\tt0 = t1;\n\n\tx1 = x2;\n\ty1 = y2;\n\tt1 = t2;\n\n\tif (db > 1) fprintf(stderr, \"wait: %2d defer[%02d]: %2d\\n\", msec, defer_update, screen->deferUpdateTime);\n\n\treturn msec;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_colormap(int reset);",
      "int parse_rotate_string(char *str, int *mode);",
      "int scale_round(int len, double fac);",
      "rfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);",
      "static int choose_delay(double dt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"wait: %2d defer[%02d]: %2d\\n\"",
            "msec",
            "defer_update",
            "screen->deferUpdateTime"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "set_defer"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"wait_ui: still 1.0\\n\""
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bogg[%d] %.3f %.3f %.3f %.3f\\n\"",
            "msec",
            "dts[ndt-4]",
            "dts[ndt-3]",
            "dts[ndt-2]",
            "dts[ndt-1]"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_xdamage_mark",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "set_xdamage_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2441-2459",
          "snippet": "void set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid set_xdamage_mark(int x, int y, int w, int h) {\n\tsraRegionPtr region;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\tmark_for_xdamage(x, y, w, h);\n\n\tif (xdamage_scheduled_mark == 0.0) {\n\t\txdamage_scheduled_mark = dnow() + 2.0;\n\t}\n\n\tif (xdamage_scheduled_mark_region == NULL) {\n\t\txdamage_scheduled_mark_region = sraRgnCreate();\n\t}\n\tregion = sraRgnCreateRect(x, y, x + w, y + w);\n\tsraRgnOr(xdamage_scheduled_mark_region, region);\n\tsraRgnDestroy(region);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_xdamage_mark_region",
          "args": [
            "NULL",
            "0"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "clear_xdamage_mark_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "212-258",
          "snippet": "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush);\n\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dt: %.5f %.4f\\n\"",
            "dt",
            "dnowx()"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"SET_DEFER\")"
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SET_DEFER\""
          ],
          "line": 4232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SET_DEFER\""
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"DEBUG_DELAY\")"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_DELAY\""
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_DELAY\""
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_colormap(int reset);\nint parse_rotate_string(char *str, int *mode);\nint scale_round(int len, double fac);\nrfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);\nstatic int choose_delay(double dt);\n\nstatic int choose_delay(double dt) {\n\tstatic double t0 = 0.0, t1 = 0.0, t2 = 0.0, now; \n\tstatic int x0, y0, x1, y1, x2, y2, first = 1;\n\tint dx0, dy0, dx1, dy1, dm, i, msec = waitms;\n\tdouble cut1 = 0.15, cut2 = 0.075, cut3 = 0.25;\n\tdouble bogdown_time = 0.25, bave = 0.0;\n\tint bogdown = 1, bcnt = 0;\n\tint ndt = 8, nave = 3;\n\tdouble fac = 1.0;\n\tstatic int db = 0, did_set_defer = 0;\n\tstatic double dts[8];\n\tstatic int link = LR_UNSET, latency = -1, netrate = -1;\n\tstatic double last_link = 0.0;\n\n\tif (screen && did_set_defer) {\n\t\t/* reset defer in case we changed it */\n\t\tscreen->deferUpdateTime = defer_update;\n\t}\n\tif (waitms == 0) {\n\t\treturn waitms;\n\t}\n\tif (nofb) {\n\t\treturn waitms;\n\t}\n\n\tif (first) {\n\t\tfor(i=0; i<ndt; i++) {\n\t\t\tdts[i] = 0.0;\n\t\t}\n\t\tif (getenv(\"DEBUG_DELAY\")) {\n\t\t\tdb = atoi(getenv(\"DEBUG_DELAY\"));\n\t\t}\n\t\tif (getenv(\"SET_DEFER\")) {\n\t\t\tset_defer = atoi(getenv(\"SET_DEFER\"));\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\tnow = dnow();\n\n\tif (now > last_link + 30.0 || link == LR_UNSET) {\n\t\tlink = link_rate(&latency, &netrate);\n\t\tlast_link = now;\n\t}\n\n\t/*\n\t * first check for bogdown, e.g. lots of activity, scrolling text\n\t * from command output, etc.\n\t */\n\tif (nap_ok) {\n\t\tdt = 0.0;\n\t}\n\tif (! wait_bog) {\n\t\tbogdown = 0;\n\n\t} else if (button_mask || now < last_keyboard_time + 2*bogdown_time) {\n\t\t/*\n\t\t * let scrolls & keyboard input through the normal way\n\t\t * otherwise, it will likely just annoy them.\n\t\t */\n\t\tbogdown = 0;\n\n\t} else if (dt > 0.0) {\n\t\t/*\n\t\t * inspect recent dt's:\n\t\t * 0 1 2 3 4 5 6 7 dt\n\t\t *             ^ ^ ^\n\t\t */\n\t\tfor (i = ndt - (nave - 1); i < ndt; i++) {\n\t\t\tbave += dts[i];\n\t\t\tbcnt++;\n\t\t\tif (dts[i] < bogdown_time) {\n\t\t\t\tbogdown = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbave += dt;\n\t\tbcnt++;\n\t\tbave = bave / bcnt;\n\t\tif (dt < bogdown_time) {\n\t\t\tbogdown = 0;\n\t\t}\n\t} else {\n\t\tbogdown = 0;\n\t}\n\t/* shift for next time */\n\tfor (i = 0; i < ndt-1; i++) {\n\t\tdts[i] = dts[i+1];\n\t}\n\tdts[ndt-1] = dt;\n\nif (0 && dt > 0.0) fprintf(stderr, \"dt: %.5f %.4f\\n\", dt, dnowx());\n\tif (bogdown) {\n\t\tif (use_xdamage) {\n\t\t\t/* DAMAGE can queue ~1000 rectangles for a scroll */\n\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t}\n\t\tmsec = (int) (1000 * 1.75 * bave);\n\t\tif (dts[ndt - nave - 1] > 0.75 * bave) {\n\t\t\tmsec = 1.5 * msec;\n\t\t\tset_xdamage_mark(0, 0, dpy_x, dpy_y);\n\t\t}\n\t\tif (msec > 1500) {\n\t\t\tmsec = 1500;\n\t\t}\n\t\tif (msec < waitms) {\n\t\t\tmsec = waitms;\n\t\t}\n\t\tdb = (db || debug_tiles);\n\t\tif (db) fprintf(stderr, \"bogg[%d] %.3f %.3f %.3f %.3f\\n\",\n\t\t    msec, dts[ndt-4], dts[ndt-3], dts[ndt-2], dts[ndt-1]);\n\n\t\treturn msec;\n\t}\n\n\t/* next check for pointer motion, keystrokes, to speed up */\n\tt2 = dnow();\n\tx2 = cursor_x;\n\ty2 = cursor_y;\n\n\tdx0 = nabs(x1 - x0);\n\tdy0 = nabs(y1 - y0);\n\tdx1 = nabs(x2 - x1);\n\tdy1 = nabs(y2 - y1);\n\n\t/* bigger displacement for most recent dt: */\n\tif (dx1 > dy1) {\n\t\tdm = dx1;\n\t} else {\n\t\tdm = dy1;\n\t}\n\n\tif ((dx0 || dy0) && (dx1 || dy1)) {\n\t\t/* if mouse moved the previous two times: */\n\t\tif (t2 < t0 + cut1 || t2 < t1 + cut2 || dm > 20) {\n\t\t\t/*\n\t\t\t * if within 0.15s(0) or 0.075s(1) or mouse\n\t\t\t * moved > 20pixels, set and bump up the cut\n\t\t\t * down factor.\n\t\t\t */\n\t\t\tfac = wait_ui * 1.5;\n\t\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t\tfac = wait_ui;\n\t\t} else {\n\t\t\t/* still 1.0? */\n\t\t\tif (db > 1) fprintf(stderr, \"wait_ui: still 1.0\\n\");\n\t\t}\n\t} else if ((dx1 || dy1) && dm > 40) {\n\t\t/* if mouse moved > 40 last time: */\n\t\tfac = wait_ui;\n\t}\n\n\tif (fac == 1.0 && t2 < last_keyboard_time + cut3) {\n\t\t/* if typed in last 0.25s set wait_ui */\n\t\tfac = wait_ui;\n\t}\n\tif (fac != 1.0) {\n\t\tif (link == LR_LAN || latency <= 3) {\n\t\t\tfac *= 1.5;\n\t\t}\n\t}\n\n\tmsec = (int) (((double) waitms) / fac);\n\tif (msec == 0) {\n\t\tmsec = 1;\n\t}\n\n\tif (set_defer && fac != 1.0 && screen) {\n\t\t/* this is wait_ui mode, set defer to match wait: */\n\t\tif (set_defer >= 1) {\n\t\t\tscreen->deferUpdateTime = msec;\n\t\t} else if (set_defer <= -1) {\n\t\t\tscreen->deferUpdateTime = 0;\n\t\t}\n\t\tif (nabs(set_defer) == 2) {\n\t\t\turgent_update = 1;\n\t\t}\n\t\tdid_set_defer = 1;\n\t}\n\n\tx0 = x1;\n\ty0 = y1;\n\tt0 = t1;\n\n\tx1 = x2;\n\ty1 = y2;\n\tt1 = t2;\n\n\tif (db > 1) fprintf(stderr, \"wait: %2d defer[%02d]: %2d\\n\", msec, defer_update, screen->deferUpdateTime);\n\n\treturn msec;\n}"
  },
  {
    "function_name": "record_last_fb_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "4150-4196",
    "snippet": "static void record_last_fb_update(void) {\n\tstatic int rbs0 = -1;\n\tstatic time_t last_call = 0;\n\ttime_t now = time(NULL);\n\tint rbs = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (last_fb_bytes_sent == 0) {\n\t\tlast_fb_bytes_sent = now;\n\t\tlast_call = now;\n\t}\n\n\tif (now <= last_call + 1) {\n\t\t/* check every second or so */\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tlast_call = now;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n#if 0\n\t\trbs += cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\trbs += rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (rbs != rbs0) {\n\t\trbs0 = rbs;\n\t\tif (debug_tiles > 1) {\n\t\t\tfprintf(stderr, \"record_last_fb_update: %d %d\\n\",\n\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t}\n\t\tlast_fb_bytes_sent = now;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static void record_last_fb_update(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_last_fb_update: %d %d\\n\"",
            "(int) now",
            "(int) last_fb_bytes_sent"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetSentBytesIfRaw",
          "args": [
            "cl"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void record_last_fb_update(void);\n\nstatic void record_last_fb_update(void) {\n\tstatic int rbs0 = -1;\n\tstatic time_t last_call = 0;\n\ttime_t now = time(NULL);\n\tint rbs = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (last_fb_bytes_sent == 0) {\n\t\tlast_fb_bytes_sent = now;\n\t\tlast_call = now;\n\t}\n\n\tif (now <= last_call + 1) {\n\t\t/* check every second or so */\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tlast_call = now;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n#if 0\n\t\trbs += cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\trbs += rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (rbs != rbs0) {\n\t\trbs0 = rbs;\n\t\tif (debug_tiles > 1) {\n\t\t\tfprintf(stderr, \"record_last_fb_update: %d %d\\n\",\n\t\t\t    (int) now, (int) last_fb_bytes_sent);\n\t\t}\n\t\tlast_fb_bytes_sent = now;\n\t}\n}"
  },
  {
    "function_name": "check_filexfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "4109-4148",
    "snippet": "static void check_filexfer(void) {\n\tstatic time_t last_check = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint transferring = 0; \n\t\n\tif (time(NULL) <= last_check) {\n\t\treturn;\n\t}\n\n#if 0\n\tif (getenv(\"NOFT\")) {\n\t\treturn;\n\t}\n#endif\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->fileTransfer.receiving) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (cl->fileTransfer.sending) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (transferring) {\n\t\tdouble start = dnow();\n\t\twhile (dnow() < start + 0.5) {\n\t\t\trfbCFD(5000);\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t} else {\n\t\tlast_check = time(NULL);\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static void check_filexfer(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "0"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"NOFT\""
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void check_filexfer(void);\n\nstatic void check_filexfer(void) {\n\tstatic time_t last_check = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint transferring = 0; \n\t\n\tif (time(NULL) <= last_check) {\n\t\treturn;\n\t}\n\n#if 0\n\tif (getenv(\"NOFT\")) {\n\t\treturn;\n\t}\n#endif\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->fileTransfer.receiving) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (cl->fileTransfer.sending) {\n\t\t\ttransferring = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (transferring) {\n\t\tdouble start = dnow();\n\t\twhile (dnow() < start + 0.5) {\n\t\t\trfbCFD(5000);\n\t\t\trfbCFD(1000);\n\t\t\trfbCFD(0);\n\t\t}\n\t} else {\n\t\tlast_check = time(NULL);\n\t}\n}"
  },
  {
    "function_name": "check_cursor_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "4057-4102",
    "snippet": "static void check_cursor_changes(void) {\n\tstatic double last_push = 0.0;\n\n\tif (unixpw_in_progress) return;\n\n\tcursor_changes += check_x11_pointer();\n\n\tif (cursor_changes) {\n\t\tdouble tm, max_push = 0.125, multi_push = 0.01, wait = 0.02;\n\t\tint dopush = 0, link, latency, netrate;\n\n\t\tif (! all_clients_initialized()) {\n\t\t\t/* play it safe */\n\t\t\treturn;\n\t\t}\n\t\n\t\tdtime0(&tm);\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP) {\n\t\t\tmax_push = 0.2;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tmax_push = 0.075;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_LAN) {\n\t\t\tmax_push = 0.01;\n\t\t} else if (latency < 5 && netrate > 200) {\n\t\t\tmax_push = 0.01;\n\t\t}\n\t\t\n\t\tif (tm > last_push + max_push) {\n\t\t\tdopush = 1;\n\t\t} else if (cursor_changes > 1 && tm > last_push + multi_push) {\n\t\t\tdopush = 1;\n\t\t}\n\n\t\tif (dopush) { \n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tfb_push_wait(wait, FB_MOD);\n\t\t\tlast_push = tm;\n\t\t} else {\n\t\t\trfbPE(0);\n\t\t}\n\t}\n\tcursor_changes = 0;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_cursor_changes(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "0"
          ],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "wait",
            "FB_MOD"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "1",
            "1",
            "1"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&tm"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_x11_pointer",
          "args": [],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "check_x11_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1985-2112",
          "snippet": "int check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_which_cursor(void);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "int check_x11_pointer(void);",
            "unsigned long get_cursor_serial(int mode);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_which_cursor(void);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nint check_x11_pointer(void);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nint check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void check_cursor_changes(void);\n\nstatic void check_cursor_changes(void) {\n\tstatic double last_push = 0.0;\n\n\tif (unixpw_in_progress) return;\n\n\tcursor_changes += check_x11_pointer();\n\n\tif (cursor_changes) {\n\t\tdouble tm, max_push = 0.125, multi_push = 0.01, wait = 0.02;\n\t\tint dopush = 0, link, latency, netrate;\n\n\t\tif (! all_clients_initialized()) {\n\t\t\t/* play it safe */\n\t\t\treturn;\n\t\t}\n\t\n\t\tdtime0(&tm);\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_DIALUP) {\n\t\t\tmax_push = 0.2;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tmax_push = 0.075;\n\t\t\twait = 0.05;\n\t\t} else if (link == LR_LAN) {\n\t\t\tmax_push = 0.01;\n\t\t} else if (latency < 5 && netrate > 200) {\n\t\t\tmax_push = 0.01;\n\t\t}\n\t\t\n\t\tif (tm > last_push + max_push) {\n\t\t\tdopush = 1;\n\t\t} else if (cursor_changes > 1 && tm > last_push + multi_push) {\n\t\t\tdopush = 1;\n\t\t}\n\n\t\tif (dopush) { \n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tfb_push_wait(wait, FB_MOD);\n\t\t\tlast_push = tm;\n\t\t} else {\n\t\t\trfbPE(0);\n\t\t}\n\t}\n\tcursor_changes = 0;\n}"
  },
  {
    "function_name": "set_vnc_desktop_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3970-4055",
    "snippet": "void set_vnc_desktop_name(void) {\n\tsprintf(vnc_desktop_name, \"unknown\");\n\tif (inetd) {\n\t\tchar *host = this_host();\n\t\tsprintf(vnc_desktop_name, \"%s/inetd-no-further-clients\", host);\n\t\tfree(host);\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (screen->port) {\n\n\t\tdo_mention_java_urls();\n\n\t\tif (use_openssl) {\n\t\t\tannounce(screen->port, 1, listen_str);\n\t\t} else {\n\t\t\tannounce(screen->port, 0, listen_str);\n\t\t}\n\t\tif (stunnel_port) {\n\t\t\tannounce(stunnel_port, 1, NULL);\n\t\t}\n\n\t\tdo_announce_http();\n\t\t\n\t\tfflush(stderr);\t\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port != 0) */\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (enc_str) {\n\t\t\t\t\tfprintf(stdout, \"ENCPORT=%d\\n\", screen->port);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfflush(stdout);\t\n\t\t\tif (flagfile) {\n\t\t\t\tFILE *flag = fopen(flagfile, \"w\");\n\t\t\t\tif (flag) {\n\t\t\t\t\tfprintf(flag, \"PORT=%d\\n\",screen->port);\n\t\t\t\t\tif (stunnel_port) {\n\t\t\t\t\t\tfprintf(flag, \"SSL_PORT=%d\\n\",\n\t\t\t\t\t\t    stunnel_port);\n\t\t\t\t\t}\n\t\t\t\t\tfflush(flag);\t\n\t\t\t\t\tfclose(flag);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"could not open flag file: %s\\n\",\n\t\t\t\t\t    flagfile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rm_flagfile) {\n\t\t\t\tint create = 0;\n\t\t\t\tstruct stat sb;\n\t\t\t\tif (strstr(rm_flagfile, \"create:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 1;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"create:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tif (strstr(rm_flagfile, \"nocreate:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 0;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"nocreate:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t} else if (stat(rm_flagfile, &sb) != 0) {\n\t\t\t\t\tcreate = 1;\n\t\t\t\t}\n\t\t\t\tif (create) {\n\t\t\t\t\tFILE *flag = fopen(rm_flagfile, \"w\");\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tfprintf(flag, \"%d\\n\", getpid());\n\t\t\t\t\t\tfclose(flag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\t\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_vnc_desktop_name(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "flag"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "flag",
            "\"%d\\n\"",
            "getpid()"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "rm_flagfile",
            "\"w\""
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "rm_flagfile",
            "&sb"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rm_flagfile + strlen(\"nocreate:\")"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"nocreate:\""
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rm_flagfile",
            "\"nocreate:\""
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rm_flagfile + strlen(\"create:\")"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"create:\""
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rm_flagfile",
            "\"create:\""
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not open flag file: %s\\n\"",
            "flagfile"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "flag"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "flag"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "flag",
            "\"SSL_PORT=%d\\n\"",
            "stunnel_port"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "flag",
            "\"PORT=%d\\n\"",
            "screen->port"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "flagfile",
            "\"w\""
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"SSLPORT=%d\\n\"",
            "screen->port"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"ENCPORT=%d\\n\"",
            "screen->port"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"SSLPORT=%d\\n\"",
            "stunnel_port"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"PORT=%d\\n\"",
            "screen->port"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_announce_http",
          "args": [],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "do_announce_http",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3899-3939",
          "snippet": "void do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "announce",
          "args": [
            "stunnel_port",
            "1",
            "NULL"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "announce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3797-3863",
          "snippet": "void announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}"
          ],
          "globals_used": [
            "void announce(int lport, int ssl, char *iface);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}\n\nvoid announce(int lport, int ssl, char *iface);\n\nvoid announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mention_java_urls",
          "args": [],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "do_mention_java_urls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3941-3968",
          "snippet": "void do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "vnc_desktop_name",
            "\"%s/inetd-no-further-clients\"",
            "host"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "vnc_desktop_name",
            "\"unknown\""
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_vnc_desktop_name(void);\n\nvoid set_vnc_desktop_name(void) {\n\tsprintf(vnc_desktop_name, \"unknown\");\n\tif (inetd) {\n\t\tchar *host = this_host();\n\t\tsprintf(vnc_desktop_name, \"%s/inetd-no-further-clients\", host);\n\t\tfree(host);\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\tif (screen->port) {\n\n\t\tdo_mention_java_urls();\n\n\t\tif (use_openssl) {\n\t\t\tannounce(screen->port, 1, listen_str);\n\t\t} else {\n\t\t\tannounce(screen->port, 0, listen_str);\n\t\t}\n\t\tif (stunnel_port) {\n\t\t\tannounce(stunnel_port, 1, NULL);\n\t\t}\n\n\t\tdo_announce_http();\n\t\t\n\t\tfflush(stderr);\t\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port != 0) */\n\t\t} else {\n\t\t\tfprintf(stdout, \"PORT=%d\\n\", screen->port);\n\t\t\tif (stunnel_port) {\n\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", stunnel_port);\n\t\t\t} else if (use_openssl) {\n\t\t\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t\t;\n\t\t\t\t} else if (enc_str) {\n\t\t\t\t\tfprintf(stdout, \"ENCPORT=%d\\n\", screen->port);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stdout, \"SSLPORT=%d\\n\", screen->port);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfflush(stdout);\t\n\t\t\tif (flagfile) {\n\t\t\t\tFILE *flag = fopen(flagfile, \"w\");\n\t\t\t\tif (flag) {\n\t\t\t\t\tfprintf(flag, \"PORT=%d\\n\",screen->port);\n\t\t\t\t\tif (stunnel_port) {\n\t\t\t\t\t\tfprintf(flag, \"SSL_PORT=%d\\n\",\n\t\t\t\t\t\t    stunnel_port);\n\t\t\t\t\t}\n\t\t\t\t\tfflush(flag);\t\n\t\t\t\t\tfclose(flag);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"could not open flag file: %s\\n\",\n\t\t\t\t\t    flagfile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rm_flagfile) {\n\t\t\t\tint create = 0;\n\t\t\t\tstruct stat sb;\n\t\t\t\tif (strstr(rm_flagfile, \"create:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 1;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"create:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tif (strstr(rm_flagfile, \"nocreate:\") == rm_flagfile) {\n\t\t\t\t\tchar *s = rm_flagfile;\n\t\t\t\t\tcreate = 0;\n\t\t\t\t\trm_flagfile = strdup(rm_flagfile + strlen(\"nocreate:\"));\n\t\t\t\t\tfree(s);\n\t\t\t\t} else if (stat(rm_flagfile, &sb) != 0) {\n\t\t\t\t\tcreate = 1;\n\t\t\t\t}\n\t\t\t\tif (create) {\n\t\t\t\t\tFILE *flag = fopen(rm_flagfile, \"w\");\n\t\t\t\t\tif (flag) {\n\t\t\t\t\t\tfprintf(flag, \"%d\\n\", getpid());\n\t\t\t\t\t\tfclose(flag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfflush(stdout);\t\n\t}\n}"
  },
  {
    "function_name": "do_mention_java_urls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3941-3968",
    "snippet": "void do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\""
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Append ?GET=1 to a URL for faster loading or supply:\\n\""
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"whatever is needed to reach the host e.g. Internet IP number\\n\""
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Where you replace \\\"host:port\\\" with that printed below, or\\n\""
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\""
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\""
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\""
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\""
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Here are some additional possibilities:\\n\""
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"be used for Java enabled Web browser connections.\\n\""
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"The URLs printed out below ('Java ... viewer URL') can\\n\""
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_mention_java_urls(void) {\n\tif (! quiet && screen) {\n\t\t/* XXX ipv6? */\n\t\tif (screen->httpListenSock > -1 && screen->httpPort) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"The URLs printed out below ('Java ... viewer URL') can\\n\");\n\t\t\trfbLog(\"be used for Java enabled Web browser connections.\\n\");\n\t\t\tif (!stunnel_port && enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\t\t;\n\t\t\t} else if (use_openssl || stunnel_port) {\n\t\t\t\trfbLog(\"Here are some additional possibilities:\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/proxy.vnc (MUST be used if Web Proxy used)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultra.vnc (Use UltraVNC Java Viewer)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultraproxy.vnc (Web Proxy with UltraVNC)\\n\");\n\t\t\t\trfbLog(\"https://host:port/ultrasigned.vnc (Signed UltraVNC Filexfer)\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Where you replace \\\"host:port\\\" with that printed below, or\\n\");\n\t\t\t\trfbLog(\"whatever is needed to reach the host e.g. Internet IP number\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"Append ?GET=1 to a URL for faster loading or supply:\\n\");\n\t\t\t\trfbLog(\"-env X11VNC_EXTRA_HTTPS_PARAMS='?GET=1' to cmdline.\\n\");\n\t\t\t}\n\t\t}\n\t\trfbLog(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "do_announce_http",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3899-3939",
    "snippet": "void do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "announce_http",
          "args": [
            "screen->port",
            "1",
            "NULL",
            "SPORT"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "announce_http",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3865-3897",
          "snippet": "static void announce_http(int lport, int ssl, char *iface, char *extra) {\n\t/* Result of this_host is allocated memory and must be freed. */\n\tchar *host = this_host();\n\tchar *phost = host;\n\tchar *jvu;\n\tint http = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\") && !use_stunnel) {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t} else if (ssl == 1) {\n\t\tjvu = \"Java SSL viewer URL:     https\";\n\t} else if (ssl == 2) {\n\t\tjvu = \"Java SSL viewer URL:     http\";\n\t\thttp = 1;\n\t} else {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tphost = iface;\n\t}\n\tif (http && getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\tphost = \"localhost\";\n\t}\n\tif (phost != NULL) {\n\t\tif (! inetd) {\n\t\t\tfprintf(stderr, \"%s://%s:%d/%s\\n\", jvu, phost, lport, extra);\n\t\t}\n\t}\n\tfree(host);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void announce(int lport, int ssl, char *iface);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid announce(int lport, int ssl, char *iface);\n\nstatic void announce_http(int lport, int ssl, char *iface, char *extra) {\n\t/* Result of this_host is allocated memory and must be freed. */\n\tchar *host = this_host();\n\tchar *phost = host;\n\tchar *jvu;\n\tint http = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\") && !use_stunnel) {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t} else if (ssl == 1) {\n\t\tjvu = \"Java SSL viewer URL:     https\";\n\t} else if (ssl == 2) {\n\t\tjvu = \"Java SSL viewer URL:     http\";\n\t\thttp = 1;\n\t} else {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tphost = iface;\n\t}\n\tif (http && getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\tphost = \"localhost\";\n\t}\n\tif (phost != NULL) {\n\t\tif (! inetd) {\n\t\t\tfprintf(stderr, \"%s://%s:%d/%s\\n\", jvu, phost, lport, extra);\n\t\t}\n\t}\n\tfree(host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "pmsg",
            "SPORT"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pmsg",
            "\"?PORT=%d\"",
            "stunnel_port"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_announce_http(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\t/* XXX ipv6? */\n\tif ((screen->httpListenSock > -1 || ipv6_http_fd > -1) && screen->httpPort) {\n\t\tint enc_none = (enc_str && !strcmp(enc_str, \"none\"));\n\t\tchar *SPORT = \"   (single port)\";\n\t\tif (use_openssl && ! enc_none) {\n\t\t\tannounce_http(screen->port, 1, listen_str, SPORT);\n\t\t\tif (https_port_num >= 0) {\n\t\t\t\tannounce_http(https_port_num, 1,\n\t\t\t\t    listen_str, \"\");\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, \"\");\n\t\t} else if (use_stunnel) {\n\t\t\tchar pmsg[100];\n\t\t\tpmsg[0] = '\\0';\n\t\t\tif (stunnel_port) {\n\t\t\t\tsprintf(pmsg, \"?PORT=%d\", stunnel_port);\n\t\t\t}\n\t\t\tannounce_http(screen->httpPort, 2, listen_str, pmsg);\n\t\t\tif (stunnel_http_port > 0) {\n\t\t\t\tannounce_http(stunnel_http_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t\tif (enc_none) {\n\t\t\t\tstrcat(pmsg, SPORT);\n\t\t\t\tannounce_http(stunnel_port, 1, NULL, pmsg);\n\t\t\t}\n\t\t} else {\n\t\t\tannounce_http(screen->httpPort, 0, listen_str, \"\");\n\t\t\tif (enc_none) {\n\t\t\t\tannounce_http(screen->port, 1, NULL, SPORT);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "announce_http",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3865-3897",
    "snippet": "static void announce_http(int lport, int ssl, char *iface, char *extra) {\n\t/* Result of this_host is allocated memory and must be freed. */\n\tchar *host = this_host();\n\tchar *phost = host;\n\tchar *jvu;\n\tint http = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\") && !use_stunnel) {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t} else if (ssl == 1) {\n\t\tjvu = \"Java SSL viewer URL:     https\";\n\t} else if (ssl == 2) {\n\t\tjvu = \"Java SSL viewer URL:     http\";\n\t\thttp = 1;\n\t} else {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tphost = iface;\n\t}\n\tif (http && getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\tphost = \"localhost\";\n\t}\n\tif (phost != NULL) {\n\t\tif (! inetd) {\n\t\t\tfprintf(stderr, \"%s://%s:%d/%s\\n\", jvu, phost, lport, extra);\n\t\t}\n\t}\n\tfree(host);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void announce(int lport, int ssl, char *iface);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s://%s:%d/%s\\n\"",
            "jvu",
            "phost",
            "lport",
            "extra"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTP_LISTEN_LOCALHOST\""
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "iface",
            "\"any\""
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid announce(int lport, int ssl, char *iface);\n\nstatic void announce_http(int lport, int ssl, char *iface, char *extra) {\n\t/* Result of this_host is allocated memory and must be freed. */\n\tchar *host = this_host();\n\tchar *phost = host;\n\tchar *jvu;\n\tint http = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\") && !use_stunnel) {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t} else if (ssl == 1) {\n\t\tjvu = \"Java SSL viewer URL:     https\";\n\t} else if (ssl == 2) {\n\t\tjvu = \"Java SSL viewer URL:     http\";\n\t\thttp = 1;\n\t} else {\n\t\tjvu = \"Java viewer URL:         http\";\n\t\thttp = 1;\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tphost = iface;\n\t}\n\tif (http && getenv(\"X11VNC_HTTP_LISTEN_LOCALHOST\")) {\n\t\tphost = \"localhost\";\n\t}\n\tif (phost != NULL) {\n\t\tif (! inetd) {\n\t\t\tfprintf(stderr, \"%s://%s:%d/%s\\n\", jvu, phost, lport, extra);\n\t\t}\n\t}\n\tfree(host);\n}"
  },
  {
    "function_name": "announce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3797-3863",
    "snippet": "void announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}"
    ],
    "globals_used": [
      "void announce(int lport, int ssl, char *iface);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"possible alias:    %s::%d\\n\"",
            "host",
            "lport"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "vnc_desktop_name",
            "sz",
            "\"%s:%d\"",
            "host",
            "lport"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\"",
            "host",
            "lport",
            "host",
            "lport"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "vnc_desktop_name",
            "sz",
            "\"%s:%d\"",
            "host",
            "lport - 5900"
          ],
          "line": 3842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "vnc_desktop_name",
            "sz",
            "\"%s:%d\"",
            "host",
            "lport"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "vnc_desktop_name",
            "sz",
            "\"%s:%d\"",
            "host",
            "lport - 5900"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "iface",
            "\"any\""
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_host",
          "args": [],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "this_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "340-351",
          "snippet": "char *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *this_host(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *this_host(void);\n\nchar *this_host(void) {\n\tchar host[MAXN];\n#if LIBVNCSERVER_HAVE_GETHOSTNAME\n\tif (gethostname(host, MAXN) == 0) {\n\t\thost[MAXN-1] = '\\0';\n\t\treturn strdup(host);\n\t} else if (UT.nodename) {\n\t\treturn strdup(UT.nodename);\n\t}\n#endif\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}\n\nvoid announce(int lport, int ssl, char *iface);\n\nvoid announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}"
  },
  {
    "function_name": "set_xlate_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3076-3090",
    "snippet": "static rfbBool set_xlate_wrapper(rfbClientPtr cl) {\n\tstatic int first = 1;\n\tif (first) {\n\t\tfirst = 0;\n\t} else if (ncache) {\n\t\tint save = ncache_xrootpmap;\n\t\trfbLog(\"set_xlate_wrapper: clearing -ncache for new pixel format.\\n\");\n\t\tINPUT_LOCK;\n\t\tncache_xrootpmap = 0;\n\t\tcheck_ncache(1, 0);\n\t\tncache_xrootpmap = save;\n\t\tINPUT_UNLOCK;\n\t}\n\treturn rfbSetTranslateFunction(cl);\t\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSetTranslateFunction",
          "args": [
            "cl"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "1",
            "0"
          ],
          "line": 3085
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_xlate_wrapper: clearing -ncache for new pixel format.\\n\""
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nstatic rfbBool set_xlate_wrapper(rfbClientPtr cl) {\n\tstatic int first = 1;\n\tif (first) {\n\t\tfirst = 0;\n\t} else if (ncache) {\n\t\tint save = ncache_xrootpmap;\n\t\trfbLog(\"set_xlate_wrapper: clearing -ncache for new pixel format.\\n\");\n\t\tINPUT_LOCK;\n\t\tncache_xrootpmap = 0;\n\t\tcheck_ncache(1, 0);\n\t\tncache_xrootpmap = save;\n\t\tINPUT_UNLOCK;\n\t}\n\treturn rfbSetTranslateFunction(cl);\t\n}"
  },
  {
    "function_name": "setup_rotating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "3054-3074",
    "snippet": "static void setup_rotating(void) {\n\tchar *rs = rotating_str;\n\n\trotating_cursors = 1;\n\tif (rs && strstr(rs, \"nc:\") == rs) {\n\t\trs += strlen(\"nc:\");\n\t\trotating_cursors = 0;\n\t}\n\n\trotating = parse_rotate_string(rs, NULL);\n\tif (! rotating) {\n\t\trotating_cursors = 0;\n\t}\n\n\tif (rotating == ROTATE_90  || rotating == ROTATE_90X ||\n\t    rotating == ROTATE_90Y || rotating == ROTATE_270) {\n\t\trotating_same = 0;\n\t} else {\n\t\trotating_same = 1;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_rotate_string",
          "args": [
            "rs",
            "NULL"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "parse_rotate_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2954-2981",
          "snippet": "int parse_rotate_string(char *str, int *mode) {\n\tint m = ROTATE_NONE;\n\tif (str == NULL || !strcmp(str, \"\") || !strcmp(str, \"0\")) {\n\t\tm = ROTATE_NONE;\n\t} else if (!strcmp(str, \"x\")) {\n\t\tm = ROTATE_X;\n\t} else if (!strcmp(str, \"y\")) {\n\t\tm = ROTATE_Y;\n\t} else if (!strcmp(str, \"xy\") || !strcmp(str, \"yx\") ||\n\t    !strcmp(str,\"+180\") || !strcmp(str,\"-180\") || !strcmp(str,\"180\")) {\n\t\tm = ROTATE_XY;\n\t} else if (!strcmp(str, \"+90\") || !strcmp(str, \"90\")) {\n\t\tm = ROTATE_90;\n\t} else if (!strcmp(str, \"+90x\") || !strcmp(str, \"90x\")) {\n\t\tm = ROTATE_90X;\n\t} else if (!strcmp(str, \"+90y\") || !strcmp(str, \"90y\")) {\n\t\tm = ROTATE_90Y;\n\t} else if (!strcmp(str, \"-90\") || !strcmp(str, \"270\") ||\n\t    !strcmp(str, \"+270\")) {\n\t\tm = ROTATE_270;\n\t} else {\n\t\trfbLog(\"invalid -rotate mode: %s\\n\", str);\n\t}\n\tif (mode) {\n\t\t*mode = m;\n\t}\n\treturn m;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int parse_rotate_string(char *str, int *mode);",
            "static void set_visual(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint parse_rotate_string(char *str, int *mode);\nstatic void set_visual(char *str);\n\nint parse_rotate_string(char *str, int *mode) {\n\tint m = ROTATE_NONE;\n\tif (str == NULL || !strcmp(str, \"\") || !strcmp(str, \"0\")) {\n\t\tm = ROTATE_NONE;\n\t} else if (!strcmp(str, \"x\")) {\n\t\tm = ROTATE_X;\n\t} else if (!strcmp(str, \"y\")) {\n\t\tm = ROTATE_Y;\n\t} else if (!strcmp(str, \"xy\") || !strcmp(str, \"yx\") ||\n\t    !strcmp(str,\"+180\") || !strcmp(str,\"-180\") || !strcmp(str,\"180\")) {\n\t\tm = ROTATE_XY;\n\t} else if (!strcmp(str, \"+90\") || !strcmp(str, \"90\")) {\n\t\tm = ROTATE_90;\n\t} else if (!strcmp(str, \"+90x\") || !strcmp(str, \"90x\")) {\n\t\tm = ROTATE_90X;\n\t} else if (!strcmp(str, \"+90y\") || !strcmp(str, \"90y\")) {\n\t\tm = ROTATE_90Y;\n\t} else if (!strcmp(str, \"-90\") || !strcmp(str, \"270\") ||\n\t    !strcmp(str, \"+270\")) {\n\t\tm = ROTATE_270;\n\t} else {\n\t\trfbLog(\"invalid -rotate mode: %s\\n\", str);\n\t}\n\tif (mode) {\n\t\t*mode = m;\n\t}\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"nc:\""
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rs",
            "\"nc:\""
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void setup_rotating(void) {\n\tchar *rs = rotating_str;\n\n\trotating_cursors = 1;\n\tif (rs && strstr(rs, \"nc:\") == rs) {\n\t\trs += strlen(\"nc:\");\n\t\trotating_cursors = 0;\n\t}\n\n\trotating = parse_rotate_string(rs, NULL);\n\tif (! rotating) {\n\t\trotating_cursors = 0;\n\t}\n\n\tif (rotating == ROTATE_90  || rotating == ROTATE_90X ||\n\t    rotating == ROTATE_90Y || rotating == ROTATE_270) {\n\t\trotating_same = 0;\n\t} else {\n\t\trotating_same = 1;\n\t}\n}"
  },
  {
    "function_name": "setup_scaling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2993-3052",
    "snippet": "static void setup_scaling(int *width_in, int *height_in) {\n\tint width  = *width_in;\n\tint height = *height_in;\n\n\tparse_scale_string(scale_str, &scale_fac_x, &scale_fac_y, &scaling, &scaling_blend,\n\t    &scaling_nomult4, &scaling_pad, &scaling_interpolate,\n\t    &scale_numer, &scale_denom, *width_in, *height_in);\n\n\tif (scaling) {\n\t\twidth  = scale_round(width,  scale_fac_x);\n\t\theight = scale_round(height, scale_fac_y);\n\t\tif (scale_denom && scaling_pad) {\n\t\t\t/* it is not clear this padding is useful anymore */\n\t\t\trfbLog(\"width  %% denom: %d %% %d = %d\\n\", width,\n\t\t\t    scale_denom, width  % scale_denom);\n\t\t\trfbLog(\"height %% denom: %d %% %d = %d\\n\", height,\n\t\t\t    scale_denom, height % scale_denom);\n\t\t\tif (width % scale_denom != 0) {\n\t\t\t\tint w = width;\n\t\t\t\tw += scale_denom - (w % scale_denom);\n\t\t\t\tif (!scaling_nomult4 && w % 4 != 0) {\n\t\t\t\t\t/* need to make mult of 4 as well */\n\t\t\t\t\tint c = 0;\t\n\t\t\t\t\twhile (w % 4 != 0 && c++ <= 5) {\n\t\t\t\t\t\tw += scale_denom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twidth = w;\n\t\t\t\trfbLog(\"padded width  to: %d (mult of %d%s\\n\",\n\t\t\t\t    width, scale_denom, !scaling_nomult4 ?\n\t\t\t\t    \" and 4)\" : \")\");\n\t\t\t}\n\t\t\tif (height % scale_denom != 0) {\n\t\t\t\theight += scale_denom - (height % scale_denom);\n\t\t\t\trfbLog(\"padded height to: %d (mult of %d)\\n\",\n\t\t\t\t    height, scale_denom);\n\t\t\t}\n\t\t}\n\t\tif (!scaling_nomult4 && width % 4 != 0 && width > 2) {\n\t\t\t/* reset width to be multiple of 4 */\n\t\t\tint width0 = width;\n\t\t\tif ((width+1) % 4 == 0) {\n\t\t\t\twidth = width+1;\n\t\t\t} else if ((width-1) % 4 == 0) {\n\t\t\t\twidth = width-1;\n\t\t\t} else if ((width+2) % 4 == 0) {\n\t\t\t\twidth = width+2;\n\t\t\t}\n\t\t\trfbLog(\"reset scaled width %d -> %d to be a multiple of\"\n\t\t\t    \" 4 (to\\n\", width0, width);\n\t\t\trfbLog(\"make vncviewers happy). use -scale m/n:n4 to \"\n\t\t\t    \"disable.\\n\");\n\t\t}\n\t\tscaled_x = width;\n\t\tscaled_y = height;\n\n\t\t*width_in  = width;\n\t\t*height_in = height;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_colormap(int reset);",
      "static void setup_scaling(int *width_in, int *height_in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"make vncviewers happy). use -scale m/n:n4 to \"\n\t\t\t    \"disable.\\n\""
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reset scaled width %d -> %d to be a multiple of\"\n\t\t\t    \" 4 (to\\n\"",
            "width0",
            "width"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"padded height to: %d (mult of %d)\\n\"",
            "height",
            "scale_denom"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"padded width  to: %d (mult of %d%s\\n\"",
            "width",
            "scale_denom",
            "!scaling_nomult4 ?\n\t\t\t\t    \" and 4)\" : \")\""
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"height %% denom: %d %% %d = %d\\n\"",
            "height",
            "scale_denom",
            "height % scale_denom"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"width  %% denom: %d %% %d = %d\\n\"",
            "width",
            "scale_denom",
            "width  % scale_denom"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_round",
          "args": [
            "height",
            "scale_fac_y"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "scale_round",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2983-2991",
          "snippet": "int scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int scale_round(int len, double fac);",
            "rfbBool vnc_reflect_send_cuttext(char *str, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint scale_round(int len, double fac);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\n\nint scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_scale_string",
          "args": [
            "scale_str",
            "&scale_fac_x",
            "&scale_fac_y",
            "&scaling",
            "&scaling_blend",
            "&scaling_nomult4",
            "&scaling_pad",
            "&scaling_interpolate",
            "&scale_numer",
            "&scale_denom",
            "*width_in",
            "*height_in"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scale_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2831-2952",
          "snippet": "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void set_visual(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_colormap(int reset);\nstatic void setup_scaling(int *width_in, int *height_in);\n\nstatic void setup_scaling(int *width_in, int *height_in) {\n\tint width  = *width_in;\n\tint height = *height_in;\n\n\tparse_scale_string(scale_str, &scale_fac_x, &scale_fac_y, &scaling, &scaling_blend,\n\t    &scaling_nomult4, &scaling_pad, &scaling_interpolate,\n\t    &scale_numer, &scale_denom, *width_in, *height_in);\n\n\tif (scaling) {\n\t\twidth  = scale_round(width,  scale_fac_x);\n\t\theight = scale_round(height, scale_fac_y);\n\t\tif (scale_denom && scaling_pad) {\n\t\t\t/* it is not clear this padding is useful anymore */\n\t\t\trfbLog(\"width  %% denom: %d %% %d = %d\\n\", width,\n\t\t\t    scale_denom, width  % scale_denom);\n\t\t\trfbLog(\"height %% denom: %d %% %d = %d\\n\", height,\n\t\t\t    scale_denom, height % scale_denom);\n\t\t\tif (width % scale_denom != 0) {\n\t\t\t\tint w = width;\n\t\t\t\tw += scale_denom - (w % scale_denom);\n\t\t\t\tif (!scaling_nomult4 && w % 4 != 0) {\n\t\t\t\t\t/* need to make mult of 4 as well */\n\t\t\t\t\tint c = 0;\t\n\t\t\t\t\twhile (w % 4 != 0 && c++ <= 5) {\n\t\t\t\t\t\tw += scale_denom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twidth = w;\n\t\t\t\trfbLog(\"padded width  to: %d (mult of %d%s\\n\",\n\t\t\t\t    width, scale_denom, !scaling_nomult4 ?\n\t\t\t\t    \" and 4)\" : \")\");\n\t\t\t}\n\t\t\tif (height % scale_denom != 0) {\n\t\t\t\theight += scale_denom - (height % scale_denom);\n\t\t\t\trfbLog(\"padded height to: %d (mult of %d)\\n\",\n\t\t\t\t    height, scale_denom);\n\t\t\t}\n\t\t}\n\t\tif (!scaling_nomult4 && width % 4 != 0 && width > 2) {\n\t\t\t/* reset width to be multiple of 4 */\n\t\t\tint width0 = width;\n\t\t\tif ((width+1) % 4 == 0) {\n\t\t\t\twidth = width+1;\n\t\t\t} else if ((width-1) % 4 == 0) {\n\t\t\t\twidth = width-1;\n\t\t\t} else if ((width+2) % 4 == 0) {\n\t\t\t\twidth = width+2;\n\t\t\t}\n\t\t\trfbLog(\"reset scaled width %d -> %d to be a multiple of\"\n\t\t\t    \" 4 (to\\n\", width0, width);\n\t\t\trfbLog(\"make vncviewers happy). use -scale m/n:n4 to \"\n\t\t\t    \"disable.\\n\");\n\t\t}\n\t\tscaled_x = width;\n\t\tscaled_y = height;\n\n\t\t*width_in  = width;\n\t\t*height_in = height;\n\t}\n}"
  },
  {
    "function_name": "scale_round",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2983-2991",
    "snippet": "int scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int scale_round(int len, double fac);",
      "rfbBool vnc_reflect_send_cuttext(char *str, int len);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint scale_round(int len, double fac);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\n\nint scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "parse_rotate_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2954-2981",
    "snippet": "int parse_rotate_string(char *str, int *mode) {\n\tint m = ROTATE_NONE;\n\tif (str == NULL || !strcmp(str, \"\") || !strcmp(str, \"0\")) {\n\t\tm = ROTATE_NONE;\n\t} else if (!strcmp(str, \"x\")) {\n\t\tm = ROTATE_X;\n\t} else if (!strcmp(str, \"y\")) {\n\t\tm = ROTATE_Y;\n\t} else if (!strcmp(str, \"xy\") || !strcmp(str, \"yx\") ||\n\t    !strcmp(str,\"+180\") || !strcmp(str,\"-180\") || !strcmp(str,\"180\")) {\n\t\tm = ROTATE_XY;\n\t} else if (!strcmp(str, \"+90\") || !strcmp(str, \"90\")) {\n\t\tm = ROTATE_90;\n\t} else if (!strcmp(str, \"+90x\") || !strcmp(str, \"90x\")) {\n\t\tm = ROTATE_90X;\n\t} else if (!strcmp(str, \"+90y\") || !strcmp(str, \"90y\")) {\n\t\tm = ROTATE_90Y;\n\t} else if (!strcmp(str, \"-90\") || !strcmp(str, \"270\") ||\n\t    !strcmp(str, \"+270\")) {\n\t\tm = ROTATE_270;\n\t} else {\n\t\trfbLog(\"invalid -rotate mode: %s\\n\", str);\n\t}\n\tif (mode) {\n\t\t*mode = m;\n\t}\n\treturn m;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int parse_rotate_string(char *str, int *mode);",
      "static void set_visual(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid -rotate mode: %s\\n\"",
            "str"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"+270\""
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"270\""
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"-90\""
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"90y\""
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"+90y\""
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"90x\""
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"+90x\""
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"90\""
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"+90\""
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"180\""
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"-180\""
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"+180\""
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"yx\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"xy\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"y\""
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"x\""
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"0\""
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"\""
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint parse_rotate_string(char *str, int *mode);\nstatic void set_visual(char *str);\n\nint parse_rotate_string(char *str, int *mode) {\n\tint m = ROTATE_NONE;\n\tif (str == NULL || !strcmp(str, \"\") || !strcmp(str, \"0\")) {\n\t\tm = ROTATE_NONE;\n\t} else if (!strcmp(str, \"x\")) {\n\t\tm = ROTATE_X;\n\t} else if (!strcmp(str, \"y\")) {\n\t\tm = ROTATE_Y;\n\t} else if (!strcmp(str, \"xy\") || !strcmp(str, \"yx\") ||\n\t    !strcmp(str,\"+180\") || !strcmp(str,\"-180\") || !strcmp(str,\"180\")) {\n\t\tm = ROTATE_XY;\n\t} else if (!strcmp(str, \"+90\") || !strcmp(str, \"90\")) {\n\t\tm = ROTATE_90;\n\t} else if (!strcmp(str, \"+90x\") || !strcmp(str, \"90x\")) {\n\t\tm = ROTATE_90X;\n\t} else if (!strcmp(str, \"+90y\") || !strcmp(str, \"90y\")) {\n\t\tm = ROTATE_90Y;\n\t} else if (!strcmp(str, \"-90\") || !strcmp(str, \"270\") ||\n\t    !strcmp(str, \"+270\")) {\n\t\tm = ROTATE_270;\n\t} else {\n\t\trfbLog(\"invalid -rotate mode: %s\\n\", str);\n\t}\n\tif (mode) {\n\t\t*mode = m;\n\t}\n\treturn m;\n}"
  },
  {
    "function_name": "parse_scale_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2831-2952",
    "snippet": "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void set_visual(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tstr"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"scaling disabled for factor %f %f\\n\"",
            "*factor_x",
            "*factor_y"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-scale factor too small: %f\\n\"",
            "*factor_x"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid -scale arg: %s\\n\"",
            "tstr"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid -scale arg: %s\\n\"",
            "tstr"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tstr",
            "\"%d\"",
            "&m"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tstr",
            "\"%d/%d\"",
            "&m",
            "&n"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tstr",
            "\"%dx%d\"",
            "&m",
            "&n"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-scale factor too small: %f\\n\"",
            "*factor_x"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid -scale arg: %s\\n\"",
            "tstr"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tstr",
            "\"%lf\"",
            "&f"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tstr",
            "\"%lfx%lf\"",
            "&f",
            "&f2"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tstr",
            "'.'"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"cr\""
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"nocr\""
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"pad\""
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"in\""
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"n4\""
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"fb\""
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "\"nb\""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tstr",
            "':'"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}"
  },
  {
    "function_name": "initialize_xdisplay_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2471-2829",
    "snippet": "XImage *initialize_xdisplay_fb(void) {\n#if NO_X11\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\treturn NULL;\n#else\n\tXImage *fb;\n\tchar *vis_str = visual_str;\n\tint try = 0, subwin_tries = 3;\n\tXErrorHandler old_handler = NULL;\n\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\n\tX_LOCK;\n\tif (subwin) {\n\t\tif (subwin_wait_mapped) {\n\t\t\twait_until_mapped(subwin);\n\t\t}\n\t\tif (!valid_window((Window) subwin, NULL, 0)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid sub-window: 0x%lx\\n\", subwin);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\t\n\tif (overlay) {\n\t\t/* \n\t\t * ideally we'd like to not have to cook up the\n\t\t * visual variables but rather let it all come out\n\t\t * of XReadScreen(), however there is no way to get\n\t\t * a default visual out of it, so we pretend -visual\n\t\t * TrueColor:NN was supplied with NN usually 24.\n\t\t */\n\t\tchar str[32];\n\t\tWindow twin = subwin ? subwin : rootwin;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(dpy, twin, 0, 0, 8, 8, False);\n\t\tsprintf(str, \"TrueColor:%d\", xi->depth);\n\t\tif (xi->depth != 24 && ! quiet) {\n\t\t\trfbLog(\"warning: overlay image has depth %d \"\n\t\t\t    \"instead of 24.\\n\", xi->depth);\n\t\t}\n\t\tXDestroyImage(xi);\n\t\tif (visual_str != NULL && ! quiet) {\n\t\t\trfbLog(\"warning: replacing '-visual %s' by '%s' \"\n\t\t\t    \"for use with -overlay\\n\", visual_str, str);\n\t\t}\n\t\tvis_str = strdup(str);\n\t}\n\n\tif (xform24to32) {\n\t\tif (DefaultDepth(dpy, scr) == 24) {\n\t\t\tvis_str = strdup(\"TrueColor:32\");\n\t\t\trfbLog(\"initialize_xdisplay_fb: vis_str set to: %s\\n\",\n\t\t\t    vis_str);\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t} else if (DefaultDepth(dpy, scr) < 8) {\n\t\t/* check very low bpp case, e.g. mono or vga16 */\n\t\tScreen *s = DefaultScreenOfDisplay(dpy);\n\t\tXImage *xi = XGetImage_wr(dpy, DefaultRootWindow(dpy), 0, 0, 2, 2, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (xi && xi->bits_per_pixel < 8) {\n\t\t\tint lowbpp = xi->bits_per_pixel; \n\t\t\tif (!vis_str) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tsprintf(tmp, \"0x%x:8\", (int) s->root_visual->visualid);\n\t\t\t\tvis_str = strdup(tmp);\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], vis_str \"\n\t\t\t\t    \"set to: %s\\n\", lowbpp, vis_str);\n\t\t\t}\n\t\t\tif (using_shm) {\n\t\t\t\tusing_shm = 0;\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], \"\n\t\t\t\t    \"disabling shm\\n\", lowbpp);\n\t\t\t}\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t}\n\n\tif (vis_str != NULL) {\n\t\tset_visual(vis_str);\n\t\tif (vis_str != visual_str) {\n\t\t\tfree(vis_str);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"vis_str %s\\n\", vis_str ? vis_str : \"notset\");\n\n\t/* set up parameters for subwin or non-subwin cases: */\n\n\tagain:\n\n\tif (! subwin) {\n\t\t/* full screen */\n\t\twindow = rootwin;\n\t\tdpy_x = wdpy_x = DisplayWidth(dpy, scr);\n\t\tdpy_y = wdpy_y = DisplayHeight(dpy, scr);\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = DefaultVisual(dpy, scr);\n\t} else {\n\t\t/* single window */\n\t\tXWindowAttributes attr;\n\n\t\twindow = (Window) subwin;\n\t\tif (! XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid window: 0x%lx\\n\", window);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdpy_x = wdpy_x = attr.width;\n\t\tdpy_y = wdpy_y = attr.height;\n\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = attr.visual;\n\n#if HAVE_LIBXCOMPOSITE\n\t\tif(use_xcomposite && !rootshift) {\n\t\t  XCompositeRedirectWindow(dpy, window, CompositeRedirectAutomatic);\n\t\t  XCompositeRedirectSubwindows(dpy, window, CompositeRedirectAutomatic);\n\t\t}\n#endif\n\n\t\tX_UNLOCK;\n\t\tset_offset();\n\t\tX_LOCK;\n\t}\n\n\tinitialize_clipshift();\n\n\t/* initialize depth to reasonable value, visual_id may override */\n\tdepth = DefaultDepth(dpy, scr);\n\nif (0) fprintf(stderr, \"DefaultDepth: %d  visial_id: %d\\n\", depth, (int) visual_id);\n\n\tif (visual_id) {\n\t\tint n;\n\t\tXVisualInfo vinfo_tmpl, *vinfo;\n\n\t\t/*\n\t\t * we are in here from -visual or -overlay options\n\t\t * visual_id and visual_depth were set in set_visual().\n\t\t */\n\n\t\tvinfo_tmpl.visualid = visual_id; \n\t\tvinfo = XGetVisualInfo(dpy, VisualIDMask, &vinfo_tmpl, &n);\n\t\tif (vinfo == NULL || n == 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not match visual_id: 0x%x\\n\",\n\t\t\t    (int) visual_id);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdefault_visual = vinfo->visual;\n\t\tdepth = vinfo->depth;\n\t\tif (visual_depth) {\n\t\t\t/* force it from -visual MooColor:NN */\n\t\t\tdepth = visual_depth;\n\t\t}\n\t\tif (! quiet) {\n\t\t\tfprintf(stderr, \" initialize_xdisplay_fb()\\n\");\n\t\t\tfprintf(stderr, \" Visual*:    %p\\n\",\n\t\t\t    (void *) vinfo->visual);\n\t\t\tfprintf(stderr, \" visualid:   0x%x\\n\",\n\t\t\t    (int) vinfo->visualid);\n\t\t\tfprintf(stderr, \" screen:     %d\\n\", vinfo->screen);\n\t\t\tfprintf(stderr, \" depth:      %d\\n\", vinfo->depth);\n\t\t\tfprintf(stderr, \" class:      %d\\n\", vinfo->class);\n\t\t\tfprintf(stderr, \" red_mask:   0x%08lx  %s\\n\",\n\t\t\t    vinfo->red_mask, bitprint(vinfo->red_mask, 32));\n\t\t\tfprintf(stderr, \" green_mask: 0x%08lx  %s\\n\",\n\t\t\t    vinfo->green_mask, bitprint(vinfo->green_mask, 32));\n\t\t\tfprintf(stderr, \" blue_mask:  0x%08lx  %s\\n\",\n\t\t\t    vinfo->blue_mask, bitprint(vinfo->blue_mask, 32));\n\t\t\tfprintf(stderr, \" cmap_size:  %d\\n\",\n\t\t\t    vinfo->colormap_size);\n\t\t\tfprintf(stderr, \" bits b/rgb: %d\\n\",\n\t\t\t    vinfo->bits_per_rgb);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tXFree_wr(vinfo);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"Default visual ID: 0x%x\\n\",\n\t\t    (int) XVisualIDFromVisual(default_visual));\n\t}\n\n\tif (subwin && (!use_xcomposite || rootshift)) {\n\t\tint shift = 0, resize = 0;\n\t\tint subwin_x, subwin_y;\n\t\tint disp_x = DisplayWidth(dpy, scr);\n\t\tint disp_y = DisplayHeight(dpy, scr);\n\t\tWindow twin;\n\t\t/* subwins can be a dicey if they are changing size... */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\t/* reset in if(subwin) block below */\n\t\tXTranslateCoordinates(dpy, window, rootwin, 0, 0, &subwin_x,\n\t\t    &subwin_y, &twin);\n\n\t\tif (wdpy_x > disp_x) {\n\t\t\tresize = 1;\n\t\t\tdpy_x = wdpy_x = disp_x - 4;\n\t\t}\n\t\tif (wdpy_y > disp_y) {\n\t\t\tresize = 1;\n\t\t\tdpy_y = wdpy_y = disp_y - 4;\n\t\t}\n\n\t\tif (subwin_x + wdpy_x > disp_x) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = disp_x - wdpy_x - 3;\n\t\t}\n\t\tif (subwin_y + wdpy_y > disp_y) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = disp_y - wdpy_y - 3;\n\t\t}\n\t\tif (subwin_x < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = 1;\n\t\t}\n\t\tif (subwin_y < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = 1;\n\t\t}\n\n\t\tif (resize) {\n\t\t\tXResizeWindow(dpy, window, wdpy_x, wdpy_y);\n\t\t}\n\t\tif (shift) {\n\t\t\tXMoveWindow(dpy, window, subwin_x, subwin_y);\n\t\t\toff_x = subwin_x;\n\t\t\toff_y = subwin_y;\n\t\t}\n\t\tXMapRaised(dpy, window);\n\t\tXRaiseWindow(dpy, window);\n\t\tXSync(dpy, False);\n\t}\n\ttry++;\n\n\tif (nofb) {\n\t\t/* \n\t\t * For -nofb we do not allocate the framebuffer, so we\n\t\t * can save a few MB of memory. \n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\n\t} else if (visual_id) {\n\t\t/*\n\t\t * we need to call XCreateImage to supply the visual\n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\t\tif (fb) {\n\t\t\tfb->data = (char *) malloc(fb->bytes_per_line * fb->height);\n\t\t}\n\n\t} else {\n\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (! quiet) {\n\t\t\trfbLog(\"Read initial data from X display into\"\n\t\t\t    \" framebuffer.\\n\");\n\t\t}\n\t}\n\n\tif (subwin) {\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror || fb == NULL) {\n\t\t    rfbLog(\"trapped GetImage at SUBWIN creation.\\n\");\n\t\t    if (try < subwin_tries) {\n\t\t\tusleep(250 * 1000);\n\t\t\tif (!get_window_size(window, &wdpy_x, &wdpy_y)) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"could not get size of subwin \"\n\t\t\t\t    \"0x%lx\\n\", subwin);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tgoto again;\n\t\t    }\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t} else if (fb == NULL) {\n#if HAVE_LIBXRANDR\n\t\tXEvent xev;\n#endif\n\t\trfbLog(\"initialize_xdisplay_fb: *** fb creation failed: 0x%x try: %d\\n\", fb, try);\n#if HAVE_LIBXRANDR\n\t\tif (xrandr_present && xrandr_base_event_type) {\n\t\t\tint cnt = 0;\n\t\t\twhile (XCheckTypedEvent(dpy, xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\t\t\tXRRScreenChangeNotifyEvent *rev;\n\t\t\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: XRANDR event while redoing fb[%d]:\\n\", cnt++);\n\t\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"previous WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n\n\t\t\t\txrandr_width  = rev->width;\n\t\t\t\txrandr_height = rev->height;\n\t\t\t\txrandr_timestamp = rev->timestamp;\n\t\t\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\t\t\txrandr_rotation = (int) rev->rotation;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: updating XRANDR config...\\n\");\n\t\t\t\tXRRUpdateConfiguration(&xev);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (try < 5)  {\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(250 * 1000);\n\t\t\tif (try < 3) {\n\t\t\t\tXSync(dpy, False);\n\t\t\t} else if (try >= 3) {\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tinitialize_snap_fb();\n\t}\n\n\tX_UNLOCK;\n\n\tif (fb->bits_per_pixel == 24 && ! quiet) {\n\t\trfbLog(\"warning: 24 bpp may have poor performance.\\n\");\n\t}\n\treturn fb;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_colormap(int reset);",
      "XImage *initialize_xdisplay_fb(void);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void set_visual(char *str);",
      "static void install_fake_fb(int w, int h, int bpp);",
      "static void initialize_snap_fb(void);",
      "XImage *initialize_raw_fb(int);",
      "static void initialize_clipshift(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: 24 bpp may have poor performance.\\n\""
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_snap_fb",
          "args": [],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_snap_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1151-1159",
          "snippet": "static void initialize_snap_fb(void) {\n\tRAWFB_RET_VOID\n\tif (snap_fb) {\n\t\tfree(snap_fb);\n\t}\n\tsnap = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t    ZPixmap);\n\tsnap_fb = snap->data;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void initialize_snap_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void initialize_snap_fb(void);\n\nstatic void initialize_snap_fb(void) {\n\tRAWFB_RET_VOID\n\tif (snap_fb) {\n\t\tfree(snap_fb);\n\t}\n\tsnap = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t    ZPixmap);\n\tsnap_fb = snap->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250 * 1000"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRRUpdateConfiguration",
          "args": [
            "&xev"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: updating XRANDR config...\\n\""
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"previous WxH: %dx%d\\n\"",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  mheight:         %d mm\\n\"",
            "(int) rev->mheight"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  mwidth:          %d mm\\n\"",
            "(int) rev->mwidth"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  height:          %d\\n\"",
            "(int) rev->height"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  width:           %d\\n\"",
            "(int) rev->width"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rotation:        %d\\n\"",
            "(int) rev->rotation"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  sub_pixel:       %d\\n\"",
            "(int) rev->subpixel_order"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  size_id:         %d\\n\"",
            "(int) rev->size_index"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  cfg_timestamp:   %d\\n\"",
            "(int) rev->config_timestamp"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  timestamp:       %d\\n\"",
            "(int) rev->timestamp"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  serial:          %d\\n\"",
            "(int) rev->serial"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: XRANDR event while redoing fb[%d]:\\n\"",
            "cnt++"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xrandr_base_event_type + RRScreenChangeNotify",
            "&xev"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: *** fb creation failed: 0x%x try: %d\\n\"",
            "fb",
            "try"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not get size of subwin \"\n\t\t\t\t    \"0x%lx\\n\"",
            "subwin"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_window_size",
          "args": [
            "window",
            "&wdpy_x",
            "&wdpy_y"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "get_window_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "175-185",
          "snippet": "int get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250 * 1000"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"trapped GetImage at SUBWIN creation.\\n\""
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Read initial data from X display into\"\n\t\t\t    \" framebuffer.\\n\""
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetImage_wr",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "fb->bytes_per_line * fb->height"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateImage_wr",
          "args": [
            "dpy",
            "default_visual",
            "depth",
            "ZPixmap",
            "0",
            "NULL",
            "dpy_x",
            "dpy_y",
            "BitmapPad(dpy)",
            "0"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "XCreateImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "370-429",
          "snippet": "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_bits_per_color(int bits_per_pixel);",
            "int XFlush_wr(Display *disp);",
            "Status XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint guess_bits_per_color(int bits_per_pixel);\nint XFlush_wr(Display *disp);\nStatus XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nint XFree_wr(void *data);\n\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitmapPad",
          "args": [
            "dpy"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitmapPad",
          "args": [
            "dpy"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRaiseWindow",
          "args": [
            "dpy",
            "window"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapRaised",
          "args": [
            "dpy",
            "window"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMoveWindow",
          "args": [
            "dpy",
            "window",
            "subwin_x",
            "subwin_y"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XResizeWindow",
          "args": [
            "dpy",
            "window",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTranslateCoordinates",
          "args": [
            "dpy",
            "window",
            "rootwin",
            "0",
            "0",
            "&subwin_x",
            "&subwin_y",
            "&twin"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayHeight",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayWidth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Default visual ID: 0x%x\\n\"",
            "(int) XVisualIDFromVisual(default_visual)"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XVisualIDFromVisual",
          "args": [
            "default_visual"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "vinfo"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" bits b/rgb: %d\\n\"",
            "vinfo->bits_per_rgb"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cmap_size:  %d\\n\"",
            "vinfo->colormap_size"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" blue_mask:  0x%08lx  %s\\n\"",
            "vinfo->blue_mask",
            "bitprint(vinfo->blue_mask, 32)"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitprint",
          "args": [
            "vinfo->blue_mask",
            "32"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "bitprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "251-269",
          "snippet": "char *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "char *bitprint(unsigned int st, int nbits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nchar *bitprint(unsigned int st, int nbits);\n\nchar *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" green_mask: 0x%08lx  %s\\n\"",
            "vinfo->green_mask",
            "bitprint(vinfo->green_mask, 32)"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" red_mask:   0x%08lx  %s\\n\"",
            "vinfo->red_mask",
            "bitprint(vinfo->red_mask, 32)"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" class:      %d\\n\"",
            "vinfo->class"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" depth:      %d\\n\"",
            "vinfo->depth"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" screen:     %d\\n\"",
            "vinfo->screen"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" visualid:   0x%x\\n\"",
            "(int) vinfo->visualid"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" Visual*:    %p\\n\"",
            "(void *) vinfo->visual"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" initialize_xdisplay_fb()\\n\""
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not match visual_id: 0x%x\\n\"",
            "(int) visual_id"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetVisualInfo",
          "args": [
            "dpy",
            "VisualIDMask",
            "&vinfo_tmpl",
            "&n"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DefaultDepth: %d  visial_id: %d\\n\"",
            "depth",
            "(int) visual_id"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDepth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_clipshift",
          "args": [],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_clipshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2397-2437",
          "snippet": "static void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_padded_fb(char *geom);",
            "static void initialize_clipshift(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void initialize_clipshift(void);\n\nstatic void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_offset",
          "args": [],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "set_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "3149-3157",
          "snippet": "void set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_offset(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid set_offset(void);\n\nvoid set_offset(void) {\n\tWindow w;\n\tif (! subwin) {\n\t\treturn;\n\t}\n\tX_LOCK;\n\txtranslate(window, rootwin, 0, 0, &off_x, &off_y, &w, 0);\n\tX_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCompositeRedirectSubwindows",
          "args": [
            "dpy",
            "window",
            "CompositeRedirectAutomatic"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCompositeRedirectWindow",
          "args": [
            "dpy",
            "window",
            "CompositeRedirectAutomatic"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid window: 0x%lx\\n\"",
            "window"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "window",
            "&attr"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultVisual",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayHeight",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayWidth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"vis_str %s\\n\"",
            "vis_str ? vis_str : \"notset\""
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "vis_str"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_visual",
          "args": [
            "vis_str"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "set_visual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "427-509",
          "snippet": "static void set_visual(char *str) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!str) {}\n\treturn;\n#else\n\tint vis, vdepth, defdepth;\n\tXVisualInfo vinfo;\n\tchar *p, *vstring = strdup(str);\n\n\tRAWFB_RET_VOID\n\n\tdefdepth = DefaultDepth(dpy, scr);\n\tvisual_id = (VisualID) 0;\n\tvisual_depth = 0;\n\n\tif (!strcmp(vstring, \"ignore\") || !strcmp(vstring, \"default\")\n\t    || !strcmp(vstring, \"\")) {\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\t/* set visual depth */\n\tif ((p = strchr(vstring, ':')) != NULL) {\n\t\tvisual_depth = atoi(p+1);\n\t\t*p = '\\0';\n\t\tvdepth = visual_depth;\n\t} else {\n\t\tvdepth = defdepth; \n\t}\n\tif (! quiet) {\n\t\tfprintf(stderr, \"\\nVisual Info:\\n\");\n\t\tfprintf(stderr, \" set_visual(\\\"%s\\\")\\n\", str);\n\t\tfprintf(stderr, \" visual_depth: %d\\n\", vdepth);\n\t}\n\n\t/* set visual id number */\n\tif (strcmp(vstring, \"StaticGray\") == 0) {\n\t\tvis = StaticGray;\n\t} else if (strcmp(vstring, \"GrayScale\") == 0) {\n\t\tvis = GrayScale;\n\t} else if (strcmp(vstring, \"StaticColor\") == 0) {\n\t\tvis = StaticColor;\n\t} else if (strcmp(vstring, \"PseudoColor\") == 0) {\n\t\tvis = PseudoColor;\n\t} else if (strcmp(vstring, \"TrueColor\") == 0) {\n\t\tvis = TrueColor;\n\t} else if (strcmp(vstring, \"DirectColor\") == 0) {\n\t\tvis = DirectColor;\n\t} else {\n\t\tunsigned int v_in;\n\t\tif (sscanf(vstring, \"0x%x\", &v_in) != 1) {\n\t\t\tif (sscanf(vstring, \"%u\", &v_in) == 1) {\n\t\t\t\tvisual_id = (VisualID) v_in;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -visual arg: %s\\n\", vstring);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tvisual_id = (VisualID) v_in;\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\tif (! quiet) fprintf(stderr, \" visual: %d\\n\", vis);\n\tif (XMatchVisualInfo(dpy, scr, visual_depth, vis, &vinfo)) {\n\t\t;\n\t} else if (XMatchVisualInfo(dpy, scr, defdepth, vis, &vinfo)) {\n\t\t;\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not find visual: %s\\n\", vstring);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tfree(vstring);\n\n\t/* set numerical visual id. */\n\tvisual_id = vinfo.visualid;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_visual(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void set_visual(char *str);\n\nstatic void set_visual(char *str) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!str) {}\n\treturn;\n#else\n\tint vis, vdepth, defdepth;\n\tXVisualInfo vinfo;\n\tchar *p, *vstring = strdup(str);\n\n\tRAWFB_RET_VOID\n\n\tdefdepth = DefaultDepth(dpy, scr);\n\tvisual_id = (VisualID) 0;\n\tvisual_depth = 0;\n\n\tif (!strcmp(vstring, \"ignore\") || !strcmp(vstring, \"default\")\n\t    || !strcmp(vstring, \"\")) {\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\t/* set visual depth */\n\tif ((p = strchr(vstring, ':')) != NULL) {\n\t\tvisual_depth = atoi(p+1);\n\t\t*p = '\\0';\n\t\tvdepth = visual_depth;\n\t} else {\n\t\tvdepth = defdepth; \n\t}\n\tif (! quiet) {\n\t\tfprintf(stderr, \"\\nVisual Info:\\n\");\n\t\tfprintf(stderr, \" set_visual(\\\"%s\\\")\\n\", str);\n\t\tfprintf(stderr, \" visual_depth: %d\\n\", vdepth);\n\t}\n\n\t/* set visual id number */\n\tif (strcmp(vstring, \"StaticGray\") == 0) {\n\t\tvis = StaticGray;\n\t} else if (strcmp(vstring, \"GrayScale\") == 0) {\n\t\tvis = GrayScale;\n\t} else if (strcmp(vstring, \"StaticColor\") == 0) {\n\t\tvis = StaticColor;\n\t} else if (strcmp(vstring, \"PseudoColor\") == 0) {\n\t\tvis = PseudoColor;\n\t} else if (strcmp(vstring, \"TrueColor\") == 0) {\n\t\tvis = TrueColor;\n\t} else if (strcmp(vstring, \"DirectColor\") == 0) {\n\t\tvis = DirectColor;\n\t} else {\n\t\tunsigned int v_in;\n\t\tif (sscanf(vstring, \"0x%x\", &v_in) != 1) {\n\t\t\tif (sscanf(vstring, \"%u\", &v_in) == 1) {\n\t\t\t\tvisual_id = (VisualID) v_in;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -visual arg: %s\\n\", vstring);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tvisual_id = (VisualID) v_in;\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\tif (! quiet) fprintf(stderr, \" visual: %d\\n\", vis);\n\tif (XMatchVisualInfo(dpy, scr, visual_depth, vis, &vinfo)) {\n\t\t;\n\t} else if (XMatchVisualInfo(dpy, scr, defdepth, vis, &vinfo)) {\n\t\t;\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not find visual: %s\\n\", vstring);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tfree(vstring);\n\n\t/* set numerical visual id. */\n\tvisual_id = vinfo.visualid;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xi"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: low bpp[%d], \"\n\t\t\t\t    \"disabling shm\\n\"",
            "lowbpp"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: low bpp[%d], vis_str \"\n\t\t\t\t    \"set to: %s\\n\"",
            "lowbpp",
            "vis_str"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"0x%x:8\"",
            "(int) s->root_visual->visualid"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreenOfDisplay",
          "args": [
            "dpy"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDepth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_xdisplay_fb: vis_str set to: %s\\n\"",
            "vis_str"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"TrueColor:32\""
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDepth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: replacing '-visual %s' by '%s' \"\n\t\t\t    \"for use with -overlay\\n\"",
            "visual_str",
            "str"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xi"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: overlay image has depth %d \"\n\t\t\t    \"instead of 24.\\n\"",
            "xi->depth"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"TrueColor:%d\"",
            "xi->depth"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xreadscreen",
          "args": [
            "dpy",
            "twin",
            "0",
            "0",
            "8",
            "8",
            "False"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "xreadscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "265-291",
          "snippet": "XImage *xreadscreen(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, Bool show_cursor) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !show_cursor) {}\n\treturn NULL;\n#else\n\n#ifdef SOLARIS_OVERLAY\n\treturn XReadScreen(disp, d, x, y, width, height,\n\t    show_cursor);\n#else\n#  ifdef IRIX_OVERLAY\n\t{\tunsigned long hints = 0, hints_ret;\n\t\tif (show_cursor) hints |= XRD_READ_POINTER;\n\t\treturn XReadDisplay(disp, d, x, y, width, height,\n\t\t    hints, &hints_ret);\n\t}\n#  else\n\t/* unused vars warning: */\n\tif (disp || d || x || y || width || height || show_cursor) {}\n\n\treturn NULL;\n#  endif\n#endif\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *xreadscreen(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, Bool show_cursor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *xreadscreen(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, Bool show_cursor);\n\nXImage *xreadscreen(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, Bool show_cursor) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !show_cursor) {}\n\treturn NULL;\n#else\n\n#ifdef SOLARIS_OVERLAY\n\treturn XReadScreen(disp, d, x, y, width, height,\n\t    show_cursor);\n#else\n#  ifdef IRIX_OVERLAY\n\t{\tunsigned long hints = 0, hints_ret;\n\t\tif (show_cursor) hints |= XRD_READ_POINTER;\n\t\treturn XReadDisplay(disp, d, x, y, width, height,\n\t\t    hints, &hints_ret);\n\t}\n#  else\n\t/* unused vars warning: */\n\tif (disp || d || x || y || width || height || show_cursor) {}\n\n\treturn NULL;\n#  endif\n#endif\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid sub-window: 0x%lx\\n\"",
            "subwin"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "(Window) subwin",
            "NULL",
            "0"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_until_mapped",
          "args": [
            "subwin"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "wait_until_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2439-2466",
          "snippet": "static int wait_until_mapped(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn 0;\n#else\n\tint ms = 50, waittime = 30;\n\ttime_t start = time(NULL);\n\tXWindowAttributes attr;\n\n\twhile (1) {\n\t\tif (! valid_window(win, NULL, 0)) {\n\t\t\tif (time(NULL) > start + waittime) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(ms * 1000);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dpy && ! XGetWindowAttributes(dpy, win, &attr)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (attr.map_state == IsViewable) {\n\t\t\treturn 1;\n\t\t}\n\t\tusleep(ms * 1000);\n\t}\n\treturn 0;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wait_until_mapped(Window win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int wait_until_mapped(Window win);\n\nstatic int wait_until_mapped(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn 0;\n#else\n\tint ms = 50, waittime = 30;\n\ttime_t start = time(NULL);\n\tXWindowAttributes attr;\n\n\twhile (1) {\n\t\tif (! valid_window(win, NULL, 0)) {\n\t\t\tif (time(NULL) > start + waittime) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(ms * 1000);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dpy && ! XGetWindowAttributes(dpy, win, &attr)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (attr.map_state == IsViewable) {\n\t\t\treturn 1;\n\t\t}\n\t\tusleep(ms * 1000);\n\t}\n\treturn 0;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_raw_fb",
          "args": [
            "0"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_raw_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1640-2395",
          "snippet": "XImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define BOLDLY_CLOSE_DISPLAY 1",
            "#define RAWFB_SHM  3",
            "#define RAWFB_FILE 2",
            "#define RAWFB_MMAP 1"
          ],
          "globals_used": [
            "void set_colormap(int reset);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "char *vnc_reflect_guess(char *str, char **raw_fb_addr);",
            "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
            "static void debug_colormap(XImage *fb);",
            "static void set_visual(char *str);",
            "static void install_fake_fb(int w, int h, int bpp);",
            "XImage *initialize_raw_fb(int);",
            "static void initialize_clipshift(void);",
            "int rawfb_dev_video = 0;",
            "int rawfb_vnc_reflect = 0;",
            "int rawfb_double_buffer = 0;",
            "static char *raw_fb_orig_dpy = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define BOLDLY_CLOSE_DISPLAY 1\n#define RAWFB_SHM  3\n#define RAWFB_FILE 2\n#define RAWFB_MMAP 1\n\nvoid set_colormap(int reset);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\nstatic void install_fake_fb(int w, int h, int bpp);\nXImage *initialize_raw_fb(int);\nstatic void initialize_clipshift(void);\nint rawfb_dev_video = 0;\nint rawfb_vnc_reflect = 0;\nint rawfb_double_buffer = 0;\nstatic char *raw_fb_orig_dpy = NULL;\n\nXImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_colormap(int reset);\nXImage *initialize_xdisplay_fb(void);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\nstatic void install_fake_fb(int w, int h, int bpp);\nstatic void initialize_snap_fb(void);\nXImage *initialize_raw_fb(int);\nstatic void initialize_clipshift(void);\n\nXImage *initialize_xdisplay_fb(void) {\n#if NO_X11\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\treturn NULL;\n#else\n\tXImage *fb;\n\tchar *vis_str = visual_str;\n\tint try = 0, subwin_tries = 3;\n\tXErrorHandler old_handler = NULL;\n\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\n\tX_LOCK;\n\tif (subwin) {\n\t\tif (subwin_wait_mapped) {\n\t\t\twait_until_mapped(subwin);\n\t\t}\n\t\tif (!valid_window((Window) subwin, NULL, 0)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid sub-window: 0x%lx\\n\", subwin);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\t\n\tif (overlay) {\n\t\t/* \n\t\t * ideally we'd like to not have to cook up the\n\t\t * visual variables but rather let it all come out\n\t\t * of XReadScreen(), however there is no way to get\n\t\t * a default visual out of it, so we pretend -visual\n\t\t * TrueColor:NN was supplied with NN usually 24.\n\t\t */\n\t\tchar str[32];\n\t\tWindow twin = subwin ? subwin : rootwin;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(dpy, twin, 0, 0, 8, 8, False);\n\t\tsprintf(str, \"TrueColor:%d\", xi->depth);\n\t\tif (xi->depth != 24 && ! quiet) {\n\t\t\trfbLog(\"warning: overlay image has depth %d \"\n\t\t\t    \"instead of 24.\\n\", xi->depth);\n\t\t}\n\t\tXDestroyImage(xi);\n\t\tif (visual_str != NULL && ! quiet) {\n\t\t\trfbLog(\"warning: replacing '-visual %s' by '%s' \"\n\t\t\t    \"for use with -overlay\\n\", visual_str, str);\n\t\t}\n\t\tvis_str = strdup(str);\n\t}\n\n\tif (xform24to32) {\n\t\tif (DefaultDepth(dpy, scr) == 24) {\n\t\t\tvis_str = strdup(\"TrueColor:32\");\n\t\t\trfbLog(\"initialize_xdisplay_fb: vis_str set to: %s\\n\",\n\t\t\t    vis_str);\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t} else if (DefaultDepth(dpy, scr) < 8) {\n\t\t/* check very low bpp case, e.g. mono or vga16 */\n\t\tScreen *s = DefaultScreenOfDisplay(dpy);\n\t\tXImage *xi = XGetImage_wr(dpy, DefaultRootWindow(dpy), 0, 0, 2, 2, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (xi && xi->bits_per_pixel < 8) {\n\t\t\tint lowbpp = xi->bits_per_pixel; \n\t\t\tif (!vis_str) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tsprintf(tmp, \"0x%x:8\", (int) s->root_visual->visualid);\n\t\t\t\tvis_str = strdup(tmp);\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], vis_str \"\n\t\t\t\t    \"set to: %s\\n\", lowbpp, vis_str);\n\t\t\t}\n\t\t\tif (using_shm) {\n\t\t\t\tusing_shm = 0;\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], \"\n\t\t\t\t    \"disabling shm\\n\", lowbpp);\n\t\t\t}\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t}\n\n\tif (vis_str != NULL) {\n\t\tset_visual(vis_str);\n\t\tif (vis_str != visual_str) {\n\t\t\tfree(vis_str);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"vis_str %s\\n\", vis_str ? vis_str : \"notset\");\n\n\t/* set up parameters for subwin or non-subwin cases: */\n\n\tagain:\n\n\tif (! subwin) {\n\t\t/* full screen */\n\t\twindow = rootwin;\n\t\tdpy_x = wdpy_x = DisplayWidth(dpy, scr);\n\t\tdpy_y = wdpy_y = DisplayHeight(dpy, scr);\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = DefaultVisual(dpy, scr);\n\t} else {\n\t\t/* single window */\n\t\tXWindowAttributes attr;\n\n\t\twindow = (Window) subwin;\n\t\tif (! XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid window: 0x%lx\\n\", window);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdpy_x = wdpy_x = attr.width;\n\t\tdpy_y = wdpy_y = attr.height;\n\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = attr.visual;\n\n#if HAVE_LIBXCOMPOSITE\n\t\tif(use_xcomposite && !rootshift) {\n\t\t  XCompositeRedirectWindow(dpy, window, CompositeRedirectAutomatic);\n\t\t  XCompositeRedirectSubwindows(dpy, window, CompositeRedirectAutomatic);\n\t\t}\n#endif\n\n\t\tX_UNLOCK;\n\t\tset_offset();\n\t\tX_LOCK;\n\t}\n\n\tinitialize_clipshift();\n\n\t/* initialize depth to reasonable value, visual_id may override */\n\tdepth = DefaultDepth(dpy, scr);\n\nif (0) fprintf(stderr, \"DefaultDepth: %d  visial_id: %d\\n\", depth, (int) visual_id);\n\n\tif (visual_id) {\n\t\tint n;\n\t\tXVisualInfo vinfo_tmpl, *vinfo;\n\n\t\t/*\n\t\t * we are in here from -visual or -overlay options\n\t\t * visual_id and visual_depth were set in set_visual().\n\t\t */\n\n\t\tvinfo_tmpl.visualid = visual_id; \n\t\tvinfo = XGetVisualInfo(dpy, VisualIDMask, &vinfo_tmpl, &n);\n\t\tif (vinfo == NULL || n == 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not match visual_id: 0x%x\\n\",\n\t\t\t    (int) visual_id);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdefault_visual = vinfo->visual;\n\t\tdepth = vinfo->depth;\n\t\tif (visual_depth) {\n\t\t\t/* force it from -visual MooColor:NN */\n\t\t\tdepth = visual_depth;\n\t\t}\n\t\tif (! quiet) {\n\t\t\tfprintf(stderr, \" initialize_xdisplay_fb()\\n\");\n\t\t\tfprintf(stderr, \" Visual*:    %p\\n\",\n\t\t\t    (void *) vinfo->visual);\n\t\t\tfprintf(stderr, \" visualid:   0x%x\\n\",\n\t\t\t    (int) vinfo->visualid);\n\t\t\tfprintf(stderr, \" screen:     %d\\n\", vinfo->screen);\n\t\t\tfprintf(stderr, \" depth:      %d\\n\", vinfo->depth);\n\t\t\tfprintf(stderr, \" class:      %d\\n\", vinfo->class);\n\t\t\tfprintf(stderr, \" red_mask:   0x%08lx  %s\\n\",\n\t\t\t    vinfo->red_mask, bitprint(vinfo->red_mask, 32));\n\t\t\tfprintf(stderr, \" green_mask: 0x%08lx  %s\\n\",\n\t\t\t    vinfo->green_mask, bitprint(vinfo->green_mask, 32));\n\t\t\tfprintf(stderr, \" blue_mask:  0x%08lx  %s\\n\",\n\t\t\t    vinfo->blue_mask, bitprint(vinfo->blue_mask, 32));\n\t\t\tfprintf(stderr, \" cmap_size:  %d\\n\",\n\t\t\t    vinfo->colormap_size);\n\t\t\tfprintf(stderr, \" bits b/rgb: %d\\n\",\n\t\t\t    vinfo->bits_per_rgb);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tXFree_wr(vinfo);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"Default visual ID: 0x%x\\n\",\n\t\t    (int) XVisualIDFromVisual(default_visual));\n\t}\n\n\tif (subwin && (!use_xcomposite || rootshift)) {\n\t\tint shift = 0, resize = 0;\n\t\tint subwin_x, subwin_y;\n\t\tint disp_x = DisplayWidth(dpy, scr);\n\t\tint disp_y = DisplayHeight(dpy, scr);\n\t\tWindow twin;\n\t\t/* subwins can be a dicey if they are changing size... */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\t/* reset in if(subwin) block below */\n\t\tXTranslateCoordinates(dpy, window, rootwin, 0, 0, &subwin_x,\n\t\t    &subwin_y, &twin);\n\n\t\tif (wdpy_x > disp_x) {\n\t\t\tresize = 1;\n\t\t\tdpy_x = wdpy_x = disp_x - 4;\n\t\t}\n\t\tif (wdpy_y > disp_y) {\n\t\t\tresize = 1;\n\t\t\tdpy_y = wdpy_y = disp_y - 4;\n\t\t}\n\n\t\tif (subwin_x + wdpy_x > disp_x) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = disp_x - wdpy_x - 3;\n\t\t}\n\t\tif (subwin_y + wdpy_y > disp_y) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = disp_y - wdpy_y - 3;\n\t\t}\n\t\tif (subwin_x < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = 1;\n\t\t}\n\t\tif (subwin_y < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = 1;\n\t\t}\n\n\t\tif (resize) {\n\t\t\tXResizeWindow(dpy, window, wdpy_x, wdpy_y);\n\t\t}\n\t\tif (shift) {\n\t\t\tXMoveWindow(dpy, window, subwin_x, subwin_y);\n\t\t\toff_x = subwin_x;\n\t\t\toff_y = subwin_y;\n\t\t}\n\t\tXMapRaised(dpy, window);\n\t\tXRaiseWindow(dpy, window);\n\t\tXSync(dpy, False);\n\t}\n\ttry++;\n\n\tif (nofb) {\n\t\t/* \n\t\t * For -nofb we do not allocate the framebuffer, so we\n\t\t * can save a few MB of memory. \n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\n\t} else if (visual_id) {\n\t\t/*\n\t\t * we need to call XCreateImage to supply the visual\n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\t\tif (fb) {\n\t\t\tfb->data = (char *) malloc(fb->bytes_per_line * fb->height);\n\t\t}\n\n\t} else {\n\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (! quiet) {\n\t\t\trfbLog(\"Read initial data from X display into\"\n\t\t\t    \" framebuffer.\\n\");\n\t\t}\n\t}\n\n\tif (subwin) {\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror || fb == NULL) {\n\t\t    rfbLog(\"trapped GetImage at SUBWIN creation.\\n\");\n\t\t    if (try < subwin_tries) {\n\t\t\tusleep(250 * 1000);\n\t\t\tif (!get_window_size(window, &wdpy_x, &wdpy_y)) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"could not get size of subwin \"\n\t\t\t\t    \"0x%lx\\n\", subwin);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tgoto again;\n\t\t    }\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t} else if (fb == NULL) {\n#if HAVE_LIBXRANDR\n\t\tXEvent xev;\n#endif\n\t\trfbLog(\"initialize_xdisplay_fb: *** fb creation failed: 0x%x try: %d\\n\", fb, try);\n#if HAVE_LIBXRANDR\n\t\tif (xrandr_present && xrandr_base_event_type) {\n\t\t\tint cnt = 0;\n\t\t\twhile (XCheckTypedEvent(dpy, xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\t\t\tXRRScreenChangeNotifyEvent *rev;\n\t\t\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: XRANDR event while redoing fb[%d]:\\n\", cnt++);\n\t\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"previous WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n\n\t\t\t\txrandr_width  = rev->width;\n\t\t\t\txrandr_height = rev->height;\n\t\t\t\txrandr_timestamp = rev->timestamp;\n\t\t\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\t\t\txrandr_rotation = (int) rev->rotation;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: updating XRANDR config...\\n\");\n\t\t\t\tXRRUpdateConfiguration(&xev);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (try < 5)  {\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(250 * 1000);\n\t\t\tif (try < 3) {\n\t\t\t\tXSync(dpy, False);\n\t\t\t} else if (try >= 3) {\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tinitialize_snap_fb();\n\t}\n\n\tX_UNLOCK;\n\n\tif (fb->bits_per_pixel == 24 && ! quiet) {\n\t\trfbLog(\"warning: 24 bpp may have poor performance.\\n\");\n\t}\n\treturn fb;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "wait_until_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2439-2466",
    "snippet": "static int wait_until_mapped(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn 0;\n#else\n\tint ms = 50, waittime = 30;\n\ttime_t start = time(NULL);\n\tXWindowAttributes attr;\n\n\twhile (1) {\n\t\tif (! valid_window(win, NULL, 0)) {\n\t\t\tif (time(NULL) > start + waittime) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(ms * 1000);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dpy && ! XGetWindowAttributes(dpy, win, &attr)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (attr.map_state == IsViewable) {\n\t\t\treturn 1;\n\t\t}\n\t\tusleep(ms * 1000);\n\t}\n\treturn 0;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wait_until_mapped(Window win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "win",
            "&attr"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "NULL",
            "0"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic int wait_until_mapped(Window win);\n\nstatic int wait_until_mapped(Window win) {\n#if NO_X11\n\tif (!win) {}\n\treturn 0;\n#else\n\tint ms = 50, waittime = 30;\n\ttime_t start = time(NULL);\n\tXWindowAttributes attr;\n\n\twhile (1) {\n\t\tif (! valid_window(win, NULL, 0)) {\n\t\t\tif (time(NULL) > start + waittime) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tusleep(ms * 1000);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dpy && ! XGetWindowAttributes(dpy, win, &attr)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (attr.map_state == IsViewable) {\n\t\t\treturn 1;\n\t\t}\n\t\tusleep(ms * 1000);\n\t}\n\treturn 0;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "initialize_clipshift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "2397-2437",
    "snippet": "static void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void install_padded_fb(char *geom);",
      "static void initialize_clipshift(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** ignoring invalid -clip WxH+X+Y: %s\\n\"",
            "clip_str"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_geom",
          "args": [
            "clip_str",
            "&w",
            "&h",
            "&x",
            "&y",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "parse_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "210-237",
          "snippet": "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dabs(double x);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);\n\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void initialize_clipshift(void);\n\nstatic void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "initialize_raw_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1640-2395",
    "snippet": "XImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define BOLDLY_CLOSE_DISPLAY 1",
      "#define RAWFB_SHM  3",
      "#define RAWFB_FILE 2",
      "#define RAWFB_MMAP 1"
    ],
    "globals_used": [
      "void set_colormap(int reset);",
      "int parse_rotate_string(char *str, int *mode);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "char *vnc_reflect_guess(char *str, char **raw_fb_addr);",
      "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
      "static void debug_colormap(XImage *fb);",
      "static void set_visual(char *str);",
      "static void install_fake_fb(int w, int h, int bpp);",
      "XImage *initialize_raw_fb(int);",
      "static void initialize_clipshift(void);",
      "int rawfb_dev_video = 0;",
      "int rawfb_vnc_reflect = 0;",
      "int rawfb_double_buffer = 0;",
      "static char *raw_fb_orig_dpy = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        snap_fb %p\\n\"",
            "snap_fb"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        bpl     %d\\n\"",
            "raw_fb_image->bytes_per_line"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        depth   %d\\n\"",
            "raw_fb_image->depth"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        bpp     %d\\n\"",
            "raw_fb_image->bits_per_pixel"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        height  %d\\n\"",
            "raw_fb_image->height"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        width   %d\\n\"",
            "raw_fb_image->width"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"        format  %d\\n\"",
            "raw_fb_image->format"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb:  raw_fb  %p\\n\"",
            "raw_fb"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_fb",
            "0xff",
            "dpy_y * raw_fb_image->bytes_per_line"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "raw_fb",
            "raw_fb_addr + raw_fb_offset",
            "dpy_y * raw_fb_image->bytes_per_line"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_fb",
            "0xff",
            "dpy_y * raw_fb_image->bytes_per_line"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_y * dpy_x * b_use/8"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_y * dpy_x * b/8"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayBytesPerRow",
          "args": [],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayBytesPerRow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "385-390",
          "snippet": "int macosxCG_CGDisplayBytesPerRow(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp()/8;\n\t}\n\treturn (int) CGDisplayBytesPerRow(displayID);;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBytesPerRow(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp()/8;\n\t}\n\treturn (int) CGDisplayBytesPerRow(displayID);;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_clipshift",
          "args": [],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_clipshift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2397-2437",
          "snippet": "static void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_padded_fb(char *geom);",
            "static void initialize_clipshift(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void initialize_clipshift(void);\n\nstatic void initialize_clipshift(void) {\n\tclipshift = 0;\n\tcdpy_x = cdpy_y = coff_x = coff_y = 0;\n\tif (clip_str) {\n\t\tint w, h, x, y, bad = 0;\n\t\tif (parse_geom(clip_str, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tif (x + w > wdpy_x) {\n\t\t\t\tw = wdpy_x - x;\n\t\t\t}\n\t\t\tif (y + h > wdpy_y) {\n\t\t\t\th = wdpy_y - y;\n\t\t\t}\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\trfbLog(\"*** ignoring invalid -clip WxH+X+Y: %s\\n\",\n\t\t\t    clip_str); \n\t\t} else {\n\t\t\t/* OK, change geom behind everyone's back... */\n\t\t\tcdpy_x = w;\n\t\t\tcdpy_y = h;\n\t\t\tcoff_x = x;\n\t\t\tcoff_y = y;\n\n\t\t\tclipshift = 1;\n\n\t\t\tdpy_x = cdpy_x;\n\t\t\tdpy_y = cdpy_y;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "unlink_me"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid rawfb str: %s\\n\"",
            "str"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   W: %d H: %d B: %d sz: %d\\n\"",
            "w",
            "h",
            "b",
            "size"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: seek file: %s\\n\"",
            "q"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\""
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   w: %d h: %d b: %d addr: %p sz: %d\\n\"",
            "w",
            "h",
            "b",
            "raw_fb_addr",
            "size"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   w: %d h: %d b: %d addr: %p sz: %d\\n\"",
            "w",
            "h",
            "b",
            "raw_fb_addr",
            "vsize"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: mmap file: %s\\n\"",
            "q"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"mmap(2) failed, trying slower lseek(2)\\n\""
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mmap\""
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   raw_fb_addr: %p\\n\"",
            "raw_fb_addr"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to mmap file: %s, %s\\n\"",
            "q",
            "str"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "0",
            "size",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "0",
            "vsize",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   w: %d h: %d b: %d addr: %p sz: %d\\n\"",
            "w",
            "h",
            "b",
            "raw_fb_addr",
            "size"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: vnc fb: %s\\n\"",
            "q"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   w: %d h: %d b: %d addr: %p sz: %d\\n\"",
            "w",
            "h",
            "b",
            "raw_fb_addr",
            "size"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: macosx fb: %s\\n\"",
            "q"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_get_fb_addr",
          "args": [],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_fb_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "158-161",
          "snippet": "char *macosx_get_fb_addr(void) {\n\tmacosxCG_init();\n\treturn macosxCG_get_fb_addr();\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *macosx_get_fb_addr(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nchar *macosx_get_fb_addr(void);\n\nchar *macosx_get_fb_addr(void) {\n\tmacosxCG_init();\n\treturn macosxCG_get_fb_addr();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw fb is non-regular file: %s\\n\"",
            "q"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&sbuf"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"virtual size: %d\"",
            "vsize"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linux_dev_fb_msg",
          "args": [
            "q"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "linux_dev_fb_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1618-1634",
          "snippet": "void linux_dev_fb_msg(char* q) {\n\tif (strstr(q, \"/dev/fb\") && strstr(UT.sysname, \"Linux\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"On Linux you may need to load a kernel module to enable\\n\");\n\t\trfbLog(\"the framebuffer device /dev/fb*; e.g.:\\n\");\n\t\trfbLog(\"   vga=0x303 (and others) kernel boot parameter\\n\");\n\t\trfbLog(\"   modprobe uvesafb\\n\");\n\t\trfbLog(\"   modprobe radeonfb (card specific)\\n\");\n\t\trfbLog(\"   modprobe nvidiafb (card specific, others)\\n\");\n\t\trfbLog(\"   modprobe vesafb (?)\\n\");\n\t\trfbLog(\"   modprobe vga16fb\\n\");\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"You may also need root permission to open /dev/fb*\\n\");\n\t\trfbLog(\"and/or /dev/tty*.\\n\");\n\t\trfbLog(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid linux_dev_fb_msg(char* q) {\n\tif (strstr(q, \"/dev/fb\") && strstr(UT.sysname, \"Linux\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"On Linux you may need to load a kernel module to enable\\n\");\n\t\trfbLog(\"the framebuffer device /dev/fb*; e.g.:\\n\");\n\t\trfbLog(\"   vga=0x303 (and others) kernel boot parameter\\n\");\n\t\trfbLog(\"   modprobe uvesafb\\n\");\n\t\trfbLog(\"   modprobe radeonfb (card specific)\\n\");\n\t\trfbLog(\"   modprobe nvidiafb (card specific, others)\\n\");\n\t\trfbLog(\"   modprobe vesafb (?)\\n\");\n\t\trfbLog(\"   modprobe vga16fb\\n\");\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"You may also need root permission to open /dev/fb*\\n\");\n\t\trfbLog(\"and/or /dev/tty*.\\n\");\n\t\trfbLog(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open\""
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to open file: %s, %s\\n\"",
            "q",
            "str"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "q",
            "O_RDONLY"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"macosx:\""
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"macosx:\""
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"file:\""
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"mmap:\""
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"map:\""
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"shmat\""
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"x11vnc was compiled without shm support.\\n\""
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\"",
            "shmid",
            "w",
            "h",
            "b",
            "raw_fb_addr"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"shmat\""
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to attach to shm: %d, %s\\n\"",
            "shmid",
            "str"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmat",
          "args": [
            "shmid",
            "0",
            "SHM_RDONLY"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"shm:%d\"",
            "&shmid"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "newstr",
            "str"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "newstr",
            "\"map:\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  but file exists, so assuming: map:%s\\n\"",
            "raw_fb_str"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"no type prefix: %s\\n\"",
            "raw_fb_str"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"map:\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "str",
            "&sbuf"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"file:\""
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"map:\""
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"mmap:\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"shm:\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"snap:\""
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: -24to32 mode and bpp=%d\\n\"",
            "b"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabling -24to32 for 24bpp video\\n\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"enabling -24to32 for 24bpp video\\n\""
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\"",
            "raw_fb_native_bpp",
            "raw_fb_native_red_mask",
            "raw_fb_native_green_mask",
            "raw_fb_native_blue_mask",
            "raw_fb_native_red_max",
            "raw_fb_native_green_max",
            "raw_fb_native_blue_max",
            "raw_fb_native_red_shift",
            "raw_fb_native_green_shift",
            "raw_fb_native_blue_shift"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid rawfb str: %s\\n\"",
            "str"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"@%dx%dx%d\"",
            "&w",
            "&h",
            "&b"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q2+1"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "q",
            "'-'"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "q",
            "'-'"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid rawfb str: %s\\n\"",
            "str"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'@'"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\":%lu/%lu/%lu\"",
            "&rm",
            "&gm",
            "&bm"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\":0x%lx/0x%lx/0x%lx\"",
            "&rm",
            "&gm",
            "&bm"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\":%lx/%lx/%lx\"",
            "&rm",
            "&gm",
            "&bm"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"#%dx%d\"",
            "&raw_fb_virt_x",
            "&raw_fb_virt_y"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'#'"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"+%d\"",
            "&raw_fb_offset"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "dpy"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"closing X DISPLAY: %s in rawfb mode.\\n\"",
            "DisplayString(dpy)"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "DisplayString(dpy)"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"not closing X DISPLAY under -noviewonly option.\\n\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_pipeinput",
          "args": [],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_pipeinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "1007-1229",
          "snippet": "void initialize_pipeinput(void) {\n\tchar *p = NULL;\n\n\tif (pipeinput_fh != NULL) {\n\t\trfbLog(\"closing pipeinput stream: %p\\n\", pipeinput_fh);\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tpipeinput_tee = 0;\n\tif (pipeinput_opts) {\n\t\tfree(pipeinput_opts);\n\t\tpipeinput_opts = NULL;\n\t}\n\n\tif (! pipeinput_str) {\n\t\treturn;\n\t}\n\n\t/* look for options:  tee, reopen, ... */\n\tif (strstr(pipeinput_str, \"UINPUT\") == pipeinput_str) {\n\t\t;\n\t} else {\n\t\tp = strchr(pipeinput_str, ':');\n\t}\n\tif (p != NULL) {\n\t\tchar *str, *opt, *q;\n\t\tint got = 0;\n\t\t*p = '\\0';\n\t\tstr = strdup(pipeinput_str);\n\t\topt = strdup(pipeinput_str);\n\t\t*p = ':';\n\t\tq = strtok(str, \",\");\n\t\twhile (q) {\n\t\t\tif (!strcmp(q, \"key\") || !strcmp(q, \"keycodes\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"reopen\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"tee\")) {\n\t\t\t\tpipeinput_tee = 1;\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tq = strtok(NULL, \",\");\n\t\t}\n\t\tif (got) {\n\t\t\tpipeinput_opts = opt;\n\t\t} else {\n\t\t\tfree(opt);\n\t\t}\n\t\tfree(str);\n\t\tp++;\n\t} else {\n\t\tp = pipeinput_str;\n\t}\nif (0) fprintf(stderr, \"initialize_pipeinput: %s -- %s\\n\", pipeinput_str, p);\n\n\tif (!strcmp(p, \"VID\")) {\n\t\tpipeinput_int = PIPEINPUT_VID;\n\t\treturn;\n\t} else if (strstr(p, \"CONSOLE\") == p) {\n\t\tint tty = 0, n;\n\t\tchar dev[32];\n\t\tif (sscanf(p, \"CONSOLE%d\", &n) == 1) {\n\t\t\ttty = n;\n\t\t}\n\t\tsprintf(dev, \"/dev/tty%d\", tty);\n\t\tpipeinput_cons_fd = open(dev, O_WRONLY);\n\t\tif (pipeinput_cons_fd >= 0) {\n\t\t\trfbLog(\"pipeinput: using linux console: %s\\n\", dev);\n\t\t\tif (pipeinput_cons_dev) {\n\t\t\t\tfree(pipeinput_cons_dev);\n\t\t\t}\n\t\t\tpipeinput_cons_dev = strdup(dev);\n\t\t\tpipeinput_int = PIPEINPUT_CONSOLE;\n\t\t} else {\n\t\t\trfbLog(\"pipeinput: could not open: %s\\n\", dev);\n\t\t\trfbLogPerror(\"open\");\n\t\t\trfbLog(\"You may need to be root to open %s.\\n\", dev);\n\t\t\trfbLog(\"\\n\");\n\t\t}\n\t\treturn;\n\t} else if (strstr(p, \"UINPUT\") == p) {\n\t\tchar *q = strchr(p, ':');\n\t\tif (q) {\n\t\t\tparse_uinput_str(q+1);\n\t\t}\n\t\tpipeinput_int = PIPEINPUT_UINPUT;\n\t\tinitialize_uinput();\n\t\treturn;\n\t} else if (strstr(p, \"MACOSX\") == p) {\n\t\tpipeinput_int = PIPEINPUT_MACOSX;\n\t\treturn;\n\t} else if (strstr(p, \"VNC\") == p) {\n\t\tpipeinput_int = PIPEINPUT_VNC;\n\t\treturn;\n\t}\n\n\tset_child_info();\n\t/* pipeinput */\n\tif (no_external_cmds || !cmd_ok(\"pipeinput\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", p);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"pipeinput: starting: \\\"%s\\\"...\\n\", p);\n\tclose_exec_fds();\n\tpipeinput_fh = popen(p, \"w\");\n\n\tif (! pipeinput_fh) {\n\t\trfbLog(\"popen(\\\"%s\\\", \\\"w\\\") failed.\\n\", p);\n\t\trfbLogPerror(\"popen\");\n\t\trfbLog(\"Disabling -pipeinput mode.\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(pipeinput_fh, \"%s\",\n\"# \\n\"\n\"# Format of the -pipeinput stream:\\n\"\n\"# --------------------------------\\n\"\n\"#\\n\"\n\"# Lines like these beginning with '#' are to be ignored.\\n\"\n\"#\\n\"\n\"# Pointer events (mouse motion and button clicks) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Pointer <client#> <x> <y> <mask> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is a decimal integer uniquely identifying the client\\n\"\n\"# that generated the event.  If it is negative that means this event\\n\"\n\"# would have been discarded since the client was viewonly.\\n\"\n\"#\\n\"\n\"# <x> and <y> are decimal integers reflecting the position on the screen\\n\"\n\"# the event took place at.\\n\"\n\"#\\n\"\n\"# <mask> is the button mask indicating the button press state, as normal\\n\"\n\"# 0 means no buttons pressed, 1 means button 1 is down 3 (11) means buttons\\n\"\n\"# 1 and 2 are down, etc.\\n\"\n\"#\\n\"\n\"# <hint> is a string containing no spaces and may be ignored.\\n\"\n\"# It contains some interpretation about what has happened.\\n\"\n\"# It can be:\\n\"\n\"#\\n\"\n\"#\tNone\t\t(nothing to report)\\n\"\n\"#\tButtonPress-N\t(this event will cause button-N to be pressed) \\n\"\n\"#\tButtonRelease-N\t(this event will cause button-N to be released) \\n\"\n\"#\\n\"\n\"# if two more more buttons change state in one event they are listed\\n\"\n\"# separated by commas.\\n\"\n\"#\\n\"\n\"# One might parse a Pointer line with:\\n\"\n\"#\\n\"\n\"# int client, x, y, mask; char hint[100];\\n\"\n\"# sscanf(line, \\\"Pointer %d %d %d %d %s\\\", &client, &x, &y, &mask, hint);\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym events (keyboard presses and releases) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym <client#> <down> <keysym#> <keysym-name> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is as with Pointer.\\n\"\n\"#\\n\"\n\"# <down> is a decimal either 1 or 0 indicating KeyPress or KeyRelease,\\n\"\n\"# respectively.\\n\"\n\"#\\n\"\n\"# <keysym#> is a decimal integer incidating the Keysym of the event.\\n\"\n\"#\\n\"\n\"# <keysym-name> is the corresponding Keysym name.\\n\"\n\"#\\n\"\n\"# See the file /usr/include/X11/keysymdef.h for the mappings.\\n\"\n\"# You basically remove the leading 'XK_' prefix from the macro name in\\n\"\n\"# that file to get the Keysym name.\\n\"\n\"#\\n\"\n\"# One might parse a Keysym line with:\\n\"\n\"#\\n\"\n\"# int client, down, keysym; char name[100], hint[100];\\n\"\n\"# sscanf(line, \\\"Keysym %d %d %d %s %s\\\", &client, &down, &keysym, name, hint);\\n\"\n\"#\\n\"\n\"# The <hint> value is currently just None, KeyPress, or KeyRelease.\\n\"\n\"#\\n\"\n\"# In the future <hint> will provide a hint for the sequence of KeyCodes\\n\"\n\"# (i.e. keyboard scancodes) that x11vnc would inject to an X display to\\n\"\n\"# simulate the Keysym.\\n\"\n\"#\\n\"\n\"# You see, some Keysyms will require more than one injected Keycode to\\n\"\n\"# generate the symbol.  E.g. the Keysym \\\"ampersand\\\" going down usually\\n\"\n\"# requires a Shift key going down, then the key with the \\\"&\\\" on it going\\n\"\n\"# down, and, perhaps, the Shift key going up (that is how x11vnc does it).\\n\"\n\"#\\n\"\n\"# The Keysym => Keycode(s) stuff gets pretty messy.  Hopefully the Keysym\\n\"\n\"# info will be enough for most purposes (having identical keyboards on\\n\"\n\"# both sides helps).\\n\"\n\"#\\n\"\n\"# Parsing example for perl:\\n\"\n\"#\\n\"\n\"# while (<>) {\\n\"\n\"#     chomp;\\n\"\n\"#     if (/^Pointer/) {\\n\"\n\"#         my ($p, $client, $x, $y, $mask, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_pointer($client, $x, $y, $mask, $hint);\\n\"\n\"#     } elsif (/^Keysym/) {\\n\"\n\"#         my ($k, $client, $down, $keysym, $name, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_keysym($client, $down, $keysym, $name, $hint);\\n\"\n\"#     }\\n\"\n\"# }\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Here comes your stream.  The following token will always indicate the\\n\"\n\"# end of this informational text:\\n\"\n\"# END_OF_TOP\\n\"\n);\n\tfflush(pipeinput_fh);\n\tif (raw_fb_str) {\n\t\t/* the pipe program may actually create the fb */\n\t\tsleep(1);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void initialize_pipeinput(void);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void buttonparse(int from, char **s);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid initialize_pipeinput(void);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void buttonparse(int from, char **s);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid initialize_pipeinput(void) {\n\tchar *p = NULL;\n\n\tif (pipeinput_fh != NULL) {\n\t\trfbLog(\"closing pipeinput stream: %p\\n\", pipeinput_fh);\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tpipeinput_tee = 0;\n\tif (pipeinput_opts) {\n\t\tfree(pipeinput_opts);\n\t\tpipeinput_opts = NULL;\n\t}\n\n\tif (! pipeinput_str) {\n\t\treturn;\n\t}\n\n\t/* look for options:  tee, reopen, ... */\n\tif (strstr(pipeinput_str, \"UINPUT\") == pipeinput_str) {\n\t\t;\n\t} else {\n\t\tp = strchr(pipeinput_str, ':');\n\t}\n\tif (p != NULL) {\n\t\tchar *str, *opt, *q;\n\t\tint got = 0;\n\t\t*p = '\\0';\n\t\tstr = strdup(pipeinput_str);\n\t\topt = strdup(pipeinput_str);\n\t\t*p = ':';\n\t\tq = strtok(str, \",\");\n\t\twhile (q) {\n\t\t\tif (!strcmp(q, \"key\") || !strcmp(q, \"keycodes\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"reopen\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"tee\")) {\n\t\t\t\tpipeinput_tee = 1;\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tq = strtok(NULL, \",\");\n\t\t}\n\t\tif (got) {\n\t\t\tpipeinput_opts = opt;\n\t\t} else {\n\t\t\tfree(opt);\n\t\t}\n\t\tfree(str);\n\t\tp++;\n\t} else {\n\t\tp = pipeinput_str;\n\t}\nif (0) fprintf(stderr, \"initialize_pipeinput: %s -- %s\\n\", pipeinput_str, p);\n\n\tif (!strcmp(p, \"VID\")) {\n\t\tpipeinput_int = PIPEINPUT_VID;\n\t\treturn;\n\t} else if (strstr(p, \"CONSOLE\") == p) {\n\t\tint tty = 0, n;\n\t\tchar dev[32];\n\t\tif (sscanf(p, \"CONSOLE%d\", &n) == 1) {\n\t\t\ttty = n;\n\t\t}\n\t\tsprintf(dev, \"/dev/tty%d\", tty);\n\t\tpipeinput_cons_fd = open(dev, O_WRONLY);\n\t\tif (pipeinput_cons_fd >= 0) {\n\t\t\trfbLog(\"pipeinput: using linux console: %s\\n\", dev);\n\t\t\tif (pipeinput_cons_dev) {\n\t\t\t\tfree(pipeinput_cons_dev);\n\t\t\t}\n\t\t\tpipeinput_cons_dev = strdup(dev);\n\t\t\tpipeinput_int = PIPEINPUT_CONSOLE;\n\t\t} else {\n\t\t\trfbLog(\"pipeinput: could not open: %s\\n\", dev);\n\t\t\trfbLogPerror(\"open\");\n\t\t\trfbLog(\"You may need to be root to open %s.\\n\", dev);\n\t\t\trfbLog(\"\\n\");\n\t\t}\n\t\treturn;\n\t} else if (strstr(p, \"UINPUT\") == p) {\n\t\tchar *q = strchr(p, ':');\n\t\tif (q) {\n\t\t\tparse_uinput_str(q+1);\n\t\t}\n\t\tpipeinput_int = PIPEINPUT_UINPUT;\n\t\tinitialize_uinput();\n\t\treturn;\n\t} else if (strstr(p, \"MACOSX\") == p) {\n\t\tpipeinput_int = PIPEINPUT_MACOSX;\n\t\treturn;\n\t} else if (strstr(p, \"VNC\") == p) {\n\t\tpipeinput_int = PIPEINPUT_VNC;\n\t\treturn;\n\t}\n\n\tset_child_info();\n\t/* pipeinput */\n\tif (no_external_cmds || !cmd_ok(\"pipeinput\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", p);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"pipeinput: starting: \\\"%s\\\"...\\n\", p);\n\tclose_exec_fds();\n\tpipeinput_fh = popen(p, \"w\");\n\n\tif (! pipeinput_fh) {\n\t\trfbLog(\"popen(\\\"%s\\\", \\\"w\\\") failed.\\n\", p);\n\t\trfbLogPerror(\"popen\");\n\t\trfbLog(\"Disabling -pipeinput mode.\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(pipeinput_fh, \"%s\",\n\"# \\n\"\n\"# Format of the -pipeinput stream:\\n\"\n\"# --------------------------------\\n\"\n\"#\\n\"\n\"# Lines like these beginning with '#' are to be ignored.\\n\"\n\"#\\n\"\n\"# Pointer events (mouse motion and button clicks) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Pointer <client#> <x> <y> <mask> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is a decimal integer uniquely identifying the client\\n\"\n\"# that generated the event.  If it is negative that means this event\\n\"\n\"# would have been discarded since the client was viewonly.\\n\"\n\"#\\n\"\n\"# <x> and <y> are decimal integers reflecting the position on the screen\\n\"\n\"# the event took place at.\\n\"\n\"#\\n\"\n\"# <mask> is the button mask indicating the button press state, as normal\\n\"\n\"# 0 means no buttons pressed, 1 means button 1 is down 3 (11) means buttons\\n\"\n\"# 1 and 2 are down, etc.\\n\"\n\"#\\n\"\n\"# <hint> is a string containing no spaces and may be ignored.\\n\"\n\"# It contains some interpretation about what has happened.\\n\"\n\"# It can be:\\n\"\n\"#\\n\"\n\"#\tNone\t\t(nothing to report)\\n\"\n\"#\tButtonPress-N\t(this event will cause button-N to be pressed) \\n\"\n\"#\tButtonRelease-N\t(this event will cause button-N to be released) \\n\"\n\"#\\n\"\n\"# if two more more buttons change state in one event they are listed\\n\"\n\"# separated by commas.\\n\"\n\"#\\n\"\n\"# One might parse a Pointer line with:\\n\"\n\"#\\n\"\n\"# int client, x, y, mask; char hint[100];\\n\"\n\"# sscanf(line, \\\"Pointer %d %d %d %d %s\\\", &client, &x, &y, &mask, hint);\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym events (keyboard presses and releases) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym <client#> <down> <keysym#> <keysym-name> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is as with Pointer.\\n\"\n\"#\\n\"\n\"# <down> is a decimal either 1 or 0 indicating KeyPress or KeyRelease,\\n\"\n\"# respectively.\\n\"\n\"#\\n\"\n\"# <keysym#> is a decimal integer incidating the Keysym of the event.\\n\"\n\"#\\n\"\n\"# <keysym-name> is the corresponding Keysym name.\\n\"\n\"#\\n\"\n\"# See the file /usr/include/X11/keysymdef.h for the mappings.\\n\"\n\"# You basically remove the leading 'XK_' prefix from the macro name in\\n\"\n\"# that file to get the Keysym name.\\n\"\n\"#\\n\"\n\"# One might parse a Keysym line with:\\n\"\n\"#\\n\"\n\"# int client, down, keysym; char name[100], hint[100];\\n\"\n\"# sscanf(line, \\\"Keysym %d %d %d %s %s\\\", &client, &down, &keysym, name, hint);\\n\"\n\"#\\n\"\n\"# The <hint> value is currently just None, KeyPress, or KeyRelease.\\n\"\n\"#\\n\"\n\"# In the future <hint> will provide a hint for the sequence of KeyCodes\\n\"\n\"# (i.e. keyboard scancodes) that x11vnc would inject to an X display to\\n\"\n\"# simulate the Keysym.\\n\"\n\"#\\n\"\n\"# You see, some Keysyms will require more than one injected Keycode to\\n\"\n\"# generate the symbol.  E.g. the Keysym \\\"ampersand\\\" going down usually\\n\"\n\"# requires a Shift key going down, then the key with the \\\"&\\\" on it going\\n\"\n\"# down, and, perhaps, the Shift key going up (that is how x11vnc does it).\\n\"\n\"#\\n\"\n\"# The Keysym => Keycode(s) stuff gets pretty messy.  Hopefully the Keysym\\n\"\n\"# info will be enough for most purposes (having identical keyboards on\\n\"\n\"# both sides helps).\\n\"\n\"#\\n\"\n\"# Parsing example for perl:\\n\"\n\"#\\n\"\n\"# while (<>) {\\n\"\n\"#     chomp;\\n\"\n\"#     if (/^Pointer/) {\\n\"\n\"#         my ($p, $client, $x, $y, $mask, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_pointer($client, $x, $y, $mask, $hint);\\n\"\n\"#     } elsif (/^Keysym/) {\\n\"\n\"#         my ($k, $client, $down, $keysym, $name, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_keysym($client, $down, $keysym, $name, $hint);\\n\"\n\"#     }\\n\"\n\"# }\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Here comes your stream.  The following token will always indicate the\\n\"\n\"# end of this informational text:\\n\"\n\"# END_OF_TOP\\n\"\n);\n\tfflush(pipeinput_fh);\n\tif (raw_fb_str) {\n\t\t/* the pipe program may actually create the fb */\n\t\tsleep(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"VNC\""
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflector set rawfb str to: %s\\n\"",
            "str"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_reflect_guess",
          "args": [
            "str",
            "&raw_fb_addr"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_reflect_guess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1458-1564",
          "snippet": "char *vnc_reflect_guess(char *str, char **raw_fb_addr) {\n\n\tstatic int first = 1;\n\tchar *hp = str + strlen(\"vnc:\");\n\tchar *at = NULL;\n\tint argc = 0, i;\n\tchar *argv[16];\n\tchar str2[256];\n\tchar *str0 = strdup(str);\n\n\tif (client == NULL) {\n\t\tint bitsPerSample = 8;\n\t\tint samplesPerPixel = 3;\n\t\tint bytesPerPixel = 4;\n\t\tchar *s;\n\t\ts = getenv(\"X11VNC_REFLECT_bitsPerSample\");\n\t\tif (s) bitsPerSample = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_samplesPerPixel\");\n\t\tif (s) samplesPerPixel = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_bytesPerPixel\");\n\t\tif (s) bytesPerPixel = atoi(s);\n\t\trfbLog(\"rfbGetClient(bitsPerSample=%d, samplesPerPixel=%d, bytesPerPixel=%d)\\n\",\n\t\t    bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t\tclient = rfbGetClient(bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t}\n\n\trfbLog(\"rawfb: %s\\n\", str);\n\n\tat = strchr(hp, '@');\n\tif (at) {\n\t\t*at = '\\0';\n\t\tat++;\n\t}\n\n\tclient->appData.useRemoteCursor = TRUE;\n\tclient->canHandleNewFBSize = TRUE;\n\n\tclient->HandleCursorPos = vnc_reflect_cursor_pos;\n\tclient->GotFrameBufferUpdate = vnc_reflect_got_update;\n\tclient->MallocFrameBuffer = vnc_reflect_resize;\n\tclient->Bell = vnc_reflect_bell;\n#if 0\n\tclient->SoftCursorLockArea = NULL;\n\tclient->SoftCursorUnlockScreen = NULL;\n\tclient->FinishedFrameBufferUpdate = NULL;\n\tclient->HandleKeyboardLedState = NULL;\n\tclient->HandleTextChat = NULL;\n#endif\n\tclient->GotXCutText = vnc_reflect_recv_cuttext;\n\tclient->GotCursorShape = vnc_reflect_got_cursorshape;\n\tclient->GotCopyRect = vnc_reflect_got_copyrect;\n\n\tif (getenv(\"X11VNC_REFLECT_PASSWORD\")) {\n\t\tclient->GetPassword = vnc_reflect_get_password;\n\t}\n#ifdef rfbCredentialTypeX509\n\tclient->GetCredential = NULL;\n\tif (0 || getenv(\"LIBVNCCLIENT_GET_CREDENTIAL\")) {\n\t\tclient->GetCredential = vnc_reflect_get_credential;\n\t}\n#endif\n\n\tif (first) {\n\t\targv[argc++] = \"x11vnc_rawfb_vnc\";\n\t\tif (strstr(hp, \"listen\") == hp) {\n\t\t\tchar *q = strrchr(hp, ':');\n\t\t\targv[argc++] = strdup(\"-listen\");\n\t\t\tif (q) {\n\t\t\t\tclient->listenPort = atoi(q+1);\n\t\t\t} else {\n\t\t\t\tclient->listenPort = LISTEN_PORT_OFFSET;\n\t\t\t}\n\t\t} else {\n\t\t\targv[argc++] = strdup(hp);\n\t\t}\n\n\t\tif (! rfbInitClient(client, &argc, argv)) {\n\t\t\trfbLog(\"vnc_reflector failed for: %s\\n\", str0);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tif (at) {\n\t\tsprintf(str2, \"map:/dev/null@%s\", at);\n\t} else {\n\t\tunsigned long red_mask, green_mask, blue_mask;\n\t\tred_mask   = (client->format.redMax   << client->format.redShift);\n\t\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\t\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\t\tsprintf(str2, \"map:/dev/null@%dx%dx%d:0x%lx/0x%lx/0x%lx\",\n\t\t    client->width, client->height, client->format.bitsPerPixel,\n\t\t    red_mask, green_mask, blue_mask);\n\t}\n\t*raw_fb_addr = (char *) client->frameBuffer;\n\tfree(str0);\n\n\tif (first) {\n\t\tsetup_cursors_and_push();\n\n\t\tfor (i=0; i<10; i++) {\n\t\t\tvnc_reflect_process_client();\n\t\t}\n\t}\n\tfirst = 0;\n\n\treturn strdup(str2);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *vnc_reflect_guess(char *str, char **raw_fb_addr);",
            "void vnc_reflect_process_client(void);",
            "static void set_visual(char *str);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr);\nvoid vnc_reflect_process_client(void);\nstatic void set_visual(char *str);\nstatic rfbClient* client = NULL;\n\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr) {\n\n\tstatic int first = 1;\n\tchar *hp = str + strlen(\"vnc:\");\n\tchar *at = NULL;\n\tint argc = 0, i;\n\tchar *argv[16];\n\tchar str2[256];\n\tchar *str0 = strdup(str);\n\n\tif (client == NULL) {\n\t\tint bitsPerSample = 8;\n\t\tint samplesPerPixel = 3;\n\t\tint bytesPerPixel = 4;\n\t\tchar *s;\n\t\ts = getenv(\"X11VNC_REFLECT_bitsPerSample\");\n\t\tif (s) bitsPerSample = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_samplesPerPixel\");\n\t\tif (s) samplesPerPixel = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_bytesPerPixel\");\n\t\tif (s) bytesPerPixel = atoi(s);\n\t\trfbLog(\"rfbGetClient(bitsPerSample=%d, samplesPerPixel=%d, bytesPerPixel=%d)\\n\",\n\t\t    bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t\tclient = rfbGetClient(bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t}\n\n\trfbLog(\"rawfb: %s\\n\", str);\n\n\tat = strchr(hp, '@');\n\tif (at) {\n\t\t*at = '\\0';\n\t\tat++;\n\t}\n\n\tclient->appData.useRemoteCursor = TRUE;\n\tclient->canHandleNewFBSize = TRUE;\n\n\tclient->HandleCursorPos = vnc_reflect_cursor_pos;\n\tclient->GotFrameBufferUpdate = vnc_reflect_got_update;\n\tclient->MallocFrameBuffer = vnc_reflect_resize;\n\tclient->Bell = vnc_reflect_bell;\n#if 0\n\tclient->SoftCursorLockArea = NULL;\n\tclient->SoftCursorUnlockScreen = NULL;\n\tclient->FinishedFrameBufferUpdate = NULL;\n\tclient->HandleKeyboardLedState = NULL;\n\tclient->HandleTextChat = NULL;\n#endif\n\tclient->GotXCutText = vnc_reflect_recv_cuttext;\n\tclient->GotCursorShape = vnc_reflect_got_cursorshape;\n\tclient->GotCopyRect = vnc_reflect_got_copyrect;\n\n\tif (getenv(\"X11VNC_REFLECT_PASSWORD\")) {\n\t\tclient->GetPassword = vnc_reflect_get_password;\n\t}\n#ifdef rfbCredentialTypeX509\n\tclient->GetCredential = NULL;\n\tif (0 || getenv(\"LIBVNCCLIENT_GET_CREDENTIAL\")) {\n\t\tclient->GetCredential = vnc_reflect_get_credential;\n\t}\n#endif\n\n\tif (first) {\n\t\targv[argc++] = \"x11vnc_rawfb_vnc\";\n\t\tif (strstr(hp, \"listen\") == hp) {\n\t\t\tchar *q = strrchr(hp, ':');\n\t\t\targv[argc++] = strdup(\"-listen\");\n\t\t\tif (q) {\n\t\t\t\tclient->listenPort = atoi(q+1);\n\t\t\t} else {\n\t\t\t\tclient->listenPort = LISTEN_PORT_OFFSET;\n\t\t\t}\n\t\t} else {\n\t\t\targv[argc++] = strdup(hp);\n\t\t}\n\n\t\tif (! rfbInitClient(client, &argc, argv)) {\n\t\t\trfbLog(\"vnc_reflector failed for: %s\\n\", str0);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tif (at) {\n\t\tsprintf(str2, \"map:/dev/null@%s\", at);\n\t} else {\n\t\tunsigned long red_mask, green_mask, blue_mask;\n\t\tred_mask   = (client->format.redMax   << client->format.redShift);\n\t\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\t\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\t\tsprintf(str2, \"map:/dev/null@%dx%dx%d:0x%lx/0x%lx/0x%lx\",\n\t\t    client->width, client->height, client->format.bitsPerPixel,\n\t\t    red_mask, green_mask, blue_mask);\n\t}\n\t*raw_fb_addr = (char *) client->frameBuffer;\n\tfree(str0);\n\n\tif (first) {\n\t\tsetup_cursors_and_push();\n\n\t\tfor (i=0; i<10; i++) {\n\t\t\tvnc_reflect_process_client();\n\t\t}\n\t}\n\tfirst = 0;\n\n\treturn strdup(str2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"vnc:\""
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"console_guess returned: %s\\n\"",
            "str"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"console_guess failed for: %s\\n\"",
            "str"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_guess",
          "args": [
            "str",
            "&raw_fb_fd"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "console_guess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/linuxfb.c",
          "lines": "82-292",
          "snippet": "char *console_guess(char *str, int *fd) {\n\tchar *q, *in = strdup(str);\n\tchar *atparms = NULL, *file = NULL;\n\tint do_input, have_uinput, tty = -1;\n\n#ifdef MACOSX\n\treturn macosx_console_guess(str, fd);\n#endif\n\n\n\tif (strstr(in, \"/dev/fb\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console:\") + strlen(str) + 1);\n\t\tsprintf(in, \"console:%s\", str);\n\t} else if (strstr(in, \"fb\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console:/dev/\") + strlen(str) + 1);\n\t\tsprintf(in, \"console:/dev/%s\", str);\n\t} else if (strstr(in, \"vt\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console_\") + strlen(str) + 1);\n\t\tsprintf(in, \"console_%s\", str);\n\t}\n\n\tif (strstr(in, \"console\") != in) {\n\t\trfbLog(\"console_guess: unrecognized console/fb format: %s\\n\", str);\n\t\tfree(in);\n\t\treturn NULL;\n\t}\n\n\tq = strrchr(in, '@');\n\tif (q) {\n\t\tatparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tq = strrchr(in, ':');\n\tif (q) {\n\t\tfile = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tif (! file || file[0] == '\\0')  {\n\t\tfile = strdup(\"/dev/fb\");\n\t}\n\tif (strstr(file, \"fb\") == file) {\n\t\tq = (char *) malloc(strlen(\"/dev/\") + strlen(file) + 1);\n\t\tsprintf(q, \"/dev/%s\", file);\n\t\tfree(file);\n\t\tfile = q;\n\t}\n\tif (!strcmp(file, \"/dev/fb\")) {\n\t\t/* sometimes no sylink fb -> fb0 */\n\t\tstruct stat sbuf;\n\t\tif (stat(file, &sbuf) != 0) {\n\t\t\tfree(file);\n\t\t\tfile = strdup(\"/dev/fb0\");\n\t\t}\n\t}\n\n\tdo_input = 1;\n\tif (pipeinput_str) {\n\t\thave_uinput = 0;\n\t\tdo_input = 0;\n\t} else {\n\t\thave_uinput = check_uinput();\n\t}\n\tif (strstr(in, \"console_vt\")) {\n\t\thave_uinput = 0;\n\t}\n\n\tif (!strcmp(in, \"consolex\")) {\n\t\tdo_input = 0;\n\t} else if (strstr(in, \"console_vtx\")) {\n\t\thave_uinput = 0;\n\t\tdo_input = 0;\n\t} else if (!strcmp(in, \"console\")) {\n\t\t/* current active VT: */\n\t\tif (! have_uinput) {\n\t\t\ttty = 0;\n\t\t}\n\t} else {\n\t\tint n;\n\t\tif (sscanf(in, \"console%d\", &n) == 1)  {\n\t\t\ttty = n;\n\t\t\thave_uinput = 0;\n\t\t} else if (sscanf(in, \"console_vt%d\", &n) == 1)  {\n\t\t\ttty = n;\n\t\t\thave_uinput = 0;\n\t\t}\n\t}\n\tif (strstr(in, \"console_vt\") == in) {\n\t\tchar tmp[100];\n\t\tint fd, rows = 30, cols = 80, w, h;\n\t\tsprintf(tmp, \"/dev/vcsa%d\", tty);\n\t\tfile = strdup(tmp);\n\t\tfd = open(file, O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tread(fd, tmp, 4);\n\t\t\trows = (unsigned char) tmp[0];\n\t\t\tcols = (unsigned char) tmp[1];\n\t\t\tclose(fd);\n\t\t}\n\t\tw = cols * 8;\n\t\th = rows * 16;\n\t\trfbLog(\"%s %dx%d\\n\", file, cols, rows);\n\t\tif (getenv(\"RAWFB_VCSA_BPP\")) {\n\t\t\t/* 8bpp, etc */\n\t\t\tint bt = atoi(getenv(\"RAWFB_VCSA_BPP\"));\n\t\t\tif (bt > 0 && bt <=32) {\n\t\t\t\tsprintf(tmp, \"%dx%dx%d\", w, h, bt);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"%dx%dx16\", w, h);\n\t\t\t}\n\t\t} else {\n\t\t\t/* default 16bpp */\n\t\t\tsprintf(tmp, \"%dx%dx16\", w, h);\n\t\t}\n\t\tatparms = strdup(tmp);\n\t}\n\trfbLog(\"console_guess: file is %s\\n\", file);\n\n\tif (! atparms) {\n#if HAVE_LINUX_FB_H\n#if HAVE_SYS_IOCTL_H\n\t\tstruct fb_var_screeninfo var_info;\n\t\tint d = open(file, O_RDWR);\n\t\tif (d >= 0) {\n\t\t\tint w, h, b;\n\t\t\tunsigned long rm = 0, gm = 0, bm = 0;\n\t\t\tif (ioctl(d, FBIOGET_VSCREENINFO, &var_info) != -1) {\n\t\t\t\tw = (int) var_info.xres;\n\t\t\t\th = (int) var_info.yres;\n\t\t\t\tb = (int) var_info.bits_per_pixel;\n\n\t\t\t\trm = (1 << var_info.red.length)   - 1;\n\t\t\t\tgm = (1 << var_info.green.length) - 1;\n\t\t\t\tbm = (1 << var_info.blue.length)  - 1;\n\t\t\t\trm = rm << var_info.red.offset;\n\t\t\t\tgm = gm << var_info.green.offset;\n\t\t\t\tbm = bm << var_info.blue.offset;\n\n\t\t\t\tif (b == 8 && rm == 0xff && gm == 0xff && bm == 0xff) {\n\t\t\t\t\t/* I don't believe it... */\n\t\t\t\t\trm = 0x07;\n\t\t\t\t\tgm = 0x38;\n\t\t\t\t\tbm = 0xc0;\n\t\t\t\t}\n\t\t\t\tif (b <= 8 && (rm == gm && gm == bm)) {\n\t\t\t\t\tif (b == 4) {\n\t\t\t\t\t\trm = 0x07;\n\t\t\t\t\t\tgm = 0x38;\n\t\t\t\t\t\tbm = 0xc0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* @66666x66666x32:0xffffffff:... */\n\t\t\t\tatparms = (char *) malloc(200);\n\t\t\t\tsprintf(atparms, \"%dx%dx%d:%lx/%lx/%lx\",\n\t\t\t\t    w, h, b, rm, gm, bm);\n\t\t\t\t*fd = d;\n\t\t\t} else {\n\t\t\t\tperror(\"ioctl\");\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"could not open: %s\\n\", file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(file);\n\t\t\tclose(d);\n\t\t}\n#endif\n#endif\n\t}\n\n\tif (atparms) {\n\t\tint gw, gh, gb;\n\t\tif (sscanf(atparms, \"%dx%dx%d\", &gw, &gh, &gb) == 3)  {\n\t\t\tfb_x = gw;\t\n\t\t\tfb_y = gh;\t\n\t\t\tfb_b = gb;\t\n\t\t}\n\t}\n\n\tif (do_input) {\n\t\tif (tty >=0 && tty < 64) {\n\t\t\tpipeinput_str = (char *) malloc(10);\n\t\t\tsprintf(pipeinput_str, \"CONSOLE%d\", tty);\n\t\t\trfbLog(\"console_guess: file pipeinput %s\\n\",\n\t\t\t    pipeinput_str);\n\t\t\tinitialize_pipeinput();\n\t\t} else if (have_uinput) {\n\t\t\tpipeinput_str = strdup(\"UINPUT\");\n\t\t\trfbLog(\"console_guess: file pipeinput %s\\n\",\n\t\t\t    pipeinput_str);\n\t\t\tinitialize_pipeinput();\n\t\t}\n\t}\n\n\tif (! atparms) {\n\t\trfbLog(\"console_guess: could not get @ parameters.\\n\");\n\t\treturn NULL;\n\t}\n\n\tq = (char *) malloc(strlen(\"mmap:\") + strlen(file) + 1 + strlen(atparms) + 1);\n\tif (strstr(in, \"console_vt\")) {\n\t\tsprintf(q, \"snap:%s@%s\", file, atparms);\n\t} else {\n\t\tsprintf(q, \"map:%s@%s\", file, atparms);\n\t}\n\tfree(atparms);\n\treturn q;\n}",
          "includes": [
            "#include <linux/fb.h>",
            "#include <sys/ioctl.h>",
            "#include \"macosx.h\"",
            "#include \"keyboard.h\"",
            "#include \"uinput.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *console_guess(char *str, int *fd);",
            "void linux_dev_fb_msg(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fb.h>\n#include <sys/ioctl.h>\n#include \"macosx.h\"\n#include \"keyboard.h\"\n#include \"uinput.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *console_guess(char *str, int *fd);\nvoid linux_dev_fb_msg(char *);\n\nchar *console_guess(char *str, int *fd) {\n\tchar *q, *in = strdup(str);\n\tchar *atparms = NULL, *file = NULL;\n\tint do_input, have_uinput, tty = -1;\n\n#ifdef MACOSX\n\treturn macosx_console_guess(str, fd);\n#endif\n\n\n\tif (strstr(in, \"/dev/fb\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console:\") + strlen(str) + 1);\n\t\tsprintf(in, \"console:%s\", str);\n\t} else if (strstr(in, \"fb\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console:/dev/\") + strlen(str) + 1);\n\t\tsprintf(in, \"console:/dev/%s\", str);\n\t} else if (strstr(in, \"vt\") == in) {\n\t\tfree(in);\n\t\tin = (char *) malloc(strlen(\"console_\") + strlen(str) + 1);\n\t\tsprintf(in, \"console_%s\", str);\n\t}\n\n\tif (strstr(in, \"console\") != in) {\n\t\trfbLog(\"console_guess: unrecognized console/fb format: %s\\n\", str);\n\t\tfree(in);\n\t\treturn NULL;\n\t}\n\n\tq = strrchr(in, '@');\n\tif (q) {\n\t\tatparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tq = strrchr(in, ':');\n\tif (q) {\n\t\tfile = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tif (! file || file[0] == '\\0')  {\n\t\tfile = strdup(\"/dev/fb\");\n\t}\n\tif (strstr(file, \"fb\") == file) {\n\t\tq = (char *) malloc(strlen(\"/dev/\") + strlen(file) + 1);\n\t\tsprintf(q, \"/dev/%s\", file);\n\t\tfree(file);\n\t\tfile = q;\n\t}\n\tif (!strcmp(file, \"/dev/fb\")) {\n\t\t/* sometimes no sylink fb -> fb0 */\n\t\tstruct stat sbuf;\n\t\tif (stat(file, &sbuf) != 0) {\n\t\t\tfree(file);\n\t\t\tfile = strdup(\"/dev/fb0\");\n\t\t}\n\t}\n\n\tdo_input = 1;\n\tif (pipeinput_str) {\n\t\thave_uinput = 0;\n\t\tdo_input = 0;\n\t} else {\n\t\thave_uinput = check_uinput();\n\t}\n\tif (strstr(in, \"console_vt\")) {\n\t\thave_uinput = 0;\n\t}\n\n\tif (!strcmp(in, \"consolex\")) {\n\t\tdo_input = 0;\n\t} else if (strstr(in, \"console_vtx\")) {\n\t\thave_uinput = 0;\n\t\tdo_input = 0;\n\t} else if (!strcmp(in, \"console\")) {\n\t\t/* current active VT: */\n\t\tif (! have_uinput) {\n\t\t\ttty = 0;\n\t\t}\n\t} else {\n\t\tint n;\n\t\tif (sscanf(in, \"console%d\", &n) == 1)  {\n\t\t\ttty = n;\n\t\t\thave_uinput = 0;\n\t\t} else if (sscanf(in, \"console_vt%d\", &n) == 1)  {\n\t\t\ttty = n;\n\t\t\thave_uinput = 0;\n\t\t}\n\t}\n\tif (strstr(in, \"console_vt\") == in) {\n\t\tchar tmp[100];\n\t\tint fd, rows = 30, cols = 80, w, h;\n\t\tsprintf(tmp, \"/dev/vcsa%d\", tty);\n\t\tfile = strdup(tmp);\n\t\tfd = open(file, O_RDWR);\n\t\tif (fd >= 0) {\n\t\t\tread(fd, tmp, 4);\n\t\t\trows = (unsigned char) tmp[0];\n\t\t\tcols = (unsigned char) tmp[1];\n\t\t\tclose(fd);\n\t\t}\n\t\tw = cols * 8;\n\t\th = rows * 16;\n\t\trfbLog(\"%s %dx%d\\n\", file, cols, rows);\n\t\tif (getenv(\"RAWFB_VCSA_BPP\")) {\n\t\t\t/* 8bpp, etc */\n\t\t\tint bt = atoi(getenv(\"RAWFB_VCSA_BPP\"));\n\t\t\tif (bt > 0 && bt <=32) {\n\t\t\t\tsprintf(tmp, \"%dx%dx%d\", w, h, bt);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"%dx%dx16\", w, h);\n\t\t\t}\n\t\t} else {\n\t\t\t/* default 16bpp */\n\t\t\tsprintf(tmp, \"%dx%dx16\", w, h);\n\t\t}\n\t\tatparms = strdup(tmp);\n\t}\n\trfbLog(\"console_guess: file is %s\\n\", file);\n\n\tif (! atparms) {\n#if HAVE_LINUX_FB_H\n#if HAVE_SYS_IOCTL_H\n\t\tstruct fb_var_screeninfo var_info;\n\t\tint d = open(file, O_RDWR);\n\t\tif (d >= 0) {\n\t\t\tint w, h, b;\n\t\t\tunsigned long rm = 0, gm = 0, bm = 0;\n\t\t\tif (ioctl(d, FBIOGET_VSCREENINFO, &var_info) != -1) {\n\t\t\t\tw = (int) var_info.xres;\n\t\t\t\th = (int) var_info.yres;\n\t\t\t\tb = (int) var_info.bits_per_pixel;\n\n\t\t\t\trm = (1 << var_info.red.length)   - 1;\n\t\t\t\tgm = (1 << var_info.green.length) - 1;\n\t\t\t\tbm = (1 << var_info.blue.length)  - 1;\n\t\t\t\trm = rm << var_info.red.offset;\n\t\t\t\tgm = gm << var_info.green.offset;\n\t\t\t\tbm = bm << var_info.blue.offset;\n\n\t\t\t\tif (b == 8 && rm == 0xff && gm == 0xff && bm == 0xff) {\n\t\t\t\t\t/* I don't believe it... */\n\t\t\t\t\trm = 0x07;\n\t\t\t\t\tgm = 0x38;\n\t\t\t\t\tbm = 0xc0;\n\t\t\t\t}\n\t\t\t\tif (b <= 8 && (rm == gm && gm == bm)) {\n\t\t\t\t\tif (b == 4) {\n\t\t\t\t\t\trm = 0x07;\n\t\t\t\t\t\tgm = 0x38;\n\t\t\t\t\t\tbm = 0xc0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* @66666x66666x32:0xffffffff:... */\n\t\t\t\tatparms = (char *) malloc(200);\n\t\t\t\tsprintf(atparms, \"%dx%dx%d:%lx/%lx/%lx\",\n\t\t\t\t    w, h, b, rm, gm, bm);\n\t\t\t\t*fd = d;\n\t\t\t} else {\n\t\t\t\tperror(\"ioctl\");\n\t\t\t\tclose(d);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"could not open: %s\\n\", file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(file);\n\t\t\tclose(d);\n\t\t}\n#endif\n#endif\n\t}\n\n\tif (atparms) {\n\t\tint gw, gh, gb;\n\t\tif (sscanf(atparms, \"%dx%dx%d\", &gw, &gh, &gb) == 3)  {\n\t\t\tfb_x = gw;\t\n\t\t\tfb_y = gh;\t\n\t\t\tfb_b = gb;\t\n\t\t}\n\t}\n\n\tif (do_input) {\n\t\tif (tty >=0 && tty < 64) {\n\t\t\tpipeinput_str = (char *) malloc(10);\n\t\t\tsprintf(pipeinput_str, \"CONSOLE%d\", tty);\n\t\t\trfbLog(\"console_guess: file pipeinput %s\\n\",\n\t\t\t    pipeinput_str);\n\t\t\tinitialize_pipeinput();\n\t\t} else if (have_uinput) {\n\t\t\tpipeinput_str = strdup(\"UINPUT\");\n\t\t\trfbLog(\"console_guess: file pipeinput %s\\n\",\n\t\t\t    pipeinput_str);\n\t\t\tinitialize_pipeinput();\n\t\t}\n\t}\n\n\tif (! atparms) {\n\t\trfbLog(\"console_guess: could not get @ parameters.\\n\");\n\t\treturn NULL;\n\t}\n\n\tq = (char *) malloc(strlen(\"mmap:\") + strlen(file) + 1 + strlen(atparms) + 1);\n\tif (strstr(in, \"console_vt\")) {\n\t\tsprintf(q, \"snap:%s@%s\", file, atparms);\n\t} else {\n\t\tsprintf(q, \"map:%s@%s\", file, atparms);\n\t}\n\tfree(atparms);\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"vt\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"/dev/fb\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"fb\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"console\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"dev/video\""
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"v4l_guess returned: %s\\n\"",
            "str"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"v4l_guess failed for: %s\\n\"",
            "str"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l_guess",
          "args": [
            "str",
            "&raw_fb_fd"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_guess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1350-1396",
          "snippet": "char *v4l_guess(char *str, int *fd) {\n\tchar *dev = NULL, *settings = NULL, *atparms = NULL;\n\n\tparse_str(str, &dev, &settings, &atparms);\n\n\tinit_freqs();\n\n\tv4l1_cap = -1;\n\tv4l2_cap = -1;\n\t*fd = -1;\n\n\tif (dev == NULL) {\n\t\trfbLog(\"v4l_guess: could not find device in: %s\\n\", str);\n\t\treturn NULL;\n\t}\n\n\tif (settings) {\n\t\tapply_settings(dev, settings, fd);\n\t}\n\n\tif (atparms) {\n\t\t/* use user's parameters. */\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n\n\t/* try to query the device for parameters. */\n\tatparms = guess_via_v4l(dev, fd);\n\tif (atparms == NULL) {\n\t\t/* try again with v4l-info(1) */\n\t\tatparms = guess_via_v4l_info(dev, fd);\n\t}\n\n\tif (atparms == NULL) {\n\t\t/* bad news */\n\t\tif (*fd >= 0) {\n\t\t\tclose(*fd);\n\t\t}\n\t\t*fd = -1;\n\t\treturn NULL;\n\t} else {\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int open_dev(char *dev);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static void parse_str(char *str, char **dev, char **settings, char **atparms);",
            "static void init_freqs(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\nstatic void init_freqs(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nchar *v4l_guess(char *str, int *fd) {\n\tchar *dev = NULL, *settings = NULL, *atparms = NULL;\n\n\tparse_str(str, &dev, &settings, &atparms);\n\n\tinit_freqs();\n\n\tv4l1_cap = -1;\n\tv4l2_cap = -1;\n\t*fd = -1;\n\n\tif (dev == NULL) {\n\t\trfbLog(\"v4l_guess: could not find device in: %s\\n\", str);\n\t\treturn NULL;\n\t}\n\n\tif (settings) {\n\t\tapply_settings(dev, settings, fd);\n\t}\n\n\tif (atparms) {\n\t\t/* use user's parameters. */\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n\n\t/* try to query the device for parameters. */\n\tatparms = guess_via_v4l(dev, fd);\n\tif (atparms == NULL) {\n\t\t/* try again with v4l-info(1) */\n\t\tatparms = guess_via_v4l_info(dev, fd);\n\t}\n\n\tif (atparms == NULL) {\n\t\t/* bad news */\n\t\tif (*fd >= 0) {\n\t\t\tclose(*fd);\n\t\t}\n\t\t*fd = -1;\n\t\treturn NULL;\n\t} else {\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"/dev/video\""
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"video\""
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"VID\""
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"Video\""
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rstr"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setup command returned: %s\\n\"",
            "str"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "pipe"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read of setup command failed.\\n\""
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "pipe"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"popen\""
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"popen of setup command failed.\\n\""
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "q",
            "\"r\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running command to setup rawfb: %s\\n\"",
            "q"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "q"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\""
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"rawfb-setup\""
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"setup:\""
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_child_info",
          "args": [],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "set_child_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "417-434",
          "snippet": "void set_child_info(void) {\n\tchar pid[16];\n\t/* set up useful environment for child process */\n\tsprintf(pid, \"%d\", (int) getpid());\n\tset_env(\"X11VNC_PID\", pid);\n\tif (program_name) {\n\t\t/* e.g. for remote control -R */\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t}\n\tif (program_cmdline) {\n\t\tset_env(\"X11VNC_CMDLINE\", program_cmdline);\n\t}\n\tif (raw_fb_str) {\n\t\tset_env(\"X11VNC_RAWFB_STR\", raw_fb_str);\n\t} else {\n\t\tset_env(\"X11VNC_RAWFB_STR\", \"\");\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_child_info(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid set_child_info(void);\n\nvoid set_child_info(void) {\n\tchar pid[16];\n\t/* set up useful environment for child process */\n\tsprintf(pid, \"%d\", (int) getpid());\n\tset_env(\"X11VNC_PID\", pid);\n\tif (program_name) {\n\t\t/* e.g. for remote control -R */\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t}\n\tif (program_cmdline) {\n\t\tset_env(\"X11VNC_CMDLINE\", program_cmdline);\n\t}\n\tif (raw_fb_str) {\n\t\tset_env(\"X11VNC_RAWFB_STR\", raw_fb_str);\n\t} else {\n\t\tset_env(\"X11VNC_RAWFB_STR\", \"\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rstr",
            "\"setup:\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"map:%s@%dx%dx32\"",
            "tmp",
            "w",
            "h"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "(char *)val",
            "4 * w"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rstr",
            "\"swirl\""
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"map:%s@%dx%dx32\"",
            "tmp",
            "w",
            "h"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pixel",
          "args": [
            "n"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "get_pixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "157-175",
          "snippet": "unsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\n\nunsigned long get_pixel(char *color) {\n#if NO_X11\n\treturn 0;\n#else\n\tXColor cdef;\n\tColormap cmap;\n\tunsigned long pixel = BlackPixel(dpy, scr);\n\tif (depth > 8 || strcmp(color, solid_default)) {\n\t\tcmap = DefaultColormap (dpy, scr);\n\t\tif (XParseColor(dpy, cmap, color, &cdef) &&\n\t\t    XAllocColor(dpy, cmap, &cdef)) {\n\t\t\tpixel = cdef.pixel;\n\t\t} else {\n\t\t\trfbLog(\"error parsing/allocing color: %s\\n\", color);\n\t\t}\n\t}\n\treturn pixel;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "n",
            "\"0x%x\"",
            "&val"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "n",
            "\"0x\""
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"solid=\""
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rstr",
            "\"solid=\""
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"file:/dev/urandom@1024x768x16\""
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"RANDHUGE\""
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"file:/dev/urandom@640x480x16\""
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"RANDBIG\""
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"file:/dev/urandom@128x128x16\""
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"RAND\""
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"map:/dev/zero@1024x768x32\""
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"NONEBIG\""
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"NULLBIG\""
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"map:/dev/zero@640x480x32\""
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"NONE\""
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"ZERO\""
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "rstr",
            "\"NULL\""
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "raw_fb_str"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "raw_fb_str+1"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "raw_fb_addr",
            "raw_fb_mmap"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmdt",
          "args": [
            "raw_fb_addr"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mmap\""
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   raw_fb_addr: %p\\n\"",
            "raw_fb_addr"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to mmap file: %s\\n\"",
            "last_file"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "0",
            "raw_fb_mmap",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open\""
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to rawfb file: %s\\n\"",
            "last_file"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"initialize_raw_fb reset\\n\""
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "raw_fb_addr",
            "raw_fb_mmap"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define BOLDLY_CLOSE_DISPLAY 1\n#define RAWFB_SHM  3\n#define RAWFB_FILE 2\n#define RAWFB_MMAP 1\n\nvoid set_colormap(int reset);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\nstatic void install_fake_fb(int w, int h, int bpp);\nXImage *initialize_raw_fb(int);\nstatic void initialize_clipshift(void);\nint rawfb_dev_video = 0;\nint rawfb_vnc_reflect = 0;\nint rawfb_double_buffer = 0;\nstatic char *raw_fb_orig_dpy = NULL;\n\nXImage *initialize_raw_fb(int reset) {\n\tchar *str, *rstr, *q;\n\tint w, h, b, shmid = 0;\n\tunsigned long rm = 0, gm = 0, bm = 0, tm;\n\tstatic XImage ximage_struct;\t/* n.b.: not (XImage *) */\n\tstatic XImage ximage_struct_snap;\n\tint closedpy = 1, i, m, db = 0;\n\tint do_macosx = 0;\n\tint do_reflect = 0;\n\tchar *unlink_me = NULL;\n\n\tstatic char *last_file = NULL;\n\tstatic int last_mode = 0;\n\n\tif (reset && last_mode) {\n\t\tint fd;\n\t\tif (last_mode != RAWFB_MMAP && last_mode != RAWFB_FILE) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t}\n\t\tif (raw_fb_fd >= 0) {\n\t\t\tclose(raw_fb_fd);\n\t\t}\n\t\traw_fb_fd = -1;\nif (db) fprintf(stderr, \"initialize_raw_fb reset\\n\");\n\t\t\t\n\t\tfd = -1;\n\t\tif (rawfb_dev_video) {\n\t\t\tfd = open(last_file, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(last_file, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to rawfb file: %s\\n\", last_file);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\t\tif (last_mode == RAWFB_MMAP) {\n\t\t\traw_fb_addr = mmap(0, raw_fb_mmap, PROT_READ,\n\t\t\t    MAP_SHARED, fd, 0);\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s\\n\", last_file);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n#ifdef MACOSX\n\tif (raw_fb_addr != NULL && macosx_console && raw_fb_addr == macosx_get_fb_addr()) {\n\t\traw_fb_addr = NULL;\n\t}\n#endif\n\n\tif (raw_fb_addr || raw_fb_seek) {\n\t\tif (raw_fb_shm) {\n\t\t\tshmdt(raw_fb_addr);\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t} else if (raw_fb_mmap) {\n\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n#endif\n\t\t} else if (raw_fb_seek) {\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t}\n\t\traw_fb_addr = NULL;\n\t\traw_fb_mmap = 0;\n\t\traw_fb_seek = 0;\n\t}\n\tif (! raw_fb_str) {\n\t\treturn NULL;\n\t}\n\n\tif (raw_fb_str[0] == '+') {\n\t\trstr = strdup(raw_fb_str+1);\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t} else {\n\t\trstr = strdup(raw_fb_str);\n\t}\n\n\t/* testing aliases */\n\tif (!strcasecmp(rstr, \"NULL\") || !strcasecmp(rstr, \"ZERO\")\n\t    || !strcasecmp(rstr, \"NONE\")) {\n\t\trstr = strdup(\"map:/dev/zero@640x480x32\");\n\t} else if (!strcasecmp(rstr, \"NULLBIG\") || !strcasecmp(rstr, \"NONEBIG\")) {\n\t\trstr = strdup(\"map:/dev/zero@1024x768x32\");\n\t}\n\tif (!strcasecmp(rstr, \"RAND\")) {\n\t\trstr = strdup(\"file:/dev/urandom@128x128x16\");\n\t} else if (!strcasecmp(rstr, \"RANDBIG\")) {\n\t\trstr = strdup(\"file:/dev/urandom@640x480x16\");\n\t} else if (!strcasecmp(rstr, \"RANDHUGE\")) {\n\t\trstr = strdup(\"file:/dev/urandom@1024x768x16\");\n\t}\n\tif (strstr(rstr, \"solid=\") == rstr) {\n\t\tchar *n = rstr + strlen(\"solid=\");\n\t\tchar tmp[] = \"/tmp/rawfb_solid.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int vals[1024], val;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tif (strstr(n, \"0x\")) {\n\t\t\tif (sscanf(n, \"0x%x\", &val) != 1) {\n\t\t\t\tval = 0;\n\t\t\t}\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = get_pixel(n);\n\t\t}\n\t\tif (val == 0) {\n\t\t\tval = 0xFF00FF;\n\t\t}\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tvals[x] = val;\n\t\t\t}\n\t\t\twrite(fd, (char *)vals, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t} else if (strstr(rstr, \"swirl\") == rstr) {\n\t\tchar tmp[] = \"/tmp/rawfb_swirl.XXXXXX\";\n\t\tchar str[100];\n\t\tunsigned int val[1024];\n\t\tunsigned int c1, c2, c3, c4;\n\t\tint x, y, fd, w = 1024, h = 768;\n\t\tfd = mkstemp(tmp);\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tc1 = 0;\n\t\t\t\tc2 = ((x+y)*128)/(w+h);\n\t\t\t\tc3 = (x*128)/w;\n\t\t\t\tc4 = (y*256)/h;\n\t\t\t\tval[x] = (c1 << 24) | (c2 << 16) | (c3 << 8) | (c4 << 0);\n\t\t\t}\n\t\t\twrite(fd, (char *)val, 4 * w);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(tmp, O_WRONLY);\n\t\tunlink_me = strdup(tmp);\n\t\tsprintf(str, \"map:%s@%dx%dx32\", tmp, w, h);\n\t\trstr = strdup(str);\n\t}\n\n\n\tif ( (q = strstr(rstr, \"setup:\")) == rstr) {\n\t\tFILE *pipe;\n\t\tchar line[1024], *t;\n\n\t\tset_child_info();\n\t\tq += strlen(\"setup:\");\n\t\t/* rawfb-setup */\n\t\tif (no_external_cmds || !cmd_ok(\"rawfb-setup\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds \"\n\t\t\t    \"mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", q);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trfbLog(\"running command to setup rawfb: %s\\n\", q);\n\t\tclose_exec_fds();\n\t\tpipe = popen(q, \"r\");\n\t\tif (! pipe) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"popen of setup command failed.\\n\");\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tline[0] = '\\0';\n\t\tif (fgets(line, 1024, pipe) == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"read of setup command failed.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tpclose(pipe);\n\t\tstr = strdup(line);\n\t\tt = str;\n\t\twhile (*t != '\\0') {\n\t\t\tif (*t == '\\n') {\n\t\t\t\t*t = '\\0';\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\trfbLog(\"setup command returned: %s\\n\", str);\n\n\t} else {\n\t\tstr = strdup(rstr);\n\t}\n\n\traw_fb_shm = 0;\n\traw_fb_mmap = 0;\n\traw_fb_seek = 0;\n\traw_fb_fd = -1;\n\traw_fb_addr = NULL;\n\traw_fb_offset = 0;\n\traw_fb_bytes_per_line = 0;\n\trawfb_vnc_reflect = 0;\n\n\tlast_mode = 0;\n\tif (last_file) {\n\t\tfree(last_file);\n\t\tlast_file = NULL;\n\t}\n\tif (strstr(str, \"Video\") == str) {\n\t\tif (pipeinput_str != NULL) {\n\t\t\tfree(pipeinput_str);\n\t\t}\n\t\tpipeinput_str = strdup(\"VID\");\n\t\tinitialize_pipeinput();\n\t\tstr[0] = 'v';\n\t}\n\n\tif (strstr(str, \"video\") == str || strstr(str, \"/dev/video\") == str) {\n\t\tchar *str2 = v4l_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"v4l_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"v4l_guess returned: %s\\n\", str);\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"dev/video\")) {\n\t\trawfb_dev_video = 1;\n\t} else if (strstr(str, \"console\") == str || strstr(str, \"fb\") == str ||\n\t    strstr(str, \"/dev/fb\") == str || strstr(str, \"vt\") == str) {\n\t\tchar *str2 = console_guess(str, &raw_fb_fd);\n\t\tif (str2 == NULL) {\n\t\t\trfbLog(\"console_guess failed for: %s\\n\", str);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tstr = str2;\n\t\trfbLog(\"console_guess returned: %s\\n\", str);\n\t} else if (strstr(str, \"vnc:\") == str) {\n\t\tchar *str2 = vnc_reflect_guess(str, &raw_fb_addr);\n\n\t\trawfb_vnc_reflect = 1;\n\t\tdo_reflect = 1;\n\n\t\tstr = str2;\n\t\trfbLog(\"vnc_reflector set rawfb str to: %s\\n\", str);\n\t\tif (pipeinput_str == NULL) {\n\t\t\tpipeinput_str = strdup(\"VNC\");\n\t\t}\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (closedpy && !view_only && got_noviewonly) {\n\t\trfbLog(\"not closing X DISPLAY under -noviewonly option.\\n\");\n\t\tclosedpy = 0;\n\t\tif (! window) {\n\t\t\twindow = rootwin;\n\t\t}\n\t}\n\n\tif (! raw_fb_orig_dpy && dpy) {\n\t\traw_fb_orig_dpy = strdup(DisplayString(dpy));\n\t}\n#ifndef BOLDLY_CLOSE_DISPLAY\n#define BOLDLY_CLOSE_DISPLAY 1\n#endif\n#if BOLDLY_CLOSE_DISPLAY\n\tif (closedpy) {\n\t\tif (dpy) {\n\t\t\trfbLog(\"closing X DISPLAY: %s in rawfb mode.\\n\",\n\t\t\t    DisplayString(dpy));\n\t\t\tXCloseDisplay_wr(dpy);\t/* yow! */\n\t\t}\n\t\tdpy = NULL;\n\t}\n#endif\n\n\t/*\n\t * -rawfb shm:163938442@640x480x32:ff/ff00/ff0000+3000\n\t * -rawfb map:/path/to/file@640x480x32:ff/ff00/ff0000\n\t * -rawfb file:/path/to/file@640x480x32:ff/ff00/ff0000\n\t */\n\n\tif (raw_fb_full_str) {\n\t\tfree(raw_fb_full_str);\n\t}\n\traw_fb_full_str = strdup(str);\n\n\n\t/* +O offset */\n\tchar *end = NULL;\n\tif ((q = strrchr(str, '+')) != NULL) {\n\t\tend = q;\n\t\tif (sscanf(q, \"+%d\", &raw_fb_offset) != 1) {\n\t\t\traw_fb_offset = 0;\n\t\t}\n\t}\n\n\t/* #VWxVH virtual dimensions */\n\tif ((q = strrchr(str, '#')) != NULL) {\n\t\tif (q < end) end = q;\n\t\tif (sscanf(q, \"#%dx%d\", &raw_fb_virt_x, &raw_fb_virt_y) != 2) {\n\t\t\traw_fb_virt_x = 0;\n\t\t\traw_fb_virt_y = 0;\n\t\t}\n\t}\n\n\tif (end != NULL) *end = '\\0';\n\n\tif ((q = strrchr(str, ':')) != NULL) {\n\t\tif (sscanf(q, \":%lx/%lx/%lx\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":0x%lx/0x%lx/0x%lx\", &rm, &gm, &bm)== 3) {\n\t\t\t*q = '\\0';\n\t\t} else if (sscanf(q, \":%lu/%lu/%lu\", &rm, &gm, &bm) == 3) {\n\t\t\t*q = '\\0';\n\t\t} else {\n\t\t\trm = 0;\n\t\t\tgm = 0;\n\t\t\tbm = 0;\n\t\t}\n\t}\n\tif ((q = strrchr(str, '@')) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strrchr(q, '-')) {\n\t\tchar *q2 = strrchr(q, '-');\n\t\traw_fb_bytes_per_line = atoi(q2+1);\n\t\t*q2 = '\\0';\n\t}\n\t/* @WxHxB */\n\tif (sscanf(q, \"@%dx%dx%d\", &w, &h, &b) != 3) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\t*q = '\\0';\n\n\tif (rm == 0 && gm == 0 && bm == 0) {\n\t\t/* guess masks... */\n\t\tif (b == 24 || b == 32) {\n\t\t\trm = 0xff0000;\n\t\t\tgm = 0x00ff00;\n\t\t\tbm = 0x0000ff;\n\t\t} else if (b == 16) {\n\t\t\trm = 0xf800;\n\t\t\tgm = 0x07e0;\n\t\t\tbm = 0x001f;\n\t\t} else if (b == 8) {\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t}\n\t/* we can fake -flipbyteorder to some degree... */\n\tif (flip_byte_order) {\n\t\tif (b == 24 || b == 32) {\n\t\t\ttm = rm;\n\t\t\trm = bm;\n\t\t\tbm = tm;\n\t\t} else if (b == 16) {\n\t\t\tunsigned short s1, s2;\n\t\t\ts1 = (unsigned short) rm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\trm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) gm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tgm = (unsigned long) s2;\n\t\t\ts1 = (unsigned short) bm;\n\t\t\ts2 = ((0xff & s1) << 8) | ((0xff00 & s1) >> 8);\n\t\t\tbm = (unsigned long) s2;\n\t\t}\n\t}\n\n\t/* native fb stuff for bpp < 8 only */\n\traw_fb_native_bpp = b;\n\traw_fb_native_red_mask = rm;\n\traw_fb_native_green_mask = gm;\n\traw_fb_native_blue_mask = bm;\n\traw_fb_native_red_shift = 100;\n\traw_fb_native_green_shift = 100;\n\traw_fb_native_blue_shift = 100;\n\traw_fb_native_red_max = 1;\n\traw_fb_native_green_max = 1;\n\traw_fb_native_blue_max = 1;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (raw_fb_native_red_mask & m) {\n\t\t\tif (raw_fb_native_red_shift == 100) {\n\t\t\t\traw_fb_native_red_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_red_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_green_mask & m) {\n\t\t\tif (raw_fb_native_green_shift == 100) {\n\t\t\t\traw_fb_native_green_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_green_max *= 2;\n\t\t}\n\t\tif (raw_fb_native_blue_mask & m) {\n\t\t\tif (raw_fb_native_blue_shift == 100) {\n\t\t\t\traw_fb_native_blue_shift = i;\n\t\t\t}\n\t\t\traw_fb_native_blue_max *= 2;\n\t\t}\n\t\tm = m << 1;\n\t}\n\traw_fb_native_red_max -= 1;\n\traw_fb_native_green_max -= 1;\n\traw_fb_native_blue_max -= 1;\n\n\tif (b < 8) {\n\t\t/* e.g. VGA16 */\n\t\trfbLog(\"raw_fb_native_bpp: %d 0x%02lx 0x%02lx 0x%02lx %d/%d/%d %d/%d/%d\\n\", raw_fb_native_bpp,\n\t\t    raw_fb_native_red_mask, raw_fb_native_green_mask, raw_fb_native_blue_mask,\n\t\t    raw_fb_native_red_max, raw_fb_native_green_max, raw_fb_native_blue_max,\n\t\t    raw_fb_native_red_shift, raw_fb_native_green_shift, raw_fb_native_blue_shift);\n\t\traw_fb_expand_bytes = 1;\n\t\tb = 8;\n\t\trm = 0x07;\n\t\tgm = 0x38;\n\t\tbm = 0xc0;\n\t}\n\t/* end of stuff for bpp < 8 */\n\n\tdpy_x = wdpy_x = w;\n\tdpy_y = wdpy_y = h;\n\toff_x = 0;\n\toff_y = 0;\n\n\tif (rawfb_dev_video) {\n\t\tif (b == 24) {\n\t\t\trfbLog(\"enabling -24to32 for 24bpp video\\n\");\n\t\t\txform24to32 = 1;\n\t\t} else {\n\t\t\tif (xform24to32) {\n\t\t\t\trfbLog(\"disabling -24to32 for 24bpp video\\n\");\n\t\t\t}\n\t\t\txform24to32 = 0;\n\t\t}\n\t}\n\n\tif (xform24to32) {\n\t\tif (b != 24) {\n\t\t\trfbLog(\"warning: -24to32 mode and bpp=%d\\n\", b);\n\t\t}\n\t\tb = 32;\n\t}\n\tif (strstr(str, \"snap:\") == str) {\n\t\tuse_snapfb = 1;\n\t\tstr[0] = 'f'; str[1] = 'i'; str[2] = 'l'; str[3] = 'e';\n\t}\n\n\tif (strstr(str, \"shm:\") != str && strstr(str, \"mmap:\") != str &&\n\t    strstr(str, \"map:\") != str && strstr(str, \"file:\") != str) {\n\t\t/* hmmm, not following directions, see if map: applies */\n\t\tstruct stat sbuf;\n\t\tif (stat(str, &sbuf) == 0) {\n\t\t\tchar *newstr;\n\t\t\tint len = strlen(\"map:\") + strlen(str) + 1;\n\t\t\trfbLog(\"no type prefix: %s\\n\", raw_fb_str);\n\t\t\trfbLog(\"  but file exists, so assuming: map:%s\\n\",\n\t\t\t    raw_fb_str);\n\t\t\tnewstr = (char *) malloc(len);\n\t\t\tstrcpy(newstr, \"map:\");\n\t\t\tstrcat(newstr, str);\n\t\t\tfree(str);\n\t\t\tstr = newstr;\n\t\t}\n\t}\n\n\tif (sscanf(str, \"shm:%d\", &shmid) == 1) {\n\t\t/* shm:N */\n#if HAVE_XSHM || HAVE_SHMAT\n\t\traw_fb_addr = (char *) shmat(shmid, 0, SHM_RDONLY);\n\t\tif (! raw_fb_addr) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to attach to shm: %d, %s\\n\", shmid, str);\n\t\t\trfbLogPerror(\"shmat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_shm = 1;\n\t\trfbLog(\"rawfb: shm: %d W: %d H: %d B: %d addr: %p\\n\",\n\t\t    shmid, w, h, b, raw_fb_addr);\n\t\tlast_mode = RAWFB_SHM;\n#else\n\t\trfbLogEnable(1);\n\t\trfbLog(\"x11vnc was compiled without shm support.\\n\");\n\t\trfbLogPerror(\"shmat\");\n\t\tclean_up_exit(1);\n#endif\n\t} else if (strstr(str, \"map:\") == str || strstr(str, \"mmap:\") == str\n\t    || strstr(str, \"file:\") == str) {\n\t\t/* map:/path/... or file:/path  */\n\t\tint fd, do_mmap = 1, size, vsize = 0;\n\t\tstruct stat sbuf;\n\n\t\tif (*str == 'f') {\n\t\t\tdo_mmap = 0;\n\t\t}\n\t\tq = strchr(str, ':');\n\t\tq++;\n\n\t\tmacosx_console = 0;\n\t\tif (strstr(q, \"macosx:\") == q) {\n\t\t\t/* mmap:macosx:/dev/null@... */\n\t\t\tq += strlen(\"macosx:\");\t\t\t\n\t\t\tdo_macosx = 1;\n\t\t\tdo_mmap = 0;\n\t\t\tmacosx_console = 1;\n\t\t}\n\n\t\tlast_file = strdup(q);\n\n\t\tfd = raw_fb_fd;\n\t\tif (fd < 0 && rawfb_dev_video) {\n\t\t\tfd = open(q, O_RDWR);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfd = open(q, O_RDONLY);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"failed to open file: %s, %s\\n\", q, str);\n\t\t\trfbLogPerror(\"open\");\n\t\t\tlinux_dev_fb_msg(q);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\traw_fb_fd = fd;\n\n\t\tif (raw_fb_native_bpp < 8) {\n\t\t\tsize = w*h*raw_fb_native_bpp/8 + raw_fb_offset;\n\t\t} else if (xform24to32) {\n\t\t\tsize = w*h*24/8 + raw_fb_offset;\n\t\t} else if (raw_fb_virt_x != 0 && raw_fb_virt_y != 0) {\n\t\t\tsize = w*h*b/8;\n\t\t\tvsize = raw_fb_virt_x*raw_fb_virt_y*b/8;\n\t\t\trawfb_double_buffer = 1;\n\t\t\trfbLog(\"virtual size: %d\", vsize);\n\t\t} else {\n\t\t\tsize = w*h*b/8 + raw_fb_offset;\n\t\t}\n\n\t\tif (fstat(fd, &sbuf) == 0) {\n\t\t\tif (S_ISREG(sbuf.st_mode)) {\n\t\t\t\tif (0) size = sbuf.st_size;\n\t\t\t} else {\n\t\t\t\trfbLog(\"raw fb is non-regular file: %s\\n\", q);\n\t\t\t}\n\t\t}\n\n\t\tif (do_macosx) {\n\t\t\traw_fb_addr = macosx_get_fb_addr();\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: macosx fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\t\t} else if (do_reflect) {\n\t\t\traw_fb_mmap = size;\n\t\t\trfbLog(\"rawfb: vnc fb: %s\\n\", q);\n\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t    b, raw_fb_addr, size);\n\t\t\tlast_mode = 0;\n\n\t\t} else if (do_mmap) {\n#if LIBVNCSERVER_HAVE_MMAP\n\t\t\tif (vsize != 0) {\n\t\t\t\traw_fb_addr = mmap(0, vsize, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t} else {\n\t\t\t\traw_fb_addr = mmap(0, size, PROT_READ, MAP_SHARED, fd, 0);\n\t\t\t}\n\n\t\t\tif (raw_fb_addr == MAP_FAILED || raw_fb_addr == NULL) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"failed to mmap file: %s, %s\\n\", q, str);\n\t\t\t\trfbLog(\"   raw_fb_addr: %p\\n\", raw_fb_addr);\n\t\t\t\trfbLogPerror(\"mmap\");\n\n\t\t\t\traw_fb_addr = NULL;\n\t\t\t\trfbLog(\"mmap(2) failed, trying slower lseek(2)\\n\");\n\t\t\t\traw_fb_seek = size;\n\t\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\t} else {\n\t\t\t\traw_fb_mmap = size;\n\n\t\t\t\trfbLog(\"rawfb: mmap file: %s\\n\", q);\n\t\t\t\tif (vsize != 0) {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, vsize);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"   w: %d h: %d b: %d addr: %p sz: %d\\n\", w, h,\n\t\t\t\t\t\tb, raw_fb_addr, size);\n\t\t\t\t}\n\t\t\t\tlast_mode = RAWFB_MMAP;\n\t\t\t}\n#else\n\t\t\trfbLog(\"mmap(2) not supported on system, using\"\n\t\t\t    \" slower lseek(2)\\n\");\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n#endif\n\t\t} else {\n\t\t\traw_fb_seek = size;\n\t\t\tlast_mode = RAWFB_FILE;\n\n\t\t\trfbLog(\"rawfb: seek file: %s\\n\", q);\n\t\t\trfbLog(\"   W: %d H: %d B: %d sz: %d\\n\", w, h, b, size);\n\t\t}\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"invalid rawfb str: %s\\n\", str);\n\t\tclean_up_exit(1);\n\t}\n\n\tif (unlink_me) {\n\t\tunlink(unlink_me);\n\t}\n\n\tif (! raw_fb_image) {\n\t\traw_fb_image = &ximage_struct;\n\t}\n\n\tinitialize_clipshift();\n\n\tif (raw_fb_bytes_per_line == 0) {\n\t\traw_fb_bytes_per_line = dpy_x*b/8;\n\n\t\t/*\n\t\t * Put cases here were we can determine that\n\t\t * raw_bytes_per_line != dpy_x*b/8\n\t\t */\n#ifdef MACOSX\n\t\tif (do_macosx) {\n\t\t\traw_fb_bytes_per_line = macosxCG_CGDisplayBytesPerRow();\n\t\t}\n#endif\n\t}\n\n\traw_fb_image->bytes_per_line = dpy_x * b/8;\n\traw_fb = (char *) malloc(dpy_y * dpy_x * b/8);\n\traw_fb_image->data = raw_fb;\n\traw_fb_image->format = ZPixmap;\n\traw_fb_image->width  = dpy_x;\n\traw_fb_image->height = dpy_y;\n\traw_fb_image->bits_per_pixel = b;\n\traw_fb_image->bitmap_unit = -1;\n\n\n\tif (use_snapfb && (raw_fb_seek || raw_fb_mmap)) {\n\t\tint b_use = b;\n\t\tif (snap_fb) {\n\t\t\tfree(snap_fb);\n\t\t}\n\t\tif (b_use == 32 && xform24to32) {\n\t\t\t/*\n\t\t\t * The actual framebuffer (e.g. mapped addr) and\n\t\t\t * snap fb must be the same bpp.  E.g. both 24bpp.\n\t\t\t * Reading FROM snap to utility image will be\n\t\t\t * transformed 24->32 in copy_raw_fb_24_to_32.\n\t\t\t *\n\t\t\t * addr -> snap -> (scanline, fullscreen, ...)\n\t\t\t */\n\t\t\tb_use = 24;\n\t\t\traw_fb_bytes_per_line = dpy_x * b_use/8;\n\t\t}\n\t\tsnap_fb = (char *) malloc(dpy_y * dpy_x * b_use/8);\n\t\tsnap = &ximage_struct_snap;\n\t\tsnap->data = snap_fb;\n\t\tsnap->format = ZPixmap;\n\t\tsnap->width  = dpy_x;\n\t\tsnap->height = dpy_y;\n\t\tsnap->bits_per_pixel = b_use;\n\t\tsnap->bytes_per_line = dpy_x * b_use/8;\n\t\tsnap->bitmap_unit = -1;\n\t}\n\n\n\traw_fb_image->red_mask = rm;\n\traw_fb_image->green_mask = gm;\n\traw_fb_image->blue_mask = bm;\n\n\traw_fb_image->depth = 0;\n\tm = 1;\n\tfor (i=0; i<32; i++)  {\n\t\tif (rm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (gm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tif (bm & m) {\n\t\t\traw_fb_image->depth++;\n\t\t}\n\t\tm = m << 1;\n\t}\n\tif (raw_fb_native_bpp < 8) {\n\t\traw_fb_image->depth = raw_fb_expand_bytes * 8;\n\t}\n\tif (! raw_fb_image->depth) { \n\t\traw_fb_image->depth = (b == 32) ? 24 : b;\n\t}\n\n\tdepth = raw_fb_image->depth;\n\n\tif (raw_fb_image->depth == 15) {\n\t\t/* unresolved bug with RGB555... */\n\t\tdepth++;\n\t}\n\n\tif (clipshift || raw_fb_native_bpp < 8) {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t} else if (raw_fb_addr && ! xform24to32) {\n\t\tmemcpy(raw_fb, raw_fb_addr + raw_fb_offset, dpy_y * raw_fb_image->bytes_per_line);\n\t} else {\n\t\tmemset(raw_fb, 0xff, dpy_y * raw_fb_image->bytes_per_line);\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"rawfb:  raw_fb  %p\\n\", raw_fb);\n\t\trfbLog(\"        format  %d\\n\", raw_fb_image->format);\n\t\trfbLog(\"        width   %d\\n\", raw_fb_image->width);\n\t\trfbLog(\"        height  %d\\n\", raw_fb_image->height);\n\t\trfbLog(\"        bpp     %d\\n\", raw_fb_image->bits_per_pixel);\n\t\trfbLog(\"        depth   %d\\n\", raw_fb_image->depth);\n\t\trfbLog(\"        bpl     %d\\n\", raw_fb_image->bytes_per_line);\n\t\tif (use_snapfb && snap_fb) {\n\t\t\trfbLog(\"        snap_fb %p\\n\", snap_fb);\n\t\t}\n\t}\n\n\tfree(str);\n\n\treturn raw_fb_image;\n}"
  },
  {
    "function_name": "linux_dev_fb_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1618-1634",
    "snippet": "void linux_dev_fb_msg(char* q) {\n\tif (strstr(q, \"/dev/fb\") && strstr(UT.sysname, \"Linux\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"On Linux you may need to load a kernel module to enable\\n\");\n\t\trfbLog(\"the framebuffer device /dev/fb*; e.g.:\\n\");\n\t\trfbLog(\"   vga=0x303 (and others) kernel boot parameter\\n\");\n\t\trfbLog(\"   modprobe uvesafb\\n\");\n\t\trfbLog(\"   modprobe radeonfb (card specific)\\n\");\n\t\trfbLog(\"   modprobe nvidiafb (card specific, others)\\n\");\n\t\trfbLog(\"   modprobe vesafb (?)\\n\");\n\t\trfbLog(\"   modprobe vga16fb\\n\");\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"You may also need root permission to open /dev/fb*\\n\");\n\t\trfbLog(\"and/or /dev/tty*.\\n\");\n\t\trfbLog(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"and/or /dev/tty*.\\n\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"You may also need root permission to open /dev/fb*\\n\""
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   modprobe vga16fb\\n\""
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   modprobe vesafb (?)\\n\""
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   modprobe nvidiafb (card specific, others)\\n\""
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   modprobe radeonfb (card specific)\\n\""
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   modprobe uvesafb\\n\""
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   vga=0x303 (and others) kernel boot parameter\\n\""
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"the framebuffer device /dev/fb*; e.g.:\\n\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"On Linux you may need to load a kernel module to enable\\n\""
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "UT.sysname",
            "\"Linux\""
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"/dev/fb\""
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid linux_dev_fb_msg(char* q) {\n\tif (strstr(q, \"/dev/fb\") && strstr(UT.sysname, \"Linux\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"On Linux you may need to load a kernel module to enable\\n\");\n\t\trfbLog(\"the framebuffer device /dev/fb*; e.g.:\\n\");\n\t\trfbLog(\"   vga=0x303 (and others) kernel boot parameter\\n\");\n\t\trfbLog(\"   modprobe uvesafb\\n\");\n\t\trfbLog(\"   modprobe radeonfb (card specific)\\n\");\n\t\trfbLog(\"   modprobe nvidiafb (card specific, others)\\n\");\n\t\trfbLog(\"   modprobe vesafb (?)\\n\");\n\t\trfbLog(\"   modprobe vga16fb\\n\");\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"You may also need root permission to open /dev/fb*\\n\");\n\t\trfbLog(\"and/or /dev/tty*.\\n\");\n\t\trfbLog(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "vnc_reflect_process_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1604-1616",
    "snippet": "void vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vnc_reflect_process_client(void);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_process_client: read failure to server\\n\""
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleRFBServerMessage",
          "args": [
            "client"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WaitForMessage",
          "args": [
            "client",
            "1000"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid vnc_reflect_process_client(void);\nstatic rfbClient* client = NULL;\n\nvoid vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "vnc_reflect_send_cuttext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1600-1602",
    "snippet": "rfbBool vnc_reflect_send_cuttext(char *str, int len) {\n\treturn SendClientCutText(client, str, len);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
      "static void set_visual(char *str);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendClientCutText",
          "args": [
            "client",
            "str",
            "len"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void set_visual(char *str);\nstatic rfbClient* client = NULL;\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len) {\n\treturn SendClientCutText(client, str, len);\n}"
  },
  {
    "function_name": "vnc_reflect_send_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1596-1598",
    "snippet": "rfbBool vnc_reflect_send_key(uint32_t key, rfbBool down) {\n\treturn SendKeyEvent(client, key, down);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendKeyEvent",
          "args": [
            "client",
            "key",
            "down"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_key(uint32_t key, rfbBool down);\nstatic rfbClient* client = NULL;\n\nrfbBool vnc_reflect_send_key(uint32_t key, rfbBool down) {\n\treturn SendKeyEvent(client, key, down);\n}"
  },
  {
    "function_name": "vnc_reflect_send_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1566-1594",
    "snippet": "rfbBool vnc_reflect_send_pointer(int x, int y, int mask) {\n\tint rc;\n\tif (mask >= 0) {\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_time = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx += coff_x;\n\t\ty += coff_y;\n\t}\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\t/* record the x, y position for the rfb screen as well. */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\treturn SendPointerEvent(client, x, y, mask);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool vnc_reflect_send_pointer(int x, int y, int mask);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendPointerEvent",
          "args": [
            "client",
            "x",
            "y",
            "mask"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cursor",
          "args": [
            "x",
            "y",
            "get_which_cursor()"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1963-1979",
          "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cursor_position",
          "args": [
            "x",
            "y",
            "NULL"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1811-1936",
          "snippet": "void cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_pointer(int x, int y, int mask);\nstatic rfbClient* client = NULL;\n\nrfbBool vnc_reflect_send_pointer(int x, int y, int mask) {\n\tint rc;\n\tif (mask >= 0) {\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_time = time(NULL);\n\t}\n\n\tif (clipshift) {\n\t\tx += coff_x;\n\t\ty += coff_y;\n\t}\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\t/* record the x, y position for the rfb screen as well. */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\treturn SendPointerEvent(client, x, y, mask);\n}"
  },
  {
    "function_name": "vnc_reflect_guess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1458-1564",
    "snippet": "char *vnc_reflect_guess(char *str, char **raw_fb_addr) {\n\n\tstatic int first = 1;\n\tchar *hp = str + strlen(\"vnc:\");\n\tchar *at = NULL;\n\tint argc = 0, i;\n\tchar *argv[16];\n\tchar str2[256];\n\tchar *str0 = strdup(str);\n\n\tif (client == NULL) {\n\t\tint bitsPerSample = 8;\n\t\tint samplesPerPixel = 3;\n\t\tint bytesPerPixel = 4;\n\t\tchar *s;\n\t\ts = getenv(\"X11VNC_REFLECT_bitsPerSample\");\n\t\tif (s) bitsPerSample = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_samplesPerPixel\");\n\t\tif (s) samplesPerPixel = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_bytesPerPixel\");\n\t\tif (s) bytesPerPixel = atoi(s);\n\t\trfbLog(\"rfbGetClient(bitsPerSample=%d, samplesPerPixel=%d, bytesPerPixel=%d)\\n\",\n\t\t    bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t\tclient = rfbGetClient(bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t}\n\n\trfbLog(\"rawfb: %s\\n\", str);\n\n\tat = strchr(hp, '@');\n\tif (at) {\n\t\t*at = '\\0';\n\t\tat++;\n\t}\n\n\tclient->appData.useRemoteCursor = TRUE;\n\tclient->canHandleNewFBSize = TRUE;\n\n\tclient->HandleCursorPos = vnc_reflect_cursor_pos;\n\tclient->GotFrameBufferUpdate = vnc_reflect_got_update;\n\tclient->MallocFrameBuffer = vnc_reflect_resize;\n\tclient->Bell = vnc_reflect_bell;\n#if 0\n\tclient->SoftCursorLockArea = NULL;\n\tclient->SoftCursorUnlockScreen = NULL;\n\tclient->FinishedFrameBufferUpdate = NULL;\n\tclient->HandleKeyboardLedState = NULL;\n\tclient->HandleTextChat = NULL;\n#endif\n\tclient->GotXCutText = vnc_reflect_recv_cuttext;\n\tclient->GotCursorShape = vnc_reflect_got_cursorshape;\n\tclient->GotCopyRect = vnc_reflect_got_copyrect;\n\n\tif (getenv(\"X11VNC_REFLECT_PASSWORD\")) {\n\t\tclient->GetPassword = vnc_reflect_get_password;\n\t}\n#ifdef rfbCredentialTypeX509\n\tclient->GetCredential = NULL;\n\tif (0 || getenv(\"LIBVNCCLIENT_GET_CREDENTIAL\")) {\n\t\tclient->GetCredential = vnc_reflect_get_credential;\n\t}\n#endif\n\n\tif (first) {\n\t\targv[argc++] = \"x11vnc_rawfb_vnc\";\n\t\tif (strstr(hp, \"listen\") == hp) {\n\t\t\tchar *q = strrchr(hp, ':');\n\t\t\targv[argc++] = strdup(\"-listen\");\n\t\t\tif (q) {\n\t\t\t\tclient->listenPort = atoi(q+1);\n\t\t\t} else {\n\t\t\t\tclient->listenPort = LISTEN_PORT_OFFSET;\n\t\t\t}\n\t\t} else {\n\t\t\targv[argc++] = strdup(hp);\n\t\t}\n\n\t\tif (! rfbInitClient(client, &argc, argv)) {\n\t\t\trfbLog(\"vnc_reflector failed for: %s\\n\", str0);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tif (at) {\n\t\tsprintf(str2, \"map:/dev/null@%s\", at);\n\t} else {\n\t\tunsigned long red_mask, green_mask, blue_mask;\n\t\tred_mask   = (client->format.redMax   << client->format.redShift);\n\t\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\t\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\t\tsprintf(str2, \"map:/dev/null@%dx%dx%d:0x%lx/0x%lx/0x%lx\",\n\t\t    client->width, client->height, client->format.bitsPerPixel,\n\t\t    red_mask, green_mask, blue_mask);\n\t}\n\t*raw_fb_addr = (char *) client->frameBuffer;\n\tfree(str0);\n\n\tif (first) {\n\t\tsetup_cursors_and_push();\n\n\t\tfor (i=0; i<10; i++) {\n\t\t\tvnc_reflect_process_client();\n\t\t}\n\t}\n\tfirst = 0;\n\n\treturn strdup(str2);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *vnc_reflect_guess(char *str, char **raw_fb_addr);",
      "void vnc_reflect_process_client(void);",
      "static void set_visual(char *str);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str2"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_reflect_process_client",
          "args": [],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_reflect_process_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1604-1616",
          "snippet": "void vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vnc_reflect_process_client(void);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid vnc_reflect_process_client(void);\nstatic rfbClient* client = NULL;\n\nvoid vnc_reflect_process_client(void) {\n\tint num;\n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tnum = WaitForMessage(client, 1000);\n\tif (num > 0) {\n\t\tif (!HandleRFBServerMessage(client)) {\n\t\t\trfbLog(\"vnc_reflect_process_client: read failure to server\\n\");\n\t\t\tshut_down = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_cursors_and_push",
          "args": [],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cursors_and_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "876-879",
          "snippet": "void setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void first_cursor(void);",
            "void setup_cursors_and_push(void);",
            "static void setup_cursors(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid first_cursor(void);\nvoid setup_cursors_and_push(void);\nstatic void setup_cursors(void);\n\nvoid setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str0"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str2",
            "\"map:/dev/null@%dx%dx%d:0x%lx/0x%lx/0x%lx\"",
            "client->width",
            "client->height",
            "client->format.bitsPerPixel",
            "red_mask",
            "green_mask",
            "blue_mask"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str2",
            "\"map:/dev/null@%s\"",
            "at"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflector failed for: %s\\n\"",
            "str0"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbInitClient",
          "args": [
            "client",
            "&argc",
            "argv"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "hp"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"-listen\""
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "hp",
            "':'"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "hp",
            "\"listen\""
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LIBVNCCLIENT_GET_CREDENTIAL\""
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_PASSWORD\""
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hp",
            "'@'"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: %s\\n\"",
            "str"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClient",
          "args": [
            "bitsPerSample",
            "samplesPerPixel",
            "bytesPerPixel"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbGetClient(bitsPerSample=%d, samplesPerPixel=%d, bytesPerPixel=%d)\\n\"",
            "bitsPerSample",
            "samplesPerPixel",
            "bytesPerPixel"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_bytesPerPixel\""
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_samplesPerPixel\""
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_bitsPerSample\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"vnc:\""
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr);\nvoid vnc_reflect_process_client(void);\nstatic void set_visual(char *str);\nstatic rfbClient* client = NULL;\n\nchar *vnc_reflect_guess(char *str, char **raw_fb_addr) {\n\n\tstatic int first = 1;\n\tchar *hp = str + strlen(\"vnc:\");\n\tchar *at = NULL;\n\tint argc = 0, i;\n\tchar *argv[16];\n\tchar str2[256];\n\tchar *str0 = strdup(str);\n\n\tif (client == NULL) {\n\t\tint bitsPerSample = 8;\n\t\tint samplesPerPixel = 3;\n\t\tint bytesPerPixel = 4;\n\t\tchar *s;\n\t\ts = getenv(\"X11VNC_REFLECT_bitsPerSample\");\n\t\tif (s) bitsPerSample = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_samplesPerPixel\");\n\t\tif (s) samplesPerPixel = atoi(s);\n\t\ts = getenv(\"X11VNC_REFLECT_bytesPerPixel\");\n\t\tif (s) bytesPerPixel = atoi(s);\n\t\trfbLog(\"rfbGetClient(bitsPerSample=%d, samplesPerPixel=%d, bytesPerPixel=%d)\\n\",\n\t\t    bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t\tclient = rfbGetClient(bitsPerSample, samplesPerPixel, bytesPerPixel);\n\t}\n\n\trfbLog(\"rawfb: %s\\n\", str);\n\n\tat = strchr(hp, '@');\n\tif (at) {\n\t\t*at = '\\0';\n\t\tat++;\n\t}\n\n\tclient->appData.useRemoteCursor = TRUE;\n\tclient->canHandleNewFBSize = TRUE;\n\n\tclient->HandleCursorPos = vnc_reflect_cursor_pos;\n\tclient->GotFrameBufferUpdate = vnc_reflect_got_update;\n\tclient->MallocFrameBuffer = vnc_reflect_resize;\n\tclient->Bell = vnc_reflect_bell;\n#if 0\n\tclient->SoftCursorLockArea = NULL;\n\tclient->SoftCursorUnlockScreen = NULL;\n\tclient->FinishedFrameBufferUpdate = NULL;\n\tclient->HandleKeyboardLedState = NULL;\n\tclient->HandleTextChat = NULL;\n#endif\n\tclient->GotXCutText = vnc_reflect_recv_cuttext;\n\tclient->GotCursorShape = vnc_reflect_got_cursorshape;\n\tclient->GotCopyRect = vnc_reflect_got_copyrect;\n\n\tif (getenv(\"X11VNC_REFLECT_PASSWORD\")) {\n\t\tclient->GetPassword = vnc_reflect_get_password;\n\t}\n#ifdef rfbCredentialTypeX509\n\tclient->GetCredential = NULL;\n\tif (0 || getenv(\"LIBVNCCLIENT_GET_CREDENTIAL\")) {\n\t\tclient->GetCredential = vnc_reflect_get_credential;\n\t}\n#endif\n\n\tif (first) {\n\t\targv[argc++] = \"x11vnc_rawfb_vnc\";\n\t\tif (strstr(hp, \"listen\") == hp) {\n\t\t\tchar *q = strrchr(hp, ':');\n\t\t\targv[argc++] = strdup(\"-listen\");\n\t\t\tif (q) {\n\t\t\t\tclient->listenPort = atoi(q+1);\n\t\t\t} else {\n\t\t\t\tclient->listenPort = LISTEN_PORT_OFFSET;\n\t\t\t}\n\t\t} else {\n\t\t\targv[argc++] = strdup(hp);\n\t\t}\n\n\t\tif (! rfbInitClient(client, &argc, argv)) {\n\t\t\trfbLog(\"vnc_reflector failed for: %s\\n\", str0);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tif (at) {\n\t\tsprintf(str2, \"map:/dev/null@%s\", at);\n\t} else {\n\t\tunsigned long red_mask, green_mask, blue_mask;\n\t\tred_mask   = (client->format.redMax   << client->format.redShift);\n\t\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\t\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\t\tsprintf(str2, \"map:/dev/null@%dx%dx%d:0x%lx/0x%lx/0x%lx\",\n\t\t    client->width, client->height, client->format.bitsPerPixel,\n\t\t    red_mask, green_mask, blue_mask);\n\t}\n\t*raw_fb_addr = (char *) client->frameBuffer;\n\tfree(str0);\n\n\tif (first) {\n\t\tsetup_cursors_and_push();\n\n\t\tfor (i=0; i<10; i++) {\n\t\t\tvnc_reflect_process_client();\n\t\t}\n\t}\n\tfirst = 0;\n\n\treturn strdup(str2);\n}"
  },
  {
    "function_name": "vnc_reflect_get_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1423-1456",
    "snippet": "static char* vnc_reflect_get_password(rfbClient* client) {\n\tchar *q, *p, *str = getenv(\"X11VNC_REFLECT_PASSWORD\");\n\tint len = 110;\n\n\tif (client) {}\n\n\tif (str) {\n\t\tlen += 2*strlen(str);\t\n\t}\n\tp = (char *) calloc(len, 1);\n\tif (!str || strlen(str) == 0) {\n\t\tfprintf(stderr, \"VNC Reflect Password: \");\n\t\tfgets(p, 100, stdin);\n\t} else {\n\t\tif (strstr(str, \"file:\") == str) {\n\t\t\tFILE *f = fopen(str + strlen(\"file:\"), \"r\");\n\t\t\tif (f) {\n\t\t\t\tfgets(p, 100, f);\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\t\tif (p[0] == '\\0') {\n\t\t\tstrncpy(p, str, 100);\n\t\t}\n\t}\n\tq = p;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n') {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tq++;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
      "static void set_visual(char *str);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "p",
            "str",
            "100"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "p",
            "100",
            "f"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "str + strlen(\"file:\")",
            "\"r\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"file:\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"file:\""
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "p",
            "100",
            "stdin"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VNC Reflect Password: \""
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len",
            "1"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_PASSWORD\""
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void set_visual(char *str);\nstatic rfbClient* client = NULL;\n\nstatic char* vnc_reflect_get_password(rfbClient* client) {\n\tchar *q, *p, *str = getenv(\"X11VNC_REFLECT_PASSWORD\");\n\tint len = 110;\n\n\tif (client) {}\n\n\tif (str) {\n\t\tlen += 2*strlen(str);\t\n\t}\n\tp = (char *) calloc(len, 1);\n\tif (!str || strlen(str) == 0) {\n\t\tfprintf(stderr, \"VNC Reflect Password: \");\n\t\tfgets(p, 100, stdin);\n\t} else {\n\t\tif (strstr(str, \"file:\") == str) {\n\t\t\tFILE *f = fopen(str + strlen(\"file:\"), \"r\");\n\t\t\tif (f) {\n\t\t\t\tfgets(p, 100, f);\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\t\tif (p[0] == '\\0') {\n\t\t\tstrncpy(p, str, 100);\n\t\t}\n\t}\n\tq = p;\n\twhile (*q != '\\0') {\n\t\tif (*q == '\\n') {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tq++;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "vnc_reflect_get_credential",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1381-1420",
    "snippet": "static rfbCredential* vnc_reflect_get_credential(rfbClient* client, int type) {\n\tchar *pass = getenv(\"X11VNC_REFLECT_PASSWORD\");\n\tchar *user = getenv(\"X11VNC_REFLECT_USER\");\n\tchar *cert = getenv(\"X11VNC_REFLECT_CACERT\");\n\tchar *ccrl = getenv(\"X11VNC_REFLECT_CACRL\");\n\tchar *clic = getenv(\"X11VNC_REFLECT_CLIENTCERT\");\n\tchar *clik = getenv(\"X11VNC_REFLECT_CLIENTKEY\");\n\tint db = 0;\n\tif (client) {}\nif (db) fprintf(stderr, \"type: %d\\n\", type);\n#ifdef rfbCredentialTypeUser\n\tif (type == rfbCredentialTypeUser) {\n\t\tif (!pass && !user) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\trfbCredential *rc = (rfbCredential *) calloc(sizeof(rfbCredential), 1);\n\t\t\trc->userCredential.username = (user ? strdup(user) : NULL);\n\t\t\trc->userCredential.password = (pass ? strdup(pass) : NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n#endif\n\tif (type == rfbCredentialTypeX509) {\nif (db) fprintf(stderr, \"cert: %s\\n\", cert);\nif (db) fprintf(stderr, \"ccrl: %s\\n\", ccrl);\nif (db) fprintf(stderr, \"clic: %s\\n\", clic);\nif (db) fprintf(stderr, \"clik: %s\\n\", clik);\n\t\tif (!cert && !ccrl && !clic && !clik) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\trfbCredential *rc = (rfbCredential *) calloc(sizeof(rfbCredential), 1);\n\t\t\trc->x509Credential.x509CACertFile     = (cert ? strdup(cert) : NULL);\n\t\t\trc->x509Credential.x509CACrlFile      = (ccrl ? strdup(ccrl) : NULL);\n\t\t\trc->x509Credential.x509ClientCertFile = (clic ? strdup(clic) : NULL);\n\t\t\trc->x509Credential.x509ClientKeyFile  = (clik ? strdup(clik) : NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "clik"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "clic"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ccrl"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cert"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(rfbCredential)",
            "1"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clik: %s\\n\"",
            "clik"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clic: %s\\n\"",
            "clic"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ccrl: %s\\n\"",
            "ccrl"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cert: %s\\n\"",
            "cert"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pass"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "user"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(rfbCredential)",
            "1"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"type: %d\\n\"",
            "type"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_CLIENTKEY\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_CLIENTCERT\""
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_CACRL\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_CACERT\""
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_USER\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REFLECT_PASSWORD\""
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic rfbClient* client = NULL;\n\nstatic rfbCredential* vnc_reflect_get_credential(rfbClient* client, int type) {\n\tchar *pass = getenv(\"X11VNC_REFLECT_PASSWORD\");\n\tchar *user = getenv(\"X11VNC_REFLECT_USER\");\n\tchar *cert = getenv(\"X11VNC_REFLECT_CACERT\");\n\tchar *ccrl = getenv(\"X11VNC_REFLECT_CACRL\");\n\tchar *clic = getenv(\"X11VNC_REFLECT_CLIENTCERT\");\n\tchar *clik = getenv(\"X11VNC_REFLECT_CLIENTKEY\");\n\tint db = 0;\n\tif (client) {}\nif (db) fprintf(stderr, \"type: %d\\n\", type);\n#ifdef rfbCredentialTypeUser\n\tif (type == rfbCredentialTypeUser) {\n\t\tif (!pass && !user) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\trfbCredential *rc = (rfbCredential *) calloc(sizeof(rfbCredential), 1);\n\t\t\trc->userCredential.username = (user ? strdup(user) : NULL);\n\t\t\trc->userCredential.password = (pass ? strdup(pass) : NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n#endif\n\tif (type == rfbCredentialTypeX509) {\nif (db) fprintf(stderr, \"cert: %s\\n\", cert);\nif (db) fprintf(stderr, \"ccrl: %s\\n\", ccrl);\nif (db) fprintf(stderr, \"clic: %s\\n\", clic);\nif (db) fprintf(stderr, \"clik: %s\\n\", clik);\n\t\tif (!cert && !ccrl && !clic && !clik) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\trfbCredential *rc = (rfbCredential *) calloc(sizeof(rfbCredential), 1);\n\t\t\trc->x509Credential.x509CACertFile     = (cert ? strdup(cert) : NULL);\n\t\t\trc->x509Credential.x509CACrlFile      = (ccrl ? strdup(ccrl) : NULL);\n\t\t\trc->x509Credential.x509ClientCertFile = (clic ? strdup(clic) : NULL);\n\t\t\trc->x509Credential.x509ClientKeyFile  = (clik ? strdup(clik) : NULL);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "vnc_reflect_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1365-1378",
    "snippet": "rfbBool vnc_reflect_resize(rfbClient *cl)  {\n\tstatic int first = 1;\n\tif(cl->frameBuffer) {\n\t\tfree(cl->frameBuffer);\n\t}\n\tcl->frameBuffer= malloc(cl->width * cl->height * cl->format.bitsPerPixel/8);\n\trfbLog(\"vnc_reflect_resize: %dx%dx%d first=%d\\n\", cl->width, cl->height,\n\t    cl->format.bitsPerPixel, first);\n\tif (!first) {\n\t\tdo_new_fb(1);\n\t}\n\tfirst = 0;\n\treturn cl->frameBuffer ? TRUE : FALSE;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_resize: %dx%dx%d first=%d\\n\"",
            "cl->width",
            "cl->height",
            "cl->format.bitsPerPixel",
            "first"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "cl->width * cl->height * cl->format.bitsPerPixel/8"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cl->frameBuffer"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nrfbBool vnc_reflect_resize(rfbClient *cl)  {\n\tstatic int first = 1;\n\tif(cl->frameBuffer) {\n\t\tfree(cl->frameBuffer);\n\t}\n\tcl->frameBuffer= malloc(cl->width * cl->height * cl->format.bitsPerPixel/8);\n\trfbLog(\"vnc_reflect_resize: %dx%dx%d first=%d\\n\", cl->width, cl->height,\n\t    cl->format.bitsPerPixel, first);\n\tif (!first) {\n\t\tdo_new_fb(1);\n\t}\n\tfirst = 0;\n\treturn cl->frameBuffer ? TRUE : FALSE;\n}"
  },
  {
    "function_name": "vnc_reflect_got_copyrect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1337-1363",
    "snippet": "void vnc_reflect_got_copyrect(rfbClient *cl, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n\tsraRegionPtr reg;\n\tint dx, dy, rc = -1;\n\tstatic int last_dx = 0, last_dy = 0;\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_got_copyrect: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tdx = dest_x - src_x;\n\tdy = dest_y - src_y;\n\tif (dx != last_dx || dy != last_dy) {\n\t\trc = fb_push_wait(0.05, FB_COPY|FB_MOD);\n\t}\n\tif (0) fprintf(stderr, \"vnc_reflect_got_copyrect: %03dx%03d+%03d+%03d   %3d %3d  rc=%d\\n\", dest_x, dest_y, w, h, dx, dy, rc);\n\treg = sraRgnCreateRect(dest_x, dest_y, dest_x + w, dest_y + h);\n\tdo_copyregion(reg, dx, dy, 0);\n\tsraRgnDestroy(reg);\n\n\tlast_dx = dx;\n\tlast_dy = dy;\n\n\tfrom_libvncclient_CopyRectangleFromRectangle(cl, src_x, src_y, w, h, dest_x, dest_y);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_libvncclient_CopyRectangleFromRectangle",
          "args": [
            "cl",
            "src_x",
            "src_y",
            "w",
            "h",
            "dest_x",
            "dest_y"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "from_libvncclient_CopyRectangleFromRectangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1295-1335",
          "snippet": "static void from_libvncclient_CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic rfbClient* client = NULL;\n\nstatic void from_libvncclient_CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "reg"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_copyregion",
          "args": [
            "reg",
            "dx",
            "dy",
            "0"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "do_copyregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1864-2041",
          "snippet": "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int DCR_Normal = 0;",
            "int DCR_FBOnly = 1;",
            "int DCR_Direct = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint DCR_Normal = 0;\nint DCR_FBOnly = 1;\nint DCR_Direct = 2;\n\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode)  {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\tint Bpp0 = bpp/8, Bpp;\n\tint x1, y1, x2, y2, w, stride, stride0;\n\tint sx1, sy1, sx2, sy2, sdx, sdy;\n\tint req, mod, cpy, ncli;\n\tchar *dst = NULL, *src = NULL;\n\n\tlast_copyrect = dnow();\n\n\tif (rfb_fb == main_fb && ! rotating && mode == DCR_Normal) {\n\t\t/* normal case, no -scale or -8to24 */\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \">>>-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\trfbDoCopyRegion(screen, region, dx, dy);\n\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\nif (0 || debug_scroll > 1) fprintf(stderr, \"<<<-rfbDoCopyRect req: %d mod: %d cpy: %d\\n\", req, mod, cpy); \n\n\t\treturn;\n\t}\n\n\t/* rarer case, we need to call rfbDoCopyRect with scaled xy */\n\tstride0 = dpy_x * Bpp0;\n\n\titer = sraRgnGetReverseIterator(region, dx < 0, dy < 0);\n\twhile(sraRgnIteratorNext(iter, &rect)) {\n\t\tint j, c, t;\n\n\t\tx1 = rect.x1;\n\t\ty1 = rect.y1;\n\t\tx2 = rect.x2;\n\t\ty2 = rect.y2;\n\n\t\tfor (c= 0; c < 2; c++) {\n\n\t\t\tBpp = Bpp0;\n\t\t\tstride = stride0;\n\n\t\t\tif (c == 0) {\n\t\t\t\tdst = main_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = main_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\n\t\t\t} else if (c == 1) {\n\t\t\t\tif (!cmap8to24 || !cmap8to24_fb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cmap8to24_fb == rfb_fb) {\n\t\t\t\t\tif (mode == DCR_FBOnly) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Direct) {\n\t\t\t\t\t\t;\n\t\t\t\t\t} else if (mode == DCR_Normal) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\nif (0) fprintf(stderr, \"copyrect: cmap8to24_fb: mode=%d\\n\", mode);\n\t\t\t\tif (cmap8to24) {\n\t\t\t\t\tif (depth <= 8) {\n\t\t\t\t\t\tBpp    = 4 * Bpp0;\n\t\t\t\t\t\tstride = 4 * stride0;\n\t\t\t\t\t} else if (depth <= 16) {\n\t\t\t\t\t\tBpp    = 2 * Bpp0;\n\t\t\t\t\t\tstride = 2 * stride0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = cmap8to24_fb + y1*stride + x1*Bpp;\n\t\t\t\tsrc = cmap8to24_fb + (y1-dy)*stride + (x1-dx)*Bpp;\n\t\t\t}\n\n\t\t\tw = (x2 - x1)*Bpp; \n\t\t\t\n\t\t\tif (dy < 0) {\n\t\t\t\tfor (j=y1; j<y2; j++) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst += stride;\n\t\t\t\t\tsrc += stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst += (y2 - y1 - 1)*stride;\n\t\t\t\tsrc += (y2 - y1 - 1)*stride;\n\t\t\t\tfor (j=y2-1; j>=y1; j--) {\n\t\t\t\t\tmemmove(dst, src, w);\n\t\t\t\t\tdst -= stride;\n\t\t\t\t\tsrc -= stride;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mode == DCR_FBOnly) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (scaling) {\n\t\t\tsx1 = ((double) x1 / dpy_x) * scaled_x;\n\t\t\tsy1 = ((double) y1 / dpy_y) * scaled_y;\n\t\t\tsx2 = ((double) x2 / dpy_x) * scaled_x;\n\t\t\tsy2 = ((double) y2 / dpy_y) * scaled_y;\n\t\t\tsdx = ((double) dx / dpy_x) * scaled_x;\n\t\t\tsdy = ((double) dy / dpy_y) * scaled_y;\n\t\t} else {\n\t\t\tsx1 = x1;\n\t\t\tsy1 = y1;\n\t\t\tsx2 = x2;\n\t\t\tsy2 = y2;\n\t\t\tsdx = dx;\n\t\t\tsdy = dy;\n\t\t}\nif (0) fprintf(stderr, \"sa.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (rotating) {\n\t\t\trotate_coords(sx1, sy1, &sx1, &sy1, -1, -1);\n\t\t\trotate_coords(sx2, sy2, &sx2, &sy2, -1, -1);\n\t\t\tif (rotating == ROTATE_X) {\n\t\t\t\tsdx = -sdx;\n\t\t\t} else if (rotating == ROTATE_Y) {\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_XY) {\n\t\t\t\tsdx = -sdx;\n\t\t\t\tsdy = -sdy;\n\t\t\t} else if (rotating == ROTATE_90) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90X) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = t;\n\t\t\t} else if (rotating == ROTATE_90Y) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = -sdy;\n\t\t\t\tsdy = -t;\n\t\t\t} else if (rotating == ROTATE_270) {\n\t\t\t\tt = sdx;\n\t\t\t\tsdx = sdy;\n\t\t\t\tsdy = -t;\n\t\t\t}\n\t\t}\n\n\t\t/* XXX -1? */\n\t\tif (sx2 < 0) sx2 = 0;\n\t\tif (sy2 < 0) sy2 = 0;\n\t\t\n\t\tif (sx2 < sx1) {\n\t\t\tt = sx1;\n\t\t\tsx1 = sx2;\n\t\t\tsx2 = t;\n\t\t}\n\t\tif (sy2 < sy1) {\n\t\t\tt = sy1;\n\t\t\tsy1 = sy2;\n\t\t\tsy2 = t;\n\t\t}\nif (0) fprintf(stderr, \"sb.. %d %d %d %d %d %d\\n\", sx1, sy1, sx2, sy2, sdx, sdy);\n\n\t\tif (mode == DCR_Direct) {\n\t\t\trfbClientIteratorPtr i;\n\t\t\trfbClientPtr cl;\n\t\t\tsraRegionPtr r = sraRgnCreateRect(sx1, sy1, sx2, sy2);\n\n\t\t\ti = rfbGetClientIterator(screen);\n\t\t\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\t\t\trfbSendCopyRegion(cl, r, sdx, sdy);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t}\n\t\t\trfbReleaseClientIterator(i);\n\t\t\tsraRgnDestroy(r);\n\t\t\t\n\t\t} else {\n\t\t\trfbDoCopyRect(screen, sx1, sy1, sx2, sy2, sdx, sdy);\n\t\t}\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "dest_x",
            "dest_y",
            "dest_x + w",
            "dest_y + h"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"vnc_reflect_got_copyrect: %03dx%03d+%03d+%03d   %3d %3d  rc=%d\\n\"",
            "dest_x",
            "dest_y",
            "w",
            "h",
            "dx",
            "dy",
            "rc"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb_push_wait",
          "args": [
            "0.05",
            "FB_COPY|FB_MOD"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2207-2240",
          "snippet": "int fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);",
            "int fb_push_wait(double max_wait, int flags);",
            "static void check_user_input2(double dt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\nint fb_push_wait(double max_wait, int flags);\nstatic void check_user_input2(double dt);\n\nint fb_push_wait(double max_wait, int flags) {\n\tdouble tm, dt = 0.0;\n\tint req, mod, cpy, ncli;\n\tint ok = 0, first = 1;\n\n\tdtime0(&tm);\t\n\twhile (dt < max_wait) {\n\t\tint done = 1;\n\t\tfb_push();\n\t\tget_client_regions(&req, &mod, &cpy, &ncli);\n\t\tif (flags & FB_COPY && cpy) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_MOD && mod) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (flags & FB_REQ && req) {\n\t\t\tdone = 0;\n\t\t}\n\t\tif (done) {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\t\n\t\t}\n\n\t\trfbCFD(0);\n\t\tusleep(1000);\n\t\tdt += dtime(&tm);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_got_copyrect: no send: uninitialized clients\\n\""
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nvoid vnc_reflect_got_copyrect(rfbClient *cl, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n\tsraRegionPtr reg;\n\tint dx, dy, rc = -1;\n\tstatic int last_dx = 0, last_dy = 0;\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_got_copyrect: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tdx = dest_x - src_x;\n\tdy = dest_y - src_y;\n\tif (dx != last_dx || dy != last_dy) {\n\t\trc = fb_push_wait(0.05, FB_COPY|FB_MOD);\n\t}\n\tif (0) fprintf(stderr, \"vnc_reflect_got_copyrect: %03dx%03d+%03d+%03d   %3d %3d  rc=%d\\n\", dest_x, dest_y, w, h, dx, dy, rc);\n\treg = sraRgnCreateRect(dest_x, dest_y, dest_x + w, dest_y + h);\n\tdo_copyregion(reg, dx, dy, 0);\n\tsraRgnDestroy(reg);\n\n\tlast_dx = dx;\n\tlast_dy = dy;\n\n\tfrom_libvncclient_CopyRectangleFromRectangle(cl, src_x, src_y, w, h, dest_x, dest_y);\n}"
  },
  {
    "function_name": "from_libvncclient_CopyRectangleFromRectangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1295-1335",
    "snippet": "static void from_libvncclient_CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbClientLog",
          "args": [
            "\"Unsupported bitsPerPixel: %d\\n\"",
            "client->format.bitsPerPixel"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_RECT_FROM_RECT",
          "args": [
            "32"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_RECT_FROM_RECT",
          "args": [
            "16"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPY_RECT_FROM_RECT",
          "args": [
            "8"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic rfbClient* client = NULL;\n\nstatic void from_libvncclient_CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}"
  },
  {
    "function_name": "vnc_reflect_cursor_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1273-1293",
    "snippet": "rfbBool vnc_reflect_cursor_pos(rfbClient *cl, int x, int y) {\n\tif (cl) {}\n\tif (debug_pointer) {\n\t\trfbLog(\"vnc_reflect_cursor_pos: %d %d\\n\", x, y);\n\t}\n\tif (unixpw_in_progress) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"vnc_reflect_cursor_pos: unixpw_in_progress%d\\n\", unixpw_in_progress);\n\t\t}\n\t\treturn TRUE;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_cursor_pos: no send: uninitialized clients\\n\");\n\t\treturn TRUE; /* some clients initializing, cannot send */ \n\t}\n\n\tcursor_position(x, y, NULL);\n\tset_cursor(x, y, get_which_cursor());\n\n\treturn TRUE;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cursor",
          "args": [
            "x",
            "y",
            "get_which_cursor()"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1963-1979",
          "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cursor_position",
          "args": [
            "x",
            "y",
            "NULL"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1811-1936",
          "snippet": "void cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_cursor_pos: no send: uninitialized clients\\n\""
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_cursor_pos: unixpw_in_progress%d\\n\"",
            "unixpw_in_progress"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_cursor_pos: %d %d\\n\"",
            "x",
            "y"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nrfbBool vnc_reflect_cursor_pos(rfbClient *cl, int x, int y) {\n\tif (cl) {}\n\tif (debug_pointer) {\n\t\trfbLog(\"vnc_reflect_cursor_pos: %d %d\\n\", x, y);\n\t}\n\tif (unixpw_in_progress) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"vnc_reflect_cursor_pos: unixpw_in_progress%d\\n\", unixpw_in_progress);\n\t\t}\n\t\treturn TRUE;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_cursor_pos: no send: uninitialized clients\\n\");\n\t\treturn TRUE; /* some clients initializing, cannot send */ \n\t}\n\n\tcursor_position(x, y, NULL);\n\tset_cursor(x, y, get_which_cursor());\n\n\treturn TRUE;\n}"
  },
  {
    "function_name": "vnc_reflect_got_cursorshape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1207-1271",
    "snippet": "void vnc_reflect_got_cursorshape(rfbClient *cl, int xhot, int yhot, int width, int height, int bytesPerPixel) {\n\tstatic int serial = 1;\n\tint i, j;\n\tuint32_t *pixels = NULL;\n\tuint32_t r, g, b;\n\tuint32_t ui = 0;\n\tuint32_t red_mask, green_mask, blue_mask;\n\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_got_copyshape: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (! client->rcSource) {\n\t\treturn;\n\t}\n\tif (bytesPerPixel != 1 && bytesPerPixel != 2 && bytesPerPixel != 4) {\n\t\treturn;\n\t}\n\n\tred_mask   = (client->format.redMax   << client->format.redShift);\n\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\n\tpixels = (uint32_t *)malloc(4*width*height);\n\tfor (j=0; j<height; j++) {\n\t\tfor (i=0; i<width; i++) {\n\t\t\tunsigned char* uic;\n\t\t\tint m;\n\t\t\tif (bytesPerPixel == 1) {\n\t\t\t\tuint8_t* p = (uint8_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t} else if (bytesPerPixel == 2) {\n\t\t\t\tuint16_t* p = (uint16_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t} else if (bytesPerPixel == 4) {\n\t\t\t\tuint32_t* p = (uint32_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t}\n\t\t\tr = (red_mask   & ui) >> client->format.redShift;\n\t\t\tg = (green_mask & ui) >> client->format.greenShift;\n\t\t\tb = (blue_mask  & ui) >> client->format.blueShift;\n\n\t\t\tr = (255 * r) / client->format.redMax;\n\t\t\tg = (255 * g) / client->format.greenMax;\n\t\t\tb = (255 * b) / client->format.blueMax;\n\n\t\t\tui = (r << 16 | g << 8 | b << 0) ;\n\n\t\t\tuic = (unsigned char *)client->rcMask;\n\t\t\tm = (int) *(uic + j * width + i);\n\t\t\tif (m) {\n\t\t\t\tui |= 0xff000000;\n\t\t\t}\n\t\t\t*(pixels + j * width + i) = ui;\n\t\t}\n\t}\n\n\tstore_cursor(serial++, pixels, width, height, 32, xhot, yhot);\n\tfree(pixels);\n\tset_cursor(cursor_x, cursor_y, get_which_cursor());\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cursor",
          "args": [
            "cursor_x",
            "cursor_y",
            "get_which_cursor()"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1963-1979",
          "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pixels"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_cursor",
          "args": [
            "serial++",
            "pixels",
            "width",
            "height",
            "32",
            "xhot",
            "yhot"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "store_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1353-1450",
          "snippet": "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CURS_DYN_MAX CURS_DYN16",
            "#define CURS_DYN_MIN CURS_DYN1"
          ],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;",
            "static time_t curs_times[CURS_MAX];",
            "static unsigned long curs_index[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_DYN_MAX CURS_DYN16\n#define CURS_DYN_MIN CURS_DYN1\n\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4*width*height"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_got_copyshape: no send: uninitialized clients\\n\""
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nvoid vnc_reflect_got_cursorshape(rfbClient *cl, int xhot, int yhot, int width, int height, int bytesPerPixel) {\n\tstatic int serial = 1;\n\tint i, j;\n\tuint32_t *pixels = NULL;\n\tuint32_t r, g, b;\n\tuint32_t ui = 0;\n\tuint32_t red_mask, green_mask, blue_mask;\n\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_got_copyshape: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (! client->rcSource) {\n\t\treturn;\n\t}\n\tif (bytesPerPixel != 1 && bytesPerPixel != 2 && bytesPerPixel != 4) {\n\t\treturn;\n\t}\n\n\tred_mask   = (client->format.redMax   << client->format.redShift);\n\tgreen_mask = (client->format.greenMax << client->format.greenShift);\n\tblue_mask  = (client->format.blueMax  << client->format.blueShift);\n\n\tpixels = (uint32_t *)malloc(4*width*height);\n\tfor (j=0; j<height; j++) {\n\t\tfor (i=0; i<width; i++) {\n\t\t\tunsigned char* uic;\n\t\t\tint m;\n\t\t\tif (bytesPerPixel == 1) {\n\t\t\t\tuint8_t* p = (uint8_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t} else if (bytesPerPixel == 2) {\n\t\t\t\tuint16_t* p = (uint16_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t} else if (bytesPerPixel == 4) {\n\t\t\t\tuint32_t* p = (uint32_t *) client->rcSource;\n\t\t\t\tui = (uint32_t) *(p + j * width + i);\n\t\t\t}\n\t\t\tr = (red_mask   & ui) >> client->format.redShift;\n\t\t\tg = (green_mask & ui) >> client->format.greenShift;\n\t\t\tb = (blue_mask  & ui) >> client->format.blueShift;\n\n\t\t\tr = (255 * r) / client->format.redMax;\n\t\t\tg = (255 * g) / client->format.greenMax;\n\t\t\tb = (255 * b) / client->format.blueMax;\n\n\t\t\tui = (r << 16 | g << 8 | b << 0) ;\n\n\t\t\tuic = (unsigned char *)client->rcMask;\n\t\t\tm = (int) *(uic + j * width + i);\n\t\t\tif (m) {\n\t\t\t\tui |= 0xff000000;\n\t\t\t}\n\t\t\t*(pixels + j * width + i) = ui;\n\t\t}\n\t}\n\n\tstore_cursor(serial++, pixels, width, height, 32, xhot, yhot);\n\tfree(pixels);\n\tset_cursor(cursor_x, cursor_y, get_which_cursor());\n}"
  },
  {
    "function_name": "vnc_reflect_got_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1195-1205",
    "snippet": "void vnc_reflect_got_update(rfbClient *cl, int x, int y, int w, int h) {\n\tif (cl) {}\n\tif (use_xdamage) {\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\tfirst = 0;\n\t\t}\n\t\tcollect_non_X_xdamage(x, y, w, h, 1);\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_non_X_xdamage",
          "args": [
            "x",
            "y",
            "w",
            "h",
            "1"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "collect_non_X_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "260-388",
          "snippet": "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "int xdamage_hint_skip(int y);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nvoid vnc_reflect_got_update(rfbClient *cl, int x, int y, int w, int h) {\n\tif (cl) {}\n\tif (use_xdamage) {\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tcollect_non_X_xdamage(-1, -1, -1, -1, 0);\n\t\t\tfirst = 0;\n\t\t}\n\t\tcollect_non_X_xdamage(x, y, w, h, 1);\n\t}\n}"
  },
  {
    "function_name": "vnc_reflect_recv_cuttext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1180-1193",
    "snippet": "void vnc_reflect_recv_cuttext(rfbClient *cl, const char *str, int len) {\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! watch_selection) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_recv_cuttext: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\trfbSendServerCutText(screen, (char *)str, len);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
      "static void set_visual(char *str);",
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "(char *)str",
            "len"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_recv_cuttext: no send: uninitialized clients\\n\""
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void set_visual(char *str);\nstatic void nofb_hook(rfbClientPtr cl);\n\nvoid vnc_reflect_recv_cuttext(rfbClient *cl, const char *str, int len) {\n\tif (cl) {}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (! watch_selection) {\n\t\treturn;\n\t}\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"vnc_reflect_recv_cuttext: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\trfbSendServerCutText(screen, (char *)str, len);\n}"
  },
  {
    "function_name": "vnc_reflect_bell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1163-1178",
    "snippet": "void vnc_reflect_bell(rfbClient *cl) {\n\tif (cl) {}\n\tif (sound_bell) {\n\t\tif (unixpw_in_progress) {\n\t\t\treturn;\n\t\t}\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"vnc_reflect_bell: not sending bell: \"\n\t\t\t    \"uninitialized clients\\n\");\n\t\t} else {\n\t\t\tif (screen && client_count) {\n\t\t\t\trfbSendBell(screen);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendBell",
          "args": [
            "screen"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vnc_reflect_bell: not sending bell: \"\n\t\t\t    \"uninitialized clients\\n\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\n\nvoid vnc_reflect_bell(rfbClient *cl) {\n\tif (cl) {}\n\tif (sound_bell) {\n\t\tif (unixpw_in_progress) {\n\t\t\treturn;\n\t\t}\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"vnc_reflect_bell: not sending bell: \"\n\t\t\t    \"uninitialized clients\\n\");\n\t\t} else {\n\t\t\tif (screen && client_count) {\n\t\t\t\trfbSendBell(screen);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "initialize_snap_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1151-1159",
    "snippet": "static void initialize_snap_fb(void) {\n\tRAWFB_RET_VOID\n\tif (snap_fb) {\n\t\tfree(snap_fb);\n\t}\n\tsnap = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t    ZPixmap);\n\tsnap_fb = snap->data;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void initialize_snap_fb(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XGetImage_wr",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "snap_fb"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void initialize_snap_fb(void);\n\nstatic void initialize_snap_fb(void) {\n\tRAWFB_RET_VOID\n\tif (snap_fb) {\n\t\tfree(snap_fb);\n\t}\n\tsnap = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t    ZPixmap);\n\tsnap_fb = snap->data;\n}"
  },
  {
    "function_name": "install_padded_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1129-1149",
    "snippet": "void install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void install_padded_fb(char *geom);",
      "static void install_fake_fb(int w, int h, int bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_fake_fb",
          "args": [
            "w",
            "h",
            "bpp"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "install_fake_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1094-1116",
          "snippet": "static void install_fake_fb(int w, int h, int bpp) {\n\tint bpc;\n\tif (! screen) {\n\t\treturn;\n\t}\n\tlock_client_sends(1);\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*bpp/8, 1);\n\tif (! fake_fb) {\n\t\trfbLog(\"could not create fake fb: %dx%d %d\\n\", w, h, bpp);\n\t\tlock_client_sends(0);\n\t\treturn;\n\t}\n\tbpc = guess_bits_per_color(bpp);\n\trfbLog(\"installing fake fb: %dx%d %d\\n\", w, h, bpp);\n\trfbLog(\"rfbNewFramebuffer(0x%x, 0x%x, %d, %d, %d, %d, %d)\\n\",\n\t    screen, fake_fb, w, h, bpc, 1, bpp/8);\n\n\trfb_new_framebuffer(screen, fake_fb, w, h, bpc, 1, bpp/8);\n\tlock_client_sends(0);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void install_fake_fb(int w, int h, int bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void install_fake_fb(int w, int h, int bpp);\n\nstatic void install_fake_fb(int w, int h, int bpp) {\n\tint bpc;\n\tif (! screen) {\n\t\treturn;\n\t}\n\tlock_client_sends(1);\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*bpp/8, 1);\n\tif (! fake_fb) {\n\t\trfbLog(\"could not create fake fb: %dx%d %d\\n\", w, h, bpp);\n\t\tlock_client_sends(0);\n\t\treturn;\n\t}\n\tbpc = guess_bits_per_color(bpp);\n\trfbLog(\"installing fake fb: %dx%d %d\\n\", w, h, bpp);\n\trfbLog(\"rfbNewFramebuffer(0x%x, 0x%x, %d, %d, %d, %d, %d)\\n\",\n\t    screen, fake_fb, w, h, bpc, 1, bpp/8);\n\n\trfb_new_framebuffer(screen, fake_fb, w, h, bpc, 1, bpp/8);\n\tlock_client_sends(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid pad geometry: '%s'\\n\"",
            "NONUL(geom)"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NONUL",
          "args": [
            "geom"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "h"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "geom",
            "\"%dx%d\"",
            "&w",
            "&h"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void install_fake_fb(int w, int h, int bpp);\n\nvoid install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}"
  },
  {
    "function_name": "check_padded_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1118-1127",
    "snippet": "void check_padded_fb(void) {\n\tif (! fake_fb) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (time(NULL) > pad_geometry_time+1 && all_clients_initialized()) {\n\t\tremove_fake_fb();\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_padded_fb(void);",
      "static void remove_fake_fb(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_fake_fb",
          "args": [],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "remove_fake_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1070-1083",
          "snippet": "static void remove_fake_fb(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\trfbLog(\"removing fake fb: 0x%x\\n\", fake_fb);\n\n\tdo_new_fb(1);\n\n\t/*\n\t * fake_fb is freed in do_new_fb(), but we set to NULL here to\n\t * indicate it is gone.\n\t */\n\tfake_fb = NULL;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void remove_fake_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void remove_fake_fb(void);\n\nstatic void remove_fake_fb(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\trfbLog(\"removing fake fb: 0x%x\\n\", fake_fb);\n\n\tdo_new_fb(1);\n\n\t/*\n\t * fake_fb is freed in do_new_fb(), but we set to NULL here to\n\t * indicate it is gone.\n\t */\n\tfake_fb = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid check_padded_fb(void);\nstatic void remove_fake_fb(void);\n\nvoid check_padded_fb(void) {\n\tif (! fake_fb) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (time(NULL) > pad_geometry_time+1 && all_clients_initialized()) {\n\t\tremove_fake_fb();\n\t}\n}"
  },
  {
    "function_name": "install_fake_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1094-1116",
    "snippet": "static void install_fake_fb(int w, int h, int bpp) {\n\tint bpc;\n\tif (! screen) {\n\t\treturn;\n\t}\n\tlock_client_sends(1);\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*bpp/8, 1);\n\tif (! fake_fb) {\n\t\trfbLog(\"could not create fake fb: %dx%d %d\\n\", w, h, bpp);\n\t\tlock_client_sends(0);\n\t\treturn;\n\t}\n\tbpc = guess_bits_per_color(bpp);\n\trfbLog(\"installing fake fb: %dx%d %d\\n\", w, h, bpp);\n\trfbLog(\"rfbNewFramebuffer(0x%x, 0x%x, %d, %d, %d, %d, %d)\\n\",\n\t    screen, fake_fb, w, h, bpc, 1, bpp/8);\n\n\trfb_new_framebuffer(screen, fake_fb, w, h, bpc, 1, bpp/8);\n\tlock_client_sends(0);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void install_fake_fb(int w, int h, int bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_client_sends",
          "args": [
            "0"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "lock_client_sends",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "840-889",
          "snippet": "static int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nstatic int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfb_new_framebuffer",
          "args": [
            "screen",
            "fake_fb",
            "w",
            "h",
            "bpc",
            "1",
            "bpp/8"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "rfb_new_framebuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1085-1092",
          "snippet": "static void rfb_new_framebuffer(rfbScreenInfoPtr rfbScreen, char *framebuffer,\n    int width,int height, int bitsPerSample,int samplesPerPixel,\n    int bytesPerPixel) {\n\n\trfbNewFramebuffer(rfbScreen, framebuffer, width, height, bitsPerSample,\n\t    samplesPerPixel, bytesPerPixel);\n\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void rfb_new_framebuffer(rfbScreenInfoPtr rfbScreen, char *framebuffer,\n    int width,int height, int bitsPerSample,int samplesPerPixel,\n    int bytesPerPixel) {\n\n\trfbNewFramebuffer(rfbScreen, framebuffer, width, height, bitsPerSample,\n\t    samplesPerPixel, bytesPerPixel);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbNewFramebuffer(0x%x, 0x%x, %d, %d, %d, %d, %d)\\n\"",
            "screen",
            "fake_fb",
            "w",
            "h",
            "bpc",
            "1",
            "bpp/8"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"installing fake fb: %dx%d %d\\n\"",
            "w",
            "h",
            "bpp"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_bits_per_color",
          "args": [
            "bpp"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "guess_bits_per_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "134-152",
          "snippet": "int guess_bits_per_color(int bits_per_pixel) {\n\tint bits_per_color;\n\t\n\t/* first guess, spread them \"evenly\" over R, G, and B */\n\tbits_per_color = bits_per_pixel/3;\n\tif (bits_per_color < 1) {\n\t\tbits_per_color = 1;\t/* 1bpp, 2bpp... */\n\t}\n\n\t/* choose safe values for usual cases: */\n\tif (bits_per_pixel == 8) {\n\t\tbits_per_color = 2;\n\t} else if (bits_per_pixel == 15 || bits_per_pixel == 16) {\n\t\tbits_per_color = 5;\n\t} else if (bits_per_pixel == 24 || bits_per_pixel == 32) {\n\t\tbits_per_color = 8;\n\t}\n\treturn bits_per_color;\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_bits_per_color(int bits_per_pixel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint guess_bits_per_color(int bits_per_pixel);\n\nint guess_bits_per_color(int bits_per_pixel) {\n\tint bits_per_color;\n\t\n\t/* first guess, spread them \"evenly\" over R, G, and B */\n\tbits_per_color = bits_per_pixel/3;\n\tif (bits_per_color < 1) {\n\t\tbits_per_color = 1;\t/* 1bpp, 2bpp... */\n\t}\n\n\t/* choose safe values for usual cases: */\n\tif (bits_per_pixel == 8) {\n\t\tbits_per_color = 2;\n\t} else if (bits_per_pixel == 15 || bits_per_pixel == 16) {\n\t\tbits_per_color = 5;\n\t} else if (bits_per_pixel == 24 || bits_per_pixel == 32) {\n\t\tbits_per_color = 8;\n\t}\n\treturn bits_per_color;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not create fake fb: %dx%d %d\\n\"",
            "w",
            "h",
            "bpp"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "w*h*bpp/8",
            "1"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fake_fb"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void install_fake_fb(int w, int h, int bpp);\n\nstatic void install_fake_fb(int w, int h, int bpp) {\n\tint bpc;\n\tif (! screen) {\n\t\treturn;\n\t}\n\tlock_client_sends(1);\n\tif (fake_fb) {\n\t\tfree(fake_fb);\n\t}\n\tfake_fb = (char *) calloc(w*h*bpp/8, 1);\n\tif (! fake_fb) {\n\t\trfbLog(\"could not create fake fb: %dx%d %d\\n\", w, h, bpp);\n\t\tlock_client_sends(0);\n\t\treturn;\n\t}\n\tbpc = guess_bits_per_color(bpp);\n\trfbLog(\"installing fake fb: %dx%d %d\\n\", w, h, bpp);\n\trfbLog(\"rfbNewFramebuffer(0x%x, 0x%x, %d, %d, %d, %d, %d)\\n\",\n\t    screen, fake_fb, w, h, bpc, 1, bpp/8);\n\n\trfb_new_framebuffer(screen, fake_fb, w, h, bpc, 1, bpp/8);\n\tlock_client_sends(0);\n}"
  },
  {
    "function_name": "rfb_new_framebuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1085-1092",
    "snippet": "static void rfb_new_framebuffer(rfbScreenInfoPtr rfbScreen, char *framebuffer,\n    int width,int height, int bitsPerSample,int samplesPerPixel,\n    int bytesPerPixel) {\n\n\trfbNewFramebuffer(rfbScreen, framebuffer, width, height, bitsPerSample,\n\t    samplesPerPixel, bytesPerPixel);\n\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbNewFramebuffer",
          "args": [
            "rfbScreen",
            "framebuffer",
            "width",
            "height",
            "bitsPerSample",
            "samplesPerPixel",
            "bytesPerPixel"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void rfb_new_framebuffer(rfbScreenInfoPtr rfbScreen, char *framebuffer,\n    int width,int height, int bitsPerSample,int samplesPerPixel,\n    int bytesPerPixel) {\n\n\trfbNewFramebuffer(rfbScreen, framebuffer, width, height, bitsPerSample,\n\t    samplesPerPixel, bytesPerPixel);\n\n}"
  },
  {
    "function_name": "remove_fake_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1070-1083",
    "snippet": "static void remove_fake_fb(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\trfbLog(\"removing fake fb: 0x%x\\n\", fake_fb);\n\n\tdo_new_fb(1);\n\n\t/*\n\t * fake_fb is freed in do_new_fb(), but we set to NULL here to\n\t * indicate it is gone.\n\t */\n\tfake_fb = NULL;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void remove_fake_fb(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"removing fake fb: 0x%x\\n\"",
            "fake_fb"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void remove_fake_fb(void);\n\nstatic void remove_fake_fb(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\trfbLog(\"removing fake fb: 0x%x\\n\", fake_fb);\n\n\tdo_new_fb(1);\n\n\t/*\n\t * fake_fb is freed in do_new_fb(), but we set to NULL here to\n\t * indicate it is gone.\n\t */\n\tfake_fb = NULL;\n}"
  },
  {
    "function_name": "do_new_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "1008-1068",
    "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void do_new_fb(int reset_mem);",
      "void free_old_fb(void);",
      "XImage *initialize_xdisplay_fb(void);",
      "int parse_rotate_string(char *str, int *mode);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "settle_clients",
          "args": [
            "0"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "settle_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "891-987",
          "snippet": "static void settle_clients(int init) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint fb_pend, i, ms = 1000;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\n\tif (init) {\n\t\titer = rfbGetClientIterator(screen);\n\t\ti = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (i < _bytes0_size) {\n\t\t\t\t_bytes0[i] = rfbStatGetSentBytesIfRaw(cl);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 250;\n\t\t} else {\n\t\t\tms = 500;\n\t\t}\n\t\tusleep(ms * 1000);\n\t\treturn;\n\t}\n\n\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t} else if (subwin) {\n\t\tms = 500;\n\t} else {\n\t\tms = 1000;\n\t}\n\tusleep(ms * 1000);\n\n\tfor (i=0; i < 5; i++) {\n\t\tfb_pend = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tif (cl->newFBSizePending) {\n\t\t\t\tfb_pend++;\n\t\t\t\trfbLog(\"pending fb size: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (fb_pend > 0) {\n\t\t\trfbLog(\"do_new_fb: newFBSizePending extra -threads sleep (%d)\\n\", i+1); \n\t\t\tusleep(ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i < 5; i++) {\n\t\tint stuck = 0, tot = 0, j = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (j < _bytes0_size) {\n\t\t\t\tint db = rfbStatGetSentBytesIfRaw(cl) - _bytes0[j];\n\t\t\t\tint Bpp = cl->format.bitsPerPixel / 8;\n\n\t\t\t\ts = lcs(cl);\n\t\t\t\trfbLog(\"addl bytes sent: %p  %.6f %s  %d  %d\\n\",\n\t\t\t\t    cl, dnowx(), s, db, _bytes0[j]);\n\n\t\t\t\tif (i==0) {\n\t\t\t\t\tif (db < Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i==1) {\n\t\t\t\t\tif (db < 0.5 * Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (db <= 0) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot++;\n\t\t\tj++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (stuck > 0) {\n\t\t\trfbLog(\"clients stuck:  %d/%d  sleep(%d)\\n\", stuck, tot, i);\n\t\t\tusleep(2 * ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void nofb_hook(rfbClientPtr cl);",
            "static int _bytes0_size = 128, _bytes0[128];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void nofb_hook(rfbClientPtr cl);\nstatic int _bytes0_size = 128, _bytes0[128];\n\nstatic void settle_clients(int init) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint fb_pend, i, ms = 1000;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\n\tif (init) {\n\t\titer = rfbGetClientIterator(screen);\n\t\ti = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (i < _bytes0_size) {\n\t\t\t\t_bytes0[i] = rfbStatGetSentBytesIfRaw(cl);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 250;\n\t\t} else {\n\t\t\tms = 500;\n\t\t}\n\t\tusleep(ms * 1000);\n\t\treturn;\n\t}\n\n\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t} else if (subwin) {\n\t\tms = 500;\n\t} else {\n\t\tms = 1000;\n\t}\n\tusleep(ms * 1000);\n\n\tfor (i=0; i < 5; i++) {\n\t\tfb_pend = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tif (cl->newFBSizePending) {\n\t\t\t\tfb_pend++;\n\t\t\t\trfbLog(\"pending fb size: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (fb_pend > 0) {\n\t\t\trfbLog(\"do_new_fb: newFBSizePending extra -threads sleep (%d)\\n\", i+1); \n\t\t\tusleep(ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i < 5; i++) {\n\t\tint stuck = 0, tot = 0, j = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (j < _bytes0_size) {\n\t\t\t\tint db = rfbStatGetSentBytesIfRaw(cl) - _bytes0[j];\n\t\t\t\tint Bpp = cl->format.bitsPerPixel / 8;\n\n\t\t\t\ts = lcs(cl);\n\t\t\t\trfbLog(\"addl bytes sent: %p  %.6f %s  %d  %d\\n\",\n\t\t\t\t    cl, dnowx(), s, db, _bytes0[j]);\n\n\t\t\t\tif (i==0) {\n\t\t\t\t\tif (db < Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i==1) {\n\t\t\t\t\tif (db < 0.5 * Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (db <= 0) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot++;\n\t\t\tj++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (stuck > 0) {\n\t\t\trfbLog(\"clients stuck:  %d/%d  sleep(%d)\\n\", stuck, tot, i);\n\t\t\tusleep(2 * ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_client_sends",
          "args": [
            "0"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "lock_client_sends",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "840-889",
          "snippet": "static int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nstatic int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_clients_for_new_fb",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "prep_clients_for_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "989-1006",
          "snippet": "static void prep_clients_for_new_fb(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(screen);\n\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\tif (!cl->newFBSizePending) {\n\t\t\trfbLog(\"** set_new_fb_size_pending client:   %p\\n\", cl);\n\t\t\tcl->newFBSizePending = TRUE;\n\t\t}\n\t\tcl->cursorWasChanged = FALSE;\n\t\tcl->cursorWasMoved = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nstatic void prep_clients_for_new_fb(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(screen);\n\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\tif (!cl->newFBSizePending) {\n\t\t\trfbLog(\"** set_new_fb_size_pending client:   %p\\n\", cl);\n\t\t\tcl->newFBSizePending = TRUE;\n\t\t}\n\t\tcl->cursorWasChanged = FALSE;\n\t\tcl->cursorWasMoved = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "1",
            "0"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_polling_images",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_polling_images",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "423-520",
          "snippet": "void initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "void initialize_polling_images(void);",
            "static int island_try(int x, int y, int u, int v, int *run);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid initialize_polling_images(void);\nstatic int island_try(int x, int y, int u, int v, int *run);\nstatic int fs_factor = 0;\n\nvoid initialize_polling_images(void) {\n\tint i, MB = 1024 * 1024;\n\n\t/* set all shm areas to \"none\" before trying to create any */\n\tscanline_shm.shmid\t= -1;\n\tscanline_shm.shmaddr\t= (char *) -1;\n\tscanline\t\t= NULL;\n\tfullscreen_shm.shmid\t= -1;\n\tfullscreen_shm.shmaddr\t= (char *) -1;\n\tfullscreen\t\t= NULL;\n\tsnaprect_shm.shmid\t= -1;\n\tsnaprect_shm.shmaddr\t= (char *) -1;\n\tsnaprect\t\t= NULL;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\ttile_row_shm[i].shmid\t= -1;\n\t\ttile_row_shm[i].shmaddr\t= (char *) -1;\n\t\ttile_row[i]\t\t= NULL;\n\t}\n\n\t/* the scanline (e.g. 1280x1) shared memory area image: */\n\n\tif (! shm_create(&scanline_shm, &scanline, dpy_x, 1, \"scanline\")) {\n\t\tclean_up_exit(1);\n\t}\n\n\t/*\n\t * the fullscreen (e.g. 1280x1024/fs_factor) shared memory area image:\n\t * (we cut down the size of the shm area to try avoid and shm segment\n\t * limits, e.g. the default 1MB on Solaris)\n\t */\n\tif (UT.sysname && strstr(UT.sysname, \"Linux\")) {\n\t\tset_fs_factor(10 * MB);\n\t} else {\n\t\tset_fs_factor(1 * MB);\n\t}\n\tif (fs_frac >= 1.0) {\n\t\tfs_frac = 1.1;\n\t\tfs_factor = 0;\n\t}\n\tif (! fs_factor) {\n\t\trfbLog(\"warning: fullscreen updates are disabled.\\n\");\n\t} else {\n\t\tif (! shm_create(&fullscreen_shm, &fullscreen, dpy_x,\n\t\t    dpy_y/fs_factor, \"fullscreen\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tif (! fs_factor) {\n\t\t\trfbLog(\"warning: disabling -snapfb mode.\\n\");\n\t\t\tuse_snapfb = 0;\n\t\t} else if (! shm_create(&snaprect_shm, &snaprect, dpy_x,\n\t\t    dpy_y/fs_factor, \"snaprect\")) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\t/*\n\t * for copy_tiles we need a lot of shared memory areas, one for\n\t * each possible run length of changed tiles.  32 for 1024x768\n\t * and 40 for 1280x1024, etc. \n\t */\n\n\ttile_shm_count = 0;\n\tfor (i=1; i<=ntiles_x; i++) {\n\t\tif (! shm_create(&tile_row_shm[i], &tile_row[i], tile_x * i,\n\t\t    tile_y, \"tile_row\")) {\n\t\t\tif (i == 1) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\trfbLog(\"shm: Error creating shared memory tile-row for\"\n\t\t\t    \" len=%d,\\n\", i);\n\t\t\trfbLog(\"shm: reverting to -onetile mode. If this\"\n\t\t\t    \" problem persists\\n\");\n\t\t\trfbLog(\"shm: try using the -onetile or -noshm options\"\n\t\t\t    \" to limit\\n\");\n\t\t\trfbLog(\"shm: shared memory usage, or run ipcrm(1)\"\n\t\t\t    \" to manually\\n\");\n\t\t\trfbLog(\"shm: delete unattached shm segments.\\n\");\n\t\t\tsingle_copytile_count = i;\n\t\t\tsingle_copytile = 1;\n\t\t}\n\t\ttile_shm_count++;\n\t\tif (single_copytile && i >= 1) {\n\t\t\t/* only need 1x1 tiles */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (verbose) {\n\t\tif (using_shm && ! xform24to32) {\n\t\t\trfbLog(\"created %d tile_row shm polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t} else {\n\t\t\trfbLog(\"created %d tile_row polling images.\\n\",\n\t\t\t    tile_shm_count);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_blackouts_and_xinerama",
          "args": [],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_blackouts_and_xinerama",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "471-487",
          "snippet": "void initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int blackouts = 0;",
            "void initialize_blackouts_and_xinerama(void);",
            "static void blackout_tiles(void);",
            "static void initialize_xinerama (void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint blackouts = 0;\nvoid initialize_blackouts_and_xinerama(void);\nstatic void blackout_tiles(void);\nstatic void initialize_xinerama (void);\n\nvoid initialize_blackouts_and_xinerama(void) {\n\n\tblackouts = 0;\n\tblackout_ptr = 0;\n\n\tif (blackout_str != NULL) {\n\t\tinitialize_blackouts(blackout_str);\n\t}\n\tif (xinerama) {\n\t\tinitialize_xinerama();\n\t}\n\tif (blackouts) {\n\t\tblackout_tiles();\n\t\t/* schedule a copy_screen(), now is too early. */\n\t\tdo_copy_screen = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_tiles",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "131-158",
          "snippet": "void initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_tiles(void);",
            "static hint_t *hint_list;",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid initialize_tiles(void) {\n\n\tntiles_x = (dpy_x - 1)/tile_x + 1;\n\tntiles_y = (dpy_y - 1)/tile_y + 1;\n\tntiles = ntiles_x * ntiles_y;\n\n\ttile_has_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_row_has_xdamage_diff = (unsigned char *)\n\t\tcalloc((size_t) (ntiles_y * sizeof(unsigned char)), 1);\n\ttile_tried    = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_copied   = (unsigned char *)\n\t\tcalloc((size_t) (ntiles * sizeof(unsigned char)), 1);\n\ttile_blackout    = (tile_blackout_t *)\n\t\tcalloc((size_t) (ntiles * sizeof(tile_blackout_t)), 1);\n\ttile_region = (region_t *) calloc((size_t) (ntiles * sizeof(region_t)), 1);\n\n\ttile_row = (XImage **)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XImage *)), 1);\n\ttile_row_shm = (XShmSegmentInfo *)\n\t\tcalloc((size_t) ((ntiles_x + 1) * sizeof(XShmSegmentInfo)), 1);\n\n\t/* there will never be more hints than tiles: */\n\thint_list = (hint_t *) calloc((size_t) (ntiles * sizeof(hint_t)), 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_screen",
          "args": [
            "NULL",
            "NULL",
            "fb"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xdisplay_fb",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xdisplay_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2471-2829",
          "snippet": "XImage *initialize_xdisplay_fb(void) {\n#if NO_X11\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\treturn NULL;\n#else\n\tXImage *fb;\n\tchar *vis_str = visual_str;\n\tint try = 0, subwin_tries = 3;\n\tXErrorHandler old_handler = NULL;\n\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\n\tX_LOCK;\n\tif (subwin) {\n\t\tif (subwin_wait_mapped) {\n\t\t\twait_until_mapped(subwin);\n\t\t}\n\t\tif (!valid_window((Window) subwin, NULL, 0)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid sub-window: 0x%lx\\n\", subwin);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\t\n\tif (overlay) {\n\t\t/* \n\t\t * ideally we'd like to not have to cook up the\n\t\t * visual variables but rather let it all come out\n\t\t * of XReadScreen(), however there is no way to get\n\t\t * a default visual out of it, so we pretend -visual\n\t\t * TrueColor:NN was supplied with NN usually 24.\n\t\t */\n\t\tchar str[32];\n\t\tWindow twin = subwin ? subwin : rootwin;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(dpy, twin, 0, 0, 8, 8, False);\n\t\tsprintf(str, \"TrueColor:%d\", xi->depth);\n\t\tif (xi->depth != 24 && ! quiet) {\n\t\t\trfbLog(\"warning: overlay image has depth %d \"\n\t\t\t    \"instead of 24.\\n\", xi->depth);\n\t\t}\n\t\tXDestroyImage(xi);\n\t\tif (visual_str != NULL && ! quiet) {\n\t\t\trfbLog(\"warning: replacing '-visual %s' by '%s' \"\n\t\t\t    \"for use with -overlay\\n\", visual_str, str);\n\t\t}\n\t\tvis_str = strdup(str);\n\t}\n\n\tif (xform24to32) {\n\t\tif (DefaultDepth(dpy, scr) == 24) {\n\t\t\tvis_str = strdup(\"TrueColor:32\");\n\t\t\trfbLog(\"initialize_xdisplay_fb: vis_str set to: %s\\n\",\n\t\t\t    vis_str);\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t} else if (DefaultDepth(dpy, scr) < 8) {\n\t\t/* check very low bpp case, e.g. mono or vga16 */\n\t\tScreen *s = DefaultScreenOfDisplay(dpy);\n\t\tXImage *xi = XGetImage_wr(dpy, DefaultRootWindow(dpy), 0, 0, 2, 2, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (xi && xi->bits_per_pixel < 8) {\n\t\t\tint lowbpp = xi->bits_per_pixel; \n\t\t\tif (!vis_str) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tsprintf(tmp, \"0x%x:8\", (int) s->root_visual->visualid);\n\t\t\t\tvis_str = strdup(tmp);\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], vis_str \"\n\t\t\t\t    \"set to: %s\\n\", lowbpp, vis_str);\n\t\t\t}\n\t\t\tif (using_shm) {\n\t\t\t\tusing_shm = 0;\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], \"\n\t\t\t\t    \"disabling shm\\n\", lowbpp);\n\t\t\t}\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t}\n\n\tif (vis_str != NULL) {\n\t\tset_visual(vis_str);\n\t\tif (vis_str != visual_str) {\n\t\t\tfree(vis_str);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"vis_str %s\\n\", vis_str ? vis_str : \"notset\");\n\n\t/* set up parameters for subwin or non-subwin cases: */\n\n\tagain:\n\n\tif (! subwin) {\n\t\t/* full screen */\n\t\twindow = rootwin;\n\t\tdpy_x = wdpy_x = DisplayWidth(dpy, scr);\n\t\tdpy_y = wdpy_y = DisplayHeight(dpy, scr);\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = DefaultVisual(dpy, scr);\n\t} else {\n\t\t/* single window */\n\t\tXWindowAttributes attr;\n\n\t\twindow = (Window) subwin;\n\t\tif (! XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid window: 0x%lx\\n\", window);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdpy_x = wdpy_x = attr.width;\n\t\tdpy_y = wdpy_y = attr.height;\n\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = attr.visual;\n\n#if HAVE_LIBXCOMPOSITE\n\t\tif(use_xcomposite && !rootshift) {\n\t\t  XCompositeRedirectWindow(dpy, window, CompositeRedirectAutomatic);\n\t\t  XCompositeRedirectSubwindows(dpy, window, CompositeRedirectAutomatic);\n\t\t}\n#endif\n\n\t\tX_UNLOCK;\n\t\tset_offset();\n\t\tX_LOCK;\n\t}\n\n\tinitialize_clipshift();\n\n\t/* initialize depth to reasonable value, visual_id may override */\n\tdepth = DefaultDepth(dpy, scr);\n\nif (0) fprintf(stderr, \"DefaultDepth: %d  visial_id: %d\\n\", depth, (int) visual_id);\n\n\tif (visual_id) {\n\t\tint n;\n\t\tXVisualInfo vinfo_tmpl, *vinfo;\n\n\t\t/*\n\t\t * we are in here from -visual or -overlay options\n\t\t * visual_id and visual_depth were set in set_visual().\n\t\t */\n\n\t\tvinfo_tmpl.visualid = visual_id; \n\t\tvinfo = XGetVisualInfo(dpy, VisualIDMask, &vinfo_tmpl, &n);\n\t\tif (vinfo == NULL || n == 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not match visual_id: 0x%x\\n\",\n\t\t\t    (int) visual_id);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdefault_visual = vinfo->visual;\n\t\tdepth = vinfo->depth;\n\t\tif (visual_depth) {\n\t\t\t/* force it from -visual MooColor:NN */\n\t\t\tdepth = visual_depth;\n\t\t}\n\t\tif (! quiet) {\n\t\t\tfprintf(stderr, \" initialize_xdisplay_fb()\\n\");\n\t\t\tfprintf(stderr, \" Visual*:    %p\\n\",\n\t\t\t    (void *) vinfo->visual);\n\t\t\tfprintf(stderr, \" visualid:   0x%x\\n\",\n\t\t\t    (int) vinfo->visualid);\n\t\t\tfprintf(stderr, \" screen:     %d\\n\", vinfo->screen);\n\t\t\tfprintf(stderr, \" depth:      %d\\n\", vinfo->depth);\n\t\t\tfprintf(stderr, \" class:      %d\\n\", vinfo->class);\n\t\t\tfprintf(stderr, \" red_mask:   0x%08lx  %s\\n\",\n\t\t\t    vinfo->red_mask, bitprint(vinfo->red_mask, 32));\n\t\t\tfprintf(stderr, \" green_mask: 0x%08lx  %s\\n\",\n\t\t\t    vinfo->green_mask, bitprint(vinfo->green_mask, 32));\n\t\t\tfprintf(stderr, \" blue_mask:  0x%08lx  %s\\n\",\n\t\t\t    vinfo->blue_mask, bitprint(vinfo->blue_mask, 32));\n\t\t\tfprintf(stderr, \" cmap_size:  %d\\n\",\n\t\t\t    vinfo->colormap_size);\n\t\t\tfprintf(stderr, \" bits b/rgb: %d\\n\",\n\t\t\t    vinfo->bits_per_rgb);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tXFree_wr(vinfo);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"Default visual ID: 0x%x\\n\",\n\t\t    (int) XVisualIDFromVisual(default_visual));\n\t}\n\n\tif (subwin && (!use_xcomposite || rootshift)) {\n\t\tint shift = 0, resize = 0;\n\t\tint subwin_x, subwin_y;\n\t\tint disp_x = DisplayWidth(dpy, scr);\n\t\tint disp_y = DisplayHeight(dpy, scr);\n\t\tWindow twin;\n\t\t/* subwins can be a dicey if they are changing size... */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\t/* reset in if(subwin) block below */\n\t\tXTranslateCoordinates(dpy, window, rootwin, 0, 0, &subwin_x,\n\t\t    &subwin_y, &twin);\n\n\t\tif (wdpy_x > disp_x) {\n\t\t\tresize = 1;\n\t\t\tdpy_x = wdpy_x = disp_x - 4;\n\t\t}\n\t\tif (wdpy_y > disp_y) {\n\t\t\tresize = 1;\n\t\t\tdpy_y = wdpy_y = disp_y - 4;\n\t\t}\n\n\t\tif (subwin_x + wdpy_x > disp_x) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = disp_x - wdpy_x - 3;\n\t\t}\n\t\tif (subwin_y + wdpy_y > disp_y) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = disp_y - wdpy_y - 3;\n\t\t}\n\t\tif (subwin_x < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = 1;\n\t\t}\n\t\tif (subwin_y < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = 1;\n\t\t}\n\n\t\tif (resize) {\n\t\t\tXResizeWindow(dpy, window, wdpy_x, wdpy_y);\n\t\t}\n\t\tif (shift) {\n\t\t\tXMoveWindow(dpy, window, subwin_x, subwin_y);\n\t\t\toff_x = subwin_x;\n\t\t\toff_y = subwin_y;\n\t\t}\n\t\tXMapRaised(dpy, window);\n\t\tXRaiseWindow(dpy, window);\n\t\tXSync(dpy, False);\n\t}\n\ttry++;\n\n\tif (nofb) {\n\t\t/* \n\t\t * For -nofb we do not allocate the framebuffer, so we\n\t\t * can save a few MB of memory. \n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\n\t} else if (visual_id) {\n\t\t/*\n\t\t * we need to call XCreateImage to supply the visual\n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\t\tif (fb) {\n\t\t\tfb->data = (char *) malloc(fb->bytes_per_line * fb->height);\n\t\t}\n\n\t} else {\n\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (! quiet) {\n\t\t\trfbLog(\"Read initial data from X display into\"\n\t\t\t    \" framebuffer.\\n\");\n\t\t}\n\t}\n\n\tif (subwin) {\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror || fb == NULL) {\n\t\t    rfbLog(\"trapped GetImage at SUBWIN creation.\\n\");\n\t\t    if (try < subwin_tries) {\n\t\t\tusleep(250 * 1000);\n\t\t\tif (!get_window_size(window, &wdpy_x, &wdpy_y)) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"could not get size of subwin \"\n\t\t\t\t    \"0x%lx\\n\", subwin);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tgoto again;\n\t\t    }\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t} else if (fb == NULL) {\n#if HAVE_LIBXRANDR\n\t\tXEvent xev;\n#endif\n\t\trfbLog(\"initialize_xdisplay_fb: *** fb creation failed: 0x%x try: %d\\n\", fb, try);\n#if HAVE_LIBXRANDR\n\t\tif (xrandr_present && xrandr_base_event_type) {\n\t\t\tint cnt = 0;\n\t\t\twhile (XCheckTypedEvent(dpy, xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\t\t\tXRRScreenChangeNotifyEvent *rev;\n\t\t\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: XRANDR event while redoing fb[%d]:\\n\", cnt++);\n\t\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"previous WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n\n\t\t\t\txrandr_width  = rev->width;\n\t\t\t\txrandr_height = rev->height;\n\t\t\t\txrandr_timestamp = rev->timestamp;\n\t\t\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\t\t\txrandr_rotation = (int) rev->rotation;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: updating XRANDR config...\\n\");\n\t\t\t\tXRRUpdateConfiguration(&xev);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (try < 5)  {\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(250 * 1000);\n\t\t\tif (try < 3) {\n\t\t\t\tXSync(dpy, False);\n\t\t\t} else if (try >= 3) {\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tinitialize_snap_fb();\n\t}\n\n\tX_UNLOCK;\n\n\tif (fb->bits_per_pixel == 24 && ! quiet) {\n\t\trfbLog(\"warning: 24 bpp may have poor performance.\\n\");\n\t}\n\treturn fb;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_colormap(int reset);",
            "XImage *initialize_xdisplay_fb(void);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void set_visual(char *str);",
            "static void install_fake_fb(int w, int h, int bpp);",
            "static void initialize_snap_fb(void);",
            "XImage *initialize_raw_fb(int);",
            "static void initialize_clipshift(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_colormap(int reset);\nXImage *initialize_xdisplay_fb(void);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\nstatic void install_fake_fb(int w, int h, int bpp);\nstatic void initialize_snap_fb(void);\nXImage *initialize_raw_fb(int);\nstatic void initialize_clipshift(void);\n\nXImage *initialize_xdisplay_fb(void) {\n#if NO_X11\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\treturn NULL;\n#else\n\tXImage *fb;\n\tchar *vis_str = visual_str;\n\tint try = 0, subwin_tries = 3;\n\tXErrorHandler old_handler = NULL;\n\n\tif (raw_fb_str) {\n\t\treturn initialize_raw_fb(0);\n\t}\n\n\tX_LOCK;\n\tif (subwin) {\n\t\tif (subwin_wait_mapped) {\n\t\t\twait_until_mapped(subwin);\n\t\t}\n\t\tif (!valid_window((Window) subwin, NULL, 0)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid sub-window: 0x%lx\\n\", subwin);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\t\n\tif (overlay) {\n\t\t/* \n\t\t * ideally we'd like to not have to cook up the\n\t\t * visual variables but rather let it all come out\n\t\t * of XReadScreen(), however there is no way to get\n\t\t * a default visual out of it, so we pretend -visual\n\t\t * TrueColor:NN was supplied with NN usually 24.\n\t\t */\n\t\tchar str[32];\n\t\tWindow twin = subwin ? subwin : rootwin;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(dpy, twin, 0, 0, 8, 8, False);\n\t\tsprintf(str, \"TrueColor:%d\", xi->depth);\n\t\tif (xi->depth != 24 && ! quiet) {\n\t\t\trfbLog(\"warning: overlay image has depth %d \"\n\t\t\t    \"instead of 24.\\n\", xi->depth);\n\t\t}\n\t\tXDestroyImage(xi);\n\t\tif (visual_str != NULL && ! quiet) {\n\t\t\trfbLog(\"warning: replacing '-visual %s' by '%s' \"\n\t\t\t    \"for use with -overlay\\n\", visual_str, str);\n\t\t}\n\t\tvis_str = strdup(str);\n\t}\n\n\tif (xform24to32) {\n\t\tif (DefaultDepth(dpy, scr) == 24) {\n\t\t\tvis_str = strdup(\"TrueColor:32\");\n\t\t\trfbLog(\"initialize_xdisplay_fb: vis_str set to: %s\\n\",\n\t\t\t    vis_str);\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t} else if (DefaultDepth(dpy, scr) < 8) {\n\t\t/* check very low bpp case, e.g. mono or vga16 */\n\t\tScreen *s = DefaultScreenOfDisplay(dpy);\n\t\tXImage *xi = XGetImage_wr(dpy, DefaultRootWindow(dpy), 0, 0, 2, 2, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (xi && xi->bits_per_pixel < 8) {\n\t\t\tint lowbpp = xi->bits_per_pixel; \n\t\t\tif (!vis_str) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tsprintf(tmp, \"0x%x:8\", (int) s->root_visual->visualid);\n\t\t\t\tvis_str = strdup(tmp);\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], vis_str \"\n\t\t\t\t    \"set to: %s\\n\", lowbpp, vis_str);\n\t\t\t}\n\t\t\tif (using_shm) {\n\t\t\t\tusing_shm = 0;\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: low bpp[%d], \"\n\t\t\t\t    \"disabling shm\\n\", lowbpp);\n\t\t\t}\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t\tset_visual_str_to_something = 1;\n\t\t}\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t}\n\n\tif (vis_str != NULL) {\n\t\tset_visual(vis_str);\n\t\tif (vis_str != visual_str) {\n\t\t\tfree(vis_str);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"vis_str %s\\n\", vis_str ? vis_str : \"notset\");\n\n\t/* set up parameters for subwin or non-subwin cases: */\n\n\tagain:\n\n\tif (! subwin) {\n\t\t/* full screen */\n\t\twindow = rootwin;\n\t\tdpy_x = wdpy_x = DisplayWidth(dpy, scr);\n\t\tdpy_y = wdpy_y = DisplayHeight(dpy, scr);\n\t\toff_x = 0;\n\t\toff_y = 0;\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = DefaultVisual(dpy, scr);\n\t} else {\n\t\t/* single window */\n\t\tXWindowAttributes attr;\n\n\t\twindow = (Window) subwin;\n\t\tif (! XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid window: 0x%lx\\n\", window);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdpy_x = wdpy_x = attr.width;\n\t\tdpy_y = wdpy_y = attr.height;\n\n\t\t/* this may be overridden via visual_id below */\n\t\tdefault_visual = attr.visual;\n\n#if HAVE_LIBXCOMPOSITE\n\t\tif(use_xcomposite && !rootshift) {\n\t\t  XCompositeRedirectWindow(dpy, window, CompositeRedirectAutomatic);\n\t\t  XCompositeRedirectSubwindows(dpy, window, CompositeRedirectAutomatic);\n\t\t}\n#endif\n\n\t\tX_UNLOCK;\n\t\tset_offset();\n\t\tX_LOCK;\n\t}\n\n\tinitialize_clipshift();\n\n\t/* initialize depth to reasonable value, visual_id may override */\n\tdepth = DefaultDepth(dpy, scr);\n\nif (0) fprintf(stderr, \"DefaultDepth: %d  visial_id: %d\\n\", depth, (int) visual_id);\n\n\tif (visual_id) {\n\t\tint n;\n\t\tXVisualInfo vinfo_tmpl, *vinfo;\n\n\t\t/*\n\t\t * we are in here from -visual or -overlay options\n\t\t * visual_id and visual_depth were set in set_visual().\n\t\t */\n\n\t\tvinfo_tmpl.visualid = visual_id; \n\t\tvinfo = XGetVisualInfo(dpy, VisualIDMask, &vinfo_tmpl, &n);\n\t\tif (vinfo == NULL || n == 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not match visual_id: 0x%x\\n\",\n\t\t\t    (int) visual_id);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tdefault_visual = vinfo->visual;\n\t\tdepth = vinfo->depth;\n\t\tif (visual_depth) {\n\t\t\t/* force it from -visual MooColor:NN */\n\t\t\tdepth = visual_depth;\n\t\t}\n\t\tif (! quiet) {\n\t\t\tfprintf(stderr, \" initialize_xdisplay_fb()\\n\");\n\t\t\tfprintf(stderr, \" Visual*:    %p\\n\",\n\t\t\t    (void *) vinfo->visual);\n\t\t\tfprintf(stderr, \" visualid:   0x%x\\n\",\n\t\t\t    (int) vinfo->visualid);\n\t\t\tfprintf(stderr, \" screen:     %d\\n\", vinfo->screen);\n\t\t\tfprintf(stderr, \" depth:      %d\\n\", vinfo->depth);\n\t\t\tfprintf(stderr, \" class:      %d\\n\", vinfo->class);\n\t\t\tfprintf(stderr, \" red_mask:   0x%08lx  %s\\n\",\n\t\t\t    vinfo->red_mask, bitprint(vinfo->red_mask, 32));\n\t\t\tfprintf(stderr, \" green_mask: 0x%08lx  %s\\n\",\n\t\t\t    vinfo->green_mask, bitprint(vinfo->green_mask, 32));\n\t\t\tfprintf(stderr, \" blue_mask:  0x%08lx  %s\\n\",\n\t\t\t    vinfo->blue_mask, bitprint(vinfo->blue_mask, 32));\n\t\t\tfprintf(stderr, \" cmap_size:  %d\\n\",\n\t\t\t    vinfo->colormap_size);\n\t\t\tfprintf(stderr, \" bits b/rgb: %d\\n\",\n\t\t\t    vinfo->bits_per_rgb);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tXFree_wr(vinfo);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"Default visual ID: 0x%x\\n\",\n\t\t    (int) XVisualIDFromVisual(default_visual));\n\t}\n\n\tif (subwin && (!use_xcomposite || rootshift)) {\n\t\tint shift = 0, resize = 0;\n\t\tint subwin_x, subwin_y;\n\t\tint disp_x = DisplayWidth(dpy, scr);\n\t\tint disp_y = DisplayHeight(dpy, scr);\n\t\tWindow twin;\n\t\t/* subwins can be a dicey if they are changing size... */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\t/* reset in if(subwin) block below */\n\t\tXTranslateCoordinates(dpy, window, rootwin, 0, 0, &subwin_x,\n\t\t    &subwin_y, &twin);\n\n\t\tif (wdpy_x > disp_x) {\n\t\t\tresize = 1;\n\t\t\tdpy_x = wdpy_x = disp_x - 4;\n\t\t}\n\t\tif (wdpy_y > disp_y) {\n\t\t\tresize = 1;\n\t\t\tdpy_y = wdpy_y = disp_y - 4;\n\t\t}\n\n\t\tif (subwin_x + wdpy_x > disp_x) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = disp_x - wdpy_x - 3;\n\t\t}\n\t\tif (subwin_y + wdpy_y > disp_y) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = disp_y - wdpy_y - 3;\n\t\t}\n\t\tif (subwin_x < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_x = 1;\n\t\t}\n\t\tif (subwin_y < 0) {\n\t\t\tshift = 1;\n\t\t\tsubwin_y = 1;\n\t\t}\n\n\t\tif (resize) {\n\t\t\tXResizeWindow(dpy, window, wdpy_x, wdpy_y);\n\t\t}\n\t\tif (shift) {\n\t\t\tXMoveWindow(dpy, window, subwin_x, subwin_y);\n\t\t\toff_x = subwin_x;\n\t\t\toff_y = subwin_y;\n\t\t}\n\t\tXMapRaised(dpy, window);\n\t\tXRaiseWindow(dpy, window);\n\t\tXSync(dpy, False);\n\t}\n\ttry++;\n\n\tif (nofb) {\n\t\t/* \n\t\t * For -nofb we do not allocate the framebuffer, so we\n\t\t * can save a few MB of memory. \n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\n\t} else if (visual_id) {\n\t\t/*\n\t\t * we need to call XCreateImage to supply the visual\n\t\t */\n\t\tfb = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, dpy_x, dpy_y, BitmapPad(dpy), 0);\n\t\tif (fb) {\n\t\t\tfb->data = (char *) malloc(fb->bytes_per_line * fb->height);\n\t\t}\n\n\t} else {\n\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes,\n\t\t    ZPixmap);\n\t\tif (! quiet) {\n\t\t\trfbLog(\"Read initial data from X display into\"\n\t\t\t    \" framebuffer.\\n\");\n\t\t}\n\t}\n\n\tif (subwin) {\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror || fb == NULL) {\n\t\t    rfbLog(\"trapped GetImage at SUBWIN creation.\\n\");\n\t\t    if (try < subwin_tries) {\n\t\t\tusleep(250 * 1000);\n\t\t\tif (!get_window_size(window, &wdpy_x, &wdpy_y)) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"could not get size of subwin \"\n\t\t\t\t    \"0x%lx\\n\", subwin);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tgoto again;\n\t\t    }\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t} else if (fb == NULL) {\n#if HAVE_LIBXRANDR\n\t\tXEvent xev;\n#endif\n\t\trfbLog(\"initialize_xdisplay_fb: *** fb creation failed: 0x%x try: %d\\n\", fb, try);\n#if HAVE_LIBXRANDR\n\t\tif (xrandr_present && xrandr_base_event_type) {\n\t\t\tint cnt = 0;\n\t\t\twhile (XCheckTypedEvent(dpy, xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\t\t\tXRRScreenChangeNotifyEvent *rev;\n\t\t\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: XRANDR event while redoing fb[%d]:\\n\", cnt++);\n\t\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"previous WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n\n\t\t\t\txrandr_width  = rev->width;\n\t\t\t\txrandr_height = rev->height;\n\t\t\t\txrandr_timestamp = rev->timestamp;\n\t\t\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\t\t\txrandr_rotation = (int) rev->rotation;\n\n\t\t\t\trfbLog(\"initialize_xdisplay_fb: updating XRANDR config...\\n\");\n\t\t\t\tXRRUpdateConfiguration(&xev);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (try < 5)  {\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(250 * 1000);\n\t\t\tif (try < 3) {\n\t\t\t\tXSync(dpy, False);\n\t\t\t} else if (try >= 3) {\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (use_snapfb) {\n\t\tinitialize_snap_fb();\n\t}\n\n\tX_UNLOCK;\n\n\tif (fb->bits_per_pixel == 24 && ! quiet) {\n\t\trfbLog(\"warning: 24 bpp may have poor performance.\\n\");\n\t}\n\treturn fb;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_old_fb",
          "args": [],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "free_old_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "791-821",
          "snippet": "void free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void free_old_fb(void);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid free_old_fb(void);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_tiles",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "free_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "160-201",
          "snippet": "void free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void free_tiles(void);",
            "static hint_t *hint_list;",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid free_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_shm",
          "args": [
            "0"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "clean_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "93-132",
          "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_shm(int quick);",
            "int trap_xioerror(Display *d);",
            "static int XIOerr(Display *d);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_fini",
          "args": [],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "218-226",
          "snippet": "void macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Warning: changing framebuffers in threaded mode may be unstable.\\n\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
  },
  {
    "function_name": "prep_clients_for_new_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "989-1006",
    "snippet": "static void prep_clients_for_new_fb(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(screen);\n\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\tif (!cl->newFBSizePending) {\n\t\t\trfbLog(\"** set_new_fb_size_pending client:   %p\\n\", cl);\n\t\t\tcl->newFBSizePending = TRUE;\n\t\t}\n\t\tcl->cursorWasChanged = FALSE;\n\t\tcl->cursorWasMoved = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"** set_new_fb_size_pending client:   %p\\n\"",
            "cl"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nstatic void prep_clients_for_new_fb(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(screen);\n\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\tif (!cl->newFBSizePending) {\n\t\t\trfbLog(\"** set_new_fb_size_pending client:   %p\\n\", cl);\n\t\t\tcl->newFBSizePending = TRUE;\n\t\t}\n\t\tcl->cursorWasChanged = FALSE;\n\t\tcl->cursorWasMoved = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "settle_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "891-987",
    "snippet": "static void settle_clients(int init) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint fb_pend, i, ms = 1000;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\n\tif (init) {\n\t\titer = rfbGetClientIterator(screen);\n\t\ti = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (i < _bytes0_size) {\n\t\t\t\t_bytes0[i] = rfbStatGetSentBytesIfRaw(cl);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 250;\n\t\t} else {\n\t\t\tms = 500;\n\t\t}\n\t\tusleep(ms * 1000);\n\t\treturn;\n\t}\n\n\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t} else if (subwin) {\n\t\tms = 500;\n\t} else {\n\t\tms = 1000;\n\t}\n\tusleep(ms * 1000);\n\n\tfor (i=0; i < 5; i++) {\n\t\tfb_pend = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tif (cl->newFBSizePending) {\n\t\t\t\tfb_pend++;\n\t\t\t\trfbLog(\"pending fb size: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (fb_pend > 0) {\n\t\t\trfbLog(\"do_new_fb: newFBSizePending extra -threads sleep (%d)\\n\", i+1); \n\t\t\tusleep(ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i < 5; i++) {\n\t\tint stuck = 0, tot = 0, j = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (j < _bytes0_size) {\n\t\t\t\tint db = rfbStatGetSentBytesIfRaw(cl) - _bytes0[j];\n\t\t\t\tint Bpp = cl->format.bitsPerPixel / 8;\n\n\t\t\t\ts = lcs(cl);\n\t\t\t\trfbLog(\"addl bytes sent: %p  %.6f %s  %d  %d\\n\",\n\t\t\t\t    cl, dnowx(), s, db, _bytes0[j]);\n\n\t\t\t\tif (i==0) {\n\t\t\t\t\tif (db < Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i==1) {\n\t\t\t\t\tif (db < 0.5 * Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (db <= 0) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot++;\n\t\t\tj++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (stuck > 0) {\n\t\t\trfbLog(\"clients stuck:  %d/%d  sleep(%d)\\n\", stuck, tot, i);\n\t\t\tusleep(2 * ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void nofb_hook(rfbClientPtr cl);",
      "static int _bytes0_size = 128, _bytes0[128];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2 * ms * 1000"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"clients stuck:  %d/%d  sleep(%d)\\n\"",
            "stuck",
            "tot",
            "i"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"addl bytes sent: %p  %.6f %s  %d  %d\\n\"",
            "cl",
            "dnowx()",
            "s",
            "db",
            "_bytes0[j]"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lcs",
          "args": [
            "cl"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "lcs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "826-838",
          "snippet": "static char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static char _lcs_tmp[128];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic char _lcs_tmp[128];\n\nstatic char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbStatGetSentBytesIfRaw",
          "args": [
            "cl"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"do_new_fb: newFBSizePending extra -threads sleep (%d)\\n\"",
            "i+1"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"pending fb size: %p  %.6f %s\\n\"",
            "cl",
            "dnowx()",
            "s"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_THREADS_NEW_FB_SLEEP\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetSentBytesIfRaw",
          "args": [
            "cl"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void nofb_hook(rfbClientPtr cl);\nstatic int _bytes0_size = 128, _bytes0[128];\n\nstatic void settle_clients(int init) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint fb_pend, i, ms = 1000;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn;\n\t}\n\n\tif (init) {\n\t\titer = rfbGetClientIterator(screen);\n\t\ti = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (i < _bytes0_size) {\n\t\t\t\t_bytes0[i] = rfbStatGetSentBytesIfRaw(cl);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 250;\n\t\t} else {\n\t\t\tms = 500;\n\t\t}\n\t\tusleep(ms * 1000);\n\t\treturn;\n\t}\n\n\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t} else if (subwin) {\n\t\tms = 500;\n\t} else {\n\t\tms = 1000;\n\t}\n\tusleep(ms * 1000);\n\n\tfor (i=0; i < 5; i++) {\n\t\tfb_pend = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tif (cl->newFBSizePending) {\n\t\t\t\tfb_pend++;\n\t\t\t\trfbLog(\"pending fb size: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (fb_pend > 0) {\n\t\t\trfbLog(\"do_new_fb: newFBSizePending extra -threads sleep (%d)\\n\", i+1); \n\t\t\tusleep(ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i=0; i < 5; i++) {\n\t\tint stuck = 0, tot = 0, j = 0;\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\tif (j < _bytes0_size) {\n\t\t\t\tint db = rfbStatGetSentBytesIfRaw(cl) - _bytes0[j];\n\t\t\t\tint Bpp = cl->format.bitsPerPixel / 8;\n\n\t\t\t\ts = lcs(cl);\n\t\t\t\trfbLog(\"addl bytes sent: %p  %.6f %s  %d  %d\\n\",\n\t\t\t\t    cl, dnowx(), s, db, _bytes0[j]);\n\n\t\t\t\tif (i==0) {\n\t\t\t\t\tif (db < Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i==1) {\n\t\t\t\t\tif (db < 0.5 * Bpp * dpy_x * dpy_y) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (db <= 0) {\n\t\t\t\t\t\tstuck++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot++;\n\t\t\tj++;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t\tif (stuck > 0) {\n\t\t\trfbLog(\"clients stuck:  %d/%d  sleep(%d)\\n\", stuck, tot, i);\n\t\t\tusleep(2 * ms * 1000);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "lock_client_sends",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "840-889",
    "snippet": "static int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lcs",
          "args": [
            "cl"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "lcs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "826-838",
          "snippet": "static char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void nofb_hook(rfbClientPtr cl);",
            "static char _lcs_tmp[128];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic char _lcs_tmp[128];\n\nstatic char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"locked client:   %p  %.6f %s\\n\"",
            "cl",
            "dnowx()",
            "s"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEND_LOCK",
          "args": [
            "cl"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "cls_len * sizeof(rfbClientPtr)",
            "1"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cls"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic rfbClient* client = NULL;\n\nstatic int lock_client_sends(int lock) {\n\tstatic rfbClientPtr *cls = NULL;\n\tstatic int cls_len = 0;\n\tstatic int blocked = 0;\n\tstatic int state = 0;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *s;\n\n\tif (!use_threads || !screen) {\n\t\treturn 0;\n\t}\n\tif (lock < 0) {\n\t\treturn state;\n\t}\n\tstate = lock;\n\n\tif (lock) {\n\t\tif (cls_len < client_count + 128) {\n\t\t\tif (cls != NULL) {\n\t\t\t\tfree(cls);\n\t\t\t}\n\t\t\tcls_len = client_count + 256;\n\t\t\tcls = (rfbClientPtr *) calloc(cls_len * sizeof(rfbClientPtr), 1);\n\t\t}\n\t\t\n\t\titer = rfbGetClientIterator(screen);\n\t\tblocked = 0;\n\t\twhile ((cl = rfbClientIteratorNext(iter)) != NULL) {\n\t\t\ts = lcs(cl);\n\t\t\tSEND_LOCK(cl);\n\t\t\trfbLog(\"locked client:   %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\tcls[blocked++] = cl;\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t} else {\n\t\tint i;\n\t\tfor (i=0; i < blocked; i++) {\n\t\t\tcl = cls[i];\n\t\t\tif (cl != NULL) {\n\t\t\t\ts = lcs(cl);\n\t\t\t\tSEND_UNLOCK(cl)\n\t\t\t\trfbLog(\"unlocked client: %p  %.6f %s\\n\", cl, dnowx(), s);\n\t\t\t}\n\t\t\tcls[i] = NULL;\n\t\t}\n\t\tblocked = 0;\n\t}\n\treturn state;\n}"
  },
  {
    "function_name": "lcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "826-838",
    "snippet": "static char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void nofb_hook(rfbClientPtr cl);",
      "static char _lcs_tmp[128];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "_lcs_tmp",
            "\"%d/%d/%d/%d/%d-%d/%d/%d\"",
            "!!(cl->newFBSizePending)",
            "!!(cl->cursorWasChanged)",
            "!!(cl->cursorWasMoved)",
            "!!(cl->reverseConnection)",
            "cl->state",
            "cl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2",
            "cl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2",
            "cl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "cl->copyRegion"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void nofb_hook(rfbClientPtr cl);\nstatic char _lcs_tmp[128];\n\nstatic char *lcs(rfbClientPtr cl) {\n\tsprintf(_lcs_tmp, \"%d/%d/%d/%d/%d-%d/%d/%d\",\n\t\t!!(cl->newFBSizePending),\n\t\t!!(cl->cursorWasChanged),\n\t\t!!(cl->cursorWasMoved),\n\t\t!!(cl->reverseConnection),\n\t\tcl->state,\n\t\tcl->modifiedRegion  ? !!(sraRgnEmpty(cl->modifiedRegion))  : 2,\n\t\tcl->requestedRegion ? !!(sraRgnEmpty(cl->requestedRegion)) : 2,\n\t\tcl->copyRegion      ? !!(sraRgnEmpty(cl->copyRegion))      : 2\n\t);\n\treturn _lcs_tmp;\n}"
  },
  {
    "function_name": "free_old_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "791-821",
    "snippet": "void free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void free_old_fb(void);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"skip: %i %p\\n\"",
            "i",
            "fb"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fb"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"free: %i %p\\n\"",
            "i",
            "fb"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid free_old_fb(void);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nofb_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "765-789",
    "snippet": "static void nofb_hook(rfbClientPtr cl) {\n\tXImage *fb;\n\tXImage raw;\n\n\trfbLog(\"framebuffer requested in -nofb mode by client %s\\n\", cl->host);\n\t/* ignore xrandr */\n\n\tif (raw_fb && ! dpy) {\n\t\tfb = &raw;\n\t\tfb->data = (char *)malloc(32);\n\t} else {\n\t\tint use_real_ximage = 0;\n\t\tif (use_real_ximage) {\n\t\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t} else {\n\t\t\tfb = &raw;\n\t\t\tfb->data = (char *) calloc(dpy_x*dpy_y*bpp/8, 1);\n\t\t}\n\t}\n\tmain_fb = fb->data;\n\trfb_fb = main_fb;\n\t/* mutex */\n\tscreen->frameBuffer = rfb_fb;\n\tscreen->displayHook = NULL;\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int parse_rotate_string(char *str, int *mode);",
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);",
      "static void nofb_hook(rfbClientPtr cl);",
      "static void install_fake_fb(int w, int h, int bpp);",
      "static rfbClient* client = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "dpy_x*dpy_y*bpp/8",
            "1"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetImage_wr",
          "args": [
            "dpy",
            "window",
            "0",
            "0",
            "dpy_x",
            "dpy_y",
            "AllPlanes",
            "ZPixmap"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "XGetImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "340-368",
          "snippet": "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nvoid XTestDiscard_wr(Display *dpy);\n\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format) {\n#if NO_X11\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format) {}\n\tnox11_exit(1);\n\treturn NULL;\n#else\n\n\tADJUST_ROOTSHIFT\n\n\tif (overlay) {\n\t\treturn xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin  && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi = XGetImage(disp, pixmap, x, y, width, height, plane_mask, format);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetImage(disp, d, x, y, width, height, plane_mask, format);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "32"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"framebuffer requested in -nofb mode by client %s\\n\"",
            "cl->host"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void install_fake_fb(int w, int h, int bpp);\nstatic rfbClient* client = NULL;\n\nstatic void nofb_hook(rfbClientPtr cl) {\n\tXImage *fb;\n\tXImage raw;\n\n\trfbLog(\"framebuffer requested in -nofb mode by client %s\\n\", cl->host);\n\t/* ignore xrandr */\n\n\tif (raw_fb && ! dpy) {\n\t\tfb = &raw;\n\t\tfb->data = (char *)malloc(32);\n\t} else {\n\t\tint use_real_ximage = 0;\n\t\tif (use_real_ximage) {\n\t\t\tfb = XGetImage_wr(dpy, window, 0, 0, dpy_x, dpy_y, AllPlanes, ZPixmap);\n\t\t} else {\n\t\t\tfb = &raw;\n\t\t\tfb->data = (char *) calloc(dpy_x*dpy_y*bpp/8, 1);\n\t\t}\n\t}\n\tmain_fb = fb->data;\n\trfb_fb = main_fb;\n\t/* mutex */\n\tscreen->frameBuffer = rfb_fb;\n\tscreen->displayHook = NULL;\n}"
  },
  {
    "function_name": "set_raw_fb_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "607-756",
    "snippet": "void set_raw_fb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int vo0, us0, sm0, ws0, wp0, wc0, wb0, na0, tn0;  \n\tstatic int xr0, xrm0, sb0, re0;\n\tstatic char *mc0;\n\n\t/*\n\t * set turn off a bunch of parameters not compatible with \n\t * -rawfb mode: 1) ignoring the X server 2) ignoring user input. \n\t */\n\t\n\tif (first) {\n\t\t/* at least save the initial settings... */\n\t\tvo0 = view_only;\n\t\tws0 = watch_selection;\n\t\twp0 = watch_primary;\n\t\twc0 = watch_clipboard;\n\t\twb0 = watch_bell;\n\t\tna0 = no_autorepeat;\n\t\tsb0 = use_solid_bg;\n\n\t\tus0 = use_snapfb;\n\t\tsm0 = using_shm;\n\t\ttn0 = take_naps;\n\t\txr0 = xrandr;\n\t\txrm0 = xrandr_maybe;\n\t\tre0 = noxrecord;\n\t\tmc0 = multiple_cursors_mode;\n\n\t\tfirst = 0;\n\t}\n\n\tif (restore) {\n\t\tview_only = vo0;\n\t\twatch_selection = ws0;\n\t\twatch_primary = wp0;\n\t\twatch_clipboard = wc0;\n\t\twatch_bell = wb0;\n\t\tno_autorepeat = na0;\n\t\tuse_solid_bg = sb0;\n\n\t\tuse_snapfb = us0;\n\t\tusing_shm = sm0;\n\t\ttake_naps = tn0;\n\t\txrandr = xr0;\n\t\txrandr_maybe = xrm0;\n\t\tnoxrecord = re0;\n\t\tmultiple_cursors_mode = mc0;\n\n\t\tif (! dpy && raw_fb_orig_dpy) {\n\t\t\tdpy = XOpenDisplay_wr(raw_fb_orig_dpy);\n\t\t\tlast_open_xdisplay = time(NULL);\n\t\t\tif (dpy) {\n\t\t\t\tif (! quiet) rfbLog(\"reopened DISPLAY: %s\\n\",\n\t\t\t\t    raw_fb_orig_dpy);\n\t\t\t\tscr = DefaultScreen(dpy);\n\t\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\t\tcheck_xevents(1);\n\t\t\t} else {\n\t\t\t\tif (! quiet) rfbLog(\"WARNING: failed to reopen \"\n\t\t\t\t    \"DISPLAY: %s\\n\", raw_fb_orig_dpy);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"set_raw_fb_params: modifying settings for \"\n\t\t    \"-rawfb mode.\\n\");\n\t}\n\n\tif (got_noviewonly) {\n\t\t/*\n\t\t * The user input parameters are not unset under\n\t\t * -noviewonly... this usage should be very rare\n\t\t * (i.e. rawfb but also send user input to the X\n\t\t * display, most likely using /dev/fb0 for some reason...)\n\t\t */\n\t\tif (verbose) {\n\t\t   rfbLog(\"rawfb: -noviewonly mode: still sending mouse and\\n\");\n\t\t   rfbLog(\"rawfb:   keyboard input to the X DISPLAY!!\\n\");\n\t\t}\n\t} else {\n\t\t/* Normal case: */\n#if 0\n\t\tif (! view_only && ! pipeinput_str) {\n\t\t\tif (! quiet) rfbLog(\"  rawfb: setting view_only\\n\");\n\t\t\tview_only = 1;\n\t\t}\n#endif\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else if (watch_selection) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_selection\\n\");\n\t\t\twatch_selection = 0;\n\t\t}\n\t\tif (watch_primary) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_primary\\n\");\n\t\t\twatch_primary = 0;\n\t\t}\n\t\tif (watch_clipboard) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_clipboard\\n\");\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (watch_bell) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off watch_bell\\n\");\n\t\t\twatch_bell = 0;\n\t\t}\n\t\tif (no_autorepeat) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"no_autorepeat\\n\");\n\t\t\tno_autorepeat = 0;\n\t\t}\n\t\tif (use_solid_bg) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"use_solid_bg\\n\");\n\t\t\tuse_solid_bg = 0;\n\t\t}\n#ifndef MACOSX\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else {\n\t\t\tmultiple_cursors_mode = strdup(\"arrow\");\n\t\t}\n#endif\n\t}\n\tif (using_shm) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off using_shm\\n\");\n\t\tusing_shm = 0;\n\t}\n\tif (take_naps) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off take_naps\\n\");\n\t\ttake_naps = 0;\n\t}\n\tif (xrandr) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr\\n\");\n\t\txrandr = 0;\n\t}\n\tif (xrandr_maybe) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr_maybe\\n\");\n\t\txrandr_maybe = 0;\n\t}\n\tif (! noxrecord) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrecord\\n\");\n\t\tnoxrecord = 1;\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_nofb_params(int restore);",
      "void set_raw_fb_params(int restore);",
      "int parse_rotate_string(char *str, int *mode);",
      "static char *raw_fb_orig_dpy = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off xrecord\\n\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off xrandr_maybe\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off xrandr\\n\""
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off take_naps\\n\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off using_shm\\n\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"arrow\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "raw_fb_str",
            "\"vnc\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off \"\n\t\t\t    \"use_solid_bg\\n\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off \"\n\t\t\t    \"no_autorepeat\\n\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off watch_bell\\n\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off \"\n\t\t\t    \"watch_clipboard\\n\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off \"\n\t\t\t    \"watch_primary\\n\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: turning off \"\n\t\t\t    \"watch_selection\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "raw_fb_str",
            "\"vnc\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rawfb: setting view_only\\n\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb:   keyboard input to the X DISPLAY!!\\n\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rawfb: -noviewonly mode: still sending mouse and\\n\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_raw_fb_params: modifying settings for \"\n\t\t    \"-rawfb mode.\\n\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"WARNING: failed to reopen \"\n\t\t\t\t    \"DISPLAY: %s\\n\"",
            "raw_fb_orig_dpy"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xevents",
          "args": [
            "1"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "check_xevents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1203-1675",
          "snippet": "void check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DEBUG_XEVENTS 1"
          ],
          "globals_used": [
            "int sync_tod_delay = 20;",
            "void sync_tod_with_servertime(void);",
            "void set_prop_atom(Atom atom);",
            "void check_xevents(int reset);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "void set_text_chat(rfbClientPtr cl, int l, char *t);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static void initialize_xevents(int reset);",
            "static void print_xevent_bases(void);",
            "static void bust_grab(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DEBUG_XEVENTS 1\n\nint sync_tod_delay = 20;\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nvoid set_text_chat(rfbClientPtr cl, int l, char *t);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void print_xevent_bases(void);\nstatic void bust_grab(int reset);\n\nvoid check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reopened DISPLAY: %s\\n\"",
            "raw_fb_orig_dpy"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "raw_fb_orig_dpy"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_nofb_params(int restore);\nvoid set_raw_fb_params(int restore);\nint parse_rotate_string(char *str, int *mode);\nstatic char *raw_fb_orig_dpy = NULL;\n\nvoid set_raw_fb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int vo0, us0, sm0, ws0, wp0, wc0, wb0, na0, tn0;  \n\tstatic int xr0, xrm0, sb0, re0;\n\tstatic char *mc0;\n\n\t/*\n\t * set turn off a bunch of parameters not compatible with \n\t * -rawfb mode: 1) ignoring the X server 2) ignoring user input. \n\t */\n\t\n\tif (first) {\n\t\t/* at least save the initial settings... */\n\t\tvo0 = view_only;\n\t\tws0 = watch_selection;\n\t\twp0 = watch_primary;\n\t\twc0 = watch_clipboard;\n\t\twb0 = watch_bell;\n\t\tna0 = no_autorepeat;\n\t\tsb0 = use_solid_bg;\n\n\t\tus0 = use_snapfb;\n\t\tsm0 = using_shm;\n\t\ttn0 = take_naps;\n\t\txr0 = xrandr;\n\t\txrm0 = xrandr_maybe;\n\t\tre0 = noxrecord;\n\t\tmc0 = multiple_cursors_mode;\n\n\t\tfirst = 0;\n\t}\n\n\tif (restore) {\n\t\tview_only = vo0;\n\t\twatch_selection = ws0;\n\t\twatch_primary = wp0;\n\t\twatch_clipboard = wc0;\n\t\twatch_bell = wb0;\n\t\tno_autorepeat = na0;\n\t\tuse_solid_bg = sb0;\n\n\t\tuse_snapfb = us0;\n\t\tusing_shm = sm0;\n\t\ttake_naps = tn0;\n\t\txrandr = xr0;\n\t\txrandr_maybe = xrm0;\n\t\tnoxrecord = re0;\n\t\tmultiple_cursors_mode = mc0;\n\n\t\tif (! dpy && raw_fb_orig_dpy) {\n\t\t\tdpy = XOpenDisplay_wr(raw_fb_orig_dpy);\n\t\t\tlast_open_xdisplay = time(NULL);\n\t\t\tif (dpy) {\n\t\t\t\tif (! quiet) rfbLog(\"reopened DISPLAY: %s\\n\",\n\t\t\t\t    raw_fb_orig_dpy);\n\t\t\t\tscr = DefaultScreen(dpy);\n\t\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\t\tcheck_xevents(1);\n\t\t\t} else {\n\t\t\t\tif (! quiet) rfbLog(\"WARNING: failed to reopen \"\n\t\t\t\t    \"DISPLAY: %s\\n\", raw_fb_orig_dpy);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (verbose) {\n\t\trfbLog(\"set_raw_fb_params: modifying settings for \"\n\t\t    \"-rawfb mode.\\n\");\n\t}\n\n\tif (got_noviewonly) {\n\t\t/*\n\t\t * The user input parameters are not unset under\n\t\t * -noviewonly... this usage should be very rare\n\t\t * (i.e. rawfb but also send user input to the X\n\t\t * display, most likely using /dev/fb0 for some reason...)\n\t\t */\n\t\tif (verbose) {\n\t\t   rfbLog(\"rawfb: -noviewonly mode: still sending mouse and\\n\");\n\t\t   rfbLog(\"rawfb:   keyboard input to the X DISPLAY!!\\n\");\n\t\t}\n\t} else {\n\t\t/* Normal case: */\n#if 0\n\t\tif (! view_only && ! pipeinput_str) {\n\t\t\tif (! quiet) rfbLog(\"  rawfb: setting view_only\\n\");\n\t\t\tview_only = 1;\n\t\t}\n#endif\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else if (watch_selection) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_selection\\n\");\n\t\t\twatch_selection = 0;\n\t\t}\n\t\tif (watch_primary) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_primary\\n\");\n\t\t\twatch_primary = 0;\n\t\t}\n\t\tif (watch_clipboard) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"watch_clipboard\\n\");\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (watch_bell) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off watch_bell\\n\");\n\t\t\twatch_bell = 0;\n\t\t}\n\t\tif (no_autorepeat) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"no_autorepeat\\n\");\n\t\t\tno_autorepeat = 0;\n\t\t}\n\t\tif (use_solid_bg) {\n\t\t\tif (verbose) rfbLog(\"  rawfb: turning off \"\n\t\t\t    \"use_solid_bg\\n\");\n\t\t\tuse_solid_bg = 0;\n\t\t}\n#ifndef MACOSX\n\t\tif (raw_fb_str && strstr(raw_fb_str, \"vnc\") == raw_fb_str) {\n\t\t\t;\n\t\t} else {\n\t\t\tmultiple_cursors_mode = strdup(\"arrow\");\n\t\t}\n#endif\n\t}\n\tif (using_shm) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off using_shm\\n\");\n\t\tusing_shm = 0;\n\t}\n\tif (take_naps) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off take_naps\\n\");\n\t\ttake_naps = 0;\n\t}\n\tif (xrandr) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr\\n\");\n\t\txrandr = 0;\n\t}\n\tif (xrandr_maybe) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrandr_maybe\\n\");\n\t\txrandr_maybe = 0;\n\t}\n\tif (! noxrecord) {\n\t\tif (verbose) rfbLog(\"  rawfb: turning off xrecord\\n\");\n\t\tnoxrecord = 1;\n\t}\n}"
  },
  {
    "function_name": "set_nofb_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "511-603",
    "snippet": "void set_nofb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int save[100];\n\tstatic char *scroll = NULL;\n\tint i = 0;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tsave[i++] = use_xfixes;\n\t\tsave[i++] = use_xdamage;\n\t\tsave[i++] = use_xrecord;\n\t\tsave[i++] = wireframe;\n\t\tsave[i++] = use_solid_bg;\n\t\tsave[i++] = overlay;\n\t\tsave[i++] = overlay_cursor;\n\t\tsave[i++] = using_shm;\n\t\tsave[i++] = single_copytile;\n\t\tsave[i++] = take_naps;\n\t\tsave[i++] = measure_speeds;\n\t\tsave[i++] = grab_buster;\n\t\tsave[i++] = show_cursor;\n\t\tsave[i++] = cursor_shape_updates;\n\t\tsave[i++] = cursor_pos_updates;\n\t\tsave[i++] = ncache;\n\n\t\tscroll = scroll_copyrect;\n\t}\n\tif (restore) {\n\t\ti = 0;\n\t\tuse_xfixes            = save[i++];\n\t\tuse_xdamage           = save[i++];\n\t\tuse_xrecord           = save[i++];\n\t\twireframe             = save[i++];\n\t\tuse_solid_bg          = save[i++];\n\t\toverlay               = save[i++];\n\t\toverlay_cursor        = save[i++];\n\t\tusing_shm             = save[i++];\n\t\tsingle_copytile       = save[i++];\n\t\ttake_naps             = save[i++];\n\t\tmeasure_speeds        = save[i++];\n\t\tgrab_buster           = save[i++];\n\t\tshow_cursor           = save[i++];\n\t\tcursor_shape_updates  = save[i++];\n\t\tcursor_pos_updates    = save[i++];\n\t\tncache                = save[i++];\n\n\t\tscroll_copyrect = scroll;\n\n\t\tif (cursor_shape_updates) {\n\t\t\trestore_cursor_shape_updates(screen);\n\t\t}\n\t\tinitialize_cursors_mode();\n\n\t\treturn;\n\t}\n\n\tuse_xfixes = 0;\n\tuse_xdamage = 0;\n\tuse_xrecord = 0;\n\twireframe = 0;\n\n\tuse_solid_bg = 0;\n\toverlay = 0;\n\toverlay_cursor = 0;\n\n\tusing_shm = 0;\n\tsingle_copytile = 1;\n\n\ttake_naps = 0;\n\tmeasure_speeds = 0;\n\n\t/* got_grab_buster? */\n\tgrab_buster = 0;\n\n\tshow_cursor = 0;\n\tshow_multiple_cursors = 0;\n\tcursor_shape_updates = 0;\n\tif (! got_cursorpos) {\n\t\tcursor_pos_updates = 0;\n\t}\n\n\tncache = 0;\n\n\tscroll_copyrect = \"never\";\n\n\tif (! quiet) {\n\t\trfbLog(\"disabling: xfixes, xdamage, solid, overlay, shm,\\n\");\n\t\trfbLog(\"  wireframe, scrollcopyrect, ncache,\\n\");\n\t\trfbLog(\"  noonetile, nap, cursor, %scursorshape\\n\",\n\t\t    got_cursorpos ? \"\" : \"cursorpos, \" );\n\t\trfbLog(\"  in -nofb mode.\\n\");\n\t}\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_nofb_params(int restore);",
      "void set_raw_fb_params(int restore);",
      "int parse_rotate_string(char *str, int *mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  in -nofb mode.\\n\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  noonetile, nap, cursor, %scursorshape\\n\"",
            "got_cursorpos ? \"\" : \"cursorpos, \""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  wireframe, scrollcopyrect, ncache,\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"disabling: xfixes, xdamage, solid, overlay, shm,\\n\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_cursors_mode",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_cursors_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1470-1510",
          "snippet": "void initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void initialize_cursors_mode(void);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nunsigned long get_cursor_serial(int mode);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nvoid initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_cursor_shape_updates",
          "args": [
            "screen"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "restore_cursor_shape_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1675-1709",
          "snippet": "void restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_nofb_params(int restore);\nvoid set_raw_fb_params(int restore);\nint parse_rotate_string(char *str, int *mode);\n\nvoid set_nofb_params(int restore) {\n\tstatic int first = 1;\n\tstatic int save[100];\n\tstatic char *scroll = NULL;\n\tint i = 0;\n\n\tif (first) {\n\t\tfirst = 0;\n\t\tsave[i++] = use_xfixes;\n\t\tsave[i++] = use_xdamage;\n\t\tsave[i++] = use_xrecord;\n\t\tsave[i++] = wireframe;\n\t\tsave[i++] = use_solid_bg;\n\t\tsave[i++] = overlay;\n\t\tsave[i++] = overlay_cursor;\n\t\tsave[i++] = using_shm;\n\t\tsave[i++] = single_copytile;\n\t\tsave[i++] = take_naps;\n\t\tsave[i++] = measure_speeds;\n\t\tsave[i++] = grab_buster;\n\t\tsave[i++] = show_cursor;\n\t\tsave[i++] = cursor_shape_updates;\n\t\tsave[i++] = cursor_pos_updates;\n\t\tsave[i++] = ncache;\n\n\t\tscroll = scroll_copyrect;\n\t}\n\tif (restore) {\n\t\ti = 0;\n\t\tuse_xfixes            = save[i++];\n\t\tuse_xdamage           = save[i++];\n\t\tuse_xrecord           = save[i++];\n\t\twireframe             = save[i++];\n\t\tuse_solid_bg          = save[i++];\n\t\toverlay               = save[i++];\n\t\toverlay_cursor        = save[i++];\n\t\tusing_shm             = save[i++];\n\t\tsingle_copytile       = save[i++];\n\t\ttake_naps             = save[i++];\n\t\tmeasure_speeds        = save[i++];\n\t\tgrab_buster           = save[i++];\n\t\tshow_cursor           = save[i++];\n\t\tcursor_shape_updates  = save[i++];\n\t\tcursor_pos_updates    = save[i++];\n\t\tncache                = save[i++];\n\n\t\tscroll_copyrect = scroll;\n\n\t\tif (cursor_shape_updates) {\n\t\t\trestore_cursor_shape_updates(screen);\n\t\t}\n\t\tinitialize_cursors_mode();\n\n\t\treturn;\n\t}\n\n\tuse_xfixes = 0;\n\tuse_xdamage = 0;\n\tuse_xrecord = 0;\n\twireframe = 0;\n\n\tuse_solid_bg = 0;\n\toverlay = 0;\n\toverlay_cursor = 0;\n\n\tusing_shm = 0;\n\tsingle_copytile = 1;\n\n\ttake_naps = 0;\n\tmeasure_speeds = 0;\n\n\t/* got_grab_buster? */\n\tgrab_buster = 0;\n\n\tshow_cursor = 0;\n\tshow_multiple_cursors = 0;\n\tcursor_shape_updates = 0;\n\tif (! got_cursorpos) {\n\t\tcursor_pos_updates = 0;\n\t}\n\n\tncache = 0;\n\n\tscroll_copyrect = \"never\";\n\n\tif (! quiet) {\n\t\trfbLog(\"disabling: xfixes, xdamage, solid, overlay, shm,\\n\");\n\t\trfbLog(\"  wireframe, scrollcopyrect, ncache,\\n\");\n\t\trfbLog(\"  noonetile, nap, cursor, %scursorshape\\n\",\n\t\t    got_cursorpos ? \"\" : \"cursorpos, \" );\n\t\trfbLog(\"  in -nofb mode.\\n\");\n\t}\n}"
  },
  {
    "function_name": "set_visual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "427-509",
    "snippet": "static void set_visual(char *str) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!str) {}\n\treturn;\n#else\n\tint vis, vdepth, defdepth;\n\tXVisualInfo vinfo;\n\tchar *p, *vstring = strdup(str);\n\n\tRAWFB_RET_VOID\n\n\tdefdepth = DefaultDepth(dpy, scr);\n\tvisual_id = (VisualID) 0;\n\tvisual_depth = 0;\n\n\tif (!strcmp(vstring, \"ignore\") || !strcmp(vstring, \"default\")\n\t    || !strcmp(vstring, \"\")) {\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\t/* set visual depth */\n\tif ((p = strchr(vstring, ':')) != NULL) {\n\t\tvisual_depth = atoi(p+1);\n\t\t*p = '\\0';\n\t\tvdepth = visual_depth;\n\t} else {\n\t\tvdepth = defdepth; \n\t}\n\tif (! quiet) {\n\t\tfprintf(stderr, \"\\nVisual Info:\\n\");\n\t\tfprintf(stderr, \" set_visual(\\\"%s\\\")\\n\", str);\n\t\tfprintf(stderr, \" visual_depth: %d\\n\", vdepth);\n\t}\n\n\t/* set visual id number */\n\tif (strcmp(vstring, \"StaticGray\") == 0) {\n\t\tvis = StaticGray;\n\t} else if (strcmp(vstring, \"GrayScale\") == 0) {\n\t\tvis = GrayScale;\n\t} else if (strcmp(vstring, \"StaticColor\") == 0) {\n\t\tvis = StaticColor;\n\t} else if (strcmp(vstring, \"PseudoColor\") == 0) {\n\t\tvis = PseudoColor;\n\t} else if (strcmp(vstring, \"TrueColor\") == 0) {\n\t\tvis = TrueColor;\n\t} else if (strcmp(vstring, \"DirectColor\") == 0) {\n\t\tvis = DirectColor;\n\t} else {\n\t\tunsigned int v_in;\n\t\tif (sscanf(vstring, \"0x%x\", &v_in) != 1) {\n\t\t\tif (sscanf(vstring, \"%u\", &v_in) == 1) {\n\t\t\t\tvisual_id = (VisualID) v_in;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -visual arg: %s\\n\", vstring);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tvisual_id = (VisualID) v_in;\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\tif (! quiet) fprintf(stderr, \" visual: %d\\n\", vis);\n\tif (XMatchVisualInfo(dpy, scr, visual_depth, vis, &vinfo)) {\n\t\t;\n\t} else if (XMatchVisualInfo(dpy, scr, defdepth, vis, &vinfo)) {\n\t\t;\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not find visual: %s\\n\", vstring);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tfree(vstring);\n\n\t/* set numerical visual id. */\n\tvisual_id = vinfo.visualid;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_visual(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "vstring"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not find visual: %s\\n\"",
            "vstring"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMatchVisualInfo",
          "args": [
            "dpy",
            "scr",
            "defdepth",
            "vis",
            "&vinfo"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMatchVisualInfo",
          "args": [
            "dpy",
            "scr",
            "visual_depth",
            "vis",
            "&vinfo"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" visual: %d\\n\"",
            "vis"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid -visual arg: %s\\n\"",
            "vstring"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "vstring",
            "\"%u\"",
            "&v_in"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "vstring",
            "\"0x%x\"",
            "&v_in"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"DirectColor\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"TrueColor\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"PseudoColor\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"StaticColor\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"GrayScale\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"StaticGray\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" visual_depth: %d\\n\"",
            "vdepth"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" set_visual(\\\"%s\\\")\\n\"",
            "str"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nVisual Info:\\n\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+1"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "vstring",
            "':'"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"default\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vstring",
            "\"ignore\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDepth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nstatic void set_visual(char *str);\n\nstatic void set_visual(char *str) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!str) {}\n\treturn;\n#else\n\tint vis, vdepth, defdepth;\n\tXVisualInfo vinfo;\n\tchar *p, *vstring = strdup(str);\n\n\tRAWFB_RET_VOID\n\n\tdefdepth = DefaultDepth(dpy, scr);\n\tvisual_id = (VisualID) 0;\n\tvisual_depth = 0;\n\n\tif (!strcmp(vstring, \"ignore\") || !strcmp(vstring, \"default\")\n\t    || !strcmp(vstring, \"\")) {\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\t/* set visual depth */\n\tif ((p = strchr(vstring, ':')) != NULL) {\n\t\tvisual_depth = atoi(p+1);\n\t\t*p = '\\0';\n\t\tvdepth = visual_depth;\n\t} else {\n\t\tvdepth = defdepth; \n\t}\n\tif (! quiet) {\n\t\tfprintf(stderr, \"\\nVisual Info:\\n\");\n\t\tfprintf(stderr, \" set_visual(\\\"%s\\\")\\n\", str);\n\t\tfprintf(stderr, \" visual_depth: %d\\n\", vdepth);\n\t}\n\n\t/* set visual id number */\n\tif (strcmp(vstring, \"StaticGray\") == 0) {\n\t\tvis = StaticGray;\n\t} else if (strcmp(vstring, \"GrayScale\") == 0) {\n\t\tvis = GrayScale;\n\t} else if (strcmp(vstring, \"StaticColor\") == 0) {\n\t\tvis = StaticColor;\n\t} else if (strcmp(vstring, \"PseudoColor\") == 0) {\n\t\tvis = PseudoColor;\n\t} else if (strcmp(vstring, \"TrueColor\") == 0) {\n\t\tvis = TrueColor;\n\t} else if (strcmp(vstring, \"DirectColor\") == 0) {\n\t\tvis = DirectColor;\n\t} else {\n\t\tunsigned int v_in;\n\t\tif (sscanf(vstring, \"0x%x\", &v_in) != 1) {\n\t\t\tif (sscanf(vstring, \"%u\", &v_in) == 1) {\n\t\t\t\tvisual_id = (VisualID) v_in;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -visual arg: %s\\n\", vstring);\n\t\t\tX_UNLOCK;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tvisual_id = (VisualID) v_in;\n\t\tfree(vstring);\n\t\treturn;\n\t}\n\n\tif (! quiet) fprintf(stderr, \" visual: %d\\n\", vis);\n\tif (XMatchVisualInfo(dpy, scr, visual_depth, vis, &vinfo)) {\n\t\t;\n\t} else if (XMatchVisualInfo(dpy, scr, defdepth, vis, &vinfo)) {\n\t\t;\n\t} else {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not find visual: %s\\n\", vstring);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tfree(vstring);\n\n\t/* set numerical visual id. */\n\tvisual_id = vinfo.visualid;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "debug_colormap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "369-417",
    "snippet": "static void debug_colormap(XImage *fb) {\n\tstatic int debug_cmap = -1;\n\tint i, k, *histo;\n\tint ncolor;\n\n\tif (debug_cmap < 0) {\n\t\tif (getenv(\"DEBUG_CMAP\") != NULL) {\n\t\t\tdebug_cmap = 1;\n\t\t} else {\n\t\t\tdebug_cmap = 0;\n\t\t}\n\t}\n\tif (! debug_cmap) {\n\t\treturn;\n\t}\n\tif (! fb) {\n\t\treturn;\n\t}\n\tif (fb->bits_per_pixel > 16) {\n\t\treturn;\n\t}\n\tncolor = screen->colourMap.count;\n\thisto = (int *) calloc(ncolor * sizeof(int), 1);\n\n\tfor (i=0; i < ncolor; i++) {\n\t\thisto[i] = 0;\n\t}\n\tfor (k = 0; k < fb->width * fb->height; k++) {\n\t\tunsigned char n;\n\t\tchar c = *(fb->data + k);\n\n\t\tn = (unsigned char) c;\n\t\thisto[n]++;\n\t}\n\tfprintf(stderr, \"\\nColormap histogram for current screen contents:\\n\");\n\tfor (i=0; i < ncolor; i++) {\n\t\tunsigned short r = screen->colourMap.data.shorts[i*3+0];\n\t\tunsigned short g = screen->colourMap.data.shorts[i*3+1];\n\t\tunsigned short b = screen->colourMap.data.shorts[i*3+2];\n\n\t\tfprintf(stderr, \"   %03d: %7d %04x/%04x/%04x\", i, histo[i],\n\t\t    r, g, b);\n\t\tif ((i+1) % 2 == 0)  {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n\tfree(histo);\n\tfprintf(stderr, \"\\n\");\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_screen(int *argc, char **argv, XImage *fb);",
      "static void debug_colormap(XImage *fb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "histo"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   %03d: %7d %04x/%04x/%04x\"",
            "i",
            "histo[i]",
            "r",
            "g",
            "b"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nColormap histogram for current screen contents:\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "ncolor * sizeof(int)",
            "1"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_CMAP\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nstatic void debug_colormap(XImage *fb) {\n\tstatic int debug_cmap = -1;\n\tint i, k, *histo;\n\tint ncolor;\n\n\tif (debug_cmap < 0) {\n\t\tif (getenv(\"DEBUG_CMAP\") != NULL) {\n\t\t\tdebug_cmap = 1;\n\t\t} else {\n\t\t\tdebug_cmap = 0;\n\t\t}\n\t}\n\tif (! debug_cmap) {\n\t\treturn;\n\t}\n\tif (! fb) {\n\t\treturn;\n\t}\n\tif (fb->bits_per_pixel > 16) {\n\t\treturn;\n\t}\n\tncolor = screen->colourMap.count;\n\thisto = (int *) calloc(ncolor * sizeof(int), 1);\n\n\tfor (i=0; i < ncolor; i++) {\n\t\thisto[i] = 0;\n\t}\n\tfor (k = 0; k < fb->width * fb->height; k++) {\n\t\tunsigned char n;\n\t\tchar c = *(fb->data + k);\n\n\t\tn = (unsigned char) c;\n\t\thisto[n]++;\n\t}\n\tfprintf(stderr, \"\\nColormap histogram for current screen contents:\\n\");\n\tfor (i=0; i < ncolor; i++) {\n\t\tunsigned short r = screen->colourMap.data.shorts[i*3+0];\n\t\tunsigned short g = screen->colourMap.data.shorts[i*3+1];\n\t\tunsigned short b = screen->colourMap.data.shorts[i*3+2];\n\n\t\tfprintf(stderr, \"   %03d: %7d %04x/%04x/%04x\", i, histo[i],\n\t\t    r, g, b);\n\t\tif ((i+1) % 2 == 0)  {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t}\n\tfree(histo);\n\tfprintf(stderr, \"\\n\");\n}"
  },
  {
    "function_name": "set_colormap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "202-367",
    "snippet": "void set_colormap(int reset) {\n\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int init = 1;\n\tstatic XColor *color = NULL, *prev = NULL;\n\tstatic int ncolor = 0;\n\tColormap cmap;\n\tVisual *vis;\n\tint i, ncells, diffs = 0;\n\n\tif (reset) {\n\t\tinit = 1;\n\t\tncolor = 0;\n\t\t/* mutex */\n\t\tif (screen->colourMap.data.shorts) {\n\t\t\tfree(screen->colourMap.data.shorts);\n\t\t\tscreen->colourMap.data.shorts = NULL;\n\t\t}\n\t\tif (color) {\n\t\t\tfree(color);\n\t\t\tcolor = NULL;\n\t\t}\n\t\tif (prev) {\n\t\t\tfree(prev);\n\t\t\tprev = NULL;\n\t\t}\n\t}\n\n\tif (init) {\n\t\tif (depth > 16) {\n\t\t\tncolor = NCOLOR;\n\t\t} else if (depth > 8) {\n\t\t\tncolor = 1 << depth;\n\t\t} else {\n\t\t\tncolor = NCOLOR;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->colourMap.count = ncolor;\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->colourMap.is16 = TRUE;\n\t\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\t\tmalloc(3*sizeof(unsigned short) * ncolor);\n\t}\n\tif (color == NULL) {\n\t\tcolor = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t\tprev  = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t}\n\n\tfor (i=0; i < ncolor; i++) {\n\t\tprev[i].red   = color[i].red;\n\t\tprev[i].green = color[i].green;\n\t\tprev[i].blue  = color[i].blue;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\n\tcmap = DefaultColormap(dpy, scr);\n\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\tvis = default_visual;\n\n\tif (subwin) {\n\t\tXWindowAttributes attr;\n\n\t\tif (XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\tcmap = attr.colormap;\n\t\t\tvis = attr.visual;\n\t\t\tncells = vis->map_entries;\n\t\t}\n\t}\n\n\tif (ncells != ncolor) {\n\t\tif (! shift_cmap) {\n\t\t\tscreen->colourMap.count = ncells;\n\t\t}\n\t}\n\tif (init && ! quiet) {\n\t\trfbLog(\"set_colormap: number of cells: %d, \"\n\t\t    \"ncolor(%d) is %d.\\n\", ncells, depth, ncolor);\n\t}\n\n\tif (flash_cmap && ! init) {\n\t\tXWindowAttributes attr;\n\t\tWindow c;\n\t\tint tries = 0;\n\n\t\tc = window;\n\t\twhile (c && tries++ < 16) {\n\t\t\tc = query_pointer(c);\n\t\t\tif (valid_window(c, &attr, 0)) {\n\t\t\t\tif (attr.colormap && attr.map_installed) {\n\t\t\t\t\tcmap = attr.colormap;\n\t\t\t\t\tvis = attr.visual;\n\t\t\t\t\tncells = vis->map_entries;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncells > ncolor && ! quiet) {\n\t\trfbLog(\"set_colormap: big problem: ncells=%d > %d\\n\",\n\t\t    ncells, ncolor);\n\t}\n\n\tif (vis->class == TrueColor || vis->class == DirectColor) {\n\t\t/*\n\t\t * Kludge to make 8bpp TrueColor & DirectColor be like\n\t\t * the StaticColor map.  The ncells = 8 is \"8 per subfield\"\n\t\t * mentioned in xdpyinfo.  Looks OK... perhaps fortuitously.\n\t\t */\n\t\tif (ncells == 8 && ! shift_cmap) {\n\t\t\tncells = ncolor;\n\t\t}\n\t}\n\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[i].pixel = i;\n\t\tcolor[i].pad = 0;\n\t}\n\n\tXQueryColors(dpy, cmap, color, ncells);\n\n\tX_UNLOCK;\n\n\tfor(i = ncells - 1; i >= 0; i--) {\n\t\tint k = i + shift_cmap;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = color[i].red;\n\t\tscreen->colourMap.data.shorts[i*3+1] = color[i].green;\n\t\tscreen->colourMap.data.shorts[i*3+2] = color[i].blue;\n\n\t\tif (prev[i].red   != color[i].red ||\n\t\t    prev[i].green != color[i].green || \n\t\t    prev[i].blue  != color[i].blue ) {\n\t\t\tdiffs++;\n\t\t}\n\n\t\tif (shift_cmap && k >= 0 && k < ncolor) {\n\t\t\t/* kludge to copy the colors to higher pixel values */\n\t\t\tscreen->colourMap.data.shorts[k*3+0] = color[i].red;\n\t\t\tscreen->colourMap.data.shorts[k*3+1] = color[i].green;\n\t\t\tscreen->colourMap.data.shorts[k*3+2] = color[i].blue;\n\t\t}\n\t}\n\n\tif (diffs && ! init) {\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"set_colormap: warning: sending cmap \"\n\t\t\t    \"with uninitialized clients.\\n\");\n\t\t}\n\t\tif (shift_cmap) {\n\t\t\trfbSetClientColourMaps(screen, 0, ncolor);\n\t\t} else {\n\t\t\trfbSetClientColourMaps(screen, 0, ncells);\n\t\t}\n\t}\n\n\tinit = 0;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NCOLOR 256"
    ],
    "globals_used": [
      "void set_colormap(int reset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSetClientColourMaps",
          "args": [
            "screen",
            "0",
            "ncells"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSetClientColourMaps",
          "args": [
            "screen",
            "0",
            "ncolor"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_colormap: warning: sending cmap \"\n\t\t\t    \"with uninitialized clients.\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryColors",
          "args": [
            "dpy",
            "cmap",
            "color",
            "ncells"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_colormap: big problem: ncells=%d > %d\\n\"",
            "ncells",
            "ncolor"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "c",
            "&attr",
            "0"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_pointer",
          "args": [
            "c"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "query_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "355-384",
          "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_colormap: number of cells: %d, \"\n\t\t    \"ncolor(%d) is %d.\\n\"",
            "ncells",
            "depth",
            "ncolor"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "window",
            "&attr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CellsOfScreen",
          "args": [
            "ScreenOfDisplay(dpy, scr)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScreenOfDisplay",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultColormap",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "ncolor * sizeof(XColor)",
            "1"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "ncolor * sizeof(XColor)",
            "1"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*sizeof(unsigned short) * ncolor"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "prev"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nvoid set_colormap(int reset);\n\nvoid set_colormap(int reset) {\n\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int init = 1;\n\tstatic XColor *color = NULL, *prev = NULL;\n\tstatic int ncolor = 0;\n\tColormap cmap;\n\tVisual *vis;\n\tint i, ncells, diffs = 0;\n\n\tif (reset) {\n\t\tinit = 1;\n\t\tncolor = 0;\n\t\t/* mutex */\n\t\tif (screen->colourMap.data.shorts) {\n\t\t\tfree(screen->colourMap.data.shorts);\n\t\t\tscreen->colourMap.data.shorts = NULL;\n\t\t}\n\t\tif (color) {\n\t\t\tfree(color);\n\t\t\tcolor = NULL;\n\t\t}\n\t\tif (prev) {\n\t\t\tfree(prev);\n\t\t\tprev = NULL;\n\t\t}\n\t}\n\n\tif (init) {\n\t\tif (depth > 16) {\n\t\t\tncolor = NCOLOR;\n\t\t} else if (depth > 8) {\n\t\t\tncolor = 1 << depth;\n\t\t} else {\n\t\t\tncolor = NCOLOR;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->colourMap.count = ncolor;\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->colourMap.is16 = TRUE;\n\t\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\t\tmalloc(3*sizeof(unsigned short) * ncolor);\n\t}\n\tif (color == NULL) {\n\t\tcolor = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t\tprev  = (XColor *) calloc(ncolor * sizeof(XColor), 1);\n\t}\n\n\tfor (i=0; i < ncolor; i++) {\n\t\tprev[i].red   = color[i].red;\n\t\tprev[i].green = color[i].green;\n\t\tprev[i].blue  = color[i].blue;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tX_LOCK;\n\n\tcmap = DefaultColormap(dpy, scr);\n\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\tvis = default_visual;\n\n\tif (subwin) {\n\t\tXWindowAttributes attr;\n\n\t\tif (XGetWindowAttributes(dpy, window, &attr)) {\n\t\t\tcmap = attr.colormap;\n\t\t\tvis = attr.visual;\n\t\t\tncells = vis->map_entries;\n\t\t}\n\t}\n\n\tif (ncells != ncolor) {\n\t\tif (! shift_cmap) {\n\t\t\tscreen->colourMap.count = ncells;\n\t\t}\n\t}\n\tif (init && ! quiet) {\n\t\trfbLog(\"set_colormap: number of cells: %d, \"\n\t\t    \"ncolor(%d) is %d.\\n\", ncells, depth, ncolor);\n\t}\n\n\tif (flash_cmap && ! init) {\n\t\tXWindowAttributes attr;\n\t\tWindow c;\n\t\tint tries = 0;\n\n\t\tc = window;\n\t\twhile (c && tries++ < 16) {\n\t\t\tc = query_pointer(c);\n\t\t\tif (valid_window(c, &attr, 0)) {\n\t\t\t\tif (attr.colormap && attr.map_installed) {\n\t\t\t\t\tcmap = attr.colormap;\n\t\t\t\t\tvis = attr.visual;\n\t\t\t\t\tncells = vis->map_entries;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncells > ncolor && ! quiet) {\n\t\trfbLog(\"set_colormap: big problem: ncells=%d > %d\\n\",\n\t\t    ncells, ncolor);\n\t}\n\n\tif (vis->class == TrueColor || vis->class == DirectColor) {\n\t\t/*\n\t\t * Kludge to make 8bpp TrueColor & DirectColor be like\n\t\t * the StaticColor map.  The ncells = 8 is \"8 per subfield\"\n\t\t * mentioned in xdpyinfo.  Looks OK... perhaps fortuitously.\n\t\t */\n\t\tif (ncells == 8 && ! shift_cmap) {\n\t\t\tncells = ncolor;\n\t\t}\n\t}\n\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[i].pixel = i;\n\t\tcolor[i].pad = 0;\n\t}\n\n\tXQueryColors(dpy, cmap, color, ncells);\n\n\tX_UNLOCK;\n\n\tfor(i = ncells - 1; i >= 0; i--) {\n\t\tint k = i + shift_cmap;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = color[i].red;\n\t\tscreen->colourMap.data.shorts[i*3+1] = color[i].green;\n\t\tscreen->colourMap.data.shorts[i*3+2] = color[i].blue;\n\n\t\tif (prev[i].red   != color[i].red ||\n\t\t    prev[i].green != color[i].green || \n\t\t    prev[i].blue  != color[i].blue ) {\n\t\t\tdiffs++;\n\t\t}\n\n\t\tif (shift_cmap && k >= 0 && k < ncolor) {\n\t\t\t/* kludge to copy the colors to higher pixel values */\n\t\t\tscreen->colourMap.data.shorts[k*3+0] = color[i].red;\n\t\t\tscreen->colourMap.data.shorts[k*3+1] = color[i].green;\n\t\t\tscreen->colourMap.data.shorts[k*3+2] = color[i].blue;\n\t\t}\n\t}\n\n\tif (diffs && ! init) {\n\t\tif (! all_clients_initialized()) {\n\t\t\trfbLog(\"set_colormap: warning: sending cmap \"\n\t\t\t    \"with uninitialized clients.\\n\");\n\t\t}\n\t\tif (shift_cmap) {\n\t\t\trfbSetClientColourMaps(screen, 0, ncolor);\n\t\t} else {\n\t\t\trfbSetClientColourMaps(screen, 0, ncells);\n\t\t}\n\t}\n\n\tinit = 0;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "unset_colormap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "189-199",
    "snippet": "void unset_colormap(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\tscreen->serverFormat.trueColour = TRUE;\nif (0) fprintf(stderr, \"unset_colormap: %s\\n\", raw_fb_pixfmt);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unset_colormap(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unset_colormap: %s\\n\"",
            "raw_fb_pixfmt"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "screen->colourMap.data.shorts"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid unset_colormap(void);\n\nvoid unset_colormap(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\tscreen->serverFormat.trueColour = TRUE;\nif (0) fprintf(stderr, \"unset_colormap: %s\\n\", raw_fb_pixfmt);\n}"
  },
  {
    "function_name": "set_hi240_colormap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "155-186",
    "snippet": "void set_hi240_colormap(void) {\n\tint i;\n\tif (! screen) {\n\t\treturn;\n\t}\n\t/* mutex */\nif (0) fprintf(stderr, \"set_hi240_colormap: %s\\n\", raw_fb_pixfmt);\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\n\tscreen->colourMap.count = 256;\n\tscreen->serverFormat.trueColour = FALSE;\n\tscreen->colourMap.is16 = TRUE;\n\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\tcalloc(3*sizeof(unsigned short) * 256, 1);\n\n\tfor(i = 0; i < 225; i++) {\n\t\tint r, g, b;\n\n\t\tr = ( (i/5) % 5 ) * 255.0 / 4 + 0.5;\n\t\tg = ( (i/25)    ) * 255.0 / 8 + 0.5;\n\t\tb = ( i % 5     ) * 255.0 / 4 + 0.5;\n\n\t\tscreen->colourMap.data.shorts[(i+16)*3+0] = (unsigned short) (r * 256);\n\t\tscreen->colourMap.data.shorts[(i+16)*3+1] = (unsigned short) (g * 256);\n\t\tscreen->colourMap.data.shorts[(i+16)*3+2] = (unsigned short) (b * 256);\n\t}\n\n\trfbSetClientColourMaps(screen, 0, 256);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_hi240_colormap(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSetClientColourMaps",
          "args": [
            "screen",
            "0",
            "256"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "3*sizeof(unsigned short) * 256",
            "1"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "screen->colourMap.data.shorts"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set_hi240_colormap: %s\\n\"",
            "raw_fb_pixfmt"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid set_hi240_colormap(void);\n\nvoid set_hi240_colormap(void) {\n\tint i;\n\tif (! screen) {\n\t\treturn;\n\t}\n\t/* mutex */\nif (0) fprintf(stderr, \"set_hi240_colormap: %s\\n\", raw_fb_pixfmt);\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\n\tscreen->colourMap.count = 256;\n\tscreen->serverFormat.trueColour = FALSE;\n\tscreen->colourMap.is16 = TRUE;\n\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\tcalloc(3*sizeof(unsigned short) * 256, 1);\n\n\tfor(i = 0; i < 225; i++) {\n\t\tint r, g, b;\n\n\t\tr = ( (i/5) % 5 ) * 255.0 / 4 + 0.5;\n\t\tg = ( (i/25)    ) * 255.0 / 8 + 0.5;\n\t\tb = ( i % 5     ) * 255.0 / 4 + 0.5;\n\n\t\tscreen->colourMap.data.shorts[(i+16)*3+0] = (unsigned short) (r * 256);\n\t\tscreen->colourMap.data.shorts[(i+16)*3+1] = (unsigned short) (g * 256);\n\t\tscreen->colourMap.data.shorts[(i+16)*3+2] = (unsigned short) (b * 256);\n\t}\n\n\trfbSetClientColourMaps(screen, 0, 256);\n}"
  },
  {
    "function_name": "set_greyscale_colormap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
    "lines": "125-152",
    "snippet": "void set_greyscale_colormap(void) {\n\tint i;\n\tif (! screen) {\n\t\treturn;\n\t}\n\t/* mutex */\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\nif (0) fprintf(stderr, \"set_greyscale_colormap: %s\\n\", raw_fb_pixfmt);\n\tscreen->colourMap.count = NCOLOR;\n\tscreen->serverFormat.trueColour = FALSE;\n\tscreen->colourMap.is16 = TRUE;\n\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\tmalloc(3*sizeof(unsigned short) * NCOLOR);\n\n\tfor(i = 0; i < NCOLOR; i++) {\n\t\tunsigned short lvl = i * 256;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = lvl;\n\t\tscreen->colourMap.data.shorts[i*3+1] = lvl;\n\t\tscreen->colourMap.data.shorts[i*3+2] = lvl;\n\t}\n\n\trfbSetClientColourMaps(screen, 0, NCOLOR);\n}",
    "includes": [
      "#include <rfb/rfbclient.h>",
      "#include \"xi2_devices.h\"",
      "#include \"pm.h\"",
      "#include \"xrecord.h\"",
      "#include \"xrandr.h\"",
      "#include \"inet.h\"",
      "#include \"solid.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"linuxfb.h\"",
      "#include \"v4l.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"rates.h\"",
      "#include \"user.h\"",
      "#include \"scan.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xdamage.h\"",
      "#include \"xinerama.h\"",
      "#include \"xwrappers.h\"",
      "#include \"xevents.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NCOLOR 256"
    ],
    "globals_used": [
      "void set_greyscale_colormap(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSetClientColourMaps",
          "args": [
            "screen",
            "0",
            "NCOLOR"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*sizeof(unsigned short) * NCOLOR"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set_greyscale_colormap: %s\\n\"",
            "raw_fb_pixfmt"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "screen->colourMap.data.shorts"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nvoid set_greyscale_colormap(void);\n\nvoid set_greyscale_colormap(void) {\n\tint i;\n\tif (! screen) {\n\t\treturn;\n\t}\n\t/* mutex */\n\tif (screen->colourMap.data.shorts) {\n\t\tfree(screen->colourMap.data.shorts);\n\t\tscreen->colourMap.data.shorts = NULL;\n\t}\n\nif (0) fprintf(stderr, \"set_greyscale_colormap: %s\\n\", raw_fb_pixfmt);\n\tscreen->colourMap.count = NCOLOR;\n\tscreen->serverFormat.trueColour = FALSE;\n\tscreen->colourMap.is16 = TRUE;\n\tscreen->colourMap.data.shorts = (unsigned short *)\n\t\tmalloc(3*sizeof(unsigned short) * NCOLOR);\n\n\tfor(i = 0; i < NCOLOR; i++) {\n\t\tunsigned short lvl = i * 256;\n\n\t\tscreen->colourMap.data.shorts[i*3+0] = lvl;\n\t\tscreen->colourMap.data.shorts[i*3+1] = lvl;\n\t\tscreen->colourMap.data.shorts[i*3+2] = lvl;\n\t}\n\n\trfbSetClientColourMaps(screen, 0, NCOLOR);\n}"
  }
]