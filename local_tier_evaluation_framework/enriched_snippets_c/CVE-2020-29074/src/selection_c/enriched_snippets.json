[
  {
    "function_name": "resend_selection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
    "lines": "510-546",
    "snippet": "void resend_selection(char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!type) {}\n\treturn;\n#else\n\tchar *selection_str = \"\";\n\tint len = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(type, \"cutbuffer\")) {\n\t\tselection_str = cutbuffer_str;\n\t\tlen = cutbuffer_len;\n\t} else if (!strcmp(type, \"clipboard\")) {\n\t\tselection_str = clipboard_str;\n\t\tlen = clipboard_len;\n\t} else if (!strcmp(type, \"primary\")) {\n\t\tselection_str = primary_str;\n\t\tlen = primary_len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void selection_request(XEvent *ev, char *type);",
      "int check_sel_direction(char *dir, char *label, char *sel, int len);",
      "void resend_selection(char *type);",
      "static char cutbuffer_str[PROP_MAX+1];",
      "static char primary_str[PROP_MAX+1];",
      "static char clipboard_str[PROP_MAX+1];",
      "static int cutbuffer_len = 0;",
      "static int primary_len   = 0;",
      "static int clipboard_len = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "selection_str",
            "len"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sel_direction",
          "args": [
            "\"send\"",
            "\"selection_send\"",
            "selection_str",
            "len"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "check_sel_direction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "259-290",
          "snippet": "int check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_sel_direction(char *dir, char *label, char *sel, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_sel_direction(char *dir, char *label, char *sel, int len);\n\nint check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"primary\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"clipboard\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"cutbuffer\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send: no send: uninitialized clients\\n\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid selection_request(XEvent *ev, char *type);\nint check_sel_direction(char *dir, char *label, char *sel, int len);\nvoid resend_selection(char *type);\nstatic char cutbuffer_str[PROP_MAX+1];\nstatic char primary_str[PROP_MAX+1];\nstatic char clipboard_str[PROP_MAX+1];\nstatic int cutbuffer_len = 0;\nstatic int primary_len   = 0;\nstatic int clipboard_len = 0;\n\nvoid resend_selection(char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!type) {}\n\treturn;\n#else\n\tchar *selection_str = \"\";\n\tint len = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(type, \"cutbuffer\")) {\n\t\tselection_str = cutbuffer_str;\n\t\tlen = cutbuffer_len;\n\t} else if (!strcmp(type, \"clipboard\")) {\n\t\tselection_str = clipboard_str;\n\t\tlen = clipboard_len;\n\t} else if (!strcmp(type, \"primary\")) {\n\t\tselection_str = primary_str;\n\t\tlen = primary_len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "selection_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
    "lines": "374-508",
    "snippet": "void selection_send(XEvent *ev) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, oldlen, newlen, toobig = 0, len;\n\tstatic int err = 0, sent_one = 0;\n\tchar before[CHKSZ], after[CHKSZ];\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar *selection_str;\n\n\tRAWFB_RET_VOID\n\t/*\n\t * remember info about our last value of PRIMARY (or CUT_BUFFER0)\n\t * so we can check for any changes below.\n\t */\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tif (! watch_primary) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = primary_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event PRIMARY   prop: %d  requestor: 0x%x  atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tif (! watch_clipboard) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = clipboard_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event CLIPBOARD prop: %d  requestor: 0x%x atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t\n\toldlen = strlen(selection_str);\n\tstrncpy(before, selection_str, CHKSZ);\n\n\tselection_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read in the current value of PRIMARY or CLIPBOARD: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, ev->xselection.requestor,\n\t\t    ev->xselection.property, nitems/4, PROP_MAX/16, True,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\ttoobig = 1;\n\t\t\t\tXFree_wr(data);\n\t\t\t\tif (err) {\t/* cut down on messages */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\terr = 5;\n\t\t\t\t}\n\t\t\t\trfbLog(\"warning: truncating large PRIMARY\"\n\t\t\t\t    \"/CLIPBOARD selection > %d bytes.\\n\",\n\t\t\t\t    PROP_MAX);\n\t\t\t\tbreak;\n\t\t\t}\nif (debug_sel) fprintf(stderr, \"selection_send: data: '%s' dlen: %d nitems: %lu ba: %lu\\n\", data, dlen, nitems, bytes_after);\n\t\t\tmemcpy(selection_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tselection_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tif (! toobig) {\n\t\terr = 0;\n\t} else if (err) {\n\t\terr--;\n\t}\n\n\tif (! sent_one) {\n\t\t/* try to force a send first time in */\n\t\toldlen = -1;\n\t\tsent_one = 1;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"selection_send:  %s '%s'\\n\",\n\t\t    ev->xselection.selection == XA_PRIMARY ? \"PRIMARY  \" : \"CLIPBOARD\",\n\t\t    selection_str);\n\t}\n\n\t/* look for changes in the new value */\n\tnewlen = strlen(selection_str);\n\tstrncpy(after, selection_str, CHKSZ);\n\n\tif (oldlen == newlen && strncmp(before, after, CHKSZ) == 0) {\n\t\t/* evidently no change */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send:  no change.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tif (newlen == 0) {\n\t\t/* do not bother sending a null string out */\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tlen = newlen;\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tprimary_len = len;\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tclipboard_len = len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHKSZ 32"
    ],
    "globals_used": [
      "Atom clipboard_atom = None;",
      "void selection_request(XEvent *ev, char *type);",
      "int check_sel_direction(char *dir, char *label, char *sel, int len);",
      "void selection_send(XEvent *ev);",
      "void resend_selection(char *type);",
      "static char primary_str[PROP_MAX+1];",
      "static char clipboard_str[PROP_MAX+1];",
      "static int primary_len   = 0;",
      "static int clipboard_len = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "selection_str",
            "len"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sel_direction",
          "args": [
            "\"send\"",
            "\"selection_send\"",
            "selection_str",
            "len"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "check_sel_direction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "259-290",
          "snippet": "int check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_sel_direction(char *dir, char *label, char *sel, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_sel_direction(char *dir, char *label, char *sel, int len);\n\nint check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send: no send: uninitialized clients\\n\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send:  no change.\\n\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "before",
            "after",
            "CHKSZ"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "after",
            "selection_str",
            "CHKSZ"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "selection_str"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send:  %s '%s'\\n\"",
            "ev->xselection.selection == XA_PRIMARY ? \"PRIMARY  \" : \"CLIPBOARD\"",
            "selection_str"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "selection_str+slen",
            "data",
            "dlen"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"selection_send: data: '%s' dlen: %d nitems: %lu ba: %lu\\n\"",
            "data",
            "dlen",
            "nitems",
            "bytes_after"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: truncating large PRIMARY\"\n\t\t\t\t    \"/CLIPBOARD selection > %d bytes.\\n\"",
            "PROP_MAX"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "ev->xselection.requestor",
            "ev->xselection.property",
            "nitems/4",
            "PROP_MAX/16",
            "True",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "before",
            "selection_str",
            "CHKSZ"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "selection_str"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send: event CLIPBOARD prop: %d  requestor: 0x%x atom: %d\\n\"",
            "ev->xselection.property",
            "ev->xselection.requestor",
            "ev->xselection.selection"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_send: event PRIMARY   prop: %d  requestor: 0x%x  atom: %d\\n\"",
            "ev->xselection.property",
            "ev->xselection.requestor",
            "ev->xselection.selection"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHKSZ 32\n\nAtom clipboard_atom = None;\nvoid selection_request(XEvent *ev, char *type);\nint check_sel_direction(char *dir, char *label, char *sel, int len);\nvoid selection_send(XEvent *ev);\nvoid resend_selection(char *type);\nstatic char primary_str[PROP_MAX+1];\nstatic char clipboard_str[PROP_MAX+1];\nstatic int primary_len   = 0;\nstatic int clipboard_len = 0;\n\nvoid selection_send(XEvent *ev) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, oldlen, newlen, toobig = 0, len;\n\tstatic int err = 0, sent_one = 0;\n\tchar before[CHKSZ], after[CHKSZ];\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar *selection_str;\n\n\tRAWFB_RET_VOID\n\t/*\n\t * remember info about our last value of PRIMARY (or CUT_BUFFER0)\n\t * so we can check for any changes below.\n\t */\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tif (! watch_primary) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = primary_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event PRIMARY   prop: %d  requestor: 0x%x  atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tif (! watch_clipboard) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = clipboard_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event CLIPBOARD prop: %d  requestor: 0x%x atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t\n\toldlen = strlen(selection_str);\n\tstrncpy(before, selection_str, CHKSZ);\n\n\tselection_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read in the current value of PRIMARY or CLIPBOARD: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, ev->xselection.requestor,\n\t\t    ev->xselection.property, nitems/4, PROP_MAX/16, True,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\ttoobig = 1;\n\t\t\t\tXFree_wr(data);\n\t\t\t\tif (err) {\t/* cut down on messages */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\terr = 5;\n\t\t\t\t}\n\t\t\t\trfbLog(\"warning: truncating large PRIMARY\"\n\t\t\t\t    \"/CLIPBOARD selection > %d bytes.\\n\",\n\t\t\t\t    PROP_MAX);\n\t\t\t\tbreak;\n\t\t\t}\nif (debug_sel) fprintf(stderr, \"selection_send: data: '%s' dlen: %d nitems: %lu ba: %lu\\n\", data, dlen, nitems, bytes_after);\n\t\t\tmemcpy(selection_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tselection_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tif (! toobig) {\n\t\terr = 0;\n\t} else if (err) {\n\t\terr--;\n\t}\n\n\tif (! sent_one) {\n\t\t/* try to force a send first time in */\n\t\toldlen = -1;\n\t\tsent_one = 1;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"selection_send:  %s '%s'\\n\",\n\t\t    ev->xselection.selection == XA_PRIMARY ? \"PRIMARY  \" : \"CLIPBOARD\",\n\t\t    selection_str);\n\t}\n\n\t/* look for changes in the new value */\n\tnewlen = strlen(selection_str);\n\tstrncpy(after, selection_str, CHKSZ);\n\n\tif (oldlen == newlen && strncmp(before, after, CHKSZ) == 0) {\n\t\t/* evidently no change */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send:  no change.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tif (newlen == 0) {\n\t\t/* do not bother sending a null string out */\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tlen = newlen;\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tprimary_len = len;\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tclipboard_len = len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "cutbuffer_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
    "lines": "298-358",
    "snippet": "void cutbuffer_send(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, len;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\n\tcutbuffer_str[0] = '\\0';\n\tslen = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* read the property value into cutbuffer_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    XA_CUT_BUFFER0, nitems/4, PROP_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large CUT_BUFFER0\"\n\t\t\t\t   \" selection > %d bytes.\\n\", PROP_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(cutbuffer_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tcutbuffer_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tcutbuffer_str[PROP_MAX] = '\\0';\n\n\tif (debug_sel) {\n\t\trfbLog(\"cutbuffer_send: '%s'\\n\", cutbuffer_str);\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"cutbuffer_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\tcutbuffer_len = len = strlen(cutbuffer_str);\n\tif (check_sel_direction(\"send\", \"cutbuffer_send\", cutbuffer_str, len)) {\n\t\trfbSendServerCutText(screen, cutbuffer_str, len);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void selection_request(XEvent *ev, char *type);",
      "int check_sel_direction(char *dir, char *label, char *sel, int len);",
      "void cutbuffer_send(void);",
      "void resend_selection(char *type);",
      "static char cutbuffer_str[PROP_MAX+1];",
      "static int cutbuffer_len = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "cutbuffer_str",
            "len"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sel_direction",
          "args": [
            "\"send\"",
            "\"cutbuffer_send\"",
            "cutbuffer_str",
            "len"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "check_sel_direction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "259-290",
          "snippet": "int check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_sel_direction(char *dir, char *label, char *sel, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_sel_direction(char *dir, char *label, char *sel, int len);\n\nint check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cutbuffer_str"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cutbuffer_send: no send: uninitialized clients\\n\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cutbuffer_send: '%s'\\n\"",
            "cutbuffer_str"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cutbuffer_str+slen",
            "data",
            "dlen"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: truncating large CUT_BUFFER0\"\n\t\t\t\t   \" selection > %d bytes.\\n\"",
            "PROP_MAX"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "DefaultRootWindow(dpy)",
            "XA_CUT_BUFFER0",
            "nitems/4",
            "PROP_MAX/16",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid selection_request(XEvent *ev, char *type);\nint check_sel_direction(char *dir, char *label, char *sel, int len);\nvoid cutbuffer_send(void);\nvoid resend_selection(char *type);\nstatic char cutbuffer_str[PROP_MAX+1];\nstatic int cutbuffer_len = 0;\n\nvoid cutbuffer_send(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, len;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\n\tcutbuffer_str[0] = '\\0';\n\tslen = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* read the property value into cutbuffer_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    XA_CUT_BUFFER0, nitems/4, PROP_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large CUT_BUFFER0\"\n\t\t\t\t   \" selection > %d bytes.\\n\", PROP_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(cutbuffer_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tcutbuffer_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tcutbuffer_str[PROP_MAX] = '\\0';\n\n\tif (debug_sel) {\n\t\trfbLog(\"cutbuffer_send: '%s'\\n\", cutbuffer_str);\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"cutbuffer_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\tcutbuffer_len = len = strlen(cutbuffer_str);\n\tif (check_sel_direction(\"send\", \"cutbuffer_send\", cutbuffer_str, len)) {\n\t\trfbSendServerCutText(screen, cutbuffer_str, len);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "check_sel_direction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
    "lines": "259-290",
    "snippet": "int check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_sel_direction(char *dir, char *label, char *sel, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s: NOT %s-ing it.\\n\"",
            "label",
            "dir"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s: %s-ing it.\\n\"",
            "label",
            "dir"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s: '%s'\\n\"",
            "label",
            "str"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "str",
            "sel",
            "n"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "sel_direction",
            "dir"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sel_direction",
            "\"debug\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "sel_direction",
            "\"debug\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_sel_direction(char *dir, char *label, char *sel, int len);\n\nint check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}"
  },
  {
    "function_name": "selection_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
    "lines": "90-257",
    "snippet": "void selection_request(XEvent *ev, char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev || !type) {}\n\treturn;\n#else\n\tXSelectionEvent notify_event;\n\tXSelectionRequestEvent *req_event;\n\tXErrorHandler old_handler;\n\tchar *str;\n\tunsigned int length;\n\tunsigned char *data;\n\tstatic Atom xa_targets = None;\n\tstatic int sync_it = -1;\n# ifndef XA_LENGTH\n\tunsigned long XA_LENGTH;\n# endif\n\tRAWFB_RET_VOID\n\n# ifndef XA_LENGTH\n\tXA_LENGTH = XInternAtom(dpy, \"LENGTH\", True);\n# endif\n\n\tif (sync_it < 0) {\n\t\tif (getenv(\"X11VNC_SENDEVENT_SYNC\")) {\n\t\t\tsync_it = 1;\n\t\t} else {\n\t\t\tsync_it = 0;\n\t\t}\n\t}\n\n\treq_event = &(ev->xselectionrequest);\n\tnotify_event.type \t= SelectionNotify;\n\tnotify_event.display\t= req_event->display;\n\tnotify_event.requestor\t= req_event->requestor;\n\tnotify_event.selection\t= req_event->selection;\n\tnotify_event.target\t= req_event->target;\n\tnotify_event.time\t= req_event->time;\n\n\tif (req_event->property == None) {\n\t\tnotify_event.property = req_event->target;\n\t} else {\n\t\tnotify_event.property = req_event->property;\n\t}\n\n\tif (!strcmp(type, \"PRIMARY\")) {\n\t\tstr = xcut_str_primary;\n\t} else if (!strcmp(type, \"CLIPBOARD\")) {\n\t\tstr = xcut_str_clipboard;\n\t} else {\n\t\treturn;\n\t}\n\tif (str) {\n\t\tlength = strlen(str);\n\t} else {\n\t\tlength = 0;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"%s\\trequest event:   owner=0x%x requestor=0x%x sel=%03d targ=%d prop=%d\\n\",\n\t\t\ttype, req_event->owner, req_event->requestor, req_event->selection,\n\t\t\treq_event->target, req_event->property);\n\t}\n\n\tif (xa_targets == None) {\n\t\txa_targets = XInternAtom(dpy, \"TARGETS\", False);\n\t}\n\n\t/* the window may have gone away, so trap errors */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (ev->xselectionrequest.target == XA_LENGTH) {\n\t\t/* length request */\n\t\tint ret;\n\t\tlong llength = (long) length;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) &llength, 1);\t/* had sizeof(unsigned int) = 4 before... */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"LENGTH: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\n\t} else if (xa_targets != None && ev->xselectionrequest.target == xa_targets) {\n\t\t/* targets request */\n\t\tint ret;\n\t\tAtom targets[2];\n\t\ttargets[0] = (Atom) xa_targets;\n\t\ttargets[1] = (Atom) XA_STRING;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) targets, 2);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"TARGETS: XChangeProperty() -> %d -- sz1: %d  sz2: %d\\n\",\n\t\t\t    ret, sizeof(targets[0]), sizeof(targets)/sizeof(targets[0]));\n\t\t}\n\n\t} else {\n\t\t/* data request */\n\t\tint ret;\n\n\t\tdata = (unsigned char *)str;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 8, PropModeReplace,\n\t\t    data, length);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"DATA: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (! trapped_xerror) {\n\t\tint ret = -2, skip_it = 0, ms = 0;\n\t\tdouble now = dnow();\n\t\tstatic double last_check = 0.0;\n\n\t\tif (now > last_check + 0.2) {\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (!valid_window(req_event->requestor , NULL, 1)) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"selection_request: not a valid window: 0x%x\\n\",\n\t\t\t\t\t    req_event->requestor);\n\t\t\t\t}\n\t\t\t\tms = 10;\n\t\t\t}\n\t\t\tif (trapped_xerror) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t}\n\t\t\tlast_check = dnow();\n\t\t}\n\n\t\tif (!skip_it) {\n\t\t\tret = XSendEvent(req_event->display, req_event->requestor, False, 0,\n\t\t\t    (XEvent *)&notify_event);\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"XSendEvent() -> %d\\n\", ret);\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tusleep(ms * 1000);\n\t\t}\n\t}\n\tif (trapped_xerror) {\n\t\trfbLog(\"selection_request: ignored XError while sending \"\n\t\t    \"%s selection to 0x%x.\\n\", type, req_event->requestor);\n\t}\n\n\tXFlush_wr(dpy);\n\tif (sync_it) {\n\t\tusleep(10 * 1000);\n\t\tXSync(dpy, False);\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *xcut_str_primary = NULL;",
      "char *xcut_str_clipboard = NULL;",
      "void selection_request(XEvent *ev, char *type);",
      "void selection_send(XEvent *ev);",
      "void resend_selection(char *type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_request: ignored XError while sending \"\n\t\t    \"%s selection to 0x%x.\\n\"",
            "type",
            "req_event->requestor"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XSendEvent() -> %d\\n\"",
            "ret"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSendEvent",
          "args": [
            "req_event->display",
            "req_event->requestor",
            "False",
            "0",
            "(XEvent *)&notify_event"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"selection_request: not a valid window: 0x%x\\n\"",
            "req_event->requestor"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "req_event->requestor",
            "NULL",
            "1"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"DATA: XChangeProperty() -> %d\\n\"",
            "ret"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "ev->xselectionrequest.display",
            "ev->xselectionrequest.requestor",
            "ev->xselectionrequest.property",
            "ev->xselectionrequest.target",
            "8",
            "PropModeReplace",
            "data",
            "length"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TARGETS: XChangeProperty() -> %d -- sz1: %d  sz2: %d\\n\"",
            "ret",
            "sizeof(targets[0])",
            "sizeof(targets)/sizeof(targets[0])"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "ev->xselectionrequest.display",
            "ev->xselectionrequest.requestor",
            "ev->xselectionrequest.property",
            "ev->xselectionrequest.target",
            "32",
            "PropModeReplace",
            "(unsigned char *) targets",
            "2"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"LENGTH: XChangeProperty() -> %d\\n\"",
            "ret"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "ev->xselectionrequest.display",
            "ev->xselectionrequest.requestor",
            "ev->xselectionrequest.property",
            "ev->xselectionrequest.target",
            "32",
            "PropModeReplace",
            "(unsigned char *) &llength",
            "1"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"TARGETS\"",
            "False"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s\\trequest event:   owner=0x%x requestor=0x%x sel=%03d targ=%d prop=%d\\n\"",
            "type",
            "req_event->owner",
            "req_event->requestor",
            "req_event->selection",
            "req_event->target",
            "req_event->property"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"CLIPBOARD\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"PRIMARY\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SENDEVENT_SYNC\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"LENGTH\"",
            "True"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *xcut_str_primary = NULL;\nchar *xcut_str_clipboard = NULL;\nvoid selection_request(XEvent *ev, char *type);\nvoid selection_send(XEvent *ev);\nvoid resend_selection(char *type);\n\nvoid selection_request(XEvent *ev, char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev || !type) {}\n\treturn;\n#else\n\tXSelectionEvent notify_event;\n\tXSelectionRequestEvent *req_event;\n\tXErrorHandler old_handler;\n\tchar *str;\n\tunsigned int length;\n\tunsigned char *data;\n\tstatic Atom xa_targets = None;\n\tstatic int sync_it = -1;\n# ifndef XA_LENGTH\n\tunsigned long XA_LENGTH;\n# endif\n\tRAWFB_RET_VOID\n\n# ifndef XA_LENGTH\n\tXA_LENGTH = XInternAtom(dpy, \"LENGTH\", True);\n# endif\n\n\tif (sync_it < 0) {\n\t\tif (getenv(\"X11VNC_SENDEVENT_SYNC\")) {\n\t\t\tsync_it = 1;\n\t\t} else {\n\t\t\tsync_it = 0;\n\t\t}\n\t}\n\n\treq_event = &(ev->xselectionrequest);\n\tnotify_event.type \t= SelectionNotify;\n\tnotify_event.display\t= req_event->display;\n\tnotify_event.requestor\t= req_event->requestor;\n\tnotify_event.selection\t= req_event->selection;\n\tnotify_event.target\t= req_event->target;\n\tnotify_event.time\t= req_event->time;\n\n\tif (req_event->property == None) {\n\t\tnotify_event.property = req_event->target;\n\t} else {\n\t\tnotify_event.property = req_event->property;\n\t}\n\n\tif (!strcmp(type, \"PRIMARY\")) {\n\t\tstr = xcut_str_primary;\n\t} else if (!strcmp(type, \"CLIPBOARD\")) {\n\t\tstr = xcut_str_clipboard;\n\t} else {\n\t\treturn;\n\t}\n\tif (str) {\n\t\tlength = strlen(str);\n\t} else {\n\t\tlength = 0;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"%s\\trequest event:   owner=0x%x requestor=0x%x sel=%03d targ=%d prop=%d\\n\",\n\t\t\ttype, req_event->owner, req_event->requestor, req_event->selection,\n\t\t\treq_event->target, req_event->property);\n\t}\n\n\tif (xa_targets == None) {\n\t\txa_targets = XInternAtom(dpy, \"TARGETS\", False);\n\t}\n\n\t/* the window may have gone away, so trap errors */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (ev->xselectionrequest.target == XA_LENGTH) {\n\t\t/* length request */\n\t\tint ret;\n\t\tlong llength = (long) length;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) &llength, 1);\t/* had sizeof(unsigned int) = 4 before... */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"LENGTH: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\n\t} else if (xa_targets != None && ev->xselectionrequest.target == xa_targets) {\n\t\t/* targets request */\n\t\tint ret;\n\t\tAtom targets[2];\n\t\ttargets[0] = (Atom) xa_targets;\n\t\ttargets[1] = (Atom) XA_STRING;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) targets, 2);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"TARGETS: XChangeProperty() -> %d -- sz1: %d  sz2: %d\\n\",\n\t\t\t    ret, sizeof(targets[0]), sizeof(targets)/sizeof(targets[0]));\n\t\t}\n\n\t} else {\n\t\t/* data request */\n\t\tint ret;\n\n\t\tdata = (unsigned char *)str;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 8, PropModeReplace,\n\t\t    data, length);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"DATA: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (! trapped_xerror) {\n\t\tint ret = -2, skip_it = 0, ms = 0;\n\t\tdouble now = dnow();\n\t\tstatic double last_check = 0.0;\n\n\t\tif (now > last_check + 0.2) {\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (!valid_window(req_event->requestor , NULL, 1)) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"selection_request: not a valid window: 0x%x\\n\",\n\t\t\t\t\t    req_event->requestor);\n\t\t\t\t}\n\t\t\t\tms = 10;\n\t\t\t}\n\t\t\tif (trapped_xerror) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t}\n\t\t\tlast_check = dnow();\n\t\t}\n\n\t\tif (!skip_it) {\n\t\t\tret = XSendEvent(req_event->display, req_event->requestor, False, 0,\n\t\t\t    (XEvent *)&notify_event);\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"XSendEvent() -> %d\\n\", ret);\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tusleep(ms * 1000);\n\t\t}\n\t}\n\tif (trapped_xerror) {\n\t\trfbLog(\"selection_request: ignored XError while sending \"\n\t\t    \"%s selection to 0x%x.\\n\", type, req_event->requestor);\n\t}\n\n\tXFlush_wr(dpy);\n\tif (sync_it) {\n\t\tusleep(10 * 1000);\n\t\tXSync(dpy, False);\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n#endif\t/* NO_X11 */\n}"
  }
]