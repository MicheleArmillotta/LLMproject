[
  {
    "function_name": "xrecord_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1664-2082",
    "snippet": "void xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NAMEINFO 2048"
    ],
    "globals_used": [
      "int xrecording = 0;",
      "int xrecord_set_by_keys = 0;",
      "int xrecord_set_by_mouse = 0;",
      "Window xrecord_focus_window = None;",
      "Window xrecord_wm_window = None;",
      "Window xrecord_ptr_window = None;",
      "KeySym xrecord_keysym = NoSymbol;",
      "char xrecord_name_info[NAMEINFO];",
      "Display *rdpy_data = NULL;",
      "Display *rdpy_ctrl = NULL;",
      "Display *gdpy_ctrl = NULL;",
      "int xserver_grabbed = 0;",
      "void xrecord_watch(int start, int setby);",
      "static void xrecord_grabserver(int start);",
      "static void check_xrecord_grabserver(void);",
      "static XID xrecord_seq = 0;",
      "static double xrecord_start = 0.0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "rdpy_data"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown_record_context",
          "args": [
            "rc_scroll",
            "0",
            "reopen_dpys"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_record_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1476-1555",
          "snippet": "static void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RECORD_ERROR_MSG",
          "args": [
            "\"enable-failed\""
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\"",
            "rc_scroll",
            "rc"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordEnableContextAsync",
          "args": [
            "rdpy_data",
            "rc_scroll",
            "record_switch",
            "(XPointer) xrecord_seq"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&xrecord_start"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  switching to -noscrollcopyrect mode.\\n\""
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to create X RECORD context rc_scroll.\\n\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RECORD_ERROR_MSG",
          "args": [
            "\"register\""
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rc_scroll: 0x%lx\\n\"",
            "rc_scroll"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\"",
            "clast"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordRegisterClients",
          "args": [
            "rdpy_ctrl",
            "rc_scroll",
            "0",
            "&rcs_scroll",
            "1",
            "rr_scroll",
            "2"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"=-=   reg-scroll 0x%lx 0x%lx\\n\"",
            "rc_scroll",
            "rcs_scroll"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"=2= unreg-scroll 0x%lx 0x%lx\\n\"",
            "rc_scroll",
            "rcs_scroll"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordUnregisterClients",
          "args": [
            "rdpy_ctrl",
            "rc_scroll",
            "&rcs_scroll",
            "1"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"NEW rc:    0x%lx\\n\"",
            "rc_scroll"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "rdpy_ctrl",
            "False"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordCreateContext",
          "args": [
            "rdpy_ctrl",
            "0",
            "&rcs_scroll",
            "1",
            "rr_scroll",
            "2"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xrecord_grabserver",
          "args": [],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1445-1473",
          "snippet": "static void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"--- xrecord_watch: SKIP.\\n\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_str_list",
          "args": [
            "nm",
            "scroll_skip_mouse"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "match_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "353-370",
          "snippet": "int match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int match_str_list(char *str, char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\n\nint match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"name_info: %s\\n\"",
            "xrecord_name_info"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descend_pointer",
          "args": [
            "6",
            "c",
            "xrecord_name_info",
            "NAMEINFO"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "descend_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "480-598",
          "snippet": "Window descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_pointer",
          "args": [
            "rootwin"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "query_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "355-384",
          "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetInputFocus",
          "args": [
            "dpy",
            "&focus",
            "&i"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrecord_watch",
          "args": [
            "0",
            "SCR_NONE"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1664-2082",
          "snippet": "void xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: do_shutdown && rc_scroll\\n\""
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XRECORD ON:  %d/%d  %.4f\\n\"",
            "xrecording",
            "setby",
            "now - x11vnc_start"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RECORD_ERROR_MSG",
          "args": [
            "\"disable\""
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordProcessReplies",
          "args": [
            "rdpy_data"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordDisableContext",
          "args": [
            "rdpy_ctrl",
            "rc_scroll"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordUnregisterClients",
          "args": [
            "rdpy_ctrl",
            "rc_scroll",
            "&rcs_scroll",
            "1"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"=== disab-scroll 0x%lx 0x%lx\\n\"",
            "rc_scroll",
            "rcs_scroll"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RECORD_ERROR_MSG",
          "args": [
            "\"shutdown\""
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordProcessReplies",
          "args": [
            "rdpy_data"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"=== shutdown-scroll 0x%lx\\n\"",
            "rc_scroll"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XRECORD OFF: %d/%d  %.4f\\n\"",
            "xrecording",
            "setby",
            "now - x11vnc_start"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xrecord_watch: %d/%d  out xserver_grabbed\\n\"",
            "start",
            "setby"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\""
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"xrecord_watch: disabling scroll detection in -threads mode.\\n\""
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XRECORD_THREADS\""
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define NAMEINFO 2048\n\nint xrecording = 0;\nint xrecord_set_by_keys = 0;\nint xrecord_set_by_mouse = 0;\nWindow xrecord_focus_window = None;\nWindow xrecord_wm_window = None;\nWindow xrecord_ptr_window = None;\nKeySym xrecord_keysym = NoSymbol;\nchar xrecord_name_info[NAMEINFO];\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid xrecord_watch(int start, int setby);\nstatic void xrecord_grabserver(int start);\nstatic void check_xrecord_grabserver(void);\nstatic XID xrecord_seq = 0;\nstatic double xrecord_start = 0.0;\n\nvoid xrecord_watch(int start, int setby) {\n#if HAVE_RECORD\n\tWindow focus, wm, c, clast;\n\tstatic double create_time = 0.0;\n\tint rc;\n\tint do_shutdown = 0;\n\tint reopen_dpys = 1;\n\tXErrorHandler old_handler = NULL;\n\tstatic Window last_win = None, last_result = None;\n#endif\n\tint db = debug_scroll;\n\tdouble now;\n\tstatic double last_error = 0.0;\n\nif (0) db = 1;\n\n\tif (nofb) {\n\t\txrecording = 0;\n\t\treturn;\n\t}\n\tif (use_threads) {\n\t\t/* XXX not working.  Still?  Painting errors. */\n\t\tstatic int first = 1;\n\t\tif (first) {\n\t\t\tif (use_xrecord && !getenv(\"XRECORD_THREADS\")) {\n\t\t\t\trfbLog(\"xrecord_watch: disabling scroll detection in -threads mode.\\n\");\n\t\t\t\trfbLog(\"xrecord_watch: Set -env XRECORD_THREADS=1 to enable it.\\n\");\n\t\t\t\tuse_xrecord = 0;\n\t\t\t\txrecording = 0;\n\t\t\t}\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!use_xrecord && !xrecording) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdtime0(&now);\n\tif (now < last_error + 0.5) {\n\t\treturn;\n\t}\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t\tif (xserver_grabbed) {\nif (db || debug_grabs) fprintf(stderr, \"xrecord_watch: %d/%d  out xserver_grabbed\\n\", start, setby);\n\t\t\treturn;\n\t\t}\n\t}\n\n#if HAVE_RECORD\n\tif (! start) {\n\t\tint shut_reopen = 2, shut_time = 25;\nif (db || debug_grabs) fprintf(stderr, \"XRECORD OFF: %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\t\txrecording = 0;\n\t\tif (! rc_scroll) {\n\t\t\txrecord_focus_window = None;\n\t\t\txrecord_wm_window = None;\n\t\t\txrecord_ptr_window = None;\n\t\t\txrecord_keysym = NoSymbol;\n\t\t\trcs_scroll = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (! do_shutdown && now > create_time + shut_time) {\n\t\t\t/* XXX unstable if we keep a RECORD going forever */\n\t\t\tdo_shutdown = 1;\n\t\t}\n\n\t\tSCR_LOCK;\n\t\t\n\t\tif (do_shutdown) {\nif (db > 1) fprintf(stderr, \"=== shutdown-scroll 0x%lx\\n\", rc_scroll);\n\t\t\tX_LOCK;\n\t\t\ttrapped_record_xerror = 0;\n\t\t\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t\t\tshutdown_record_context(rc_scroll, 0, shut_reopen);\n\t\t\trc_scroll = 0;\n\n\t\t\t/*\n\t\t\t * n.b. there is a grabserver issue wrt\n\t\t\t * XRecordCreateContext() even though rdpy_ctrl\n\t\t\t * is set imprevious to grabs.  Perhaps a bug\n\t\t\t * in the X server or library...\n\t\t\t *\n\t\t\t * If there are further problems, a thought\n\t\t\t * to recreate rc_scroll right after the\n\t\t\t * reopen.\n\t\t\t */\n\n\t\t\tif (! use_xrecord) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"shutdown\");\n\t\t\t\tlast_error = now;\n\t\t\t}\n\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\tSCR_UNLOCK;\n\n\t\t} else {\n\t\t\tif (rcs_scroll) {\nif (db > 1) fprintf(stderr, \"=== disab-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\t\t\t\tX_LOCK;\n\t\t\t\ttrapped_record_xerror = 0;\n\t\t\t\told_handler =\n\t\t\t\t    XSetErrorHandler(trap_record_xerror);\n\n\t\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t\t    &rcs_scroll, 1);\n\t\t\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\t\t\tXFlush_wr(rdpy_ctrl);\n\t\t\t\tXRecordProcessReplies(rdpy_data);\n\n\t\t\t\tif (trapped_record_xerror) {\n\t\t\t\t\tRECORD_ERROR_MSG(\"disable\");\n\n\t\t\t\t\tshutdown_record_context(rc_scroll,\n\t\t\t\t\t    0, reopen_dpys);\n\t\t\t\t\trc_scroll = 0;\n\n\t\t\t\t\tlast_error = now;\n\n\t\t\t\t\tif (! use_xrecord) {\n\t\t\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tSCR_UNLOCK;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t}\n\n\t\tSCR_UNLOCK;\n\t\t/*\n\t\t * XXX if we do a XFlush_wr(rdpy_ctrl) here we get:\n\t\t *\n\n\t\tX Error of failed request:  XRecordBadContext\n\t\t  Major opcode of failed request:  145 (RECORD)\n\t\t  Minor opcode of failed request:  5 (XRecordEnableContext)\n\t\t  Context in failed request:  0x2200013\n\t\t  Serial number of failed request:  29\n\t\t  Current serial number in output stream:  29\n\n\t\t *\n\t\t * need to figure out what is going on... since it may lead\n\t\t * infrequent failures.\n\t\t */\n\t\txrecord_focus_window = None;\n\t\txrecord_wm_window = None;\n\t\txrecord_ptr_window = None;\n\t\txrecord_keysym = NoSymbol;\n\t\trcs_scroll = 0;\n\t\treturn;\n\t}\nif (db || debug_grabs) fprintf(stderr, \"XRECORD ON:  %d/%d  %.4f\\n\", xrecording, setby, now - x11vnc_start);\n\n\tif (xrecording) {\n\t\treturn;\n\t}\n\n\tif (do_shutdown && rc_scroll) {\n\t\tstatic int didmsg = 0;\n\t\t/* should not happen... */\n\t\tif (0 || !didmsg) {\n\t\t\trfbLog(\"warning: do_shutdown && rc_scroll\\n\");\n\t\t\tdidmsg = 1;\n\t\t}\n\t\txrecord_watch(0, SCR_NONE);\n\t}\n\n\txrecording = 0;\n\txrecord_focus_window = None;\n\txrecord_wm_window = None;\n\txrecord_ptr_window = None;\n\txrecord_keysym = NoSymbol;\n\txrecord_set_by_keys  = 0;\n\txrecord_set_by_mouse = 0;\n\n\t/* get the window with focus and mouse pointer: */\n\tclast = None;\n\tfocus = None;\n\twm = None;\n\n\tX_LOCK;\n\tSCR_LOCK;\n#if 0\n\t/*\n\t * xrecord_focus_window / focus not currently used... save a\n\t * round trip to the X server for now.\n\t * N.B. our heuristic is inaccurate: if he is scrolling and\n\t * drifts off of the scrollbar onto another application we\n\t * will catch that application, not the starting ones.\n\t * check_xrecord_{keys,mouse} mitigates this somewhat by\n\t * delaying calls to xrecord_watch as much as possible.\n\t */\n\tXGetInputFocus(dpy, &focus, &i);\n#endif\n\n\twm = query_pointer(rootwin);\n\tif (wm) {\n\t\tc = wm;\n\t} else {\n\t\tc = rootwin;\n\t}\n\n\t/* descend a bit to avoid wm frames: */\n\tif (c != rootwin && c == last_win) {\n\t\t/* use cached results to avoid roundtrips: */\n\t\tclast = last_result;\n\t} else if (scroll_good_all == NULL && scroll_skip_all == NULL) {\n\t\t/* more efficient if name info not needed. */\n\t\txrecord_name_info[0] = '\\0';\n\t\tclast = descend_pointer(6, c, NULL, 0);\n\t} else {\n\t\tchar *nm;\n\t\tint matched_good = 0, matched_skip = 0;\n\n\t\tclast = descend_pointer(6, c, xrecord_name_info, NAMEINFO);\nif (db) fprintf(stderr, \"name_info: %s\\n\", xrecord_name_info);\n\n\t\tnm = xrecord_name_info;\n\n\t\tif (scroll_good_all) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_good_key) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_good_mouse) {\n\t\t\tmatched_good += match_str_list(nm, scroll_good_mouse);\n\t\t}\n\t\tif (scroll_skip_all) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_all);\n\t\t}\n\t\tif (setby == SCR_KEY && scroll_skip_key) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_key);\n\t\t}\n\t\tif (setby == SCR_MOUSE && scroll_skip_mouse) {\n\t\t\tmatched_skip += match_str_list(nm, scroll_skip_mouse);\n\t\t}\n\n\t\tif (!matched_good && matched_skip) {\n\t\t\tclast = None;\n\t\t}\n\t}\n\tif (c != rootwin) {\n\t\t/* cache results for possible use next call */\n\t\tlast_win = c;\n\t\tlast_result = clast;\n\t}\n\n\tif (!clast || clast == rootwin) {\nif (db) fprintf(stderr, \"--- xrecord_watch: SKIP.\\n\");\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* set protocol request ranges: */\n\trr_scroll[0] = rr_CA;\n\trr_scroll[1] = rr_CW;\n\n\t/*\n\t * start trapping... there still are some occasional failures\n\t * not yet understood, likely some race condition WRT the \n\t * context being setup.\n\t */\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tif (! rc_scroll) {\n\t\t/* do_shutdown case or first time in */\n\n\t\tif (gdpy_ctrl) {\n\t\t\t/*\n\t\t\t * Even though rdpy_ctrl is impervious to grabs\n\t\t\t * at this point, we still get deadlock, why?\n\t\t\t * It blocks in the library find_display() call.\n\t\t\t */\n\t\t\tcheck_xrecord_grabserver();\n\t\t\tif (xserver_grabbed) {\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\tSCR_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\t\trc_scroll = XRecordCreateContext(rdpy_ctrl, 0, &rcs_scroll, 1,\n\t\t    rr_scroll, 2);\n\n\t\tif (! do_shutdown) {\n\t\t\tXSync(rdpy_ctrl, False);\n\t\t}\nif (db) fprintf(stderr, \"NEW rc:    0x%lx\\n\", rc_scroll);\n\t\tif (rc_scroll) {\n\t\t\tdtime0(&create_time);\n\t\t} else {\n\t\t\trcs_scroll = 0;\n\t\t}\n\n\t} else if (! do_shutdown) {\n\t\tif (rcs_scroll) {\n\t\t\t/*\n\t\t\t * should have been unregistered in xrecord_watch(0)...\n\t\t\t */\n\t\t\trcs_scroll = XRecordCurrentClients;\n\t\t\tXRecordUnregisterClients(rdpy_ctrl, rc_scroll,\n\t\t\t    &rcs_scroll, 1);\n\nif (db > 1) fprintf(stderr, \"=2= unreg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\t}\n\t\t\n\t\trcs_scroll = (XRecordClientSpec) clast;\n\nif (db > 1) fprintf(stderr, \"=-=   reg-scroll 0x%lx 0x%lx\\n\", rc_scroll, rcs_scroll);\n\n\t\tif (!XRecordRegisterClients(rdpy_ctrl, rc_scroll, 0,\n\t\t    &rcs_scroll, 1, rr_scroll, 2)) {\n\t\t\tif (1 || now > last_error + 60) {\n\t\t\t\trfbLog(\"failed to register client 0x%lx with\"\n\t\t\t\t    \" X RECORD context rc_scroll.\\n\", clast);\n\t\t\t}\n\t\t\tlast_error = now;\n\t\t\trcs_scroll = 0;\n\t\t\t/* continue on for now... */\n\t\t}\n\t}\n\n\tXFlush_wr(rdpy_ctrl);\n\nif (db) fprintf(stderr, \"rc_scroll: 0x%lx\\n\", rc_scroll);\n\tif (trapped_record_xerror) {\n\t\tRECORD_ERROR_MSG(\"register\");\n\t}\n\n\tif (! rc_scroll) {\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\tuse_xrecord = 0;\n\t\trfbLog(\"failed to create X RECORD context rc_scroll.\\n\");\n\t\trfbLog(\"  switching to -noscrollcopyrect mode.\\n\");\n\t\treturn;\n\t} else if (! rcs_scroll || trapped_record_xerror) {\n\t\t/* try again later */\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\n\t\tXSetErrorHandler(old_handler);\n\t\tX_UNLOCK;\n\t\tSCR_UNLOCK;\n\t\treturn;\n\t}\n\n\txrecord_focus_window = focus;\n#if 0\n\t/* xrecord_focus_window currently unused. */\n\tif (! xrecord_focus_window) {\n\t\txrecord_focus_window = clast;\n\t}\n#endif\n\txrecord_wm_window = wm;\n\tif (! xrecord_wm_window) {\n\t\txrecord_wm_window = clast;\n\t}\n\n\txrecord_ptr_window = clast;\n\n\txrecording = 1;\n\txrecord_seq++;\n\tdtime0(&xrecord_start);\n\n\trc = XRecordEnableContextAsync(rdpy_data, rc_scroll, record_switch,\n\t    (XPointer) xrecord_seq);\n\n\tif (!rc || trapped_record_xerror) {\n\t\tif (1 || now > last_error + 60) {\n\t\t\trfbLog(\"failed to enable RECORD context \"\n\t\t\t    \"rc_scroll: 0x%lx rc: %d\\n\", rc_scroll, rc);\n\t\t\tif (trapped_record_xerror) {\n\t\t\t\tRECORD_ERROR_MSG(\"enable-failed\");\n\t\t\t}\n\t\t}\n\t\tshutdown_record_context(rc_scroll, 0, reopen_dpys);\n\t\trc_scroll = 0;\n\t\tlast_error = now;\n\t\txrecording = 0;\n\t\t/* continue on for now... */\n\t}\n\tXSetErrorHandler(old_handler);\n\n\t/* XXX this may cause more problems than it solves... */\n\tif (use_xrecord) {\n\t\tXFlush_wr(rdpy_data);\n\t}\n\n\tX_UNLOCK;\n\tSCR_UNLOCK;\n#endif\n}"
  },
  {
    "function_name": "check_xrecord_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1558-1636",
    "snippet": "void check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecording = 0;",
      "Display *gdpy_ctrl = NULL;",
      "int xserver_grabbed = 0;",
      "void check_xrecord_reset(int force);",
      "static void check_xrecord_grabserver(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown_record_context",
          "args": [
            "rc_scroll",
            "0",
            "1"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_record_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1476-1555",
          "snippet": "static void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "int xserver_grabbed = 0;",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_xrecord_grabserver",
          "args": [],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1445-1473",
          "snippet": "static void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecording = 0;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nvoid check_xrecord_reset(int force);\nstatic void check_xrecord_grabserver(void);\n\nvoid check_xrecord_reset(int force) {\n\tstatic double last_reset = 0.0;\n\tint reset_time  = 60, require_idle  = 10;\n\tint reset_time2 = 600, require_idle2 = 40;\n\tdouble now = 0.0;\n\tXErrorHandler old_handler = NULL;\n\n\tif (gdpy_ctrl) {\n\t\tX_LOCK;\n\t\tcheck_xrecord_grabserver();\n\t\tX_UNLOCK;\n\t} else {\n\t\t/* more dicey if not watching grabserver */\n\t\treset_time = reset_time2;\n\t\trequire_idle = require_idle2;\n\t}\n\n\tif (!use_xrecord) {\n\t\treturn;\n\t}\n\tif (xrecording) {\n\t\treturn;\n\t}\n\tif (button_mask) {\n\t\treturn;\n\t}\n\tif (xserver_grabbed) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n#if HAVE_RECORD\n\tif (! rc_scroll) {\n\t\treturn;\n\t}\n\tnow = dnow();\n\tif (last_reset == 0.0) {\n\t\tlast_reset = now;\n\t\treturn;\n\t}\n\t/*\n\t * try to wait for a break in input to reopen the displays\n\t * this is only to avoid XGrabServer deadlock on the repopens.\n\t */\n\tif (force) {\n\t\t;\n\t} else if (now < last_reset + reset_time) {\n\t\treturn;\n\t} else if (now < last_pointer_click_time + require_idle)  {\n\t\treturn;\n\t} else if (now < last_keyboard_time + require_idle)  {\n\t\treturn;\n\t}\n\tX_LOCK;\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\t/* unlikely, but check again since we will definitely be doing it. */\n\tif (gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\tXSetErrorHandler(old_handler);\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tshutdown_record_context(rc_scroll, 0, 1);\n\trc_scroll = 0;\n\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tlast_reset = now;\n#else\n\tif (!old_handler || now == 0.0 || !last_reset || !force) {}\n#endif\n}"
  },
  {
    "function_name": "shutdown_record_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1476-1555",
    "snippet": "static void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *rdpy_data = NULL;",
      "Display *rdpy_ctrl = NULL;",
      "Display *gdpy_ctrl = NULL;",
      "int xserver_grabbed = 0;",
      "static void check_xrecord_grabserver(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\"",
            "dpystr"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_grabserver",
          "args": [
            "rdpy_data",
            "0"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "disable_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1313-1372",
          "snippet": "void disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void disable_grabserver(Display *in_dpy, int change);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid disable_grabserver(Display *in_dpy, int change);\n\nvoid disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "rdpy_ctrl"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  disabling RECORD scroll detection.\\n\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\"",
            "dpystr"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dpystr"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "rdpy_ctrl",
            "True"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  disabling RECORD scroll detection.\\n\""
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\"",
            "dpystr"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"closing RECORD control connection.\\n\""
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"closing RECORD data connection.\\n\""
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xrecord_grabserver",
          "args": [],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrecord_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "1445-1473",
          "snippet": "static void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "static void check_xrecord_grabserver(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "rdpy_ctrl"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XRecordFreeContext(0x%lx) failed.\\n\"",
            "rc"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordFreeContext",
          "args": [
            "rdpy_ctrl",
            "rc"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XRecordDisableContext(0x%lx) failed.\\n\"",
            "rc"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordDisableContext",
          "args": [
            "rdpy_ctrl",
            "rc"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shutdown_record_context(0x%lx, %d, %d)\\n\"",
            "rc",
            "bequiet",
            "reopen"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void shutdown_record_context(XRecordContext rc, int bequiet, int reopen) {\n\tint ret1, ret2;\n\tint verb = (!bequiet && !quiet);\n\n\tRAWFB_RET_VOID\n\tif (0 || debug_scroll) {\n\t\trfbLog(\"shutdown_record_context(0x%lx, %d, %d)\\n\", rc,\n\t\t    bequiet, reopen);\n\t\tverb = 1;\n\t}\n\n\tret1 = XRecordDisableContext(rdpy_ctrl, rc);\n\tif (!ret1 && verb) {\n\t\trfbLog(\"XRecordDisableContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tret2 = XRecordFreeContext(rdpy_ctrl, rc);\n\tif (!ret2 && verb) {\n\t\trfbLog(\"XRecordFreeContext(0x%lx) failed.\\n\", rc);\t\n\t}\n\tXFlush_wr(rdpy_ctrl);\n\n\tif (reopen == 2 && ret1 && ret2) {\n\t\treopen = 0;\t/* 2 means reopen only on failure  */\n\t}\n\tif (reopen && gdpy_ctrl) {\n\t\tcheck_xrecord_grabserver();\n\t\tif (xserver_grabbed) {\n\t\t\trfbLog(\"shutdown_record_context: skip reopen,\"\n\t\t\t    \" server grabbed\\n\");\t\n\t\t\treopen = 0;\n\t\t}\n\t}\n\tif (reopen) {\n\t\tchar *dpystr = DisplayString(dpy);\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD data connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\n\t\tif (debug_scroll) {\n\t\t\trfbLog(\"closing RECORD control connection.\\n\");\n\t\t}\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\n\t\trdpy_ctrl = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_ctrl) {\n\t\t\trfbLog(\"Failed to reopen RECORD control connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tXSync(dpy, False);\n\n\t\tdisable_grabserver(rdpy_ctrl, 0);\n\t\tXSync(rdpy_ctrl, True);\n\n\t\trdpy_data = XOpenDisplay_wr(dpystr);\n\n\t\tif (! rdpy_data) {\n\t\t\trfbLog(\"Failed to reopen RECORD data connection:\"\n\t\t\t    \"%s\\n\", dpystr);\n\t\t\trfbLog(\"  disabling RECORD scroll detection.\\n\");\n\t\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\t\trdpy_ctrl = NULL;\n\t\t\tuse_xrecord = 0;\n\t\t\treturn;\n\t\t}\n\t\tdisable_grabserver(rdpy_data, 0);\n\n\t\tif (debug_scroll || (! bequiet && reopen == 2)) {\n\t\t\trfbLog(\"reopened RECORD data and control display\"\n\t\t\t    \" connections: %s\\n\", dpystr);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_xrecord_grabserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1445-1473",
    "snippet": "static void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *gdpy_ctrl = NULL;",
      "Display *gdpy_data = NULL;",
      "int xserver_grabbed = 0;",
      "static void check_xrecord_grabserver(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\"",
            "cnt",
            "i",
            "d"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&d"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "gdpy_ctrl"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRecordProcessReplies",
          "args": [
            "gdpy_data"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void check_xrecord_grabserver(void);\n\nstatic void check_xrecord_grabserver(void) {\n#if HAVE_RECORD\n\tint last_val, cnt = 0, i, max = 10;\n\tdouble d;\n\tif (!gdpy_ctrl || !gdpy_data) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tdtime0(&d);\n\tXFlush_wr(gdpy_ctrl);\n\tfor (i=0; i<max; i++) {\n\t\tlast_val = xserver_grabbed;\n\t\tXRecordProcessReplies(gdpy_data);\n\t\tif (xserver_grabbed != last_val) {\n\t\t\tcnt++;\n\t\t} else if (i > 2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt) {\n\t\tXFlush_wr(gdpy_ctrl);\n\t}\n if (debug_grabs && cnt > 0) {\n\td = dtime(&d);\nfprintf(stderr, \"check_xrecord_grabserver: cnt=%d i=%d %.4f\\n\", cnt, i, d);\n }\n#endif\n}"
  },
  {
    "function_name": "record_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1391-1442",
    "snippet": "static void record_grab(XPointer ptr, XRecordInterceptData *rec_data) {\n\txReq *req;\n\tint db = 0;\n\n\tif (debug_grabs) db = 1;\n\n\t/* should handle control msgs, start/stop/etc */\n\tif (rec_data->category == XRecordStartOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordEndOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientStarted) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientDied) {\n\t\t;\n\t} else if (rec_data->category == XRecordFromServer) {\n\t\t;\n\t}\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\tXRecordFreeData(rec_data);\n\t\treturn;\n\t}\n\n\treq = (xReq *) rec_data->data;\n\n\tif (req->reqType == X_GrabServer) {\n\t\tdouble now = dnowx();\n\t\txserver_grabbed++;\n\t\tif (db) rfbLog(\"X server Grabbed:    %d %.5f\\n\", xserver_grabbed, now);\n\t\tif (xserver_grabbed > 1) {\n\t\t\t/* \n\t\t\t * some apps do multiple grabs... very unlikely\n\t\t\t * two apps will be doing it at same time.\n\t\t\t */\n\t\t\txserver_grabbed = 1;\n\t\t}\n\t} else if (req->reqType == X_UngrabServer) {\n\t\tdouble now = dnowx();\n\t\txserver_grabbed--;\n\t\tif (xserver_grabbed < 0) {\n\t\t\txserver_grabbed = 0;\n\t\t}\n\t\tif (db) rfbLog(\"X server Un-Grabbed: %d %.5f\\n\", xserver_grabbed, now);\n\t} else {\n\t\t;\n\t}\n\tXRecordFreeData(rec_data);\n\n\t/* unused vars warning: */\n\tif (ptr) {}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xserver_grabbed = 0;",
      "static void xrecord_grabserver(int start);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XRecordFreeData",
          "args": [
            "rec_data"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X server Un-Grabbed: %d %.5f\\n\"",
            "xserver_grabbed",
            "now"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"X server Grabbed:    %d %.5f\\n\"",
            "xserver_grabbed",
            "now"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordFreeData",
          "args": [
            "rec_data"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xserver_grabbed = 0;\nstatic void xrecord_grabserver(int start);\n\nstatic void record_grab(XPointer ptr, XRecordInterceptData *rec_data) {\n\txReq *req;\n\tint db = 0;\n\n\tif (debug_grabs) db = 1;\n\n\t/* should handle control msgs, start/stop/etc */\n\tif (rec_data->category == XRecordStartOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordEndOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientStarted) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientDied) {\n\t\t;\n\t} else if (rec_data->category == XRecordFromServer) {\n\t\t;\n\t}\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\tXRecordFreeData(rec_data);\n\t\treturn;\n\t}\n\n\treq = (xReq *) rec_data->data;\n\n\tif (req->reqType == X_GrabServer) {\n\t\tdouble now = dnowx();\n\t\txserver_grabbed++;\n\t\tif (db) rfbLog(\"X server Grabbed:    %d %.5f\\n\", xserver_grabbed, now);\n\t\tif (xserver_grabbed > 1) {\n\t\t\t/* \n\t\t\t * some apps do multiple grabs... very unlikely\n\t\t\t * two apps will be doing it at same time.\n\t\t\t */\n\t\t\txserver_grabbed = 1;\n\t\t}\n\t} else if (req->reqType == X_UngrabServer) {\n\t\tdouble now = dnowx();\n\t\txserver_grabbed--;\n\t\tif (xserver_grabbed < 0) {\n\t\t\txserver_grabbed = 0;\n\t\t}\n\t\tif (db) rfbLog(\"X server Un-Grabbed: %d %.5f\\n\", xserver_grabbed, now);\n\t} else {\n\t\t;\n\t}\n\tXRecordFreeData(rec_data);\n\n\t/* unused vars warning: */\n\tif (ptr) {}\n}"
  },
  {
    "function_name": "record_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "1346-1389",
    "snippet": "static void record_switch(XPointer ptr, XRecordInterceptData *rec_data) {\n\tstatic int first = 1;\n\txReq *req;\n\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<SCR_ATTR_CACHE; i++) {\n\t\t\tscr_attr_cache[i].win = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\tscr_attr_cache[i].time = 0.0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* should handle control msgs, start/stop/etc */\n\tif (rec_data->category == XRecordStartOfData) {\n\t\trecord_CW(ptr, rec_data);\n\t} else if (rec_data->category == XRecordEndOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientStarted) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientDied) {\n\t\t;\n\t} else if (rec_data->category == XRecordFromServer) {\n\t\t;\n\t}\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\tXRecordFreeData(rec_data);\n\t\treturn;\n\t}\n\n\treq = (xReq *) rec_data->data;\n\n\tif (req->reqType == X_CopyArea) {\n\t\trecord_CA(ptr, rec_data);\n\t} else if (req->reqType == X_ConfigureWindow) {\n\t\trecord_CW(ptr, rec_data);\n\t} else {\n\t\t;\n\t}\n\tXRecordFreeData(rec_data);\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SCR_ATTR_CACHE 8"
    ],
    "globals_used": [
      "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
      "static void xrecord_grabserver(int start);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XRecordFreeData",
          "args": [
            "rec_data"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_CW",
          "args": [
            "ptr",
            "rec_data"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "record_CW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "854-1344",
          "snippet": "static void record_CW(XPointer ptr, XRecordInterceptData *rec_data) {\n\txConfigureWindowReq *req;\n\tWindow win = None, c;\n\tWindow src = None, dst = None;\n\tXWindowAttributes attr;\n\tint absent = 0x100000;\n\tint src_x, src_y, dst_x, dst_y, rx, ry;\n\tint good = 1, dx, dy, k=0, i, j, match, list[3];\n\tint f_x, f_y, f_w, f_h;\n\tint x, y, w, h;\n\tint x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2;\n\tstatic int index = 0;\n\tunsigned int vals[4];\n\tunsigned tmask;\n\tchar *data;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\n\tif (db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xConfigureWindowReq *) rec_data->data;\n\t\t\tif (req->reqType == X_ConfigureWindow) {\n\t\t\t\tsrc = req->window;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CW-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category == XRecordStartOfData) {\n\t\tindex = 0;\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->client_swapped) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\treq = (xConfigureWindowReq *) rec_data->data;\n\n\tif (req->reqType != X_ConfigureWindow) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\ttmask = req->mask;\n\n\ttmask &= ~CWX;\n\ttmask &= ~CWY;\n\ttmask &= ~CWWidth;\n\ttmask &= ~CWHeight;\n\n\tif (tmask) {\n\t\t/* require no more than these 4 flags */\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tf_x = req->mask & CWX;\n\tf_y = req->mask & CWY;\n\tf_w = req->mask & CWWidth;\n\tf_h = req->mask & CWHeight;\n\n\tif (! f_x || ! f_y)  {\n\t\tif (f_w && f_h) {\n\t\t\t;\t/* netscape 4.x style */\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ( (f_w && !f_h) || (!f_w && f_h) ) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\t\t\n\tfor (i=0; i<4; i++) {\n\t\tvals[i] = 0;\n\t}\n\n\tdata = (char *)req;\n\tdata += sz_xConfigureWindowReq;\n\n\tfor (i = 0; i < req->length - sz_xConfigureWindowReq / 4 && i < 4; i++) {\n\t\tunsigned int v;\n\t\t/*\n\t\t * We use unsigned int for the values.  There were\n\t\t * some crashes on 64bit machines with unsigned longs.\n\t\t * Need to check that X protocol sends 32bit values.\n\t\t */\n\t\tv = *( (unsigned int *) data);\nif (db > 1) fprintf(stderr, \"  vals[%d]  0x%x/%d\\n\", i, v, v);\n\t\tvals[i] = v;\n\t\tdata += sizeof(unsigned int);\n\t}\n\n\tif (index >= MAX_CW) {\n\t\tint i, j;\n\n\t\t/* FIXME, circular, etc. */\n\t\tfor (i=0; i<2; i++) {\n\t\t\tj = MAX_CW - 2 + i;\n\t\t\tcw_events[i].win = cw_events[j].win;\n\t\t\tcw_events[i].x = cw_events[j].x;\n\t\t\tcw_events[i].y = cw_events[j].y;\n\t\t\tcw_events[i].w = cw_events[j].w;\n\t\t\tcw_events[i].h = cw_events[j].h;\n\t\t}\n\t\tindex = 2;\n\t}\n\n\tif (! f_x && ! f_y) {\n\t\t/* netscape 4.x style  CWWidth,CWHeight */\n\t\tvals[2] = vals[0];\n\t\tvals[3] = vals[1];\n\t\tvals[0] = 0;\n\t\tvals[1] = 0;\n\t}\n\n\tcw_events[index].win = req->window;\n\n\tif (! f_x) {\n\t\tcw_events[index].x = absent;\n\t} else {\n\t\tcw_events[index].x = (int) vals[0];\n\t}\n\tif (! f_y) {\n\t\tcw_events[index].y = absent;\n\t} else {\n\t\tcw_events[index].y = (int) vals[1];\n\t}\n\n\tif (! f_w) {\n\t\tcw_events[index].w = absent;\n\t} else {\n\t\tcw_events[index].w = (int) vals[2];\n\t}\n\tif (! f_h) {\n\t\tcw_events[index].h = absent;\n\t} else {\n\t\tcw_events[index].h = (int) vals[3];\n\t}\n\n\tx = cw_events[index].x;\n\ty = cw_events[index].y;\n\tw = cw_events[index].w;\n\th = cw_events[index].h;\n\twin = cw_events[index].win;\n\nif (dba || db) fprintf(stderr, \"  record_CW ind: %d win: 0x%lx x: %d y: %d w: %d h: %d\\n\",\n\tindex, win, x, y, w, h);\n\n\tindex++;\n\n\tif (index < 3) {\n\t\tgood = 0;\n\t} else if (w != absent && h != absent &&\n\t    w*h < scrollcopyrect_min_area) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tmatch = 0;\n\tfor (j=index - 1; j >= 0; j--) {\n\t\tif (cw_events[j].win == win) {\n\t\t\tlist[match++] = j;\n\t\t}\n\t\tif (match >= 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (match != 3) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n/*\n\nMozilla:\n\nUp arrow: window moves down a bit (dy > 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 -18,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 3, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 0,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 65579,  v5 0,  v6 108009, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\nDown arrow: window moves up a bit (dy < 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 262147, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 -18,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 96555,  v5 48265642,  v6 48265262, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nNetscape 4.x\n\nUp arrow:\n71.76142   0.01984 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 -15,  v2 785,  v3 882,  v4 327692,  v5 159384712,  v6 1769484,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n71.76153   0.00011 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 867,  v2 329228,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n71.76157   0.00003 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 0,  v2 131132,  v3 159385313,  v4 328759,\n        CW-mask: CWX,CWY,\n                         XXX,XXX\n\nDown arrow:\n72.93147   0.01990 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 882,  v2 328972,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n72.93156   0.00009 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 -15,  v2 458764,  v3 159384712,  v4 159383567,\n        CW-mask: CWX,CWY,\n72.93160   0.00004 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 0,  v2 785,  v3 867,  v4 131132,  v5 159385335,  v6 328759,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nsadly, probably need to handle some more...\n\n */\n\tx0 = cw_events[list[2]].x;\n\ty0 = cw_events[list[2]].y;\n\tw0 = cw_events[list[2]].w;\n\th0 = cw_events[list[2]].h;\n\n\tx1 = cw_events[list[1]].x;\n\ty1 = cw_events[list[1]].y;\n\tw1 = cw_events[list[1]].w;\n\th1 = cw_events[list[1]].h;\n\n\tx2 = cw_events[list[0]].x;\n\ty2 = cw_events[list[0]].y;\n\tw2 = cw_events[list[0]].w;\n\th2 = cw_events[list[0]].h;\n\n\t/* see NS4 XXX's above: */\n\tif (w2 == absent || h2 == absent) {\n\t\t/* up arrow */\n\t\tif (w2 == absent) {\n\t\t\tw2 = w1;\n\t\t}\n\t\tif (h2 == absent) {\n\t\t\th2 = h1;\n\t\t}\n\t}\n\tif (x1 == absent || y1 == absent) {\n\t\t/* up arrow */\n\t\tif (x1 == absent) {\n\t\t\tx1 = x2;\n\t\t}\n\t\tif (y1 == absent) {\n\t\t\ty1 = y2;\n\t\t}\n\t}\n\tif (x0 == absent || y0 == absent) {\n\t\t/* down arrow */\n\t\tif (x0 == absent) {\n\t\t\t/* hmmm... what to do */\n\t\t\tx0 = x2;\n\t\t}\n\t\tif (y0 == absent) {\n\t\t\ty0 = y2;\n\t\t}\n\t}\n\nif (dba) fprintf(stderr, \"%d/%d/%d/%d  %d/%d/%d/%d  %d/%d/%d/%d\\n\", x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2);\n\n\tdy = y1 - y0;\n\tdx = x1 - x0;\n\n\tsrc_x = x2;\n\tsrc_y = y2;\n\tw = w2;\n\th = h2;\n\n\t/* check w and h before we modify them */\n\tif (w <= 0 || h <= 0) {\n\t\tgood = 0;\n\t} else if (w == absent || h == absent) {\n\t\tgood = 0;\n\t}\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (dy > 0) {\n\t\th -= dy;\t\n\t} else {\n\t\th += dy;\t\n\t\tsrc_y -= dy;\n\t}\n\tif (dx > 0) {\n\t\tw -= dx;\t\n\t} else {\n\t\tw += dx;\t\n\t\tsrc_x -= dx;\n\t}\n\n\tdst_x = src_x + dx;\n\tdst_y = src_y + dy;\n\n\tif (x0 == absent || x1 == absent || x2 == absent) {\n\t\tgood = 0;\n\t} else if (y0 == absent || y1 == absent || y2 == absent) {\n\t\tgood = 0;\n\t} else if (dx != 0 && dy != 0) {\n\t\tgood = 0;\n\t} else if (w0 - w2 != nabs(dx)) {\n\t\tgood = 0;\n\t} else if (h0 - h2 != nabs(dy)) {\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\t/*\n\t * geometry OK.\n\t * after all of the above succeeds, now contact X server.\n\t */\n\tif (lookup_attr_cache(win, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\nif (0) fprintf(stderr, \"lookup_attr_cache hit:  %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t} else {\n\t\tvalid = valid_window(win, &attr, 1);\n\nif (0) fprintf(stderr, \"lookup_attr_cache MISS: %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(win, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = win;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CW-%d *FOUND_SCROLL: win: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d  st: %.4f  dt: %.4f  %.4f\\n\", k++, win,\n\tdx, dy, src_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = win;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\t/* indicate we have a new one */\n\tscr_ev_cnt++;\n\n\tindex = 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_CW 128",
            "#define SCR_EV_MAX 128"
          ],
          "globals_used": [
            "scroll_event_t scr_ev[SCR_EV_MAX];",
            "int scr_ev_cnt;",
            "int xrecording = 0;",
            "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
            "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);",
            "static XID xrecord_seq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define MAX_CW 128\n#define SCR_EV_MAX 128\n\nscroll_event_t scr_ev[SCR_EV_MAX];\nint scr_ev_cnt;\nint xrecording = 0;\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\nstatic XID xrecord_seq = 0;\n\nstatic void record_CW(XPointer ptr, XRecordInterceptData *rec_data) {\n\txConfigureWindowReq *req;\n\tWindow win = None, c;\n\tWindow src = None, dst = None;\n\tXWindowAttributes attr;\n\tint absent = 0x100000;\n\tint src_x, src_y, dst_x, dst_y, rx, ry;\n\tint good = 1, dx, dy, k=0, i, j, match, list[3];\n\tint f_x, f_y, f_w, f_h;\n\tint x, y, w, h;\n\tint x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2;\n\tstatic int index = 0;\n\tunsigned int vals[4];\n\tunsigned tmask;\n\tchar *data;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\n\tif (db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xConfigureWindowReq *) rec_data->data;\n\t\t\tif (req->reqType == X_ConfigureWindow) {\n\t\t\t\tsrc = req->window;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CW-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category == XRecordStartOfData) {\n\t\tindex = 0;\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->client_swapped) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\treq = (xConfigureWindowReq *) rec_data->data;\n\n\tif (req->reqType != X_ConfigureWindow) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\ttmask = req->mask;\n\n\ttmask &= ~CWX;\n\ttmask &= ~CWY;\n\ttmask &= ~CWWidth;\n\ttmask &= ~CWHeight;\n\n\tif (tmask) {\n\t\t/* require no more than these 4 flags */\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tf_x = req->mask & CWX;\n\tf_y = req->mask & CWY;\n\tf_w = req->mask & CWWidth;\n\tf_h = req->mask & CWHeight;\n\n\tif (! f_x || ! f_y)  {\n\t\tif (f_w && f_h) {\n\t\t\t;\t/* netscape 4.x style */\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ( (f_w && !f_h) || (!f_w && f_h) ) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\t\t\n\tfor (i=0; i<4; i++) {\n\t\tvals[i] = 0;\n\t}\n\n\tdata = (char *)req;\n\tdata += sz_xConfigureWindowReq;\n\n\tfor (i = 0; i < req->length - sz_xConfigureWindowReq / 4 && i < 4; i++) {\n\t\tunsigned int v;\n\t\t/*\n\t\t * We use unsigned int for the values.  There were\n\t\t * some crashes on 64bit machines with unsigned longs.\n\t\t * Need to check that X protocol sends 32bit values.\n\t\t */\n\t\tv = *( (unsigned int *) data);\nif (db > 1) fprintf(stderr, \"  vals[%d]  0x%x/%d\\n\", i, v, v);\n\t\tvals[i] = v;\n\t\tdata += sizeof(unsigned int);\n\t}\n\n\tif (index >= MAX_CW) {\n\t\tint i, j;\n\n\t\t/* FIXME, circular, etc. */\n\t\tfor (i=0; i<2; i++) {\n\t\t\tj = MAX_CW - 2 + i;\n\t\t\tcw_events[i].win = cw_events[j].win;\n\t\t\tcw_events[i].x = cw_events[j].x;\n\t\t\tcw_events[i].y = cw_events[j].y;\n\t\t\tcw_events[i].w = cw_events[j].w;\n\t\t\tcw_events[i].h = cw_events[j].h;\n\t\t}\n\t\tindex = 2;\n\t}\n\n\tif (! f_x && ! f_y) {\n\t\t/* netscape 4.x style  CWWidth,CWHeight */\n\t\tvals[2] = vals[0];\n\t\tvals[3] = vals[1];\n\t\tvals[0] = 0;\n\t\tvals[1] = 0;\n\t}\n\n\tcw_events[index].win = req->window;\n\n\tif (! f_x) {\n\t\tcw_events[index].x = absent;\n\t} else {\n\t\tcw_events[index].x = (int) vals[0];\n\t}\n\tif (! f_y) {\n\t\tcw_events[index].y = absent;\n\t} else {\n\t\tcw_events[index].y = (int) vals[1];\n\t}\n\n\tif (! f_w) {\n\t\tcw_events[index].w = absent;\n\t} else {\n\t\tcw_events[index].w = (int) vals[2];\n\t}\n\tif (! f_h) {\n\t\tcw_events[index].h = absent;\n\t} else {\n\t\tcw_events[index].h = (int) vals[3];\n\t}\n\n\tx = cw_events[index].x;\n\ty = cw_events[index].y;\n\tw = cw_events[index].w;\n\th = cw_events[index].h;\n\twin = cw_events[index].win;\n\nif (dba || db) fprintf(stderr, \"  record_CW ind: %d win: 0x%lx x: %d y: %d w: %d h: %d\\n\",\n\tindex, win, x, y, w, h);\n\n\tindex++;\n\n\tif (index < 3) {\n\t\tgood = 0;\n\t} else if (w != absent && h != absent &&\n\t    w*h < scrollcopyrect_min_area) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tmatch = 0;\n\tfor (j=index - 1; j >= 0; j--) {\n\t\tif (cw_events[j].win == win) {\n\t\t\tlist[match++] = j;\n\t\t}\n\t\tif (match >= 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (match != 3) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n/*\n\nMozilla:\n\nUp arrow: window moves down a bit (dy > 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 -18,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 3, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 0,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 65579,  v5 0,  v6 108009, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\nDown arrow: window moves up a bit (dy < 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 262147, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 -18,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 96555,  v5 48265642,  v6 48265262, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nNetscape 4.x\n\nUp arrow:\n71.76142   0.01984 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 -15,  v2 785,  v3 882,  v4 327692,  v5 159384712,  v6 1769484,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n71.76153   0.00011 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 867,  v2 329228,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n71.76157   0.00003 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 0,  v2 131132,  v3 159385313,  v4 328759,\n        CW-mask: CWX,CWY,\n                         XXX,XXX\n\nDown arrow:\n72.93147   0.01990 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 882,  v2 328972,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n72.93156   0.00009 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 -15,  v2 458764,  v3 159384712,  v4 159383567,\n        CW-mask: CWX,CWY,\n72.93160   0.00004 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 0,  v2 785,  v3 867,  v4 131132,  v5 159385335,  v6 328759,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nsadly, probably need to handle some more...\n\n */\n\tx0 = cw_events[list[2]].x;\n\ty0 = cw_events[list[2]].y;\n\tw0 = cw_events[list[2]].w;\n\th0 = cw_events[list[2]].h;\n\n\tx1 = cw_events[list[1]].x;\n\ty1 = cw_events[list[1]].y;\n\tw1 = cw_events[list[1]].w;\n\th1 = cw_events[list[1]].h;\n\n\tx2 = cw_events[list[0]].x;\n\ty2 = cw_events[list[0]].y;\n\tw2 = cw_events[list[0]].w;\n\th2 = cw_events[list[0]].h;\n\n\t/* see NS4 XXX's above: */\n\tif (w2 == absent || h2 == absent) {\n\t\t/* up arrow */\n\t\tif (w2 == absent) {\n\t\t\tw2 = w1;\n\t\t}\n\t\tif (h2 == absent) {\n\t\t\th2 = h1;\n\t\t}\n\t}\n\tif (x1 == absent || y1 == absent) {\n\t\t/* up arrow */\n\t\tif (x1 == absent) {\n\t\t\tx1 = x2;\n\t\t}\n\t\tif (y1 == absent) {\n\t\t\ty1 = y2;\n\t\t}\n\t}\n\tif (x0 == absent || y0 == absent) {\n\t\t/* down arrow */\n\t\tif (x0 == absent) {\n\t\t\t/* hmmm... what to do */\n\t\t\tx0 = x2;\n\t\t}\n\t\tif (y0 == absent) {\n\t\t\ty0 = y2;\n\t\t}\n\t}\n\nif (dba) fprintf(stderr, \"%d/%d/%d/%d  %d/%d/%d/%d  %d/%d/%d/%d\\n\", x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2);\n\n\tdy = y1 - y0;\n\tdx = x1 - x0;\n\n\tsrc_x = x2;\n\tsrc_y = y2;\n\tw = w2;\n\th = h2;\n\n\t/* check w and h before we modify them */\n\tif (w <= 0 || h <= 0) {\n\t\tgood = 0;\n\t} else if (w == absent || h == absent) {\n\t\tgood = 0;\n\t}\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (dy > 0) {\n\t\th -= dy;\t\n\t} else {\n\t\th += dy;\t\n\t\tsrc_y -= dy;\n\t}\n\tif (dx > 0) {\n\t\tw -= dx;\t\n\t} else {\n\t\tw += dx;\t\n\t\tsrc_x -= dx;\n\t}\n\n\tdst_x = src_x + dx;\n\tdst_y = src_y + dy;\n\n\tif (x0 == absent || x1 == absent || x2 == absent) {\n\t\tgood = 0;\n\t} else if (y0 == absent || y1 == absent || y2 == absent) {\n\t\tgood = 0;\n\t} else if (dx != 0 && dy != 0) {\n\t\tgood = 0;\n\t} else if (w0 - w2 != nabs(dx)) {\n\t\tgood = 0;\n\t} else if (h0 - h2 != nabs(dy)) {\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\t/*\n\t * geometry OK.\n\t * after all of the above succeeds, now contact X server.\n\t */\n\tif (lookup_attr_cache(win, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\nif (0) fprintf(stderr, \"lookup_attr_cache hit:  %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t} else {\n\t\tvalid = valid_window(win, &attr, 1);\n\nif (0) fprintf(stderr, \"lookup_attr_cache MISS: %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(win, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = win;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CW-%d *FOUND_SCROLL: win: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d  st: %.4f  dt: %.4f  %.4f\\n\", k++, win,\n\tdx, dy, src_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = win;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\t/* indicate we have a new one */\n\tscr_ev_cnt++;\n\n\tindex = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_CA",
          "args": [
            "ptr",
            "rec_data"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "record_CA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "535-844",
          "snippet": "static void record_CA(XPointer ptr, XRecordInterceptData *rec_data) {\n\txCopyAreaReq *req;\n\tWindow src = None, dst = None, c;\n\tXWindowAttributes attr, attr2;\n\tint src_x, src_y, dst_x, dst_y, rx, ry, rx2, ry2;\n\tint good = 1, dx = 0, dy = 0, k=0, i;\n\tunsigned int w, h;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\tstatic int must_equal = -1;\n\n\tif (dba || db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xCopyAreaReq *) rec_data->data;\n\t\t\tif (req->reqType == X_CopyArea) {\n\t\t\t\tsrc = req->srcDrawable;\n\t\t\t\tdst = req->dstDrawable;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\treq = (xCopyAreaReq *) rec_data->data;\n\n\tif (req->reqType != X_CopyArea) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (must_equal < 0) {\n\t\tmust_equal = 0;\n\t\tif (getenv(\"X11VNC_SCROLL_MUST_EQUAL\")) {\n\t\t\tmust_equal = 1;\n\t\t}\n\t}\n\n/*\n\nxterm, gnome-terminal, others.\n\nNote we miss the X_ImageText8 that clears the block cursor.  So there is a\nshort period of time with a painting error: two cursors, one above the other.\n\n X_ImageText8 \n    draw: 0x8c00017 nChars: 1, gc: 0x8c00013, x: 101, y: 585, chars=' '\n X_ClearArea \n    window: 0x8c00018, x:   2, y: 217, w:  10, h:   5\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000a, shape: 0, coordMode: 0,\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000b, shape: 0, coordMode: 0,\n X_CopyArea \n    src: 0x8c00017, dst: 0x8c00017, gc: 0x8c00013, srcX:  17, srcY:  15, dstX:  17, dstY:   2, w: 480, h: 572\n X_ChangeWindowAttributes \n X_ClearArea \n    window: 0x8c00017, x:  17, y: 574, w: 480, h:  13\n X_ChangeWindowAttributes \n\n */\n\n\tsrc = req->srcDrawable;\n\tdst = req->dstDrawable;\n\tsrc_x = req->srcX;\n\tsrc_y = req->srcY;\n\tdst_x = req->dstX;\n\tdst_y = req->dstY;\n\tw = req->width;\n\th = req->height;\n\n\tif (w*h < (unsigned int) scrollcopyrect_min_area) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA scroll area too small.\\n\");\n\t\tgood = 0;\n\t} else if (!src || !dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null src or dst.\\n\");\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null too many scr events.\\n\");\n\t\tgood = 0;\n\t} else if (must_equal && src != dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA src not equal dst.\\n\");\n\t\tgood = 0;\n\t}\n\n\tif (src == dst) {\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\tgood = 0;\n\t\t}\n\t}\n\nif (!good && (dba || db > 1)) fprintf(stderr, \"record_CA-x src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\tif (! good) {\n\t\treturn;\n\t}\n\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\t/*\n\t * after all of the above succeeds, now contact X server.\n\t * we try to get away with some caching here.\n\t */\n\tif (lookup_attr_cache(src, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t} else {\n\t\tvalid = valid_window(src, &attr, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(src, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = src;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-1.\\n\");\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-1.\\n\");\n\t\treturn;\n\t}\n\n\t/* recent gdk/gtk windows use different src and dst. for compositing? */\n\tif (src != dst) {\n\t    if (lookup_attr_cache(dst, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr2.x = scr_attr_cache[i].x;\n\t\tattr2.y = scr_attr_cache[i].y;\n\t\tattr2.width = scr_attr_cache[i].width;\n\t\tattr2.height = scr_attr_cache[i].height;\n\t\tattr2.map_state = scr_attr_cache[i].map_state;\n\t\trx2 = scr_attr_cache[i].rx;\n\t\try2 = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t    } else {\n\t\tvalid = valid_window(dst, &attr2, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(dst, rootwin, 0, 0, &rx2, &ry2, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = dst;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr2.x;\n\t\t\t\tscr_attr_cache[i].y = attr2.y;\n\t\t\t\tscr_attr_cache[i].width = attr2.width;\n\t\t\t\tscr_attr_cache[i].height = attr2.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr2.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr2.depth;\n\t\t\t\tscr_attr_cache[i].class = attr2.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr2.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr2.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx2;\n\t\t\t\tscr_attr_cache[i].ry = ry2;\n\t\t\t}\n\t\t}\n\t    }\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-? src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\t\tif (! valid) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (attr2.map_state != IsViewable) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdst_x = dst_x - (rx - rx2);\n\t\tdst_y = dst_y - (ry - ry2);\n\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CA-%d *FOUND_SCROLL: src: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d st: %.4f %.4f  %.4f\\n\", k++, src, dx, dy,\n\tsrc_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = src;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\tscr_ev_cnt++;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SCR_EV_MAX 128"
          ],
          "globals_used": [
            "scroll_event_t scr_ev[SCR_EV_MAX];",
            "int scr_ev_cnt;",
            "int xrecording = 0;",
            "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
            "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);",
            "static XID xrecord_seq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_EV_MAX 128\n\nscroll_event_t scr_ev[SCR_EV_MAX];\nint scr_ev_cnt;\nint xrecording = 0;\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\nstatic XID xrecord_seq = 0;\n\nstatic void record_CA(XPointer ptr, XRecordInterceptData *rec_data) {\n\txCopyAreaReq *req;\n\tWindow src = None, dst = None, c;\n\tXWindowAttributes attr, attr2;\n\tint src_x, src_y, dst_x, dst_y, rx, ry, rx2, ry2;\n\tint good = 1, dx = 0, dy = 0, k=0, i;\n\tunsigned int w, h;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\tstatic int must_equal = -1;\n\n\tif (dba || db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xCopyAreaReq *) rec_data->data;\n\t\t\tif (req->reqType == X_CopyArea) {\n\t\t\t\tsrc = req->srcDrawable;\n\t\t\t\tdst = req->dstDrawable;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\treq = (xCopyAreaReq *) rec_data->data;\n\n\tif (req->reqType != X_CopyArea) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (must_equal < 0) {\n\t\tmust_equal = 0;\n\t\tif (getenv(\"X11VNC_SCROLL_MUST_EQUAL\")) {\n\t\t\tmust_equal = 1;\n\t\t}\n\t}\n\n/*\n\nxterm, gnome-terminal, others.\n\nNote we miss the X_ImageText8 that clears the block cursor.  So there is a\nshort period of time with a painting error: two cursors, one above the other.\n\n X_ImageText8 \n    draw: 0x8c00017 nChars: 1, gc: 0x8c00013, x: 101, y: 585, chars=' '\n X_ClearArea \n    window: 0x8c00018, x:   2, y: 217, w:  10, h:   5\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000a, shape: 0, coordMode: 0,\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000b, shape: 0, coordMode: 0,\n X_CopyArea \n    src: 0x8c00017, dst: 0x8c00017, gc: 0x8c00013, srcX:  17, srcY:  15, dstX:  17, dstY:   2, w: 480, h: 572\n X_ChangeWindowAttributes \n X_ClearArea \n    window: 0x8c00017, x:  17, y: 574, w: 480, h:  13\n X_ChangeWindowAttributes \n\n */\n\n\tsrc = req->srcDrawable;\n\tdst = req->dstDrawable;\n\tsrc_x = req->srcX;\n\tsrc_y = req->srcY;\n\tdst_x = req->dstX;\n\tdst_y = req->dstY;\n\tw = req->width;\n\th = req->height;\n\n\tif (w*h < (unsigned int) scrollcopyrect_min_area) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA scroll area too small.\\n\");\n\t\tgood = 0;\n\t} else if (!src || !dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null src or dst.\\n\");\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null too many scr events.\\n\");\n\t\tgood = 0;\n\t} else if (must_equal && src != dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA src not equal dst.\\n\");\n\t\tgood = 0;\n\t}\n\n\tif (src == dst) {\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\tgood = 0;\n\t\t}\n\t}\n\nif (!good && (dba || db > 1)) fprintf(stderr, \"record_CA-x src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\tif (! good) {\n\t\treturn;\n\t}\n\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\t/*\n\t * after all of the above succeeds, now contact X server.\n\t * we try to get away with some caching here.\n\t */\n\tif (lookup_attr_cache(src, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t} else {\n\t\tvalid = valid_window(src, &attr, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(src, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = src;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-1.\\n\");\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-1.\\n\");\n\t\treturn;\n\t}\n\n\t/* recent gdk/gtk windows use different src and dst. for compositing? */\n\tif (src != dst) {\n\t    if (lookup_attr_cache(dst, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr2.x = scr_attr_cache[i].x;\n\t\tattr2.y = scr_attr_cache[i].y;\n\t\tattr2.width = scr_attr_cache[i].width;\n\t\tattr2.height = scr_attr_cache[i].height;\n\t\tattr2.map_state = scr_attr_cache[i].map_state;\n\t\trx2 = scr_attr_cache[i].rx;\n\t\try2 = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t    } else {\n\t\tvalid = valid_window(dst, &attr2, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(dst, rootwin, 0, 0, &rx2, &ry2, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = dst;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr2.x;\n\t\t\t\tscr_attr_cache[i].y = attr2.y;\n\t\t\t\tscr_attr_cache[i].width = attr2.width;\n\t\t\t\tscr_attr_cache[i].height = attr2.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr2.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr2.depth;\n\t\t\t\tscr_attr_cache[i].class = attr2.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr2.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr2.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx2;\n\t\t\t\tscr_attr_cache[i].ry = ry2;\n\t\t\t}\n\t\t}\n\t    }\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-? src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\t\tif (! valid) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (attr2.map_state != IsViewable) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdst_x = dst_x - (rx - rx2);\n\t\tdst_y = dst_y - (ry - ry2);\n\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CA-%d *FOUND_SCROLL: src: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d st: %.4f %.4f  %.4f\\n\", k++, src, dx, dy,\n\tsrc_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = src;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\tscr_ev_cnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRecordFreeData",
          "args": [
            "rec_data"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_ATTR_CACHE 8\n\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic void xrecord_grabserver(int start);\n\nstatic void record_switch(XPointer ptr, XRecordInterceptData *rec_data) {\n\tstatic int first = 1;\n\txReq *req;\n\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<SCR_ATTR_CACHE; i++) {\n\t\t\tscr_attr_cache[i].win = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\tscr_attr_cache[i].time = 0.0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* should handle control msgs, start/stop/etc */\n\tif (rec_data->category == XRecordStartOfData) {\n\t\trecord_CW(ptr, rec_data);\n\t} else if (rec_data->category == XRecordEndOfData) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientStarted) {\n\t\t;\n\t} else if (rec_data->category == XRecordClientDied) {\n\t\t;\n\t} else if (rec_data->category == XRecordFromServer) {\n\t\t;\n\t}\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\tXRecordFreeData(rec_data);\n\t\treturn;\n\t}\n\n\treq = (xReq *) rec_data->data;\n\n\tif (req->reqType == X_CopyArea) {\n\t\trecord_CA(ptr, rec_data);\n\t} else if (req->reqType == X_ConfigureWindow) {\n\t\trecord_CW(ptr, rec_data);\n\t} else {\n\t\t;\n\t}\n\tXRecordFreeData(rec_data);\n}"
  },
  {
    "function_name": "record_CW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "854-1344",
    "snippet": "static void record_CW(XPointer ptr, XRecordInterceptData *rec_data) {\n\txConfigureWindowReq *req;\n\tWindow win = None, c;\n\tWindow src = None, dst = None;\n\tXWindowAttributes attr;\n\tint absent = 0x100000;\n\tint src_x, src_y, dst_x, dst_y, rx, ry;\n\tint good = 1, dx, dy, k=0, i, j, match, list[3];\n\tint f_x, f_y, f_w, f_h;\n\tint x, y, w, h;\n\tint x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2;\n\tstatic int index = 0;\n\tunsigned int vals[4];\n\tunsigned tmask;\n\tchar *data;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\n\tif (db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xConfigureWindowReq *) rec_data->data;\n\t\t\tif (req->reqType == X_ConfigureWindow) {\n\t\t\t\tsrc = req->window;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CW-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category == XRecordStartOfData) {\n\t\tindex = 0;\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->client_swapped) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\treq = (xConfigureWindowReq *) rec_data->data;\n\n\tif (req->reqType != X_ConfigureWindow) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\ttmask = req->mask;\n\n\ttmask &= ~CWX;\n\ttmask &= ~CWY;\n\ttmask &= ~CWWidth;\n\ttmask &= ~CWHeight;\n\n\tif (tmask) {\n\t\t/* require no more than these 4 flags */\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tf_x = req->mask & CWX;\n\tf_y = req->mask & CWY;\n\tf_w = req->mask & CWWidth;\n\tf_h = req->mask & CWHeight;\n\n\tif (! f_x || ! f_y)  {\n\t\tif (f_w && f_h) {\n\t\t\t;\t/* netscape 4.x style */\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ( (f_w && !f_h) || (!f_w && f_h) ) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\t\t\n\tfor (i=0; i<4; i++) {\n\t\tvals[i] = 0;\n\t}\n\n\tdata = (char *)req;\n\tdata += sz_xConfigureWindowReq;\n\n\tfor (i = 0; i < req->length - sz_xConfigureWindowReq / 4 && i < 4; i++) {\n\t\tunsigned int v;\n\t\t/*\n\t\t * We use unsigned int for the values.  There were\n\t\t * some crashes on 64bit machines with unsigned longs.\n\t\t * Need to check that X protocol sends 32bit values.\n\t\t */\n\t\tv = *( (unsigned int *) data);\nif (db > 1) fprintf(stderr, \"  vals[%d]  0x%x/%d\\n\", i, v, v);\n\t\tvals[i] = v;\n\t\tdata += sizeof(unsigned int);\n\t}\n\n\tif (index >= MAX_CW) {\n\t\tint i, j;\n\n\t\t/* FIXME, circular, etc. */\n\t\tfor (i=0; i<2; i++) {\n\t\t\tj = MAX_CW - 2 + i;\n\t\t\tcw_events[i].win = cw_events[j].win;\n\t\t\tcw_events[i].x = cw_events[j].x;\n\t\t\tcw_events[i].y = cw_events[j].y;\n\t\t\tcw_events[i].w = cw_events[j].w;\n\t\t\tcw_events[i].h = cw_events[j].h;\n\t\t}\n\t\tindex = 2;\n\t}\n\n\tif (! f_x && ! f_y) {\n\t\t/* netscape 4.x style  CWWidth,CWHeight */\n\t\tvals[2] = vals[0];\n\t\tvals[3] = vals[1];\n\t\tvals[0] = 0;\n\t\tvals[1] = 0;\n\t}\n\n\tcw_events[index].win = req->window;\n\n\tif (! f_x) {\n\t\tcw_events[index].x = absent;\n\t} else {\n\t\tcw_events[index].x = (int) vals[0];\n\t}\n\tif (! f_y) {\n\t\tcw_events[index].y = absent;\n\t} else {\n\t\tcw_events[index].y = (int) vals[1];\n\t}\n\n\tif (! f_w) {\n\t\tcw_events[index].w = absent;\n\t} else {\n\t\tcw_events[index].w = (int) vals[2];\n\t}\n\tif (! f_h) {\n\t\tcw_events[index].h = absent;\n\t} else {\n\t\tcw_events[index].h = (int) vals[3];\n\t}\n\n\tx = cw_events[index].x;\n\ty = cw_events[index].y;\n\tw = cw_events[index].w;\n\th = cw_events[index].h;\n\twin = cw_events[index].win;\n\nif (dba || db) fprintf(stderr, \"  record_CW ind: %d win: 0x%lx x: %d y: %d w: %d h: %d\\n\",\n\tindex, win, x, y, w, h);\n\n\tindex++;\n\n\tif (index < 3) {\n\t\tgood = 0;\n\t} else if (w != absent && h != absent &&\n\t    w*h < scrollcopyrect_min_area) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tmatch = 0;\n\tfor (j=index - 1; j >= 0; j--) {\n\t\tif (cw_events[j].win == win) {\n\t\t\tlist[match++] = j;\n\t\t}\n\t\tif (match >= 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (match != 3) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n/*\n\nMozilla:\n\nUp arrow: window moves down a bit (dy > 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 -18,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 3, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 0,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 65579,  v5 0,  v6 108009, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\nDown arrow: window moves up a bit (dy < 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 262147, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 -18,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 96555,  v5 48265642,  v6 48265262, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nNetscape 4.x\n\nUp arrow:\n71.76142   0.01984 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 -15,  v2 785,  v3 882,  v4 327692,  v5 159384712,  v6 1769484,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n71.76153   0.00011 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 867,  v2 329228,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n71.76157   0.00003 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 0,  v2 131132,  v3 159385313,  v4 328759,\n        CW-mask: CWX,CWY,\n                         XXX,XXX\n\nDown arrow:\n72.93147   0.01990 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 882,  v2 328972,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n72.93156   0.00009 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 -15,  v2 458764,  v3 159384712,  v4 159383567,\n        CW-mask: CWX,CWY,\n72.93160   0.00004 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 0,  v2 785,  v3 867,  v4 131132,  v5 159385335,  v6 328759,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nsadly, probably need to handle some more...\n\n */\n\tx0 = cw_events[list[2]].x;\n\ty0 = cw_events[list[2]].y;\n\tw0 = cw_events[list[2]].w;\n\th0 = cw_events[list[2]].h;\n\n\tx1 = cw_events[list[1]].x;\n\ty1 = cw_events[list[1]].y;\n\tw1 = cw_events[list[1]].w;\n\th1 = cw_events[list[1]].h;\n\n\tx2 = cw_events[list[0]].x;\n\ty2 = cw_events[list[0]].y;\n\tw2 = cw_events[list[0]].w;\n\th2 = cw_events[list[0]].h;\n\n\t/* see NS4 XXX's above: */\n\tif (w2 == absent || h2 == absent) {\n\t\t/* up arrow */\n\t\tif (w2 == absent) {\n\t\t\tw2 = w1;\n\t\t}\n\t\tif (h2 == absent) {\n\t\t\th2 = h1;\n\t\t}\n\t}\n\tif (x1 == absent || y1 == absent) {\n\t\t/* up arrow */\n\t\tif (x1 == absent) {\n\t\t\tx1 = x2;\n\t\t}\n\t\tif (y1 == absent) {\n\t\t\ty1 = y2;\n\t\t}\n\t}\n\tif (x0 == absent || y0 == absent) {\n\t\t/* down arrow */\n\t\tif (x0 == absent) {\n\t\t\t/* hmmm... what to do */\n\t\t\tx0 = x2;\n\t\t}\n\t\tif (y0 == absent) {\n\t\t\ty0 = y2;\n\t\t}\n\t}\n\nif (dba) fprintf(stderr, \"%d/%d/%d/%d  %d/%d/%d/%d  %d/%d/%d/%d\\n\", x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2);\n\n\tdy = y1 - y0;\n\tdx = x1 - x0;\n\n\tsrc_x = x2;\n\tsrc_y = y2;\n\tw = w2;\n\th = h2;\n\n\t/* check w and h before we modify them */\n\tif (w <= 0 || h <= 0) {\n\t\tgood = 0;\n\t} else if (w == absent || h == absent) {\n\t\tgood = 0;\n\t}\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (dy > 0) {\n\t\th -= dy;\t\n\t} else {\n\t\th += dy;\t\n\t\tsrc_y -= dy;\n\t}\n\tif (dx > 0) {\n\t\tw -= dx;\t\n\t} else {\n\t\tw += dx;\t\n\t\tsrc_x -= dx;\n\t}\n\n\tdst_x = src_x + dx;\n\tdst_y = src_y + dy;\n\n\tif (x0 == absent || x1 == absent || x2 == absent) {\n\t\tgood = 0;\n\t} else if (y0 == absent || y1 == absent || y2 == absent) {\n\t\tgood = 0;\n\t} else if (dx != 0 && dy != 0) {\n\t\tgood = 0;\n\t} else if (w0 - w2 != nabs(dx)) {\n\t\tgood = 0;\n\t} else if (h0 - h2 != nabs(dy)) {\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\t/*\n\t * geometry OK.\n\t * after all of the above succeeds, now contact X server.\n\t */\n\tif (lookup_attr_cache(win, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\nif (0) fprintf(stderr, \"lookup_attr_cache hit:  %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t} else {\n\t\tvalid = valid_window(win, &attr, 1);\n\nif (0) fprintf(stderr, \"lookup_attr_cache MISS: %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(win, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = win;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CW-%d *FOUND_SCROLL: win: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d  st: %.4f  dt: %.4f  %.4f\\n\", k++, win,\n\tdx, dy, src_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = win;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\t/* indicate we have a new one */\n\tscr_ev_cnt++;\n\n\tindex = 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_CW 128",
      "#define SCR_EV_MAX 128"
    ],
    "globals_used": [
      "scroll_event_t scr_ev[SCR_EV_MAX];",
      "int scr_ev_cnt;",
      "int xrecording = 0;",
      "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
      "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);",
      "static XID xrecord_seq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d *FOUND_SCROLL: win: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d  st: %.4f  dt: %.4f  %.4f\\n\"",
            "k++",
            "win",
            "dx",
            "dy",
            "src_x",
            "src_y",
            "w",
            "h",
            "st",
            "dt",
            "dnowx()"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "win",
            "rootwin",
            "0",
            "0",
            "&rx",
            "&ry",
            "&c",
            "1"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_attr_cache MISS: %2d %2d 0x%lx %d\\n\"",
            "cache_index",
            "next_index",
            "win",
            "valid"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_attr_cache hit:  %2d %2d 0x%lx %d\\n\"",
            "cache_index",
            "next_index",
            "win",
            "valid"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_attr_cache",
          "args": [
            "win",
            "&cache_index",
            "&next_index"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "466-528",
          "snippet": "static int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SCR_ATTR_CACHE 8"
          ],
          "globals_used": [
            "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
            "static double attr_cache_max_age = 1.5;",
            "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_ATTR_CACHE 8\n\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic double attr_cache_max_age = 1.5;\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\n\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "dy"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d/%d/%d/%d  %d/%d/%d/%d  %d/%d/%d/%d\\n\"",
            "x0",
            "y0",
            "w0",
            "h0",
            "x1",
            "y1",
            "w1",
            "h1",
            "x2",
            "y2",
            "w2",
            "h2"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  record_CW ind: %d win: 0x%lx x: %d y: %d w: %d h: %d\\n\"",
            "index",
            "win",
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  vals[%d]  0x%x/%d\\n\"",
            "i",
            "v",
            "v"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d\\n\"",
            "k++"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CW-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\"",
            "k++",
            "rec_data->id_base",
            "(unsigned long) ptr",
            "xrecord_seq",
            "rc_scroll",
            "rec_data->category",
            "rec_data->client_swapped",
            "src",
            "dst"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define MAX_CW 128\n#define SCR_EV_MAX 128\n\nscroll_event_t scr_ev[SCR_EV_MAX];\nint scr_ev_cnt;\nint xrecording = 0;\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\nstatic XID xrecord_seq = 0;\n\nstatic void record_CW(XPointer ptr, XRecordInterceptData *rec_data) {\n\txConfigureWindowReq *req;\n\tWindow win = None, c;\n\tWindow src = None, dst = None;\n\tXWindowAttributes attr;\n\tint absent = 0x100000;\n\tint src_x, src_y, dst_x, dst_y, rx, ry;\n\tint good = 1, dx, dy, k=0, i, j, match, list[3];\n\tint f_x, f_y, f_w, f_h;\n\tint x, y, w, h;\n\tint x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2;\n\tstatic int index = 0;\n\tunsigned int vals[4];\n\tunsigned tmask;\n\tchar *data;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\n\tif (db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xConfigureWindowReq *) rec_data->data;\n\t\t\tif (req->reqType == X_ConfigureWindow) {\n\t\t\t\tsrc = req->window;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CW-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category == XRecordStartOfData) {\n\t\tindex = 0;\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (rec_data->client_swapped) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\treq = (xConfigureWindowReq *) rec_data->data;\n\n\tif (req->reqType != X_ConfigureWindow) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\ttmask = req->mask;\n\n\ttmask &= ~CWX;\n\ttmask &= ~CWY;\n\ttmask &= ~CWWidth;\n\ttmask &= ~CWHeight;\n\n\tif (tmask) {\n\t\t/* require no more than these 4 flags */\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tf_x = req->mask & CWX;\n\tf_y = req->mask & CWY;\n\tf_w = req->mask & CWWidth;\n\tf_h = req->mask & CWHeight;\n\n\tif (! f_x || ! f_y)  {\n\t\tif (f_w && f_h) {\n\t\t\t;\t/* netscape 4.x style */\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif ( (f_w && !f_h) || (!f_w && f_h) ) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\t\t\n\tfor (i=0; i<4; i++) {\n\t\tvals[i] = 0;\n\t}\n\n\tdata = (char *)req;\n\tdata += sz_xConfigureWindowReq;\n\n\tfor (i = 0; i < req->length - sz_xConfigureWindowReq / 4 && i < 4; i++) {\n\t\tunsigned int v;\n\t\t/*\n\t\t * We use unsigned int for the values.  There were\n\t\t * some crashes on 64bit machines with unsigned longs.\n\t\t * Need to check that X protocol sends 32bit values.\n\t\t */\n\t\tv = *( (unsigned int *) data);\nif (db > 1) fprintf(stderr, \"  vals[%d]  0x%x/%d\\n\", i, v, v);\n\t\tvals[i] = v;\n\t\tdata += sizeof(unsigned int);\n\t}\n\n\tif (index >= MAX_CW) {\n\t\tint i, j;\n\n\t\t/* FIXME, circular, etc. */\n\t\tfor (i=0; i<2; i++) {\n\t\t\tj = MAX_CW - 2 + i;\n\t\t\tcw_events[i].win = cw_events[j].win;\n\t\t\tcw_events[i].x = cw_events[j].x;\n\t\t\tcw_events[i].y = cw_events[j].y;\n\t\t\tcw_events[i].w = cw_events[j].w;\n\t\t\tcw_events[i].h = cw_events[j].h;\n\t\t}\n\t\tindex = 2;\n\t}\n\n\tif (! f_x && ! f_y) {\n\t\t/* netscape 4.x style  CWWidth,CWHeight */\n\t\tvals[2] = vals[0];\n\t\tvals[3] = vals[1];\n\t\tvals[0] = 0;\n\t\tvals[1] = 0;\n\t}\n\n\tcw_events[index].win = req->window;\n\n\tif (! f_x) {\n\t\tcw_events[index].x = absent;\n\t} else {\n\t\tcw_events[index].x = (int) vals[0];\n\t}\n\tif (! f_y) {\n\t\tcw_events[index].y = absent;\n\t} else {\n\t\tcw_events[index].y = (int) vals[1];\n\t}\n\n\tif (! f_w) {\n\t\tcw_events[index].w = absent;\n\t} else {\n\t\tcw_events[index].w = (int) vals[2];\n\t}\n\tif (! f_h) {\n\t\tcw_events[index].h = absent;\n\t} else {\n\t\tcw_events[index].h = (int) vals[3];\n\t}\n\n\tx = cw_events[index].x;\n\ty = cw_events[index].y;\n\tw = cw_events[index].w;\n\th = cw_events[index].h;\n\twin = cw_events[index].win;\n\nif (dba || db) fprintf(stderr, \"  record_CW ind: %d win: 0x%lx x: %d y: %d w: %d h: %d\\n\",\n\tindex, win, x, y, w, h);\n\n\tindex++;\n\n\tif (index < 3) {\n\t\tgood = 0;\n\t} else if (w != absent && h != absent &&\n\t    w*h < scrollcopyrect_min_area) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tmatch = 0;\n\tfor (j=index - 1; j >= 0; j--) {\n\t\tif (cw_events[j].win == win) {\n\t\t\tlist[match++] = j;\n\t\t}\n\t\tif (match >= 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (match != 3) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n/*\n\nMozilla:\n\nUp arrow: window moves down a bit (dy > 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 -18,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 3, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 0,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 65579,  v5 0,  v6 108009, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\nDown arrow: window moves up a bit (dy < 0):\n\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 906,  v4 327692,  v5 48234701,  v6 262147, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n X_ConfigureWindow \n    length: 5, window: 0x2e000cd, mask: 0x3, v0 0,  v1 -18,  v2 506636,  v3 48234701,  v4 48234511, \n        CW-mask: CWX,CWY,\n X_ConfigureWindow \n    length: 7, window: 0x2e000cd, mask: 0xf, v0 0,  v1 0,  v2 760,  v3 888,  v4 96555,  v5 48265642,  v6 48265262, \n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nNetscape 4.x\n\nUp arrow:\n71.76142   0.01984 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 -15,  v2 785,  v3 882,  v4 327692,  v5 159384712,  v6 1769484,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n71.76153   0.00011 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 867,  v2 329228,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n71.76157   0.00003 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 0,  v2 131132,  v3 159385313,  v4 328759,\n        CW-mask: CWX,CWY,\n                         XXX,XXX\n\nDown arrow:\n72.93147   0.01990 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0xc, v0 785,  v1 882,  v2 328972,  v3 159384712,  v4 159383555,\n        CW-mask:       CWWidth,CWHeight,\n                XXX,XXX\n72.93156   0.00009 X_ConfigureWindow\n    length: 5, window: 0x9800488, mask: 0x3, v0 0,  v1 -15,  v2 458764,  v3 159384712,  v4 159383567,\n        CW-mask: CWX,CWY,\n72.93160   0.00004 X_ConfigureWindow\n    length: 7, window: 0x9800488, mask: 0xf, v0 0,  v1 0,  v2 785,  v3 867,  v4 131132,  v5 159385335,  v6 328759,\n        CW-mask: CWX,CWY,CWWidth,CWHeight,\n\n\nsadly, probably need to handle some more...\n\n */\n\tx0 = cw_events[list[2]].x;\n\ty0 = cw_events[list[2]].y;\n\tw0 = cw_events[list[2]].w;\n\th0 = cw_events[list[2]].h;\n\n\tx1 = cw_events[list[1]].x;\n\ty1 = cw_events[list[1]].y;\n\tw1 = cw_events[list[1]].w;\n\th1 = cw_events[list[1]].h;\n\n\tx2 = cw_events[list[0]].x;\n\ty2 = cw_events[list[0]].y;\n\tw2 = cw_events[list[0]].w;\n\th2 = cw_events[list[0]].h;\n\n\t/* see NS4 XXX's above: */\n\tif (w2 == absent || h2 == absent) {\n\t\t/* up arrow */\n\t\tif (w2 == absent) {\n\t\t\tw2 = w1;\n\t\t}\n\t\tif (h2 == absent) {\n\t\t\th2 = h1;\n\t\t}\n\t}\n\tif (x1 == absent || y1 == absent) {\n\t\t/* up arrow */\n\t\tif (x1 == absent) {\n\t\t\tx1 = x2;\n\t\t}\n\t\tif (y1 == absent) {\n\t\t\ty1 = y2;\n\t\t}\n\t}\n\tif (x0 == absent || y0 == absent) {\n\t\t/* down arrow */\n\t\tif (x0 == absent) {\n\t\t\t/* hmmm... what to do */\n\t\t\tx0 = x2;\n\t\t}\n\t\tif (y0 == absent) {\n\t\t\ty0 = y2;\n\t\t}\n\t}\n\nif (dba) fprintf(stderr, \"%d/%d/%d/%d  %d/%d/%d/%d  %d/%d/%d/%d\\n\", x0, y0, w0, h0, x1, y1, w1, h1, x2, y2, w2, h2);\n\n\tdy = y1 - y0;\n\tdx = x1 - x0;\n\n\tsrc_x = x2;\n\tsrc_y = y2;\n\tw = w2;\n\th = h2;\n\n\t/* check w and h before we modify them */\n\tif (w <= 0 || h <= 0) {\n\t\tgood = 0;\n\t} else if (w == absent || h == absent) {\n\t\tgood = 0;\n\t}\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (dy > 0) {\n\t\th -= dy;\t\n\t} else {\n\t\th += dy;\t\n\t\tsrc_y -= dy;\n\t}\n\tif (dx > 0) {\n\t\tw -= dx;\t\n\t} else {\n\t\tw += dx;\t\n\t\tsrc_x -= dx;\n\t}\n\n\tdst_x = src_x + dx;\n\tdst_y = src_y + dy;\n\n\tif (x0 == absent || x1 == absent || x2 == absent) {\n\t\tgood = 0;\n\t} else if (y0 == absent || y1 == absent || y2 == absent) {\n\t\tgood = 0;\n\t} else if (dx != 0 && dy != 0) {\n\t\tgood = 0;\n\t} else if (w0 - w2 != nabs(dx)) {\n\t\tgood = 0;\n\t} else if (h0 - h2 != nabs(dy)) {\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tgood = 0;\n\t}\n\n\tif (! good) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\t/*\n\t * geometry OK.\n\t * after all of the above succeeds, now contact X server.\n\t */\n\tif (lookup_attr_cache(win, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\nif (0) fprintf(stderr, \"lookup_attr_cache hit:  %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t} else {\n\t\tvalid = valid_window(win, &attr, 1);\n\nif (0) fprintf(stderr, \"lookup_attr_cache MISS: %2d %2d 0x%lx %d\\n\",\n    cache_index, next_index, win, valid);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(win, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = win;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CW-%d\\n\", k++);\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CW-%d *FOUND_SCROLL: win: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d  st: %.4f  dt: %.4f  %.4f\\n\", k++, win,\n\tdx, dy, src_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = win;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\t/* indicate we have a new one */\n\tscr_ev_cnt++;\n\n\tindex = 0;\n}"
  },
  {
    "function_name": "record_CA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "535-844",
    "snippet": "static void record_CA(XPointer ptr, XRecordInterceptData *rec_data) {\n\txCopyAreaReq *req;\n\tWindow src = None, dst = None, c;\n\tXWindowAttributes attr, attr2;\n\tint src_x, src_y, dst_x, dst_y, rx, ry, rx2, ry2;\n\tint good = 1, dx = 0, dy = 0, k=0, i;\n\tunsigned int w, h;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\tstatic int must_equal = -1;\n\n\tif (dba || db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xCopyAreaReq *) rec_data->data;\n\t\t\tif (req->reqType == X_CopyArea) {\n\t\t\t\tsrc = req->srcDrawable;\n\t\t\t\tdst = req->dstDrawable;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\treq = (xCopyAreaReq *) rec_data->data;\n\n\tif (req->reqType != X_CopyArea) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (must_equal < 0) {\n\t\tmust_equal = 0;\n\t\tif (getenv(\"X11VNC_SCROLL_MUST_EQUAL\")) {\n\t\t\tmust_equal = 1;\n\t\t}\n\t}\n\n/*\n\nxterm, gnome-terminal, others.\n\nNote we miss the X_ImageText8 that clears the block cursor.  So there is a\nshort period of time with a painting error: two cursors, one above the other.\n\n X_ImageText8 \n    draw: 0x8c00017 nChars: 1, gc: 0x8c00013, x: 101, y: 585, chars=' '\n X_ClearArea \n    window: 0x8c00018, x:   2, y: 217, w:  10, h:   5\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000a, shape: 0, coordMode: 0,\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000b, shape: 0, coordMode: 0,\n X_CopyArea \n    src: 0x8c00017, dst: 0x8c00017, gc: 0x8c00013, srcX:  17, srcY:  15, dstX:  17, dstY:   2, w: 480, h: 572\n X_ChangeWindowAttributes \n X_ClearArea \n    window: 0x8c00017, x:  17, y: 574, w: 480, h:  13\n X_ChangeWindowAttributes \n\n */\n\n\tsrc = req->srcDrawable;\n\tdst = req->dstDrawable;\n\tsrc_x = req->srcX;\n\tsrc_y = req->srcY;\n\tdst_x = req->dstX;\n\tdst_y = req->dstY;\n\tw = req->width;\n\th = req->height;\n\n\tif (w*h < (unsigned int) scrollcopyrect_min_area) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA scroll area too small.\\n\");\n\t\tgood = 0;\n\t} else if (!src || !dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null src or dst.\\n\");\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null too many scr events.\\n\");\n\t\tgood = 0;\n\t} else if (must_equal && src != dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA src not equal dst.\\n\");\n\t\tgood = 0;\n\t}\n\n\tif (src == dst) {\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\tgood = 0;\n\t\t}\n\t}\n\nif (!good && (dba || db > 1)) fprintf(stderr, \"record_CA-x src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\tif (! good) {\n\t\treturn;\n\t}\n\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\t/*\n\t * after all of the above succeeds, now contact X server.\n\t * we try to get away with some caching here.\n\t */\n\tif (lookup_attr_cache(src, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t} else {\n\t\tvalid = valid_window(src, &attr, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(src, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = src;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-1.\\n\");\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-1.\\n\");\n\t\treturn;\n\t}\n\n\t/* recent gdk/gtk windows use different src and dst. for compositing? */\n\tif (src != dst) {\n\t    if (lookup_attr_cache(dst, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr2.x = scr_attr_cache[i].x;\n\t\tattr2.y = scr_attr_cache[i].y;\n\t\tattr2.width = scr_attr_cache[i].width;\n\t\tattr2.height = scr_attr_cache[i].height;\n\t\tattr2.map_state = scr_attr_cache[i].map_state;\n\t\trx2 = scr_attr_cache[i].rx;\n\t\try2 = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t    } else {\n\t\tvalid = valid_window(dst, &attr2, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(dst, rootwin, 0, 0, &rx2, &ry2, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = dst;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr2.x;\n\t\t\t\tscr_attr_cache[i].y = attr2.y;\n\t\t\t\tscr_attr_cache[i].width = attr2.width;\n\t\t\t\tscr_attr_cache[i].height = attr2.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr2.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr2.depth;\n\t\t\t\tscr_attr_cache[i].class = attr2.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr2.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr2.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx2;\n\t\t\t\tscr_attr_cache[i].ry = ry2;\n\t\t\t}\n\t\t}\n\t    }\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-? src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\t\tif (! valid) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (attr2.map_state != IsViewable) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdst_x = dst_x - (rx - rx2);\n\t\tdst_y = dst_y - (ry - ry2);\n\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CA-%d *FOUND_SCROLL: src: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d st: %.4f %.4f  %.4f\\n\", k++, src, dx, dy,\n\tsrc_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = src;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\tscr_ev_cnt++;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SCR_EV_MAX 128"
    ],
    "globals_used": [
      "scroll_event_t scr_ev[SCR_EV_MAX];",
      "int scr_ev_cnt;",
      "int xrecording = 0;",
      "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
      "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);",
      "static XID xrecord_seq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d *FOUND_SCROLL: src: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d st: %.4f %.4f  %.4f\\n\"",
            "k++",
            "src",
            "dx",
            "dy",
            "src_x",
            "src_y",
            "w",
            "h",
            "st",
            "dt",
            "dnowx()"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA not viewable-2.\\n\""
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA not valid-2.\\n\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-? src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\"",
            "src_x",
            "src_y",
            "dst_x",
            "dst_y",
            "w",
            "h",
            "scr_ev_cnt",
            "src",
            "dst"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "dst",
            "rootwin",
            "0",
            "0",
            "&rx2",
            "&ry2",
            "&c",
            "1"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "dst",
            "&attr2",
            "1"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_attr_cache",
          "args": [
            "dst",
            "&cache_index",
            "&next_index"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_attr_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "466-528",
          "snippet": "static int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SCR_ATTR_CACHE 8"
          ],
          "globals_used": [
            "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
            "static double attr_cache_max_age = 1.5;",
            "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_ATTR_CACHE 8\n\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic double attr_cache_max_age = 1.5;\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\n\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA not viewable-1.\\n\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA not valid-1.\\n\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-x src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\"",
            "src_x",
            "src_y",
            "dst_x",
            "dst_y",
            "w",
            "h",
            "scr_ev_cnt",
            "src",
            "dst"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA src not equal dst.\\n\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA null too many scr events.\\n\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA null src or dst.\\n\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA scroll area too small.\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SCROLL_MUST_EQUAL\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d\\n\"",
            "k++"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"record_CA-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\"",
            "k++",
            "rec_data->id_base",
            "(unsigned long) ptr",
            "xrecord_seq",
            "rc_scroll",
            "rec_data->category",
            "rec_data->client_swapped",
            "src",
            "dst"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_EV_MAX 128\n\nscroll_event_t scr_ev[SCR_EV_MAX];\nint scr_ev_cnt;\nint xrecording = 0;\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\nstatic XID xrecord_seq = 0;\n\nstatic void record_CA(XPointer ptr, XRecordInterceptData *rec_data) {\n\txCopyAreaReq *req;\n\tWindow src = None, dst = None, c;\n\tXWindowAttributes attr, attr2;\n\tint src_x, src_y, dst_x, dst_y, rx, ry, rx2, ry2;\n\tint good = 1, dx = 0, dy = 0, k=0, i;\n\tunsigned int w, h;\n\tint dba = 0, db = debug_scroll;\n\tint cache_index, next_index, valid;\n\tstatic int must_equal = -1;\n\n\tif (dba || db) {\n\t\tif (rec_data->category == XRecordFromClient) {\n\t\t\treq = (xCopyAreaReq *) rec_data->data;\n\t\t\tif (req->reqType == X_CopyArea) {\n\t\t\t\tsrc = req->srcDrawable;\n\t\t\t\tdst = req->dstDrawable;\n\t\t\t}\n\t\t}\n\t}\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-%d id_base: 0x%lx  ptr: 0x%lx \"\n\t\"seq: 0x%lx rc: 0x%lx  cat: %d  swapped: %d 0x%lx/0x%lx\\n\", k++,\n\trec_data->id_base, (unsigned long) ptr, xrecord_seq, rc_scroll,\n\trec_data->category, rec_data->client_swapped, src, dst);\n\n\tif (! xrecording) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->id_base == 0) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif ((XID) ptr != xrecord_seq) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (rec_data->category != XRecordFromClient) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\treq = (xCopyAreaReq *) rec_data->data;\n\n\tif (req->reqType != X_CopyArea) {\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (must_equal < 0) {\n\t\tmust_equal = 0;\n\t\tif (getenv(\"X11VNC_SCROLL_MUST_EQUAL\")) {\n\t\t\tmust_equal = 1;\n\t\t}\n\t}\n\n/*\n\nxterm, gnome-terminal, others.\n\nNote we miss the X_ImageText8 that clears the block cursor.  So there is a\nshort period of time with a painting error: two cursors, one above the other.\n\n X_ImageText8 \n    draw: 0x8c00017 nChars: 1, gc: 0x8c00013, x: 101, y: 585, chars=' '\n X_ClearArea \n    window: 0x8c00018, x:   2, y: 217, w:  10, h:   5\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000a, shape: 0, coordMode: 0,\n X_FillPoly \n    draw: 0x8c00018 gc: 0x8c0000b, shape: 0, coordMode: 0,\n X_CopyArea \n    src: 0x8c00017, dst: 0x8c00017, gc: 0x8c00013, srcX:  17, srcY:  15, dstX:  17, dstY:   2, w: 480, h: 572\n X_ChangeWindowAttributes \n X_ClearArea \n    window: 0x8c00017, x:  17, y: 574, w: 480, h:  13\n X_ChangeWindowAttributes \n\n */\n\n\tsrc = req->srcDrawable;\n\tdst = req->dstDrawable;\n\tsrc_x = req->srcX;\n\tsrc_y = req->srcY;\n\tdst_x = req->dstX;\n\tdst_y = req->dstY;\n\tw = req->width;\n\th = req->height;\n\n\tif (w*h < (unsigned int) scrollcopyrect_min_area) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA scroll area too small.\\n\");\n\t\tgood = 0;\n\t} else if (!src || !dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null src or dst.\\n\");\n\t\tgood = 0;\n\t} else if (scr_ev_cnt >= SCR_EV_MAX) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA null too many scr events.\\n\");\n\t\tgood = 0;\n\t} else if (must_equal && src != dst) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA src not equal dst.\\n\");\n\t\tgood = 0;\n\t}\n\n\tif (src == dst) {\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\tgood = 0;\n\t\t}\n\t}\n\nif (!good && (dba || db > 1)) fprintf(stderr, \"record_CA-x src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\tif (! good) {\n\t\treturn;\n\t}\n\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\t/*\n\t * after all of the above succeeds, now contact X server.\n\t * we try to get away with some caching here.\n\t */\n\tif (lookup_attr_cache(src, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr.x = scr_attr_cache[i].x;\n\t\tattr.y = scr_attr_cache[i].y;\n\t\tattr.width = scr_attr_cache[i].width;\n\t\tattr.height = scr_attr_cache[i].height;\n\t\tattr.map_state = scr_attr_cache[i].map_state;\n\t\trx = scr_attr_cache[i].rx;\n\t\try = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t} else {\n\t\tvalid = valid_window(src, &attr, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(src, rootwin, 0, 0, &rx, &ry, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = src;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr.x;\n\t\t\t\tscr_attr_cache[i].y = attr.y;\n\t\t\t\tscr_attr_cache[i].width = attr.width;\n\t\t\t\tscr_attr_cache[i].height = attr.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr.depth;\n\t\t\t\tscr_attr_cache[i].class = attr.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx;\n\t\t\t\tscr_attr_cache[i].ry = ry;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! valid) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-1.\\n\");\n\t\treturn;\n\t}\nif (db > 1) fprintf(stderr, \"record_CA-%d\\n\", k++);\n\n\tif (attr.map_state != IsViewable) {\n\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-1.\\n\");\n\t\treturn;\n\t}\n\n\t/* recent gdk/gtk windows use different src and dst. for compositing? */\n\tif (src != dst) {\n\t    if (lookup_attr_cache(dst, &cache_index, &next_index)) {\n\t\ti = cache_index;\n\t\tattr2.x = scr_attr_cache[i].x;\n\t\tattr2.y = scr_attr_cache[i].y;\n\t\tattr2.width = scr_attr_cache[i].width;\n\t\tattr2.height = scr_attr_cache[i].height;\n\t\tattr2.map_state = scr_attr_cache[i].map_state;\n\t\trx2 = scr_attr_cache[i].rx;\n\t\try2 = scr_attr_cache[i].ry;\n\t\tvalid = scr_attr_cache[i].valid;\n\n\t    } else {\n\t\tvalid = valid_window(dst, &attr2, 1);\n\n\t\tif (valid) {\n\t\t\tif (!xtranslate(dst, rootwin, 0, 0, &rx2, &ry2, &c, 1)) {\n\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t\tif (next_index >= 0) {\n\t\t\ti = next_index;\n\t\t\tscr_attr_cache[i].win = dst;\n\t\t\tscr_attr_cache[i].fetched = 1;\n\t\t\tscr_attr_cache[i].valid = valid;\n\t\t\tscr_attr_cache[i].time = dnow();\n\t\t\tif (valid) {\n\t\t\t\tscr_attr_cache[i].x = attr2.x;\n\t\t\t\tscr_attr_cache[i].y = attr2.y;\n\t\t\t\tscr_attr_cache[i].width = attr2.width;\n\t\t\t\tscr_attr_cache[i].height = attr2.height;\n\t\t\t\tscr_attr_cache[i].border_width = attr2.border_width;\n\t\t\t\tscr_attr_cache[i].depth = attr2.depth;\n\t\t\t\tscr_attr_cache[i].class = attr2.class;\n\t\t\t\tscr_attr_cache[i].backing_store =\n\t\t\t\t    attr2.backing_store;\n\t\t\t\tscr_attr_cache[i].map_state = attr2.map_state;\n\n\t\t\t\tscr_attr_cache[i].rx = rx2;\n\t\t\t\tscr_attr_cache[i].ry = ry2;\n\t\t\t}\n\t\t}\n\t    }\n\nif (dba || db > 1) fprintf(stderr, \"record_CA-? src_x: %d src_y: %d \"\n\t\"dst_x: %d dst_y: %d w: %d h: %d scr_ev_cnt: %d 0x%lx/0x%lx\\n\",\n\tsrc_x, src_y, dst_x, dst_y, w, h, scr_ev_cnt, src, dst);\n\n\t\tif (! valid) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not valid-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (attr2.map_state != IsViewable) {\n\t\t\tif (db > 1) fprintf(stderr, \"record_CA not viewable-2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdst_x = dst_x - (rx - rx2);\n\t\tdst_y = dst_y - (ry - ry2);\n\n\t\tdx = dst_x - src_x;\n\t\tdy = dst_y - src_y;\n\n\t\tif (dx != 0 && dy != 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n if (0 || dba || db) {\n\tdouble st, dt;\n\tst = (double) rec_data->server_time/1000.0;\n\tdt = (dnow() - servertime_diff) - st;\n\tfprintf(stderr, \"record_CA-%d *FOUND_SCROLL: src: 0x%lx dx: %d dy: %d \"\n\t\"x: %d y: %d w: %d h: %d st: %.4f %.4f  %.4f\\n\", k++, src, dx, dy,\n\tsrc_x, src_y, w, h, st, dt, dnowx());\n }\n\n\ti = scr_ev_cnt;\n\n\tscr_ev[i].win = src;\n\tscr_ev[i].frame = None;\n\tscr_ev[i].dx = dx;\n\tscr_ev[i].dy = dy;\n\tscr_ev[i].x = rx + dst_x;\n\tscr_ev[i].y = ry + dst_y;\n\tscr_ev[i].w = w;\n\tscr_ev[i].h = h;\n\tscr_ev[i].t = ((double) rec_data->server_time)/1000.0;\n\tscr_ev[i].win_x = rx;\n\tscr_ev[i].win_y = ry;\n\tscr_ev[i].win_w = attr.width;\n\tscr_ev[i].win_h = attr.height;\n\tscr_ev[i].new_x = 0;\n\tscr_ev[i].new_y = 0;\n\tscr_ev[i].new_w = 0;\n\tscr_ev[i].new_h = 0;\n\n\tif (dx == 0) {\n\t\tif (dy > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = dy;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = ry + dst_y + h;\n\t\t\tscr_ev[i].new_w = w;\n\t\t\tscr_ev[i].new_h = -dy;\n\t\t}\n\t} else if (dy == 0) {\n\t\tif (dx > 0) {\n\t\t\tscr_ev[i].new_x = rx + src_x;\n\t\t\tscr_ev[i].new_y = rx + src_y;\n\t\t\tscr_ev[i].new_w = dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t} else {\n\t\t\tscr_ev[i].new_x = rx + dst_x + w;\n\t\t\tscr_ev[i].new_y = ry + src_y;\n\t\t\tscr_ev[i].new_w = -dx;\n\t\t\tscr_ev[i].new_h = h;\n\t\t}\n\t}\n\n\tscr_ev_cnt++;\n}"
  },
  {
    "function_name": "lookup_attr_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "466-528",
    "snippet": "static int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SCR_ATTR_CACHE 8"
    ],
    "globals_used": [
      "winattr_t scr_attr_cache[SCR_ATTR_CACHE];",
      "static double attr_cache_max_age = 1.5;",
      "static int lookup_attr_cache(Window win, int *cache_index, int *next_index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lookup_attr_cache count: %d\\n\"",
            "count"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&now"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SCR_ATTR_CACHE 8\n\nwinattr_t scr_attr_cache[SCR_ATTR_CACHE];\nstatic double attr_cache_max_age = 1.5;\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index);\n\nstatic int lookup_attr_cache(Window win, int *cache_index, int *next_index) {\n\tdouble now, t, oldest = 0.0;\n\tint i, old_index = -1, count = 0;\n\tWindow cwin;\n\n\t*cache_index = -1;\n\t*next_index  = -1;\n\t\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\tif (attr_cache_max_age == 0.0) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&now);\n\tfor (i=0; i < SCR_ATTR_CACHE; i++) {\n\n\t\tcwin = scr_attr_cache[i].win;\n\t\tt = scr_attr_cache[i].time;\n\n\t\tif (now > t + attr_cache_max_age) {\n\t\t\t/* expire it even if it is the one we want */\n\t\t\tscr_attr_cache[i].win = cwin = None;\n\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\tscr_attr_cache[i].valid = 0;\n\t\t}\n\n\t\tif (*next_index == -1 && cwin == None) {\n\t\t\t*next_index = i;\n\t\t}\n\t\tif (*next_index == -1) {\n\t\t\t/* record oldest */\n\t\t\tif (old_index == -1 || t < oldest) {\n\t\t\t\toldest = t;\n\t\t\t\told_index = i;\n\t\t\t}\n\t\t}\n\t\tif (cwin != None) {\n\t\t\tcount++;\n\t\t}\n\t\tif (cwin == win) {\n\t\t\tif (*cache_index == -1) {\n\t\t\t\t*cache_index = i;\n\t\t\t} else {\n\t\t\t\t/* remove dups */\n\t\t\t\tscr_attr_cache[i].win = None;\n\t\t\t\tscr_attr_cache[i].fetched = 0;\n\t\t\t\tscr_attr_cache[i].valid = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (*next_index == -1) {\n\t\t*next_index = old_index;\n\t}\n\nif (0) fprintf(stderr, \"lookup_attr_cache count: %d\\n\", count);\n\tif (*cache_index != -1) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "xrecord_scroll_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "443-464",
    "snippet": "int xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecord_skip_keysym(rfbKeySym keysym);",
      "int xrecord_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xrecord_emacs_scroll_keysym",
          "args": [
            "keysym"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_emacs_scroll_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "434-441",
          "snippet": "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_N || sym == XK_n || sym == XK_P || sym == XK_p) {\n\t\treturn 1;\t/* emacs */\n\t}\n\t/* Must be some more ... */\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecord_skip_keysym(rfbKeySym keysym);",
            "int xrecord_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_N || sym == XK_n || sym == XK_P || sym == XK_p) {\n\t\treturn 1;\t/* emacs */\n\t}\n\t/* Must be some more ... */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xrecord_vi_scroll_keysym",
          "args": [
            "keysym"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_vi_scroll_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "420-432",
          "snippet": "static int xrecord_vi_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_J || sym == XK_j || sym == XK_K || sym == XK_k) {\n\t\treturn 1;\t/* vi */\n\t}\n\tif (sym == XK_D || sym == XK_d || sym == XK_U || sym == XK_u) {\n\t\treturn 1;\t/* Ctrl-d/u */\n\t}\n\tif (sym == XK_Z || sym == XK_z) {\n\t\treturn 1;\t/* zz, zt, zb .. */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrecord_skip_keysym(rfbKeySym keysym);",
            "int xrecord_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
            "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_J || sym == XK_j || sym == XK_K || sym == XK_k) {\n\t\treturn 1;\t/* vi */\n\t}\n\tif (sym == XK_D || sym == XK_d || sym == XK_U || sym == XK_u) {\n\t\treturn 1;\t/* Ctrl-d/u */\n\t}\n\tif (sym == XK_Z || sym == XK_z) {\n\t\treturn 1;\t/* zz, zt, zb .. */\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nint xrecord_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\t/* X11/keysymdef.h */\n\n\tif (sym == XK_Return || sym == XK_KP_Enter || sym == XK_Linefeed) {\n\t\treturn 1;\t/* Enter */\n\t}\n\tif (sym==XK_Up || sym==XK_KP_Up || sym==XK_Down || sym==XK_KP_Down) {\n\t\treturn 1;\t/* U/D arrows */\n\t}\n\tif (sym == XK_Left || sym == XK_KP_Left || sym == XK_Right ||\n\t    sym == XK_KP_Right) {\n\t\treturn 1;\t/* L/R arrows */\n\t}\n\tif (xrecord_vi_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\tif (xrecord_emacs_scroll_keysym(keysym)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xrecord_emacs_scroll_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "434-441",
    "snippet": "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_N || sym == XK_n || sym == XK_P || sym == XK_p) {\n\t\treturn 1;\t/* emacs */\n\t}\n\t/* Must be some more ... */\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecord_skip_keysym(rfbKeySym keysym);",
      "int xrecord_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_N || sym == XK_n || sym == XK_P || sym == XK_p) {\n\t\treturn 1;\t/* emacs */\n\t}\n\t/* Must be some more ... */\n\treturn 0;\n}"
  },
  {
    "function_name": "xrecord_vi_scroll_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "420-432",
    "snippet": "static int xrecord_vi_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_J || sym == XK_j || sym == XK_K || sym == XK_k) {\n\t\treturn 1;\t/* vi */\n\t}\n\tif (sym == XK_D || sym == XK_d || sym == XK_U || sym == XK_u) {\n\t\treturn 1;\t/* Ctrl-d/u */\n\t}\n\tif (sym == XK_Z || sym == XK_z) {\n\t\treturn 1;\t/* zz, zt, zb .. */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecord_skip_keysym(rfbKeySym keysym);",
      "int xrecord_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tif (sym == XK_J || sym == XK_j || sym == XK_K || sym == XK_k) {\n\t\treturn 1;\t/* vi */\n\t}\n\tif (sym == XK_D || sym == XK_d || sym == XK_U || sym == XK_u) {\n\t\treturn 1;\t/* Ctrl-d/u */\n\t}\n\tif (sym == XK_Z || sym == XK_z) {\n\t\treturn 1;\t/* zz, zt, zb .. */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xrecord_skip_button",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "413-418",
    "snippet": "int xrecord_skip_button(int new_button, int old) {\n\t/* unused vars warning: */\n\tif (new_button || old) {}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecord_skip_button(int newb, int old);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_button(int newb, int old);\n\nint xrecord_skip_button(int new_button, int old) {\n\t/* unused vars warning: */\n\tif (new_button || old) {}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xrecord_skip_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "342-411",
    "snippet": "int xrecord_skip_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tint ok = -1, matched = 0;\n\n\tif (scroll_key_list) {\n\t\tint k, exclude = 0;\n\t\tif (scroll_key_list[0]) {\n\t\t\texclude = 1;\n\t\t}\n\t\tk = 1;\n\t\twhile (scroll_key_list[k] != NoSymbol) {\n\t\t\tif (scroll_key_list[k++] == sym) {\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (exclude) {\n\t\t\tif (matched) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (matched) {\n\t\t\t\tok = 1;\n\t\t\t} else {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (ok == 1) {\n\t\treturn 0;\n\t} else if (ok == 0) {\n\t\treturn 1;\n\t}\n\n\t/* apply various heuristics: */\n\n\tif (IsModifierKey(sym)) {\n\t\t/* Shift, Control, etc, usu. generate no scrolls */\n\t\treturn 1;\n\t}\n\tif (sym == XK_space && scroll_term) {\n\t\t/* space in a terminal is usu. full page... */\n\t\tWindow win;\n\t\tstatic Window prev_top = None;\n\t\tint size = 256;\n\t\tstatic char name[256];\n\n\t\tX_LOCK;\n\t\twin = query_pointer(rootwin);\n\t\tX_UNLOCK;\n\t\tif (win != None && win != rootwin) {\n\t\t\tif (prev_top != None && win == prev_top) {\n\t\t\t\t;\t/* use cached result */\n\t\t\t} else {\n\t\t\t\tprev_top = win;\n\t\t\t\tX_LOCK;\n\t\t\t\twin = descend_pointer(6, win, name, size);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (match_str_list(name, scroll_term)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* TBD use typing_rate() so */\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrecord_skip_keysym(rfbKeySym keysym);",
      "int xrecord_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_vi_scroll_keysym(rfbKeySym keysym);",
      "static int xrecord_emacs_scroll_keysym(rfbKeySym keysym);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_str_list",
          "args": [
            "name",
            "scroll_term"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "match_str_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "353-370",
          "snippet": "int match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int match_str_list(char *str, char **list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint match_str_list(char *str, char **list);\n\nint match_str_list(char *str, char **list) {\n\tint i = 0, matched = 0;\n\n\tif (! str || ! list) {\n\t\treturn 0;\n\t}\n\twhile (list[i] != NULL) {\n\t\tif (!strcmp(list[i], \"*\")) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t} else if (strstr(str, list[i])) {\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "descend_pointer",
          "args": [
            "6",
            "win",
            "name",
            "size"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "descend_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "480-598",
          "snippet": "Window descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_pointer",
          "args": [
            "rootwin"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "query_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "355-384",
          "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsModifierKey",
          "args": [
            "sym"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xrecord_skip_keysym(rfbKeySym keysym);\nint xrecord_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_vi_scroll_keysym(rfbKeySym keysym);\nstatic int xrecord_emacs_scroll_keysym(rfbKeySym keysym);\n\nint xrecord_skip_keysym(rfbKeySym keysym) {\n\tKeySym sym = (KeySym) keysym;\n\tint ok = -1, matched = 0;\n\n\tif (scroll_key_list) {\n\t\tint k, exclude = 0;\n\t\tif (scroll_key_list[0]) {\n\t\t\texclude = 1;\n\t\t}\n\t\tk = 1;\n\t\twhile (scroll_key_list[k] != NoSymbol) {\n\t\t\tif (scroll_key_list[k++] == sym) {\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (exclude) {\n\t\t\tif (matched) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (matched) {\n\t\t\t\tok = 1;\n\t\t\t} else {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (ok == 1) {\n\t\treturn 0;\n\t} else if (ok == 0) {\n\t\treturn 1;\n\t}\n\n\t/* apply various heuristics: */\n\n\tif (IsModifierKey(sym)) {\n\t\t/* Shift, Control, etc, usu. generate no scrolls */\n\t\treturn 1;\n\t}\n\tif (sym == XK_space && scroll_term) {\n\t\t/* space in a terminal is usu. full page... */\n\t\tWindow win;\n\t\tstatic Window prev_top = None;\n\t\tint size = 256;\n\t\tstatic char name[256];\n\n\t\tX_LOCK;\n\t\twin = query_pointer(rootwin);\n\t\tX_UNLOCK;\n\t\tif (win != None && win != rootwin) {\n\t\t\tif (prev_top != None && win == prev_top) {\n\t\t\t\t;\t/* use cached result */\n\t\t\t} else {\n\t\t\t\tprev_top = win;\n\t\t\t\tX_LOCK;\n\t\t\t\twin = descend_pointer(6, win, name, size);\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t\tif (match_str_list(name, scroll_term)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* TBD use typing_rate() so */\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_xrecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "285-340",
    "snippet": "void shutdown_xrecord(void) {\n#if HAVE_RECORD\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t}\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = NULL;\n\trr_CW = NULL;\n\trr_GS = NULL;\n\n\tX_LOCK;\n\tif (rdpy_ctrl && rc_scroll) {\n\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\tXRecordFreeContext(rdpy_ctrl, rc_scroll);\n\t\tXSync(rdpy_ctrl, False);\n\t\trc_scroll = 0;\n\t}\n\t\t\n\tif (gdpy_ctrl && rc_grab) {\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXSync(gdpy_ctrl, False);\n\t\trc_grab = 0;\n\t}\n\t\t\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\tX_UNLOCK;\n#endif\n\tuse_xrecord = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord-done: %.5f\\n\", dnowx());\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *rdpy_data = NULL;",
      "Display *rdpy_ctrl = NULL;",
      "Display *gdpy_ctrl = NULL;",
      "Display *gdpy_data = NULL;",
      "int xserver_grabbed = 0;",
      "void shutdown_xrecord(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shutdown_xrecord-done: %.5f\\n\"",
            "dnowx()"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "gdpy_ctrl"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "gdpy_ctrl",
            "False"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordFreeContext",
          "args": [
            "gdpy_ctrl",
            "rc_grab"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordDisableContext",
          "args": [
            "gdpy_ctrl",
            "rc_grab"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "rdpy_ctrl",
            "False"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordFreeContext",
          "args": [
            "rdpy_ctrl",
            "rc_scroll"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordDisableContext",
          "args": [
            "rdpy_ctrl",
            "rc_scroll"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "rr_GS"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shutdown_xrecord%d %.5f\\n\"",
            "xserver_grabbed",
            "dnowx()"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nvoid shutdown_xrecord(void);\n\nvoid shutdown_xrecord(void) {\n#if HAVE_RECORD\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t}\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = NULL;\n\trr_CW = NULL;\n\trr_GS = NULL;\n\n\tX_LOCK;\n\tif (rdpy_ctrl && rc_scroll) {\n\t\tXRecordDisableContext(rdpy_ctrl, rc_scroll);\n\t\tXRecordFreeContext(rdpy_ctrl, rc_scroll);\n\t\tXSync(rdpy_ctrl, False);\n\t\trc_scroll = 0;\n\t}\n\t\t\n\tif (gdpy_ctrl && rc_grab) {\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXSync(gdpy_ctrl, False);\n\t\trc_grab = 0;\n\t}\n\t\t\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\tX_UNLOCK;\n#endif\n\tuse_xrecord = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"shutdown_xrecord-done: %.5f\\n\", dnowx());\n\t}\n}"
  },
  {
    "function_name": "initialize_xrecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "187-283",
    "snippet": "void initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *rdpy_data = NULL;",
      "Display *rdpy_ctrl = NULL;",
      "Display *gdpy_ctrl = NULL;",
      "Display *gdpy_data = NULL;",
      "int xserver_grabbed = 0;",
      "void initialize_xrecord(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xrecord_grabserver",
          "args": [
            "1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "xrecord_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "118-178",
          "snippet": "static void xrecord_grabserver(int start) {\n\tXErrorHandler old_handler = NULL;\n\tint rc = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver%d/%d %.5f\\n\",\n\t\t\txserver_grabbed, start, dnowx());\n\t}\n\n\tif (! gdpy_ctrl || ! gdpy_data) {\n\t\treturn;\n\t}\n#if HAVE_RECORD\n\tif (!start) {\n\t\tif (! rc_grab) {\n\t\t\treturn;\n\t\t}\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXFlush_wr(gdpy_ctrl);\n\t\trc_grab = 0;\n\t\treturn;\n\t}\n\n\txserver_grabbed = 0;\n\n\trr_grab[0] = rr_GS;\n\trcs_grab = XRecordAllClients;\n\n\trc_grab = XRecordCreateContext(gdpy_ctrl, 0, &rcs_grab, 1, rr_grab, 1);\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tXSync(gdpy_ctrl, True);\n\n\tif (! rc_grab || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\trc = XRecordEnableContextAsync(gdpy_data, rc_grab, record_grab, NULL);\n\tif (!rc || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\tXFlush_wr(gdpy_data);\n\tXSetErrorHandler(old_handler);\n#else\n\tif (!rc || !old_handler) {}\n#endif\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver-done: %.5f\\n\", dnowx());\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "static void xrecord_grabserver(int start);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void xrecord_grabserver(int start);\n\nstatic void xrecord_grabserver(int start) {\n\tXErrorHandler old_handler = NULL;\n\tint rc = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver%d/%d %.5f\\n\",\n\t\t\txserver_grabbed, start, dnowx());\n\t}\n\n\tif (! gdpy_ctrl || ! gdpy_data) {\n\t\treturn;\n\t}\n#if HAVE_RECORD\n\tif (!start) {\n\t\tif (! rc_grab) {\n\t\t\treturn;\n\t\t}\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXFlush_wr(gdpy_ctrl);\n\t\trc_grab = 0;\n\t\treturn;\n\t}\n\n\txserver_grabbed = 0;\n\n\trr_grab[0] = rr_GS;\n\trcs_grab = XRecordAllClients;\n\n\trc_grab = XRecordCreateContext(gdpy_ctrl, 0, &rcs_grab, 1, rr_grab, 1);\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tXSync(gdpy_ctrl, True);\n\n\tif (! rc_grab || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\trc = XRecordEnableContextAsync(gdpy_data, rc_grab, record_grab, NULL);\n\tif (!rc || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\tXFlush_wr(gdpy_data);\n\tXSetErrorHandler(old_handler);\n#else\n\tif (!rc || !old_handler) {}\n#endif\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver-done: %.5f\\n\", dnowx());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_grabserver",
          "args": [
            "gdpy_data",
            "0"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "disable_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1313-1372",
          "snippet": "void disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void disable_grabserver(Display *in_dpy, int change);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid disable_grabserver(Display *in_dpy, int change);\n\nvoid disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"gdpy_data open failed\\n\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "DisplayString(dpy)"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "gdpy_ctrl",
            "True"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"gdpy_ctrl open failed\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "gdpy_ctrl"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rdpy_data open failed\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "rdpy_ctrl",
            "True"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rdpy_ctrl open failed: %s / %s / %s / %s\\n\"",
            "getenv(\"DISPLAY\")",
            "DisplayString(dpy)",
            "getenv(\"XAUTHORITY\")",
            "getenv(\"XAUTHORIT_\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORIT_\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordAllocRange",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordAllocRange",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordAllocRange",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "rr_GS"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nvoid initialize_xrecord(void);\n\nvoid initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}"
  },
  {
    "function_name": "zerodisp_xrecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "180-185",
    "snippet": "void zerodisp_xrecord(void) {\n\trdpy_data = NULL;\n\trdpy_ctrl = NULL;\n\tgdpy_data = NULL;\n\tgdpy_ctrl = NULL;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *rdpy_data = NULL;",
      "Display *rdpy_ctrl = NULL;",
      "Display *gdpy_ctrl = NULL;",
      "Display *gdpy_data = NULL;",
      "void zerodisp_xrecord(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nvoid zerodisp_xrecord(void);\n\nvoid zerodisp_xrecord(void) {\n\trdpy_data = NULL;\n\trdpy_ctrl = NULL;\n\tgdpy_data = NULL;\n\tgdpy_ctrl = NULL;\n}"
  },
  {
    "function_name": "xrecord_grabserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "118-178",
    "snippet": "static void xrecord_grabserver(int start) {\n\tXErrorHandler old_handler = NULL;\n\tint rc = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver%d/%d %.5f\\n\",\n\t\t\txserver_grabbed, start, dnowx());\n\t}\n\n\tif (! gdpy_ctrl || ! gdpy_data) {\n\t\treturn;\n\t}\n#if HAVE_RECORD\n\tif (!start) {\n\t\tif (! rc_grab) {\n\t\t\treturn;\n\t\t}\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXFlush_wr(gdpy_ctrl);\n\t\trc_grab = 0;\n\t\treturn;\n\t}\n\n\txserver_grabbed = 0;\n\n\trr_grab[0] = rr_GS;\n\trcs_grab = XRecordAllClients;\n\n\trc_grab = XRecordCreateContext(gdpy_ctrl, 0, &rcs_grab, 1, rr_grab, 1);\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tXSync(gdpy_ctrl, True);\n\n\tif (! rc_grab || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\trc = XRecordEnableContextAsync(gdpy_data, rc_grab, record_grab, NULL);\n\tif (!rc || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\tXFlush_wr(gdpy_data);\n\tXSetErrorHandler(old_handler);\n#else\n\tif (!rc || !old_handler) {}\n#endif\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver-done: %.5f\\n\", dnowx());\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Display *gdpy_ctrl = NULL;",
      "Display *gdpy_data = NULL;",
      "int xserver_grabbed = 0;",
      "static void xrecord_grabserver(int start);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xrecord_grabserver-done: %.5f\\n\"",
            "dnowx()"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "gdpy_data"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "gdpy_data"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRecordEnableContextAsync",
          "args": [
            "gdpy_data",
            "rc_grab",
            "record_grab",
            "NULL"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "gdpy_ctrl",
            "True"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordCreateContext",
          "args": [
            "gdpy_ctrl",
            "0",
            "&rcs_grab",
            "1",
            "rr_grab",
            "1"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordFreeContext",
          "args": [
            "gdpy_ctrl",
            "rc_grab"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRecordDisableContext",
          "args": [
            "gdpy_ctrl",
            "rc_grab"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xrecord_grabserver%d/%d %.5f\\n\"",
            "xserver_grabbed",
            "start",
            "dnowx()"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nstatic void xrecord_grabserver(int start);\n\nstatic void xrecord_grabserver(int start) {\n\tXErrorHandler old_handler = NULL;\n\tint rc = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver%d/%d %.5f\\n\",\n\t\t\txserver_grabbed, start, dnowx());\n\t}\n\n\tif (! gdpy_ctrl || ! gdpy_data) {\n\t\treturn;\n\t}\n#if HAVE_RECORD\n\tif (!start) {\n\t\tif (! rc_grab) {\n\t\t\treturn;\n\t\t}\n\t\tXRecordDisableContext(gdpy_ctrl, rc_grab);\n\t\tXRecordFreeContext(gdpy_ctrl, rc_grab);\n\t\tXFlush_wr(gdpy_ctrl);\n\t\trc_grab = 0;\n\t\treturn;\n\t}\n\n\txserver_grabbed = 0;\n\n\trr_grab[0] = rr_GS;\n\trcs_grab = XRecordAllClients;\n\n\trc_grab = XRecordCreateContext(gdpy_ctrl, 0, &rcs_grab, 1, rr_grab, 1);\n\ttrapped_record_xerror = 0;\n\told_handler = XSetErrorHandler(trap_record_xerror);\n\n\tXSync(gdpy_ctrl, True);\n\n\tif (! rc_grab || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\trc = XRecordEnableContextAsync(gdpy_data, rc_grab, record_grab, NULL);\n\tif (!rc || trapped_record_xerror) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_ctrl = NULL;\n\t\tgdpy_data = NULL;\n\t\tXSetErrorHandler(old_handler);\n\t\treturn;\n\t}\n\tXFlush_wr(gdpy_data);\n\tXSetErrorHandler(old_handler);\n#else\n\tif (!rc || !old_handler) {}\n#endif\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"xrecord_grabserver-done: %.5f\\n\", dnowx());\n\t}\n}"
  },
  {
    "function_name": "trap_record_xerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
    "lines": "109-116",
    "snippet": "int trap_record_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_record_xerror = 1;\n\ttrapped_record_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"scrollevent_t.h\"",
      "#include \"winattr_t.h\"",
      "#include \"userinput.h\"",
      "#include \"cleanup.h\"",
      "#include \"win_utils.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_record_xerror(Display *, XErrorEvent *);",
      "static XErrorEvent *trapped_record_xerror_event;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_record_xerror(Display *, XErrorEvent *);\nstatic XErrorEvent *trapped_record_xerror_event;\n\nint trap_record_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_record_xerror = 1;\n\ttrapped_record_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}"
  }
]