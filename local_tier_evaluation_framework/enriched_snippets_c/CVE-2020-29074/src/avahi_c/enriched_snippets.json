[
  {
    "function_name": "avahi_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "407-431",
    "snippet": "void avahi_cleanup(void) {\nif (db) fprintf(stderr, \"in  avahi_cleanup\\n\");\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_cleanup client null\\n\");\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"    avahi_cleanup poll_lock\\n\");\n\tavahi_threaded_poll_lock(_poll);\nif (db) fprintf(stderr, \"    avahi_cleanup poll_stop\\n\");\n\n\tsignal(SIGALRM, avahi_timeout);\n\talarm(3);\n\tavahi_threaded_poll_stop(_poll);\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\nif (db) fprintf(stderr, \"    avahi_cleanup client_free\\n\");\n\tavahi_client_free(_client);\n\t_client = NULL;\n\nif (db) fprintf(stderr, \"    avahi_cleanup poll_free\\n\");\n\tavahi_threaded_poll_free(_poll);\n\t_poll = NULL;\nif (db) fprintf(stderr, \"out avahi_cleanup\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_cleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out avahi_cleanup\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_free",
          "args": [
            "_poll"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_cleanup poll_free\\n\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_client_free",
          "args": [
            "_client"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_cleanup client_free\\n\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "0"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_stop",
          "args": [
            "_poll"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "avahi_timeout"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_cleanup poll_stop\\n\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_lock",
          "args": [
            "_poll"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_cleanup poll_lock\\n\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_cleanup client null\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  avahi_cleanup\\n\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_cleanup(void);\n\nvoid avahi_cleanup(void) {\nif (db) fprintf(stderr, \"in  avahi_cleanup\\n\");\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_cleanup client null\\n\");\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"    avahi_cleanup poll_lock\\n\");\n\tavahi_threaded_poll_lock(_poll);\nif (db) fprintf(stderr, \"    avahi_cleanup poll_stop\\n\");\n\n\tsignal(SIGALRM, avahi_timeout);\n\talarm(3);\n\tavahi_threaded_poll_stop(_poll);\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\nif (db) fprintf(stderr, \"    avahi_cleanup client_free\\n\");\n\tavahi_client_free(_client);\n\t_client = NULL;\n\nif (db) fprintf(stderr, \"    avahi_cleanup poll_free\\n\");\n\tavahi_threaded_poll_free(_poll);\n\t_poll = NULL;\nif (db) fprintf(stderr, \"out avahi_cleanup\\n\");\n}"
  },
  {
    "function_name": "avahi_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "401-404",
    "snippet": "static void avahi_timeout (int sig) {\n\trfbLog(\"sig: %d, avahi_cleanup timed out.\\n\", sig);\n\texit(1);\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_cleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sig: %d, avahi_cleanup timed out.\\n\"",
            "sig"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_cleanup(void);\n\nstatic void avahi_timeout (int sig) {\n\trfbLog(\"sig: %d, avahi_cleanup timed out.\\n\", sig);\n\texit(1);\n}"
  },
  {
    "function_name": "avahi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "379-399",
    "snippet": "void avahi_reset(void) {\n\tint i;\nif (db) fprintf(stderr, \"in  avahi_reset\\n\");\n\tfor (i=0; i<NREG; i++) {\n\t\tif (registered[i].name) {\n\t\t\tfree(registered[i].name);\n\t\t\tregistered[i].name = NULL;\n\t\t}\n\t\tif (registered[i].host) {\n\t\t\tfree(registered[i].host);\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t}\n\tif (!_client || !_group) {\nif (db) fprintf(stderr, \"    avahi_reset client/group null\\n\");\n\t\treturn;\n\t}\n\tavahi_entry_group_reset(_group);\n\trfbLog(\"Avahi resetting group.\\n\");\nif (db) fprintf(stderr, \"out avahi_reset\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NREG 16"
    ],
    "globals_used": [
      "void avahi_reset(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out avahi_reset\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Avahi resetting group.\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_entry_group_reset",
          "args": [
            "_group"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_reset client/group null\\n\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "registered[i].host"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  avahi_reset\\n\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_reset(void);\n\nvoid avahi_reset(void) {\n\tint i;\nif (db) fprintf(stderr, \"in  avahi_reset\\n\");\n\tfor (i=0; i<NREG; i++) {\n\t\tif (registered[i].name) {\n\t\t\tfree(registered[i].name);\n\t\t\tregistered[i].name = NULL;\n\t\t}\n\t\tif (registered[i].host) {\n\t\t\tfree(registered[i].host);\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t}\n\tif (!_client || !_group) {\nif (db) fprintf(stderr, \"    avahi_reset client/group null\\n\");\n\t\treturn;\n\t}\n\tavahi_entry_group_reset(_group);\n\trfbLog(\"Avahi resetting group.\\n\");\nif (db) fprintf(stderr, \"out avahi_reset\\n\");\n}"
  },
  {
    "function_name": "avahi_advertise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "331-377",
    "snippet": "void avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NREG 16"
    ],
    "globals_used": [
      "void avahi_advertise(char *name, char *host, uint16_t port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out avahi_advertise\\n\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_unlock",
          "args": [
            "_poll"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_avahi_create_services",
          "args": [
            "name",
            "host",
            "port >= 5900 ? port : 5900+port"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "_avahi_create_services",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "294-329",
          "snippet": "static void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void avahi_advertise(char *name, char *host, uint16_t port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nstatic void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_lock",
          "args": [
            "_poll"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_advertise already did this one\\n\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "registered[i].host",
            "host"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "registered[i].name",
            "name"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Avahi poll not initialized.\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_advertise client null\\n\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  avahi_advertise: '%s' '%s' %d\\n\"",
            "name",
            "host",
            "port"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "t"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_PORT\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_HOST\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_NAME\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nvoid avahi_advertise(char *name, char *host, uint16_t port) {\n\tint i;\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\nif (db) fprintf(stderr, \"in  avahi_advertise: '%s' '%s' %d\\n\", name, host, port);\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_advertise client null\\n\");\n\t\treturn;\n\t}\n\tif (_poll == NULL) {\n\t\trfbLog(\"Avahi poll not initialized.\\n\");\n\t\treturn;\n\t}\n\t/* well, we just track it ourselves... */\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].name, name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(registered[i].host, host)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (registered[i].port != port) {\n\t\t\tcontinue;\n\t\t}\nif (db) fprintf(stderr, \"    avahi_advertise already did this one\\n\");\n\t\treturn;\n\t}\n\tfor (i=0; i<NREG; i++) {\n\t\tif (!registered[i].name) {\n\t\t\tregistered[i].name = strdup(name);\n\t\t\tregistered[i].host = strdup(host);\n\t\t\tregistered[i].port = port;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tavahi_threaded_poll_lock(_poll);\n\t_avahi_create_services(name, host, port >= 5900 ? port : 5900+port);\n\tavahi_threaded_poll_unlock(_poll);\nif (db) fprintf(stderr, \"out avahi_advertise\\n\");\n}"
  },
  {
    "function_name": "_avahi_create_services",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "294-329",
    "snippet": "static void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_advertise(char *name, char *host, uint16_t port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out _avahi_create_services\\n\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Failed to commit entry_group:: %s\\n\"",
            "avahi_strerror(ret)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_strerror",
          "args": [
            "ret"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_entry_group_commit",
          "args": [
            "_group"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Failed to add _rfb._tcp service: %s\\n\"",
            "avahi_strerror(ret)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_strerror",
          "args": [
            "ret"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_entry_group_add_service",
          "args": [
            "_group",
            "AVAHI_IF_UNSPEC",
            "AVAHI_PROTO_UNSPEC",
            "0",
            "name",
            "\"_rfb._tcp\"",
            "NULL",
            "NULL",
            "port",
            "NULL"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_entry_group_new() failed: %s\\n\"",
            "avahi_strerror(avahi_client_errno(_client))"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_strerror",
          "args": [
            "avahi_client_errno(_client)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_client_errno",
          "args": [
            "_client"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_entry_group_new",
          "args": [
            "_client",
            "_avahi_entry_group_callback",
            "svc"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    _avahi_create_services create group\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  _avahi_create_services  '%s' '%s' %d\\n\"",
            "name",
            "host",
            "port"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(avahi_service_t)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nstatic void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}"
  },
  {
    "function_name": "_avahi_entry_group_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "255-292",
    "snippet": "static void _avahi_entry_group_callback(AvahiEntryGroup *g,\n    AvahiEntryGroupState state, void *userdata) {\n\tchar *new_name;\n\tavahi_service_t *svc = (avahi_service_t *)userdata;\n\nif (db) fprintf(stderr, \"in  _avahi_entry_group_callback %d 0x%p\\n\", state, svc);\n\tif (g != _group && _group != NULL) {\n\t\trfbLog(\"avahi_entry_group_callback fatal error (group).\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (userdata == NULL) {\n\t\trfbLog(\"avahi_entry_group_callback fatal error (userdata).\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tswitch(state) {\n\tcase AVAHI_ENTRY_GROUP_ESTABLISHED:\n\t\trfbLog(\"Avahi group %s established.\\n\", svc->name);\n#if 0\t\t/* is this the segv problem? */\n\t\tfree(svc);\n#endif\n\t\tbreak;\n\tcase AVAHI_ENTRY_GROUP_COLLISION:\n\t\tnew_name = avahi_alternative_service_name(svc->name);\n\t\t_avahi_create_services(new_name, svc->host, svc->port);\n\t\trfbLog(\"Avahi Entry group collision\\n\");\n\t\tavahi_free(new_name);\n\t\tbreak;\n\tcase AVAHI_ENTRY_GROUP_FAILURE:\n\t\trfbLog(\"Avahi Entry group failure: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(\n\t\t    avahi_entry_group_get_client(g))));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nif (db) fprintf(stderr, \"out _avahi_entry_group_callback\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_advertise(char *name, char *host, uint16_t port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out _avahi_entry_group_callback\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Avahi Entry group failure: %s\\n\"",
            "avahi_strerror(avahi_client_errno(\n\t\t    avahi_entry_group_get_client(g)))"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_strerror",
          "args": [
            "avahi_client_errno(\n\t\t    avahi_entry_group_get_client(g))"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_client_errno",
          "args": [
            "avahi_entry_group_get_client(g)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_entry_group_get_client",
          "args": [
            "g"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_free",
          "args": [
            "new_name"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Avahi Entry group collision\\n\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_avahi_create_services",
          "args": [
            "new_name",
            "svc->host",
            "svc->port"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "_avahi_create_services",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "294-329",
          "snippet": "static void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void avahi_advertise(char *name, char *host, uint16_t port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nstatic void _avahi_create_services(char *name, char *host, uint16_t port) {\n\tavahi_service_t *svc = (avahi_service_t *)malloc(sizeof(avahi_service_t));\n\tint ret = 0;\n\nif (db) fprintf(stderr, \"in  _avahi_create_services  '%s' '%s' %d\\n\", name, host, port);\n\tsvc->name = name;\n\tsvc->host = host;\n\tsvc->port = port;\n\n\tif (!_group) {\nif (db) fprintf(stderr, \"    _avahi_create_services create group\\n\");\n\t\t_group = avahi_entry_group_new(_client,\n\t\t    _avahi_entry_group_callback, svc);\n\t}\n\tif (!_group) {\n\t\trfbLog(\"avahi_entry_group_new() failed: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(_client)));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_add_service(_group, AVAHI_IF_UNSPEC,\n\t    AVAHI_PROTO_UNSPEC, 0, name, \"_rfb._tcp\", NULL, NULL, port, NULL);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to add _rfb._tcp service: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\n\n\tret = avahi_entry_group_commit(_group);\n\tif (ret < 0) {\n\t\trfbLog(\"Failed to commit entry_group:: %s\\n\",\n\t\t    avahi_strerror(ret));\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out _avahi_create_services\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "avahi_alternative_service_name",
          "args": [
            "svc->name"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "svc"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Avahi group %s established.\\n\"",
            "svc->name"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_entry_group_callback fatal error (userdata).\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_entry_group_callback fatal error (group).\\n\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  _avahi_entry_group_callback %d 0x%p\\n\"",
            "state",
            "svc"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nstatic void _avahi_entry_group_callback(AvahiEntryGroup *g,\n    AvahiEntryGroupState state, void *userdata) {\n\tchar *new_name;\n\tavahi_service_t *svc = (avahi_service_t *)userdata;\n\nif (db) fprintf(stderr, \"in  _avahi_entry_group_callback %d 0x%p\\n\", state, svc);\n\tif (g != _group && _group != NULL) {\n\t\trfbLog(\"avahi_entry_group_callback fatal error (group).\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (userdata == NULL) {\n\t\trfbLog(\"avahi_entry_group_callback fatal error (userdata).\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tswitch(state) {\n\tcase AVAHI_ENTRY_GROUP_ESTABLISHED:\n\t\trfbLog(\"Avahi group %s established.\\n\", svc->name);\n#if 0\t\t/* is this the segv problem? */\n\t\tfree(svc);\n#endif\n\t\tbreak;\n\tcase AVAHI_ENTRY_GROUP_COLLISION:\n\t\tnew_name = avahi_alternative_service_name(svc->name);\n\t\t_avahi_create_services(new_name, svc->host, svc->port);\n\t\trfbLog(\"Avahi Entry group collision\\n\");\n\t\tavahi_free(new_name);\n\t\tbreak;\n\tcase AVAHI_ENTRY_GROUP_FAILURE:\n\t\trfbLog(\"Avahi Entry group failure: %s\\n\",\n\t\t    avahi_strerror(avahi_client_errno(\n\t\t    avahi_entry_group_get_client(g))));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nif (db) fprintf(stderr, \"out _avahi_entry_group_callback\\n\");\n}"
  },
  {
    "function_name": "avahi_initialise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "203-250",
    "snippet": "void avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NREG 16"
    ],
    "globals_used": [
      "void avahi_initialise(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"out avahi_initialise\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_free",
          "args": [
            "_poll"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_client_free",
          "args": [
            "_client"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: unable to start Avahi poll.\\n\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_start",
          "args": [
            "_poll"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_free",
          "args": [
            "_poll"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: unable to open Avahi client: %s\\n\"",
            "avahi_strerror(ret)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_strerror",
          "args": [
            "ret"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_client_new",
          "args": [
            "avahi_threaded_poll_get(_poll)",
            "0",
            "NULL",
            "NULL",
            "&ret"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_get",
          "args": [
            "_poll"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: unable to open Avahi poll.\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_threaded_poll_new",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    avahi_initialise: poll not null\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"in  avahi_initialise\\n\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"AVAHI_DEBUG\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\n#define NREG 16\n\nvoid avahi_initialise(void);\n\nvoid avahi_initialise(void) {\n\tint ret;\n\tstatic int first = 1;\n\n\tif (getenv(\"AVAHI_DEBUG\")) {\n\t\tdb = 1;\n\t}\n\tif (first) {\n\t\tint i;\n\t\tfor (i=0; i<NREG; i++) {\n\t\t\tregistered[i].name = NULL;\n\t\t\tregistered[i].host = NULL;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nif (db) fprintf(stderr, \"in  avahi_initialise\\n\");\n\tif (_poll) {\nif (db) fprintf(stderr, \"    avahi_initialise: poll not null\\n\");\n\t\treturn;\n\t}\n\n\tif (! (_poll = avahi_threaded_poll_new()) ) {\n\t\trfbLog(\"warning: unable to open Avahi poll.\\n\");\n\t\treturn;\n\t}\n\n\t_client = avahi_client_new(avahi_threaded_poll_get(_poll),\n\t    0, NULL, NULL, &ret);\n\tif (! _client) {\n\t\trfbLog(\"warning: unable to open Avahi client: %s\\n\",\n\t\t    avahi_strerror(ret));\n\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\n\n\tif (avahi_threaded_poll_start(_poll) < 0) {\n\t\trfbLog(\"warning: unable to start Avahi poll.\\n\");\n\t\tavahi_client_free(_client);\n\t\t_client = NULL;\n\t\tavahi_threaded_poll_free(_poll);\n\t\t_poll = NULL;\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"out avahi_initialise\\n\");\n}"
  },
  {
    "function_name": "avahi_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "167-170",
    "snippet": "void avahi_cleanup(void) {\n\tkill_avahi_pid();\n\trfbLog(\"avahi_cleanup: no Avahi support at buildtime.\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_cleanup(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_cleanup: no Avahi support at buildtime.\\n\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_avahi_pid",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "kill_avahi_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "46-52",
          "snippet": "static void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t avahi_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nstatic pid_t avahi_pid = 0;\n\nstatic void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_cleanup(void);\n\nvoid avahi_cleanup(void) {\n\tkill_avahi_pid();\n\trfbLog(\"avahi_cleanup: no Avahi support at buildtime.\\n\");\n}"
  },
  {
    "function_name": "avahi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "162-165",
    "snippet": "void avahi_reset(void) {\n\tkill_avahi_pid();\n\trfbLog(\"avahi_reset: no Avahi support at buildtime.\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_reset(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_reset: no Avahi support at buildtime.\\n\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_avahi_pid",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "kill_avahi_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "46-52",
          "snippet": "static void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pid_t avahi_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nstatic pid_t avahi_pid = 0;\n\nstatic void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_reset(void);\n\nvoid avahi_reset(void) {\n\tkill_avahi_pid();\n\trfbLog(\"avahi_reset: no Avahi support at buildtime.\\n\");\n}"
  },
  {
    "function_name": "avahi_advertise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "150-160",
    "snippet": "void avahi_advertise(char *name, char *host, uint16_t port) {\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\n\tif (!try_avahi_helper(name, host, port)) {\n\t\trfbLog(\"avahi_advertise:  no Avahi support at buildtime.\\n\");\n\t\tavahi = 0;\n\t}\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_advertise(char *name, char *host, uint16_t port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_advertise:  no Avahi support at buildtime.\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_avahi_helper",
          "args": [
            "name",
            "host",
            "port"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "try_avahi_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "54-143",
          "snippet": "static int try_avahi_helper(char *name, char *host, uint16_t port) {\n#if LIBVNCSERVER_HAVE_FORK\n\tchar *cmd, *p, *path = getenv(\"PATH\"), portstr[32];\n\tint i;\n\n\tif (!name || !host || !port) {}\n\n\t/* avahi-publish */\n\tif (no_external_cmds || !cmd_ok(\"zeroconf\")) {\n\t\treturn 0;\n\t}\n\n\tif (!path) {\n\t\treturn 0;\n\t}\n\n\tpath = strdup(path); \n\tcmd = (char *) malloc(strlen(path) + 100);\n\tsprintf(portstr, \"%d\", (int) port);\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(cmd, \"%s/avahi-publish\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/dns-sd\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/mDNS\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcmd[0] = '\\0';\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (!strcmp(cmd, \"\")) {\n\t\tfree(cmd);\n\t\trfbLog(\"Could not find an external avahi/zeroconf helper program.\\n\");\n\t\treturn 0;\n\t}\n\n\tavahi_pid = fork();\n\n\tif (avahi_pid < 0) {\n\t\trfbLogPerror(\"fork\");\n\t\tavahi_pid = 0;\n\t\tfree(cmd);\n\t\treturn 0;\n\t}\n\n\tif (avahi_pid != 0) {\n\t\tint status;\n\n\t\tusleep(500 * 1000);\n\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\tif (kill(avahi_pid, 0) != 0) {\n\t\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\t\tavahi_pid = 0;\n\t\t\tfree(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! quiet) {\n\t\t\trfbLog(\"%s helper pid is: %d\\n\", cmd, (int) avahi_pid);\n\t\t}\n\t\tfree(cmd);\n\t\treturn 1;\n\t}\n\n\tfor (i=3; i<256; i++) {\n\t\tclose(i);\n\t}\n\n\tif (strstr(cmd, \"/avahi-publish\")) {\n\t\texeclp(cmd, cmd, \"-s\", name, \"_rfb._tcp\", portstr, (char *) NULL);\n\t} else {\n\t\texeclp(cmd, cmd, \"-R\", name, \"_rfb._tcp\", \".\", portstr, (char *) NULL);\n\t}\n\texit(1);\n#else\n\tif (!name || !host || !port) {}\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void avahi_advertise(char *name, char *host, uint16_t port);",
            "static pid_t avahi_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\nstatic pid_t avahi_pid = 0;\n\nstatic int try_avahi_helper(char *name, char *host, uint16_t port) {\n#if LIBVNCSERVER_HAVE_FORK\n\tchar *cmd, *p, *path = getenv(\"PATH\"), portstr[32];\n\tint i;\n\n\tif (!name || !host || !port) {}\n\n\t/* avahi-publish */\n\tif (no_external_cmds || !cmd_ok(\"zeroconf\")) {\n\t\treturn 0;\n\t}\n\n\tif (!path) {\n\t\treturn 0;\n\t}\n\n\tpath = strdup(path); \n\tcmd = (char *) malloc(strlen(path) + 100);\n\tsprintf(portstr, \"%d\", (int) port);\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(cmd, \"%s/avahi-publish\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/dns-sd\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/mDNS\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcmd[0] = '\\0';\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (!strcmp(cmd, \"\")) {\n\t\tfree(cmd);\n\t\trfbLog(\"Could not find an external avahi/zeroconf helper program.\\n\");\n\t\treturn 0;\n\t}\n\n\tavahi_pid = fork();\n\n\tif (avahi_pid < 0) {\n\t\trfbLogPerror(\"fork\");\n\t\tavahi_pid = 0;\n\t\tfree(cmd);\n\t\treturn 0;\n\t}\n\n\tif (avahi_pid != 0) {\n\t\tint status;\n\n\t\tusleep(500 * 1000);\n\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\tif (kill(avahi_pid, 0) != 0) {\n\t\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\t\tavahi_pid = 0;\n\t\t\tfree(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! quiet) {\n\t\t\trfbLog(\"%s helper pid is: %d\\n\", cmd, (int) avahi_pid);\n\t\t}\n\t\tfree(cmd);\n\t\treturn 1;\n\t}\n\n\tfor (i=3; i<256; i++) {\n\t\tclose(i);\n\t}\n\n\tif (strstr(cmd, \"/avahi-publish\")) {\n\t\texeclp(cmd, cmd, \"-s\", name, \"_rfb._tcp\", portstr, (char *) NULL);\n\t} else {\n\t\texeclp(cmd, cmd, \"-R\", name, \"_rfb._tcp\", \".\", portstr, (char *) NULL);\n\t}\n\texit(1);\n#else\n\tif (!name || !host || !port) {}\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "t"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_PORT\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_HOST\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVAHI_NAME\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\n\nvoid avahi_advertise(char *name, char *host, uint16_t port) {\n\tchar *t;\n\tt = getenv(\"X11VNC_AVAHI_NAME\"); if (t) name = t;\n\tt = getenv(\"X11VNC_AVAHI_HOST\"); if (t) host = t;\n\tt = getenv(\"X11VNC_AVAHI_PORT\"); if (t) port = atoi(t);\n\n\tif (!try_avahi_helper(name, host, port)) {\n\t\trfbLog(\"avahi_advertise:  no Avahi support at buildtime.\\n\");\n\t\tavahi = 0;\n\t}\n}"
  },
  {
    "function_name": "avahi_initialise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "146-148",
    "snippet": "void avahi_initialise(void) {\n\trfbLog(\"avahi_initialise: no Avahi support at buildtime.\\n\");\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_initialise(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"avahi_initialise: no Avahi support at buildtime.\\n\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_initialise(void);\n\nvoid avahi_initialise(void) {\n\trfbLog(\"avahi_initialise: no Avahi support at buildtime.\\n\");\n}"
  },
  {
    "function_name": "try_avahi_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "54-143",
    "snippet": "static int try_avahi_helper(char *name, char *host, uint16_t port) {\n#if LIBVNCSERVER_HAVE_FORK\n\tchar *cmd, *p, *path = getenv(\"PATH\"), portstr[32];\n\tint i;\n\n\tif (!name || !host || !port) {}\n\n\t/* avahi-publish */\n\tif (no_external_cmds || !cmd_ok(\"zeroconf\")) {\n\t\treturn 0;\n\t}\n\n\tif (!path) {\n\t\treturn 0;\n\t}\n\n\tpath = strdup(path); \n\tcmd = (char *) malloc(strlen(path) + 100);\n\tsprintf(portstr, \"%d\", (int) port);\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(cmd, \"%s/avahi-publish\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/dns-sd\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/mDNS\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcmd[0] = '\\0';\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (!strcmp(cmd, \"\")) {\n\t\tfree(cmd);\n\t\trfbLog(\"Could not find an external avahi/zeroconf helper program.\\n\");\n\t\treturn 0;\n\t}\n\n\tavahi_pid = fork();\n\n\tif (avahi_pid < 0) {\n\t\trfbLogPerror(\"fork\");\n\t\tavahi_pid = 0;\n\t\tfree(cmd);\n\t\treturn 0;\n\t}\n\n\tif (avahi_pid != 0) {\n\t\tint status;\n\n\t\tusleep(500 * 1000);\n\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\tif (kill(avahi_pid, 0) != 0) {\n\t\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\t\tavahi_pid = 0;\n\t\t\tfree(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! quiet) {\n\t\t\trfbLog(\"%s helper pid is: %d\\n\", cmd, (int) avahi_pid);\n\t\t}\n\t\tfree(cmd);\n\t\treturn 1;\n\t}\n\n\tfor (i=3; i<256; i++) {\n\t\tclose(i);\n\t}\n\n\tif (strstr(cmd, \"/avahi-publish\")) {\n\t\texeclp(cmd, cmd, \"-s\", name, \"_rfb._tcp\", portstr, (char *) NULL);\n\t} else {\n\t\texeclp(cmd, cmd, \"-R\", name, \"_rfb._tcp\", \".\", portstr, (char *) NULL);\n\t}\n\texit(1);\n#else\n\tif (!name || !host || !port) {}\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void avahi_advertise(char *name, char *host, uint16_t port);",
      "static pid_t avahi_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "cmd",
            "cmd",
            "\"-R\"",
            "name",
            "\"_rfb._tcp\"",
            "\".\"",
            "portstr",
            "(char *) NULL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "cmd",
            "cmd",
            "\"-s\"",
            "name",
            "\"_rfb._tcp\"",
            "portstr",
            "(char *) NULL"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"/avahi-publish\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s helper pid is: %d\\n\"",
            "cmd",
            "(int) avahi_pid"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "avahi_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "avahi_pid",
            "0"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "avahi_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500 * 1000"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fork\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Could not find an external avahi/zeroconf helper program.\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cmd",
            "&sbuf"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s/mDNS\"",
            "p"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s/dns-sd\"",
            "p"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s/avahi-publish\"",
            "p"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path",
            "\":\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "portstr",
            "\"%d\"",
            "(int) port"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(path) + 100"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"zeroconf\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_advertise(char *name, char *host, uint16_t port);\nstatic pid_t avahi_pid = 0;\n\nstatic int try_avahi_helper(char *name, char *host, uint16_t port) {\n#if LIBVNCSERVER_HAVE_FORK\n\tchar *cmd, *p, *path = getenv(\"PATH\"), portstr[32];\n\tint i;\n\n\tif (!name || !host || !port) {}\n\n\t/* avahi-publish */\n\tif (no_external_cmds || !cmd_ok(\"zeroconf\")) {\n\t\treturn 0;\n\t}\n\n\tif (!path) {\n\t\treturn 0;\n\t}\n\n\tpath = strdup(path); \n\tcmd = (char *) malloc(strlen(path) + 100);\n\tsprintf(portstr, \"%d\", (int) port);\n\n\tp = strtok(path, \":\");\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(cmd, \"%s/avahi-publish\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/dns-sd\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(cmd, \"%s/mDNS\", p);\n\t\tif (stat(cmd, &sbuf) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcmd[0] = '\\0';\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (!strcmp(cmd, \"\")) {\n\t\tfree(cmd);\n\t\trfbLog(\"Could not find an external avahi/zeroconf helper program.\\n\");\n\t\treturn 0;\n\t}\n\n\tavahi_pid = fork();\n\n\tif (avahi_pid < 0) {\n\t\trfbLogPerror(\"fork\");\n\t\tavahi_pid = 0;\n\t\tfree(cmd);\n\t\treturn 0;\n\t}\n\n\tif (avahi_pid != 0) {\n\t\tint status;\n\n\t\tusleep(500 * 1000);\n\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\tif (kill(avahi_pid, 0) != 0) {\n\t\t\twaitpid(avahi_pid, &status, WNOHANG); \n\t\t\tavahi_pid = 0;\n\t\t\tfree(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! quiet) {\n\t\t\trfbLog(\"%s helper pid is: %d\\n\", cmd, (int) avahi_pid);\n\t\t}\n\t\tfree(cmd);\n\t\treturn 1;\n\t}\n\n\tfor (i=3; i<256; i++) {\n\t\tclose(i);\n\t}\n\n\tif (strstr(cmd, \"/avahi-publish\")) {\n\t\texeclp(cmd, cmd, \"-s\", name, \"_rfb._tcp\", portstr, (char *) NULL);\n\t} else {\n\t\texeclp(cmd, cmd, \"-R\", name, \"_rfb._tcp\", \".\", portstr, (char *) NULL);\n\t}\n\texit(1);\n#else\n\tif (!name || !host || !port) {}\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "kill_avahi_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
    "lines": "46-52",
    "snippet": "static void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}",
    "includes": [
      "#include <avahi-common/error.h>",
      "#include <avahi-common/malloc.h>",
      "#include <avahi-client/publish.h>",
      "#include <avahi-client/client.h>",
      "#include <avahi-common/alternative.h>",
      "#include <avahi-common/thread-watch.h>",
      "#include \"cleanup.h\"",
      "#include \"connections.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pid_t avahi_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "avahi_pid",
            "SIGTERM"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"kill_avahi_pid: %d\\n\"",
            "(int) avahi_pid"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nstatic pid_t avahi_pid = 0;\n\nstatic void kill_avahi_pid(void) {\n\tif (avahi_pid != 0) {\n\t\trfbLog(\"kill_avahi_pid: %d\\n\", (int) avahi_pid);\n\t\tkill(avahi_pid, SIGTERM);\n\t\tavahi_pid = 0;\n\t}\n}"
  }
]