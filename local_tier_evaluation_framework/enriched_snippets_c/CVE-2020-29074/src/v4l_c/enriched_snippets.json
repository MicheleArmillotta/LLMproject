[
  {
    "function_name": "init_ntsc_cable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1658-1784",
    "snippet": "static void init_ntsc_cable(void) {\n\tntsc_cable[1] = 73250;\n\tntsc_cable[2] = 55250;\n\tntsc_cable[3] = 61250;\n\tntsc_cable[4] = 67250;\n\tntsc_cable[5] = 77250;\n\tntsc_cable[6] = 83250;\n\tntsc_cable[7] = 175250;\n\tntsc_cable[8] = 181250;\n\tntsc_cable[9] = 187250;\n\tntsc_cable[10] = 193250;\n\tntsc_cable[11] = 199250;\n\tntsc_cable[12] = 205250;\n\tntsc_cable[13] = 211250;\n\tntsc_cable[14] = 121250;\n\tntsc_cable[15] = 127250;\n\tntsc_cable[16] = 133250;\n\tntsc_cable[17] = 139250;\n\tntsc_cable[18] = 145250;\n\tntsc_cable[19] = 151250;\n\tntsc_cable[20] = 157250;\n\tntsc_cable[21] = 163250;\n\tntsc_cable[22] = 169250;\n\tntsc_cable[23] = 217250;\n\tntsc_cable[24] = 223250;\n\tntsc_cable[25] = 229250;\n\tntsc_cable[26] = 235250;\n\tntsc_cable[27] = 241250;\n\tntsc_cable[28] = 247250;\n\tntsc_cable[29] = 253250;\n\tntsc_cable[30] = 259250;\n\tntsc_cable[31] = 265250;\n\tntsc_cable[32] = 271250;\n\tntsc_cable[33] = 277250;\n\tntsc_cable[34] = 283250;\n\tntsc_cable[35] = 289250;\n\tntsc_cable[36] = 295250;\n\tntsc_cable[37] = 301250;\n\tntsc_cable[38] = 307250;\n\tntsc_cable[39] = 313250;\n\tntsc_cable[40] = 319250;\n\tntsc_cable[41] = 325250;\n\tntsc_cable[42] = 331250;\n\tntsc_cable[43] = 337250;\n\tntsc_cable[44] = 343250;\n\tntsc_cable[45] = 349250;\n\tntsc_cable[46] = 355250;\n\tntsc_cable[47] = 361250;\n\tntsc_cable[48] = 367250;\n\tntsc_cable[49] = 373250;\n\tntsc_cable[50] = 379250;\n\tntsc_cable[51] = 385250;\n\tntsc_cable[52] = 391250;\n\tntsc_cable[53] = 397250;\n\tntsc_cable[54] = 403250;\n\tntsc_cable[55] = 409250;\n\tntsc_cable[56] = 415250;\n\tntsc_cable[57] = 421250;\n\tntsc_cable[58] = 427250;\n\tntsc_cable[59] = 433250;\n\tntsc_cable[60] = 439250;\n\tntsc_cable[61] = 445250;\n\tntsc_cable[62] = 451250;\n\tntsc_cable[63] = 457250;\n\tntsc_cable[64] = 463250;\n\tntsc_cable[65] = 469250;\n\tntsc_cable[66] = 475250;\n\tntsc_cable[67] = 481250;\n\tntsc_cable[68] = 487250;\n\tntsc_cable[69] = 493250;\n\tntsc_cable[70] = 499250;\n\tntsc_cable[71] = 505250;\n\tntsc_cable[72] = 511250;\n\tntsc_cable[73] = 517250;\n\tntsc_cable[74] = 523250;\n\tntsc_cable[75] = 529250;\n\tntsc_cable[76] = 535250;\n\tntsc_cable[77] = 541250;\n\tntsc_cable[78] = 547250;\n\tntsc_cable[79] = 553250;\n\tntsc_cable[80] = 559250;\n\tntsc_cable[81] = 565250;\n\tntsc_cable[82] = 571250;\n\tntsc_cable[83] = 577250;\n\tntsc_cable[84] = 583250;\n\tntsc_cable[85] = 589250;\n\tntsc_cable[86] = 595250;\n\tntsc_cable[87] = 601250;\n\tntsc_cable[88] = 607250;\n\tntsc_cable[89] = 613250;\n\tntsc_cable[90] = 619250;\n\tntsc_cable[91] = 625250;\n\tntsc_cable[92] = 631250;\n\tntsc_cable[93] = 637250;\n\tntsc_cable[94] = 643250;\n\tntsc_cable[95] = 91250;\n\tntsc_cable[96] = 97250;\n\tntsc_cable[97] = 103250;\n\tntsc_cable[98] = 109250;\n\tntsc_cable[99] = 115250;\n\tntsc_cable[100] = 649250;\n\tntsc_cable[101] = 655250;\n\tntsc_cable[102] = 661250;\n\tntsc_cable[103] = 667250;\n\tntsc_cable[104] = 673250;\n\tntsc_cable[105] = 679250;\n\tntsc_cable[106] = 685250;\n\tntsc_cable[107] = 691250;\n\tntsc_cable[108] = 697250;\n\tntsc_cable[109] = 703250;\n\tntsc_cable[110] = 709250;\n\tntsc_cable[111] = 715250;\n\tntsc_cable[112] = 721250;\n\tntsc_cable[113] = 727250;\n\tntsc_cable[114] = 733250;\n\tntsc_cable[115] = 739250;\n\tntsc_cable[116] = 745250;\n\tntsc_cable[117] = 751250;\n\tntsc_cable[118] = 757250;\n\tntsc_cable[119] = 763250;\n\tntsc_cable[120] = 769250;\n\tntsc_cable[121] = 775250;\n\tntsc_cable[122] = 781250;\n\tntsc_cable[123] = 787250;\n\tntsc_cable[124] = 793250;\n\tntsc_cable[125] = 799250;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_ntsc_cable(void);",
      "static unsigned long ntsc_cable[CHANNEL_MAX];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void init_ntsc_cable(void);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\n\nstatic void init_ntsc_cable(void) {\n\tntsc_cable[1] = 73250;\n\tntsc_cable[2] = 55250;\n\tntsc_cable[3] = 61250;\n\tntsc_cable[4] = 67250;\n\tntsc_cable[5] = 77250;\n\tntsc_cable[6] = 83250;\n\tntsc_cable[7] = 175250;\n\tntsc_cable[8] = 181250;\n\tntsc_cable[9] = 187250;\n\tntsc_cable[10] = 193250;\n\tntsc_cable[11] = 199250;\n\tntsc_cable[12] = 205250;\n\tntsc_cable[13] = 211250;\n\tntsc_cable[14] = 121250;\n\tntsc_cable[15] = 127250;\n\tntsc_cable[16] = 133250;\n\tntsc_cable[17] = 139250;\n\tntsc_cable[18] = 145250;\n\tntsc_cable[19] = 151250;\n\tntsc_cable[20] = 157250;\n\tntsc_cable[21] = 163250;\n\tntsc_cable[22] = 169250;\n\tntsc_cable[23] = 217250;\n\tntsc_cable[24] = 223250;\n\tntsc_cable[25] = 229250;\n\tntsc_cable[26] = 235250;\n\tntsc_cable[27] = 241250;\n\tntsc_cable[28] = 247250;\n\tntsc_cable[29] = 253250;\n\tntsc_cable[30] = 259250;\n\tntsc_cable[31] = 265250;\n\tntsc_cable[32] = 271250;\n\tntsc_cable[33] = 277250;\n\tntsc_cable[34] = 283250;\n\tntsc_cable[35] = 289250;\n\tntsc_cable[36] = 295250;\n\tntsc_cable[37] = 301250;\n\tntsc_cable[38] = 307250;\n\tntsc_cable[39] = 313250;\n\tntsc_cable[40] = 319250;\n\tntsc_cable[41] = 325250;\n\tntsc_cable[42] = 331250;\n\tntsc_cable[43] = 337250;\n\tntsc_cable[44] = 343250;\n\tntsc_cable[45] = 349250;\n\tntsc_cable[46] = 355250;\n\tntsc_cable[47] = 361250;\n\tntsc_cable[48] = 367250;\n\tntsc_cable[49] = 373250;\n\tntsc_cable[50] = 379250;\n\tntsc_cable[51] = 385250;\n\tntsc_cable[52] = 391250;\n\tntsc_cable[53] = 397250;\n\tntsc_cable[54] = 403250;\n\tntsc_cable[55] = 409250;\n\tntsc_cable[56] = 415250;\n\tntsc_cable[57] = 421250;\n\tntsc_cable[58] = 427250;\n\tntsc_cable[59] = 433250;\n\tntsc_cable[60] = 439250;\n\tntsc_cable[61] = 445250;\n\tntsc_cable[62] = 451250;\n\tntsc_cable[63] = 457250;\n\tntsc_cable[64] = 463250;\n\tntsc_cable[65] = 469250;\n\tntsc_cable[66] = 475250;\n\tntsc_cable[67] = 481250;\n\tntsc_cable[68] = 487250;\n\tntsc_cable[69] = 493250;\n\tntsc_cable[70] = 499250;\n\tntsc_cable[71] = 505250;\n\tntsc_cable[72] = 511250;\n\tntsc_cable[73] = 517250;\n\tntsc_cable[74] = 523250;\n\tntsc_cable[75] = 529250;\n\tntsc_cable[76] = 535250;\n\tntsc_cable[77] = 541250;\n\tntsc_cable[78] = 547250;\n\tntsc_cable[79] = 553250;\n\tntsc_cable[80] = 559250;\n\tntsc_cable[81] = 565250;\n\tntsc_cable[82] = 571250;\n\tntsc_cable[83] = 577250;\n\tntsc_cable[84] = 583250;\n\tntsc_cable[85] = 589250;\n\tntsc_cable[86] = 595250;\n\tntsc_cable[87] = 601250;\n\tntsc_cable[88] = 607250;\n\tntsc_cable[89] = 613250;\n\tntsc_cable[90] = 619250;\n\tntsc_cable[91] = 625250;\n\tntsc_cable[92] = 631250;\n\tntsc_cable[93] = 637250;\n\tntsc_cable[94] = 643250;\n\tntsc_cable[95] = 91250;\n\tntsc_cable[96] = 97250;\n\tntsc_cable[97] = 103250;\n\tntsc_cable[98] = 109250;\n\tntsc_cable[99] = 115250;\n\tntsc_cable[100] = 649250;\n\tntsc_cable[101] = 655250;\n\tntsc_cable[102] = 661250;\n\tntsc_cable[103] = 667250;\n\tntsc_cable[104] = 673250;\n\tntsc_cable[105] = 679250;\n\tntsc_cable[106] = 685250;\n\tntsc_cable[107] = 691250;\n\tntsc_cable[108] = 697250;\n\tntsc_cable[109] = 703250;\n\tntsc_cable[110] = 709250;\n\tntsc_cable[111] = 715250;\n\tntsc_cable[112] = 721250;\n\tntsc_cable[113] = 727250;\n\tntsc_cable[114] = 733250;\n\tntsc_cable[115] = 739250;\n\tntsc_cable[116] = 745250;\n\tntsc_cable[117] = 751250;\n\tntsc_cable[118] = 757250;\n\tntsc_cable[119] = 763250;\n\tntsc_cable[120] = 769250;\n\tntsc_cable[121] = 775250;\n\tntsc_cable[122] = 781250;\n\tntsc_cable[123] = 787250;\n\tntsc_cable[124] = 793250;\n\tntsc_cable[125] = 799250;\n}"
  },
  {
    "function_name": "init_freqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1643-1656",
    "snippet": "static void init_freqs(void) {\n\tint i;\n\tfor (i=0; i<CHANNEL_MAX; i++) {\n\t\tntsc_cable[i] = 0;\n\t\tcustom_freq[i] = 0;\n\t}\n\n\tinit_ntsc_cable();\n\tlast_freq = ntsc_cable[1];\n\n\tif (freqtab) {\n\t\tinit_freqtab(freqtab);\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500"
    ],
    "globals_used": [
      "static void init_freqs(void);",
      "static void init_ntsc_cable(void);",
      "static unsigned long ntsc_cable[CHANNEL_MAX];",
      "static unsigned long custom_freq[CHANNEL_MAX];",
      "static unsigned long last_freq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_freqtab",
          "args": [
            "freqtab"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "init_freqtab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1441-1641",
          "snippet": "static void init_freqtab(char *file) {\n\tchar *p, *q, *dir, *file2;\n\tchar line[1024], inc[1024];\n\tchar *text, *str;\n\tint size = 0, maxn, extra, currn;\n\tFILE *in1, *in2;\n\tstatic int v = 1;\n\tif (quiet) {\n\t\tv = 0;\n\t}\n\n\t/* YUCK */\n\n\tdir = strdup(file);\n\tq = strrchr(dir, '/');\n\tif (q) {\n\t\t*(q+1) = '\\0';\n\t} else {\n\t\tfree(dir);\n\t\tdir = strdup(\"./\");\n\t}\n\tfile2 = (char *) malloc(strlen(dir) + 1024 + 1);\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file);\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tsize += strlen(line);\n\t\tlb = lblanks(line);\n\t\tif (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file2);\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tsize += strlen(line2);\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t}\n\tfclose(in1);\n\n\tsize = 4*(size + 10000);\n\n\ttext = (char *) malloc(size);\n\n\ttext[0] = '\\0';\n\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tlb = lblanks(line);\n\t\tif (lb[0] == '[') {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"freq\")) {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *lb2;\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tlb2 = lblanks(line2);\n\t\t\t\tif (lb2[0] == '[') {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t} else if (strstr(lb2, \"freq\")) {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t}\n\t\t\t\tif ((int) strlen(text) > size/2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t\tif ((int) strlen(text) > size/2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in1);\n\n\tif (0) fprintf(stderr, \"%s\", text);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\tmaxn = -1;\n\textra = 0;\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\tif (0) fprintf(stderr, \"extra: %s\\n\", p);\n\t\t\t\t\textra++;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tif (n > maxn) {\n\t\t\t\t\t\tmaxn = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (0) fprintf(stderr, \"maxn:  %d %d\\n\", maxn, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(str);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\textra = 0;\n\tcurrn = 0;\n\tif (v) fprintf(stderr, \"\\nname\\tstation\\tfreq (KHz)\\n\");\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tstrncpy(line, p, 100);\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\textra++;\n\t\t\t\t\tcurrn = maxn + extra;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tcurrn = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strstr(p, \"freq\") && (q = strchr(p, '=')) != NULL) {\n\t\t\tint n;\n\t\t\tq = lblanks(q+1);\n\t\t\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\t\t\tif (currn >= 0 && currn < CHANNEL_MAX) {\n\t\t\t\t\tif (v) fprintf(stderr, \"%s\\t%d\\t%d\\n\", line, currn, n);\n\t\t\t\t\tcustom_freq[currn] = (unsigned long) n;\n\t\t\t\t\tif (last_freq == 0) {\n\t\t\t\t\t\tlast_freq = custom_freq[currn];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tif (v) fprintf(stderr, \"\\n\");\n\tv = 0;\n\tfree(str);\n\tfree(text);\n\tfree(dir);\n\tfree(file2);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static int colon_n(char *line);",
            "static char *colon_str(char *line);",
            "static char *colon_tag(char *line);",
            "static int lookup_station(unsigned long freq);",
            "static void init_freqtab(char *file);",
            "static unsigned long custom_freq[CHANNEL_MAX];",
            "static unsigned long last_freq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic int v4l1_dpct(int old, int d);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\nstatic int lookup_station(unsigned long freq);\nstatic void init_freqtab(char *file);\nstatic unsigned long custom_freq[CHANNEL_MAX];\nstatic unsigned long last_freq = 0;\n\nstatic void init_freqtab(char *file) {\n\tchar *p, *q, *dir, *file2;\n\tchar line[1024], inc[1024];\n\tchar *text, *str;\n\tint size = 0, maxn, extra, currn;\n\tFILE *in1, *in2;\n\tstatic int v = 1;\n\tif (quiet) {\n\t\tv = 0;\n\t}\n\n\t/* YUCK */\n\n\tdir = strdup(file);\n\tq = strrchr(dir, '/');\n\tif (q) {\n\t\t*(q+1) = '\\0';\n\t} else {\n\t\tfree(dir);\n\t\tdir = strdup(\"./\");\n\t}\n\tfile2 = (char *) malloc(strlen(dir) + 1024 + 1);\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file);\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tsize += strlen(line);\n\t\tlb = lblanks(line);\n\t\tif (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file2);\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tsize += strlen(line2);\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t}\n\tfclose(in1);\n\n\tsize = 4*(size + 10000);\n\n\ttext = (char *) malloc(size);\n\n\ttext[0] = '\\0';\n\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tlb = lblanks(line);\n\t\tif (lb[0] == '[') {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"freq\")) {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *lb2;\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tlb2 = lblanks(line2);\n\t\t\t\tif (lb2[0] == '[') {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t} else if (strstr(lb2, \"freq\")) {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t}\n\t\t\t\tif ((int) strlen(text) > size/2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t\tif ((int) strlen(text) > size/2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in1);\n\n\tif (0) fprintf(stderr, \"%s\", text);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\tmaxn = -1;\n\textra = 0;\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\tif (0) fprintf(stderr, \"extra: %s\\n\", p);\n\t\t\t\t\textra++;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tif (n > maxn) {\n\t\t\t\t\t\tmaxn = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (0) fprintf(stderr, \"maxn:  %d %d\\n\", maxn, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(str);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\textra = 0;\n\tcurrn = 0;\n\tif (v) fprintf(stderr, \"\\nname\\tstation\\tfreq (KHz)\\n\");\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tstrncpy(line, p, 100);\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\textra++;\n\t\t\t\t\tcurrn = maxn + extra;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tcurrn = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strstr(p, \"freq\") && (q = strchr(p, '=')) != NULL) {\n\t\t\tint n;\n\t\t\tq = lblanks(q+1);\n\t\t\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\t\t\tif (currn >= 0 && currn < CHANNEL_MAX) {\n\t\t\t\t\tif (v) fprintf(stderr, \"%s\\t%d\\t%d\\n\", line, currn, n);\n\t\t\t\t\tcustom_freq[currn] = (unsigned long) n;\n\t\t\t\t\tif (last_freq == 0) {\n\t\t\t\t\t\tlast_freq = custom_freq[currn];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tif (v) fprintf(stderr, \"\\n\");\n\tv = 0;\n\tfree(str);\n\tfree(text);\n\tfree(dir);\n\tfree(file2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ntsc_cable",
          "args": [],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "init_ntsc_cable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1658-1784",
          "snippet": "static void init_ntsc_cable(void) {\n\tntsc_cable[1] = 73250;\n\tntsc_cable[2] = 55250;\n\tntsc_cable[3] = 61250;\n\tntsc_cable[4] = 67250;\n\tntsc_cable[5] = 77250;\n\tntsc_cable[6] = 83250;\n\tntsc_cable[7] = 175250;\n\tntsc_cable[8] = 181250;\n\tntsc_cable[9] = 187250;\n\tntsc_cable[10] = 193250;\n\tntsc_cable[11] = 199250;\n\tntsc_cable[12] = 205250;\n\tntsc_cable[13] = 211250;\n\tntsc_cable[14] = 121250;\n\tntsc_cable[15] = 127250;\n\tntsc_cable[16] = 133250;\n\tntsc_cable[17] = 139250;\n\tntsc_cable[18] = 145250;\n\tntsc_cable[19] = 151250;\n\tntsc_cable[20] = 157250;\n\tntsc_cable[21] = 163250;\n\tntsc_cable[22] = 169250;\n\tntsc_cable[23] = 217250;\n\tntsc_cable[24] = 223250;\n\tntsc_cable[25] = 229250;\n\tntsc_cable[26] = 235250;\n\tntsc_cable[27] = 241250;\n\tntsc_cable[28] = 247250;\n\tntsc_cable[29] = 253250;\n\tntsc_cable[30] = 259250;\n\tntsc_cable[31] = 265250;\n\tntsc_cable[32] = 271250;\n\tntsc_cable[33] = 277250;\n\tntsc_cable[34] = 283250;\n\tntsc_cable[35] = 289250;\n\tntsc_cable[36] = 295250;\n\tntsc_cable[37] = 301250;\n\tntsc_cable[38] = 307250;\n\tntsc_cable[39] = 313250;\n\tntsc_cable[40] = 319250;\n\tntsc_cable[41] = 325250;\n\tntsc_cable[42] = 331250;\n\tntsc_cable[43] = 337250;\n\tntsc_cable[44] = 343250;\n\tntsc_cable[45] = 349250;\n\tntsc_cable[46] = 355250;\n\tntsc_cable[47] = 361250;\n\tntsc_cable[48] = 367250;\n\tntsc_cable[49] = 373250;\n\tntsc_cable[50] = 379250;\n\tntsc_cable[51] = 385250;\n\tntsc_cable[52] = 391250;\n\tntsc_cable[53] = 397250;\n\tntsc_cable[54] = 403250;\n\tntsc_cable[55] = 409250;\n\tntsc_cable[56] = 415250;\n\tntsc_cable[57] = 421250;\n\tntsc_cable[58] = 427250;\n\tntsc_cable[59] = 433250;\n\tntsc_cable[60] = 439250;\n\tntsc_cable[61] = 445250;\n\tntsc_cable[62] = 451250;\n\tntsc_cable[63] = 457250;\n\tntsc_cable[64] = 463250;\n\tntsc_cable[65] = 469250;\n\tntsc_cable[66] = 475250;\n\tntsc_cable[67] = 481250;\n\tntsc_cable[68] = 487250;\n\tntsc_cable[69] = 493250;\n\tntsc_cable[70] = 499250;\n\tntsc_cable[71] = 505250;\n\tntsc_cable[72] = 511250;\n\tntsc_cable[73] = 517250;\n\tntsc_cable[74] = 523250;\n\tntsc_cable[75] = 529250;\n\tntsc_cable[76] = 535250;\n\tntsc_cable[77] = 541250;\n\tntsc_cable[78] = 547250;\n\tntsc_cable[79] = 553250;\n\tntsc_cable[80] = 559250;\n\tntsc_cable[81] = 565250;\n\tntsc_cable[82] = 571250;\n\tntsc_cable[83] = 577250;\n\tntsc_cable[84] = 583250;\n\tntsc_cable[85] = 589250;\n\tntsc_cable[86] = 595250;\n\tntsc_cable[87] = 601250;\n\tntsc_cable[88] = 607250;\n\tntsc_cable[89] = 613250;\n\tntsc_cable[90] = 619250;\n\tntsc_cable[91] = 625250;\n\tntsc_cable[92] = 631250;\n\tntsc_cable[93] = 637250;\n\tntsc_cable[94] = 643250;\n\tntsc_cable[95] = 91250;\n\tntsc_cable[96] = 97250;\n\tntsc_cable[97] = 103250;\n\tntsc_cable[98] = 109250;\n\tntsc_cable[99] = 115250;\n\tntsc_cable[100] = 649250;\n\tntsc_cable[101] = 655250;\n\tntsc_cable[102] = 661250;\n\tntsc_cable[103] = 667250;\n\tntsc_cable[104] = 673250;\n\tntsc_cable[105] = 679250;\n\tntsc_cable[106] = 685250;\n\tntsc_cable[107] = 691250;\n\tntsc_cable[108] = 697250;\n\tntsc_cable[109] = 703250;\n\tntsc_cable[110] = 709250;\n\tntsc_cable[111] = 715250;\n\tntsc_cable[112] = 721250;\n\tntsc_cable[113] = 727250;\n\tntsc_cable[114] = 733250;\n\tntsc_cable[115] = 739250;\n\tntsc_cable[116] = 745250;\n\tntsc_cable[117] = 751250;\n\tntsc_cable[118] = 757250;\n\tntsc_cable[119] = 763250;\n\tntsc_cable[120] = 769250;\n\tntsc_cable[121] = 775250;\n\tntsc_cable[122] = 781250;\n\tntsc_cable[123] = 787250;\n\tntsc_cable[124] = 793250;\n\tntsc_cable[125] = 799250;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_ntsc_cable(void);",
            "static unsigned long ntsc_cable[CHANNEL_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void init_ntsc_cable(void);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\n\nstatic void init_ntsc_cable(void) {\n\tntsc_cable[1] = 73250;\n\tntsc_cable[2] = 55250;\n\tntsc_cable[3] = 61250;\n\tntsc_cable[4] = 67250;\n\tntsc_cable[5] = 77250;\n\tntsc_cable[6] = 83250;\n\tntsc_cable[7] = 175250;\n\tntsc_cable[8] = 181250;\n\tntsc_cable[9] = 187250;\n\tntsc_cable[10] = 193250;\n\tntsc_cable[11] = 199250;\n\tntsc_cable[12] = 205250;\n\tntsc_cable[13] = 211250;\n\tntsc_cable[14] = 121250;\n\tntsc_cable[15] = 127250;\n\tntsc_cable[16] = 133250;\n\tntsc_cable[17] = 139250;\n\tntsc_cable[18] = 145250;\n\tntsc_cable[19] = 151250;\n\tntsc_cable[20] = 157250;\n\tntsc_cable[21] = 163250;\n\tntsc_cable[22] = 169250;\n\tntsc_cable[23] = 217250;\n\tntsc_cable[24] = 223250;\n\tntsc_cable[25] = 229250;\n\tntsc_cable[26] = 235250;\n\tntsc_cable[27] = 241250;\n\tntsc_cable[28] = 247250;\n\tntsc_cable[29] = 253250;\n\tntsc_cable[30] = 259250;\n\tntsc_cable[31] = 265250;\n\tntsc_cable[32] = 271250;\n\tntsc_cable[33] = 277250;\n\tntsc_cable[34] = 283250;\n\tntsc_cable[35] = 289250;\n\tntsc_cable[36] = 295250;\n\tntsc_cable[37] = 301250;\n\tntsc_cable[38] = 307250;\n\tntsc_cable[39] = 313250;\n\tntsc_cable[40] = 319250;\n\tntsc_cable[41] = 325250;\n\tntsc_cable[42] = 331250;\n\tntsc_cable[43] = 337250;\n\tntsc_cable[44] = 343250;\n\tntsc_cable[45] = 349250;\n\tntsc_cable[46] = 355250;\n\tntsc_cable[47] = 361250;\n\tntsc_cable[48] = 367250;\n\tntsc_cable[49] = 373250;\n\tntsc_cable[50] = 379250;\n\tntsc_cable[51] = 385250;\n\tntsc_cable[52] = 391250;\n\tntsc_cable[53] = 397250;\n\tntsc_cable[54] = 403250;\n\tntsc_cable[55] = 409250;\n\tntsc_cable[56] = 415250;\n\tntsc_cable[57] = 421250;\n\tntsc_cable[58] = 427250;\n\tntsc_cable[59] = 433250;\n\tntsc_cable[60] = 439250;\n\tntsc_cable[61] = 445250;\n\tntsc_cable[62] = 451250;\n\tntsc_cable[63] = 457250;\n\tntsc_cable[64] = 463250;\n\tntsc_cable[65] = 469250;\n\tntsc_cable[66] = 475250;\n\tntsc_cable[67] = 481250;\n\tntsc_cable[68] = 487250;\n\tntsc_cable[69] = 493250;\n\tntsc_cable[70] = 499250;\n\tntsc_cable[71] = 505250;\n\tntsc_cable[72] = 511250;\n\tntsc_cable[73] = 517250;\n\tntsc_cable[74] = 523250;\n\tntsc_cable[75] = 529250;\n\tntsc_cable[76] = 535250;\n\tntsc_cable[77] = 541250;\n\tntsc_cable[78] = 547250;\n\tntsc_cable[79] = 553250;\n\tntsc_cable[80] = 559250;\n\tntsc_cable[81] = 565250;\n\tntsc_cable[82] = 571250;\n\tntsc_cable[83] = 577250;\n\tntsc_cable[84] = 583250;\n\tntsc_cable[85] = 589250;\n\tntsc_cable[86] = 595250;\n\tntsc_cable[87] = 601250;\n\tntsc_cable[88] = 607250;\n\tntsc_cable[89] = 613250;\n\tntsc_cable[90] = 619250;\n\tntsc_cable[91] = 625250;\n\tntsc_cable[92] = 631250;\n\tntsc_cable[93] = 637250;\n\tntsc_cable[94] = 643250;\n\tntsc_cable[95] = 91250;\n\tntsc_cable[96] = 97250;\n\tntsc_cable[97] = 103250;\n\tntsc_cable[98] = 109250;\n\tntsc_cable[99] = 115250;\n\tntsc_cable[100] = 649250;\n\tntsc_cable[101] = 655250;\n\tntsc_cable[102] = 661250;\n\tntsc_cable[103] = 667250;\n\tntsc_cable[104] = 673250;\n\tntsc_cable[105] = 679250;\n\tntsc_cable[106] = 685250;\n\tntsc_cable[107] = 691250;\n\tntsc_cable[108] = 697250;\n\tntsc_cable[109] = 703250;\n\tntsc_cable[110] = 709250;\n\tntsc_cable[111] = 715250;\n\tntsc_cable[112] = 721250;\n\tntsc_cable[113] = 727250;\n\tntsc_cable[114] = 733250;\n\tntsc_cable[115] = 739250;\n\tntsc_cable[116] = 745250;\n\tntsc_cable[117] = 751250;\n\tntsc_cable[118] = 757250;\n\tntsc_cable[119] = 763250;\n\tntsc_cable[120] = 769250;\n\tntsc_cable[121] = 775250;\n\tntsc_cable[122] = 781250;\n\tntsc_cable[123] = 787250;\n\tntsc_cable[124] = 793250;\n\tntsc_cable[125] = 799250;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void init_freqs(void);\nstatic void init_ntsc_cable(void);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\nstatic unsigned long custom_freq[CHANNEL_MAX];\nstatic unsigned long last_freq = 0;\n\nstatic void init_freqs(void) {\n\tint i;\n\tfor (i=0; i<CHANNEL_MAX; i++) {\n\t\tntsc_cable[i] = 0;\n\t\tcustom_freq[i] = 0;\n\t}\n\n\tinit_ntsc_cable();\n\tlast_freq = ntsc_cable[1];\n\n\tif (freqtab) {\n\t\tinit_freqtab(freqtab);\n\t}\n}"
  },
  {
    "function_name": "init_freqtab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1441-1641",
    "snippet": "static void init_freqtab(char *file) {\n\tchar *p, *q, *dir, *file2;\n\tchar line[1024], inc[1024];\n\tchar *text, *str;\n\tint size = 0, maxn, extra, currn;\n\tFILE *in1, *in2;\n\tstatic int v = 1;\n\tif (quiet) {\n\t\tv = 0;\n\t}\n\n\t/* YUCK */\n\n\tdir = strdup(file);\n\tq = strrchr(dir, '/');\n\tif (q) {\n\t\t*(q+1) = '\\0';\n\t} else {\n\t\tfree(dir);\n\t\tdir = strdup(\"./\");\n\t}\n\tfile2 = (char *) malloc(strlen(dir) + 1024 + 1);\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file);\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tsize += strlen(line);\n\t\tlb = lblanks(line);\n\t\tif (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file2);\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tsize += strlen(line2);\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t}\n\tfclose(in1);\n\n\tsize = 4*(size + 10000);\n\n\ttext = (char *) malloc(size);\n\n\ttext[0] = '\\0';\n\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tlb = lblanks(line);\n\t\tif (lb[0] == '[') {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"freq\")) {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *lb2;\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tlb2 = lblanks(line2);\n\t\t\t\tif (lb2[0] == '[') {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t} else if (strstr(lb2, \"freq\")) {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t}\n\t\t\t\tif ((int) strlen(text) > size/2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t\tif ((int) strlen(text) > size/2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in1);\n\n\tif (0) fprintf(stderr, \"%s\", text);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\tmaxn = -1;\n\textra = 0;\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\tif (0) fprintf(stderr, \"extra: %s\\n\", p);\n\t\t\t\t\textra++;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tif (n > maxn) {\n\t\t\t\t\t\tmaxn = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (0) fprintf(stderr, \"maxn:  %d %d\\n\", maxn, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(str);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\textra = 0;\n\tcurrn = 0;\n\tif (v) fprintf(stderr, \"\\nname\\tstation\\tfreq (KHz)\\n\");\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tstrncpy(line, p, 100);\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\textra++;\n\t\t\t\t\tcurrn = maxn + extra;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tcurrn = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strstr(p, \"freq\") && (q = strchr(p, '=')) != NULL) {\n\t\t\tint n;\n\t\t\tq = lblanks(q+1);\n\t\t\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\t\t\tif (currn >= 0 && currn < CHANNEL_MAX) {\n\t\t\t\t\tif (v) fprintf(stderr, \"%s\\t%d\\t%d\\n\", line, currn, n);\n\t\t\t\t\tcustom_freq[currn] = (unsigned long) n;\n\t\t\t\t\tif (last_freq == 0) {\n\t\t\t\t\t\tlast_freq = custom_freq[currn];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tif (v) fprintf(stderr, \"\\n\");\n\tv = 0;\n\tfree(str);\n\tfree(text);\n\tfree(dir);\n\tfree(file2);\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500"
    ],
    "globals_used": [
      "static int v4l1_dpct(int old, int d);",
      "static int colon_n(char *line);",
      "static char *colon_str(char *line);",
      "static char *colon_tag(char *line);",
      "static int lookup_station(unsigned long freq);",
      "static void init_freqtab(char *file);",
      "static unsigned long custom_freq[CHANNEL_MAX];",
      "static unsigned long last_freq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file2"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\\n\""
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\t%d\\t%d\\n\"",
            "line",
            "currn",
            "n"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"%d\"",
            "&n"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "q+1"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"freq\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"[%d]\"",
            "&n"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*q)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "line",
            "p",
            "100"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nname\\tstation\\tfreq (KHz)\\n\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "text"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\\n\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"maxn:  %d %d\\n\"",
            "maxn",
            "n"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"[%d]\"",
            "&n"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"extra: %s\\n\"",
            "p"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*q)"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\"\\n\""
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "text"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "text"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in1"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "text"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in2"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "text"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "text",
            "lb2"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb2",
            "\"freq\""
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "text",
            "lb2"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line2",
            "sizeof line2",
            "in2"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error opening freqtab include: %s %s\\n\"",
            "line",
            "file2"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file2",
            "\"r\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "file2",
            "\"%s%s\"",
            "dir",
            "s"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "'\"'"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "lb",
            "\"#include %s\"",
            "inc"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"#include\""
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "text",
            "lb"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"freq\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "text",
            "lb"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "in1"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error opening freqtab: %s\\n\"",
            "file"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in1"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in2"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line2"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line2",
            "sizeof line2",
            "in2"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"loading frequencies from: %s\\n\"",
            "file2"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error opening freqtab include: %s %s\\n\"",
            "line",
            "file2"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file2",
            "\"r\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "file2",
            "\"%s%s\"",
            "dir",
            "s"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "'\"'"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "lb",
            "\"#include %s\"",
            "inc"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"#include\""
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "in1"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"loading frequencies from: %s\\n\"",
            "file"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"error opening freqtab: %s\\n\"",
            "file"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(dir) + 1024 + 1"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dir"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"./\""
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "dir",
            "'/'"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "file"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic int v4l1_dpct(int old, int d);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\nstatic int lookup_station(unsigned long freq);\nstatic void init_freqtab(char *file);\nstatic unsigned long custom_freq[CHANNEL_MAX];\nstatic unsigned long last_freq = 0;\n\nstatic void init_freqtab(char *file) {\n\tchar *p, *q, *dir, *file2;\n\tchar line[1024], inc[1024];\n\tchar *text, *str;\n\tint size = 0, maxn, extra, currn;\n\tFILE *in1, *in2;\n\tstatic int v = 1;\n\tif (quiet) {\n\t\tv = 0;\n\t}\n\n\t/* YUCK */\n\n\tdir = strdup(file);\n\tq = strrchr(dir, '/');\n\tif (q) {\n\t\t*(q+1) = '\\0';\n\t} else {\n\t\tfree(dir);\n\t\tdir = strdup(\"./\");\n\t}\n\tfile2 = (char *) malloc(strlen(dir) + 1024 + 1);\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file);\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tsize += strlen(line);\n\t\tlb = lblanks(line);\n\t\tif (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"loading frequencies from: %s\\n\", file2);\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tsize += strlen(line2);\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t}\n\tfclose(in1);\n\n\tsize = 4*(size + 10000);\n\n\ttext = (char *) malloc(size);\n\n\ttext[0] = '\\0';\n\n\tin1 = fopen(file, \"r\");\n\tif (in1 == NULL) {\n\t\trfbLog(\"error opening freqtab: %s\\n\", file);\n\t\tclean_up_exit(1);\n\t}\n\twhile (fgets(line, sizeof line, in1) != NULL) {\n\t\tchar *lb;\n\t\tchar line2[1024];\n\t\tlb = lblanks(line);\n\t\tif (lb[0] == '[') {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"freq\")) {\n\t\t\tstrcat(text, lb);\n\t\t} else if (strstr(lb, \"#include\") == lb && \n\t\t    sscanf(lb, \"#include %s\", inc) == 1) {\n\t\t\tchar *lb2;\n\t\t\tchar *q, *s = inc;\n\t\t\tif (s[0] == '\"') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tq = strrchr(s, '\"');\n\t\t\tif (q) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tsprintf(file2, \"%s%s\", dir, s);\n\t\t\tin2 = fopen(file2, \"r\");\n\t\t\tif (in2 == NULL) {\n\t\t\t\trfbLog(\"error opening freqtab include: %s %s\\n\", line, file2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twhile (fgets(line2, sizeof line2, in2) != NULL) {\n\t\t\t\tlb2 = lblanks(line2);\n\t\t\t\tif (lb2[0] == '[') {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t} else if (strstr(lb2, \"freq\")) {\n\t\t\t\t\tstrcat(text, lb2);\n\t\t\t\t}\n\t\t\t\tif ((int) strlen(text) > size/2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(in2);\n\t\t}\n\t\tif ((int) strlen(text) > size/2) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in1);\n\n\tif (0) fprintf(stderr, \"%s\", text);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\tmaxn = -1;\n\textra = 0;\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\tif (0) fprintf(stderr, \"extra: %s\\n\", p);\n\t\t\t\t\textra++;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tif (n > maxn) {\n\t\t\t\t\t\tmaxn = n;\n\t\t\t\t\t}\n\t\t\t\t\tif (0) fprintf(stderr, \"maxn:  %d %d\\n\", maxn, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tfree(str);\n\n\tstr = strdup(text);\n\tp = strtok(str, \"\\n\");\n\textra = 0;\n\tcurrn = 0;\n\tif (v) fprintf(stderr, \"\\nname\\tstation\\tfreq (KHz)\\n\");\n\twhile (p) {\n\t\tif (p[0] == '[') {\n\t\t\tint ok = 1;\n\t\t\tstrncpy(line, p, 100);\n\t\t\tq = p+1;\t\n\t\t\twhile (*q) {\n\t\t\t\tif (*q == ']') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (! isdigit((unsigned char) (*q))) {\n\t\t\t\t\textra++;\n\t\t\t\t\tcurrn = maxn + extra;\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tint n;\n\t\t\t\tif (sscanf(p, \"[%d]\", &n) == 1)  {\n\t\t\t\t\tcurrn = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strstr(p, \"freq\") && (q = strchr(p, '=')) != NULL) {\n\t\t\tint n;\n\t\t\tq = lblanks(q+1);\n\t\t\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\t\t\tif (currn >= 0 && currn < CHANNEL_MAX) {\n\t\t\t\t\tif (v) fprintf(stderr, \"%s\\t%d\\t%d\\n\", line, currn, n);\n\t\t\t\t\tcustom_freq[currn] = (unsigned long) n;\n\t\t\t\t\tif (last_freq == 0) {\n\t\t\t\t\t\tlast_freq = custom_freq[currn];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \"\\n\");\n\t}\n\tif (v) fprintf(stderr, \"\\n\");\n\tv = 0;\n\tfree(str);\n\tfree(text);\n\tfree(dir);\n\tfree(file2);\n}"
  },
  {
    "function_name": "lookup_station",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1422-1439",
    "snippet": "static int lookup_station(unsigned long freq) {\n\tint i;\n\tif (freqtab) {\n\t\tfor (i = 0; i < CHANNEL_MAX; i++) {\nif (0) fprintf(stderr, \"%lu %lu\\n\", freq, custom_freq[i]);\n\t\t\tif (freq == custom_freq[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 1; i <= 125; i++) {\n\t\t\tif (freq == ntsc_cable[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500"
    ],
    "globals_used": [
      "static int lookup_station(unsigned long freq);",
      "static unsigned long ntsc_cable[CHANNEL_MAX];",
      "static unsigned long custom_freq[CHANNEL_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%lu %lu\\n\"",
            "freq",
            "custom_freq[i]"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\nstatic unsigned long custom_freq[CHANNEL_MAX];\n\nstatic int lookup_station(unsigned long freq) {\n\tint i;\n\tif (freqtab) {\n\t\tfor (i = 0; i < CHANNEL_MAX; i++) {\nif (0) fprintf(stderr, \"%lu %lu\\n\", freq, custom_freq[i]);\n\t\t\tif (freq == custom_freq[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 1; i <= 125; i++) {\n\t\t\tif (freq == ntsc_cable[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1409-1420",
    "snippet": "static unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500"
    ],
    "globals_used": [
      "static void v4l_sta(int sta);",
      "static unsigned long lookup_freqtab(int sta);",
      "static unsigned long lookup_freq(int sta);",
      "static unsigned long ntsc_cable[CHANNEL_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_freqtab",
          "args": [
            "sta"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_freqtab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1398-1407",
          "snippet": "static unsigned long lookup_freqtab(int sta) {\n\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 0 || sta >= CHANNEL_MAX) {\n\t\treturn 0;\n\t}\n\treturn custom_freq[sta];\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static void v4l_sta(int sta);",
            "static unsigned long lookup_freqtab(int sta);",
            "static unsigned long lookup_freq(int sta);",
            "static unsigned long custom_freq[CHANNEL_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic unsigned long custom_freq[CHANNEL_MAX];\n\nstatic unsigned long lookup_freqtab(int sta) {\n\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 0 || sta >= CHANNEL_MAX) {\n\t\treturn 0;\n\t}\n\treturn custom_freq[sta];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\n\nstatic unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}"
  },
  {
    "function_name": "lookup_freqtab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1398-1407",
    "snippet": "static unsigned long lookup_freqtab(int sta) {\n\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 0 || sta >= CHANNEL_MAX) {\n\t\treturn 0;\n\t}\n\treturn custom_freq[sta];\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500"
    ],
    "globals_used": [
      "static void v4l_sta(int sta);",
      "static unsigned long lookup_freqtab(int sta);",
      "static unsigned long lookup_freq(int sta);",
      "static unsigned long custom_freq[CHANNEL_MAX];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic unsigned long custom_freq[CHANNEL_MAX];\n\nstatic unsigned long lookup_freqtab(int sta) {\n\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 0 || sta >= CHANNEL_MAX) {\n\t\treturn 0;\n\t}\n\treturn custom_freq[sta];\n}"
  },
  {
    "function_name": "v4l_guess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1350-1396",
    "snippet": "char *v4l_guess(char *str, int *fd) {\n\tchar *dev = NULL, *settings = NULL, *atparms = NULL;\n\n\tparse_str(str, &dev, &settings, &atparms);\n\n\tinit_freqs();\n\n\tv4l1_cap = -1;\n\tv4l2_cap = -1;\n\t*fd = -1;\n\n\tif (dev == NULL) {\n\t\trfbLog(\"v4l_guess: could not find device in: %s\\n\", str);\n\t\treturn NULL;\n\t}\n\n\tif (settings) {\n\t\tapply_settings(dev, settings, fd);\n\t}\n\n\tif (atparms) {\n\t\t/* use user's parameters. */\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n\n\t/* try to query the device for parameters. */\n\tatparms = guess_via_v4l(dev, fd);\n\tif (atparms == NULL) {\n\t\t/* try again with v4l-info(1) */\n\t\tatparms = guess_via_v4l_info(dev, fd);\n\t}\n\n\tif (atparms == NULL) {\n\t\t/* bad news */\n\t\tif (*fd >= 0) {\n\t\t\tclose(*fd);\n\t\t}\n\t\t*fd = -1;\n\t\treturn NULL;\n\t} else {\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int open_dev(char *dev);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static void parse_str(char *str, char **dev, char **settings, char **atparms);",
      "static void init_freqs(void);",
      "static int v4l1_cap = -1;",
      "static int v4l2_cap = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "t",
            "\"snap:%s@%s\"",
            "dev",
            "atparms"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "5+strlen(dev)+1+strlen(atparms)+1"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "atparms"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "*fd"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "guess_via_v4l_info",
          "args": [
            "dev",
            "fd"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "guess_via_v4l_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1164-1289",
          "snippet": "static char *guess_via_v4l_info(char *dev, int *fd) {\n\tchar *atparms, *cmd;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tFILE *out;\n\tint tmp_fd, len, rc, curr = 0;\n\tint g_w = 0, g_h = 0, g_b = 0, mask_rev = 0;\n\tchar *g_fmt = NULL;\n\n\tif (*fd) {}\n\n\t/* v4l-info */\n\tif (no_external_cmds || !cmd_ok(\"v4l-info\")) {\n\t\trfbLog(\"guess_via_v4l_info: cannot run external \"\n\t\t    \"command: v4l-info\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (strchr(dev, '\\'')) {\n\t\trfbLog(\"guess_via_v4l_info: bad dev string: %s\\n\", dev);\n\t\treturn NULL;\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\treturn NULL;\n\t}\n\n\tlen =  strlen(\"v4l-info\")+1+1+strlen(dev)+1+1+1+1+strlen(tmp)+1; \n\tcmd = (char *) malloc(len);\n\trfbLog(\"guess_via_v4l_info running: v4l-info '%s'\\n\", dev);\n\tsprintf(cmd, \"v4l-info '%s' > %s\", dev, tmp);\n\n\tclose(tmp_fd);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tif (rc != 0) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\n\tout = fopen(tmp, \"r\");\n\tif (out == NULL) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\t\n\tcurr = 0;\n\twhile (fgets(line, sizeof line, out) != NULL) {\n\t\tchar *lb = lblanks(line);\n\t\tif (strstr(line, \"video capture\") == line) {\n\t\t\tcurr = C_VIDEO_CAPTURE;\n\t\t} else if (strstr(line, \"picture\") == line) {\n\t\t\tcurr = C_PICTURE;\n\t\t} else if (strstr(line, \"window\") == line) {\n\t\t\tcurr = C_WINDOW;\n\t\t}\n\nif (0) fprintf(stderr, \"lb: %s\", lb);\n\n\t\tif (curr == C_VIDEO_CAPTURE) {\n\t\t\tif (strstr(lb, \"pixelformat \") == lb) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t} else if (strstr(lb, \"fmt.pix.width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.pixelformat \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_tag(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_PICTURE) {\n\t\t\tif (strstr(lb, \"depth \") == lb) {\n\t\t\t\tif (! g_b) {\n\t\t\t\t\tg_b = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"palette \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_str(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_WINDOW) {\n\t\t\tif (strstr(lb, \"width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(out);\n\tunlink(tmp);\n\n\tif (! g_w) {\n\t\trfbLog(\"could not guess device width.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device width:  %d\\n\", g_w);\n\n\tif (! g_h) {\n\t\trfbLog(\"could not guess device height.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device height: %d\\n\", g_h);\n\n\tif (g_fmt) {\n\t\trfbLog(\"guessed pixel fmt:     %s\\n\", g_fmt);\n\t\tlookup_rgb(g_fmt, &g_b, &mask_rev);\n\t}\n\tif (! g_b) {\n\t\trfbLog(\"could not guess device bpp.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device bpp:    %d\\n\", g_b);\n\n\tatparms = (char *) malloc(100);\n\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_b);\n\treturn atparms;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define C_WINDOW        3",
            "#define C_PICTURE       2",
            "#define C_VIDEO_CAPTURE 1"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static void v4l_fmt(char *fmt);",
            "static int colon_n(char *line);",
            "static char *colon_str(char *line);",
            "static char *colon_tag(char *line);",
            "static void lookup_rgb(char *g_fmt, int *g_b, int *mask_rev);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static int open_dev(char *dev);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static void parse_str(char *str, char **dev, char **settings, char **atparms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define C_WINDOW        3\n#define C_PICTURE       2\n#define C_VIDEO_CAPTURE 1\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\nstatic void lookup_rgb(char *g_fmt, int *g_b, int *mask_rev);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\n\nstatic char *guess_via_v4l_info(char *dev, int *fd) {\n\tchar *atparms, *cmd;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tFILE *out;\n\tint tmp_fd, len, rc, curr = 0;\n\tint g_w = 0, g_h = 0, g_b = 0, mask_rev = 0;\n\tchar *g_fmt = NULL;\n\n\tif (*fd) {}\n\n\t/* v4l-info */\n\tif (no_external_cmds || !cmd_ok(\"v4l-info\")) {\n\t\trfbLog(\"guess_via_v4l_info: cannot run external \"\n\t\t    \"command: v4l-info\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (strchr(dev, '\\'')) {\n\t\trfbLog(\"guess_via_v4l_info: bad dev string: %s\\n\", dev);\n\t\treturn NULL;\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\treturn NULL;\n\t}\n\n\tlen =  strlen(\"v4l-info\")+1+1+strlen(dev)+1+1+1+1+strlen(tmp)+1; \n\tcmd = (char *) malloc(len);\n\trfbLog(\"guess_via_v4l_info running: v4l-info '%s'\\n\", dev);\n\tsprintf(cmd, \"v4l-info '%s' > %s\", dev, tmp);\n\n\tclose(tmp_fd);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tif (rc != 0) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\n\tout = fopen(tmp, \"r\");\n\tif (out == NULL) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\t\n\tcurr = 0;\n\twhile (fgets(line, sizeof line, out) != NULL) {\n\t\tchar *lb = lblanks(line);\n\t\tif (strstr(line, \"video capture\") == line) {\n\t\t\tcurr = C_VIDEO_CAPTURE;\n\t\t} else if (strstr(line, \"picture\") == line) {\n\t\t\tcurr = C_PICTURE;\n\t\t} else if (strstr(line, \"window\") == line) {\n\t\t\tcurr = C_WINDOW;\n\t\t}\n\nif (0) fprintf(stderr, \"lb: %s\", lb);\n\n\t\tif (curr == C_VIDEO_CAPTURE) {\n\t\t\tif (strstr(lb, \"pixelformat \") == lb) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t} else if (strstr(lb, \"fmt.pix.width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.pixelformat \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_tag(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_PICTURE) {\n\t\t\tif (strstr(lb, \"depth \") == lb) {\n\t\t\t\tif (! g_b) {\n\t\t\t\t\tg_b = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"palette \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_str(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_WINDOW) {\n\t\t\tif (strstr(lb, \"width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(out);\n\tunlink(tmp);\n\n\tif (! g_w) {\n\t\trfbLog(\"could not guess device width.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device width:  %d\\n\", g_w);\n\n\tif (! g_h) {\n\t\trfbLog(\"could not guess device height.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device height: %d\\n\", g_h);\n\n\tif (g_fmt) {\n\t\trfbLog(\"guessed pixel fmt:     %s\\n\", g_fmt);\n\t\tlookup_rgb(g_fmt, &g_b, &mask_rev);\n\t}\n\tif (! g_b) {\n\t\trfbLog(\"could not guess device bpp.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device bpp:    %d\\n\", g_b);\n\n\tatparms = (char *) malloc(100);\n\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_b);\n\treturn atparms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "t",
            "\"snap:%s@%s\"",
            "dev",
            "atparms"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "5+strlen(dev)+1+strlen(atparms)+1"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "atparms"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_settings",
          "args": [
            "dev",
            "settings",
            "fd"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "apply_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "279-432",
          "snippet": "static void apply_settings(char *dev, char *settings, int *fd) {\n#ifdef V4L_OK\n\tchar *str, *p, *fmt = NULL, *tun = NULL, *inp = NULL;\n\tint br = -1, co = -1, cn = -1, hu = -1;\n\tint w = -1, h = -1, b = -1;\n\tint sta = -1;\n\tint setcnt = 0;\n\tif (! settings || settings[0] == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(settings);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (strstr(p, \"br=\") == p) {\n\t\t\tbr = atoi(p+3);\n\t\t\tif (br >= 0) setcnt++;\n\t\t} else if (strstr(p, \"co=\") == p) {\n\t\t\tco = atoi(p+3);\n\t\t\tif (co >= 0) setcnt++;\n\t\t} else if (strstr(p, \"cn=\") == p) {\n\t\t\tcn = atoi(p+3);\n\t\t\tif (cn >= 0) setcnt++;\n\t\t} else if (strstr(p, \"hu=\") == p) {\n\t\t\thu = atoi(p+3);\n\t\t\tif (hu >= 0) setcnt++;\n\t\t} else if (strstr(p, \"w=\") == p) {\n\t\t\tw = atoi(p+2);\n\t\t\tif (w > 0) setcnt++;\n\t\t} else if (strstr(p, \"h=\") == p) {\n\t\t\th = atoi(p+2);\n\t\t\tif (h > 0) setcnt++;\n\t\t} else if (strstr(p, \"bpp=\") == p) {\n\t\t\tb = atoi(p+4);\n\t\t\tif (b > 0) setcnt++;\n\t\t} else if (strstr(p, \"fmt=\") == p) {\n\t\t\tfmt = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"tun=\") == p) {\n\t\t\ttun = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"inp=\") == p) {\n\t\t\tinp = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"sta=\") == p) {\n\t\t\tsta = atoi(p+4);\n\t\t\tsetcnt++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\tif (! setcnt) {\n\t\treturn;\n\t}\n\tif (*fd < 0) {\n\t\t*fd = open_dev(dev);\n\t}\n\tif (*fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n\n\tif (v4l1_cap && ! ignore_all) {\n\t\tif (br >= 0) v4l1_picture.brightness = v4l1_val(br);\n\t\tif (hu >= 0) v4l1_picture.hue        = v4l1_val(hu);\n\t\tif (co >= 0) v4l1_picture.colour     = v4l1_val(co);\n\t\tif (cn >= 0) v4l1_picture.contrast   = v4l1_val(cn);\n\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\t\tif (ioctl(*fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\t}\n\n\t\tif (fmt) {\n\t\t\tv4l1_setfmt(*fd, fmt);\n\t\t} else if (b > 0 && b != v4l1_picture.depth) {\n\t\t\tif (b == 8) {\n\t\t\t\tv4l1_setfmt(*fd, \"HI240\");\n\t\t\t} else if (b == 16) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB565\");\n\t\t\t} else if (b == 24) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB24\");\n\t\t\t} else if (b == 32) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB32\");\n\t\t\t}\n\t\t}\n\n\t\tv4l1_resize(*fd, w, h);\n\n\t\tif (tun) {\n\t\t\tint mode = -1;\n\t\t\tif (!strcasecmp(tun, \"PAL\")) {\n\t\t\t\tmode = VIDEO_MODE_PAL;\n\t\t\t} else if (!strcasecmp(tun, \"NTSC\")) {\n\t\t\t\tmode = VIDEO_MODE_NTSC;\n\t\t\t} else if (!strcasecmp(tun, \"SECAM\")) {\n\t\t\t\tmode = VIDEO_MODE_SECAM;\n\t\t\t} else if (!strcasecmp(tun, \"AUTO\")) {\n\t\t\t\tmode = VIDEO_MODE_AUTO;\n\t\t\t}\n\t\t\tif (mode != -1) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (! v4l1_channel.tuners) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (v4l1_channel.norm == mode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv4l1_channel.norm = mode;\n\t\t\t\t\tioctl(*fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inp) {\n\t\t\tchar s[2];\n\t\t\tint i, chan = -1;\n\n\t\t\ts[0] = inp[0];\n\t\t\ts[1] = '\\0';\n\t\t\tif (strstr(\"0123456789\", s)) {\n\t\t\t\tchan = atoi(inp);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp(v4l1_channel.name, inp)) {\n\t\t\t\t\t\tchan = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv4l1_set_input(*fd, chan);\n\t\t}\n\t\tif (sta >= 0) {\n\t\t\tunsigned long freq = lookup_freq(sta);\n\t\t\tv4l1_setfreq(*fd, freq, 1);\n\t\t}\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n#else\n\tif (!dev || !settings || !fd) {}\n\treturn;\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_width(int w);",
            "static int v4l1_height(int h);",
            "static int v4l1_resize(int fd, int w, int h);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);",
            "static void v4l_sta(int sta);",
            "static void v4l_inp(int inp);",
            "static void v4l_fmt(char *fmt);",
            "static int open_dev(char *dev);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static unsigned long lookup_freqtab(int sta);",
            "static unsigned long lookup_freq(int sta);",
            "static int lookup_station(unsigned long freq);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;",
            "static int ignore_all = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\nstatic void v4l_sta(int sta);\nstatic void v4l_inp(int inp);\nstatic void v4l_fmt(char *fmt);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic int lookup_station(unsigned long freq);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\nstatic int ignore_all = 0;\n\nstatic void apply_settings(char *dev, char *settings, int *fd) {\n#ifdef V4L_OK\n\tchar *str, *p, *fmt = NULL, *tun = NULL, *inp = NULL;\n\tint br = -1, co = -1, cn = -1, hu = -1;\n\tint w = -1, h = -1, b = -1;\n\tint sta = -1;\n\tint setcnt = 0;\n\tif (! settings || settings[0] == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(settings);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (strstr(p, \"br=\") == p) {\n\t\t\tbr = atoi(p+3);\n\t\t\tif (br >= 0) setcnt++;\n\t\t} else if (strstr(p, \"co=\") == p) {\n\t\t\tco = atoi(p+3);\n\t\t\tif (co >= 0) setcnt++;\n\t\t} else if (strstr(p, \"cn=\") == p) {\n\t\t\tcn = atoi(p+3);\n\t\t\tif (cn >= 0) setcnt++;\n\t\t} else if (strstr(p, \"hu=\") == p) {\n\t\t\thu = atoi(p+3);\n\t\t\tif (hu >= 0) setcnt++;\n\t\t} else if (strstr(p, \"w=\") == p) {\n\t\t\tw = atoi(p+2);\n\t\t\tif (w > 0) setcnt++;\n\t\t} else if (strstr(p, \"h=\") == p) {\n\t\t\th = atoi(p+2);\n\t\t\tif (h > 0) setcnt++;\n\t\t} else if (strstr(p, \"bpp=\") == p) {\n\t\t\tb = atoi(p+4);\n\t\t\tif (b > 0) setcnt++;\n\t\t} else if (strstr(p, \"fmt=\") == p) {\n\t\t\tfmt = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"tun=\") == p) {\n\t\t\ttun = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"inp=\") == p) {\n\t\t\tinp = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"sta=\") == p) {\n\t\t\tsta = atoi(p+4);\n\t\t\tsetcnt++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\tif (! setcnt) {\n\t\treturn;\n\t}\n\tif (*fd < 0) {\n\t\t*fd = open_dev(dev);\n\t}\n\tif (*fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n\n\tif (v4l1_cap && ! ignore_all) {\n\t\tif (br >= 0) v4l1_picture.brightness = v4l1_val(br);\n\t\tif (hu >= 0) v4l1_picture.hue        = v4l1_val(hu);\n\t\tif (co >= 0) v4l1_picture.colour     = v4l1_val(co);\n\t\tif (cn >= 0) v4l1_picture.contrast   = v4l1_val(cn);\n\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\t\tif (ioctl(*fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\t}\n\n\t\tif (fmt) {\n\t\t\tv4l1_setfmt(*fd, fmt);\n\t\t} else if (b > 0 && b != v4l1_picture.depth) {\n\t\t\tif (b == 8) {\n\t\t\t\tv4l1_setfmt(*fd, \"HI240\");\n\t\t\t} else if (b == 16) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB565\");\n\t\t\t} else if (b == 24) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB24\");\n\t\t\t} else if (b == 32) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB32\");\n\t\t\t}\n\t\t}\n\n\t\tv4l1_resize(*fd, w, h);\n\n\t\tif (tun) {\n\t\t\tint mode = -1;\n\t\t\tif (!strcasecmp(tun, \"PAL\")) {\n\t\t\t\tmode = VIDEO_MODE_PAL;\n\t\t\t} else if (!strcasecmp(tun, \"NTSC\")) {\n\t\t\t\tmode = VIDEO_MODE_NTSC;\n\t\t\t} else if (!strcasecmp(tun, \"SECAM\")) {\n\t\t\t\tmode = VIDEO_MODE_SECAM;\n\t\t\t} else if (!strcasecmp(tun, \"AUTO\")) {\n\t\t\t\tmode = VIDEO_MODE_AUTO;\n\t\t\t}\n\t\t\tif (mode != -1) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (! v4l1_channel.tuners) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (v4l1_channel.norm == mode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv4l1_channel.norm = mode;\n\t\t\t\t\tioctl(*fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inp) {\n\t\t\tchar s[2];\n\t\t\tint i, chan = -1;\n\n\t\t\ts[0] = inp[0];\n\t\t\ts[1] = '\\0';\n\t\t\tif (strstr(\"0123456789\", s)) {\n\t\t\t\tchan = atoi(inp);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp(v4l1_channel.name, inp)) {\n\t\t\t\t\t\tchan = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv4l1_set_input(*fd, chan);\n\t\t}\n\t\tif (sta >= 0) {\n\t\t\tunsigned long freq = lookup_freq(sta);\n\t\t\tv4l1_setfreq(*fd, freq, 1);\n\t\t}\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n#else\n\tif (!dev || !settings || !fd) {}\n\treturn;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"v4l_guess: could not find device in: %s\\n\"",
            "str"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_freqs",
          "args": [],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "init_freqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1643-1656",
          "snippet": "static void init_freqs(void) {\n\tint i;\n\tfor (i=0; i<CHANNEL_MAX; i++) {\n\t\tntsc_cable[i] = 0;\n\t\tcustom_freq[i] = 0;\n\t}\n\n\tinit_ntsc_cable();\n\tlast_freq = ntsc_cable[1];\n\n\tif (freqtab) {\n\t\tinit_freqtab(freqtab);\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static void init_freqs(void);",
            "static void init_ntsc_cable(void);",
            "static unsigned long ntsc_cable[CHANNEL_MAX];",
            "static unsigned long custom_freq[CHANNEL_MAX];",
            "static unsigned long last_freq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void init_freqs(void);\nstatic void init_ntsc_cable(void);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\nstatic unsigned long custom_freq[CHANNEL_MAX];\nstatic unsigned long last_freq = 0;\n\nstatic void init_freqs(void) {\n\tint i;\n\tfor (i=0; i<CHANNEL_MAX; i++) {\n\t\tntsc_cable[i] = 0;\n\t\tcustom_freq[i] = 0;\n\t}\n\n\tinit_ntsc_cable();\n\tlast_freq = ntsc_cable[1];\n\n\tif (freqtab) {\n\t\tinit_freqtab(freqtab);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "str",
            "&dev",
            "&settings",
            "&atparms"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1291-1348",
          "snippet": "static void parse_str(char *str, char **dev, char **settings, char **atparms) {\n\tchar *p, *q, *s = NULL;\n\n\tq = strchr(str, '@');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends @WxHXB... */\n\t\t*atparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tq = strchr(str, ':');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends :br=N,w=N... */\n\t\ts = strdup(q+1);\n\t\t*settings = s;\n\t\t*q = '\\0';\n\t}\n\n\tif (s != NULL) {\n\t\t/* see if fn=filename */\n\t\tq = strstr(s, \"fn=\");\n\t\tif (q) {\n\t\t\tq += strlen(\"fn=\");\n\t\t\tp = strchr(q, ',');\n\t\t\tif (p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\t*dev = strdup(q); \n\t\t\t\t*p = ',';\n\t\t\t} else {\n\t\t\t\t*dev = strdup(q); \n\t\t\t}\n\t\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t\t}\n\t}\n\n\tif (*dev == NULL) {\n\t\tstruct stat sbuf;\n\t\ts = (char *) malloc(strlen(\"/dev/\") + strlen(str) + 2);\n\t\tif (strstr(str, \"/dev/\") == str) {\n\t\t\tsprintf(s, \"%s\", str);\n\t\t} else {\n\t\t\tsprintf(s, \"/dev/%s\", str);\n\t\t} \n\t\trfbLog(\"Checking existence of '%s'\\n\", s);\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tstrcat(s, \"0\");\n\t\t\trfbLog(\"switching to '%s'\\n\", s);\n\t\t}\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\trfbLog(\"You will need to specify the video device more explicitly.\\n\");\n\t\t}\n\n\t\t*dev = s;\n\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int v4l1_width(int w);",
            "static int open_dev(char *dev);",
            "static void parse_str(char *str, char **dev, char **settings, char **atparms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_width(int w);\nstatic int open_dev(char *dev);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\n\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms) {\n\tchar *p, *q, *s = NULL;\n\n\tq = strchr(str, '@');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends @WxHXB... */\n\t\t*atparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tq = strchr(str, ':');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends :br=N,w=N... */\n\t\ts = strdup(q+1);\n\t\t*settings = s;\n\t\t*q = '\\0';\n\t}\n\n\tif (s != NULL) {\n\t\t/* see if fn=filename */\n\t\tq = strstr(s, \"fn=\");\n\t\tif (q) {\n\t\t\tq += strlen(\"fn=\");\n\t\t\tp = strchr(q, ',');\n\t\t\tif (p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\t*dev = strdup(q); \n\t\t\t\t*p = ',';\n\t\t\t} else {\n\t\t\t\t*dev = strdup(q); \n\t\t\t}\n\t\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t\t}\n\t}\n\n\tif (*dev == NULL) {\n\t\tstruct stat sbuf;\n\t\ts = (char *) malloc(strlen(\"/dev/\") + strlen(str) + 2);\n\t\tif (strstr(str, \"/dev/\") == str) {\n\t\t\tsprintf(s, \"%s\", str);\n\t\t} else {\n\t\t\tsprintf(s, \"/dev/%s\", str);\n\t\t} \n\t\trfbLog(\"Checking existence of '%s'\\n\", s);\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tstrcat(s, \"0\");\n\t\t\trfbLog(\"switching to '%s'\\n\", s);\n\t\t}\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\trfbLog(\"You will need to specify the video device more explicitly.\\n\");\n\t\t}\n\n\t\t*dev = s;\n\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\nstatic void init_freqs(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nchar *v4l_guess(char *str, int *fd) {\n\tchar *dev = NULL, *settings = NULL, *atparms = NULL;\n\n\tparse_str(str, &dev, &settings, &atparms);\n\n\tinit_freqs();\n\n\tv4l1_cap = -1;\n\tv4l2_cap = -1;\n\t*fd = -1;\n\n\tif (dev == NULL) {\n\t\trfbLog(\"v4l_guess: could not find device in: %s\\n\", str);\n\t\treturn NULL;\n\t}\n\n\tif (settings) {\n\t\tapply_settings(dev, settings, fd);\n\t}\n\n\tif (atparms) {\n\t\t/* use user's parameters. */\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n\n\t/* try to query the device for parameters. */\n\tatparms = guess_via_v4l(dev, fd);\n\tif (atparms == NULL) {\n\t\t/* try again with v4l-info(1) */\n\t\tatparms = guess_via_v4l_info(dev, fd);\n\t}\n\n\tif (atparms == NULL) {\n\t\t/* bad news */\n\t\tif (*fd >= 0) {\n\t\t\tclose(*fd);\n\t\t}\n\t\t*fd = -1;\n\t\treturn NULL;\n\t} else {\n\t\tchar *t = (char *) malloc(5+strlen(dev)+1+strlen(atparms)+1);\n\t\tsprintf(t, \"snap:%s@%s\", dev, atparms);\n\t\treturn t;\n\t}\n}"
  },
  {
    "function_name": "parse_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1291-1348",
    "snippet": "static void parse_str(char *str, char **dev, char **settings, char **atparms) {\n\tchar *p, *q, *s = NULL;\n\n\tq = strchr(str, '@');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends @WxHXB... */\n\t\t*atparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tq = strchr(str, ':');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends :br=N,w=N... */\n\t\ts = strdup(q+1);\n\t\t*settings = s;\n\t\t*q = '\\0';\n\t}\n\n\tif (s != NULL) {\n\t\t/* see if fn=filename */\n\t\tq = strstr(s, \"fn=\");\n\t\tif (q) {\n\t\t\tq += strlen(\"fn=\");\n\t\t\tp = strchr(q, ',');\n\t\t\tif (p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\t*dev = strdup(q); \n\t\t\t\t*p = ',';\n\t\t\t} else {\n\t\t\t\t*dev = strdup(q); \n\t\t\t}\n\t\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t\t}\n\t}\n\n\tif (*dev == NULL) {\n\t\tstruct stat sbuf;\n\t\ts = (char *) malloc(strlen(\"/dev/\") + strlen(str) + 2);\n\t\tif (strstr(str, \"/dev/\") == str) {\n\t\t\tsprintf(s, \"%s\", str);\n\t\t} else {\n\t\t\tsprintf(s, \"/dev/%s\", str);\n\t\t} \n\t\trfbLog(\"Checking existence of '%s'\\n\", s);\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tstrcat(s, \"0\");\n\t\t\trfbLog(\"switching to '%s'\\n\", s);\n\t\t}\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\trfbLog(\"You will need to specify the video device more explicitly.\\n\");\n\t\t}\n\n\t\t*dev = s;\n\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int v4l1_width(int w);",
      "static int open_dev(char *dev);",
      "static void parse_str(char *str, char **dev, char **settings, char **atparms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set video device to: '%s'\\n\"",
            "*dev"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"You will need to specify the video device more explicitly.\\n\""
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "&sbuf"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"switching to '%s'\\n\"",
            "s"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "s",
            "\"0\""
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Checking existence of '%s'\\n\"",
            "s"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"/dev/%s\"",
            "str"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s\"",
            "str"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"/dev/\""
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/dev/\") + strlen(str) + 2"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/dev/\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set video device to: '%s'\\n\"",
            "*dev"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "','"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"fn=\""
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"fn=\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q+1"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q+1"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'@'"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_width(int w);\nstatic int open_dev(char *dev);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\n\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms) {\n\tchar *p, *q, *s = NULL;\n\n\tq = strchr(str, '@');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends @WxHXB... */\n\t\t*atparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\n\tq = strchr(str, ':');\n\tif (q && strlen(q+1) > 0) {\n\t\t/* ends :br=N,w=N... */\n\t\ts = strdup(q+1);\n\t\t*settings = s;\n\t\t*q = '\\0';\n\t}\n\n\tif (s != NULL) {\n\t\t/* see if fn=filename */\n\t\tq = strstr(s, \"fn=\");\n\t\tif (q) {\n\t\t\tq += strlen(\"fn=\");\n\t\t\tp = strchr(q, ',');\n\t\t\tif (p) {\n\t\t\t\t*p = '\\0';\n\t\t\t\t*dev = strdup(q); \n\t\t\t\t*p = ',';\n\t\t\t} else {\n\t\t\t\t*dev = strdup(q); \n\t\t\t}\n\t\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t\t}\n\t}\n\n\tif (*dev == NULL) {\n\t\tstruct stat sbuf;\n\t\ts = (char *) malloc(strlen(\"/dev/\") + strlen(str) + 2);\n\t\tif (strstr(str, \"/dev/\") == str) {\n\t\t\tsprintf(s, \"%s\", str);\n\t\t} else {\n\t\t\tsprintf(s, \"/dev/%s\", str);\n\t\t} \n\t\trfbLog(\"Checking existence of '%s'\\n\", s);\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tstrcat(s, \"0\");\n\t\t\trfbLog(\"switching to '%s'\\n\", s);\n\t\t}\n                if (stat(s, &sbuf) != 0) {\n\t\t\trfbLogPerror(\"stat\");\n\t\t\trfbLog(\"You will need to specify the video device more explicitly.\\n\");\n\t\t}\n\n\t\t*dev = s;\n\t\trfbLog(\"set video device to: '%s'\\n\", *dev);\n\t}\n}"
  },
  {
    "function_name": "guess_via_v4l_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1164-1289",
    "snippet": "static char *guess_via_v4l_info(char *dev, int *fd) {\n\tchar *atparms, *cmd;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tFILE *out;\n\tint tmp_fd, len, rc, curr = 0;\n\tint g_w = 0, g_h = 0, g_b = 0, mask_rev = 0;\n\tchar *g_fmt = NULL;\n\n\tif (*fd) {}\n\n\t/* v4l-info */\n\tif (no_external_cmds || !cmd_ok(\"v4l-info\")) {\n\t\trfbLog(\"guess_via_v4l_info: cannot run external \"\n\t\t    \"command: v4l-info\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (strchr(dev, '\\'')) {\n\t\trfbLog(\"guess_via_v4l_info: bad dev string: %s\\n\", dev);\n\t\treturn NULL;\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\treturn NULL;\n\t}\n\n\tlen =  strlen(\"v4l-info\")+1+1+strlen(dev)+1+1+1+1+strlen(tmp)+1; \n\tcmd = (char *) malloc(len);\n\trfbLog(\"guess_via_v4l_info running: v4l-info '%s'\\n\", dev);\n\tsprintf(cmd, \"v4l-info '%s' > %s\", dev, tmp);\n\n\tclose(tmp_fd);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tif (rc != 0) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\n\tout = fopen(tmp, \"r\");\n\tif (out == NULL) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\t\n\tcurr = 0;\n\twhile (fgets(line, sizeof line, out) != NULL) {\n\t\tchar *lb = lblanks(line);\n\t\tif (strstr(line, \"video capture\") == line) {\n\t\t\tcurr = C_VIDEO_CAPTURE;\n\t\t} else if (strstr(line, \"picture\") == line) {\n\t\t\tcurr = C_PICTURE;\n\t\t} else if (strstr(line, \"window\") == line) {\n\t\t\tcurr = C_WINDOW;\n\t\t}\n\nif (0) fprintf(stderr, \"lb: %s\", lb);\n\n\t\tif (curr == C_VIDEO_CAPTURE) {\n\t\t\tif (strstr(lb, \"pixelformat \") == lb) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t} else if (strstr(lb, \"fmt.pix.width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.pixelformat \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_tag(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_PICTURE) {\n\t\t\tif (strstr(lb, \"depth \") == lb) {\n\t\t\t\tif (! g_b) {\n\t\t\t\t\tg_b = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"palette \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_str(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_WINDOW) {\n\t\t\tif (strstr(lb, \"width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(out);\n\tunlink(tmp);\n\n\tif (! g_w) {\n\t\trfbLog(\"could not guess device width.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device width:  %d\\n\", g_w);\n\n\tif (! g_h) {\n\t\trfbLog(\"could not guess device height.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device height: %d\\n\", g_h);\n\n\tif (g_fmt) {\n\t\trfbLog(\"guessed pixel fmt:     %s\\n\", g_fmt);\n\t\tlookup_rgb(g_fmt, &g_b, &mask_rev);\n\t}\n\tif (! g_b) {\n\t\trfbLog(\"could not guess device bpp.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device bpp:    %d\\n\", g_b);\n\n\tatparms = (char *) malloc(100);\n\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_b);\n\treturn atparms;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define C_WINDOW        3",
      "#define C_PICTURE       2",
      "#define C_VIDEO_CAPTURE 1"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static void v4l_fmt(char *fmt);",
      "static int colon_n(char *line);",
      "static char *colon_str(char *line);",
      "static char *colon_tag(char *line);",
      "static void lookup_rgb(char *g_fmt, int *g_b, int *mask_rev);",
      "static char *v4l1_lu_palette(unsigned short palette);",
      "static char *v4l2_lu_palette(unsigned int palette);",
      "static int open_dev(char *dev);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static void parse_str(char *str, char **dev, char **settings, char **atparms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "atparms",
            "\"%dx%dx%d\"",
            "g_w",
            "g_h",
            "g_b"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "100"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed device bpp:    %d\\n\"",
            "g_b"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not guess device bpp.\\n\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rgb",
          "args": [
            "g_fmt",
            "&g_b",
            "&mask_rev"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rgb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "735-748",
          "snippet": "static void lookup_rgb(char *fmt, int *bits, int *rev) {\n\tint tb, tr;\n\n\tif (v4l2_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n\tif (v4l1_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void v4l_fmt(char *fmt);",
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_fmt(char *fmt);\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic void lookup_rgb(char *fmt, int *bits, int *rev) {\n\tint tb, tr;\n\n\tif (v4l2_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n\tif (v4l1_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed pixel fmt:     %s\\n\"",
            "g_fmt"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed device height: %d\\n\"",
            "g_h"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not guess device height.\\n\""
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guessed device width:  %d\\n\"",
            "g_w"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not guess device width.\\n\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "colon_n",
          "args": [
            "line"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "colon_n",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "688-700",
          "snippet": "static int colon_n(char *line) {\n\tchar *q;\n\tint n;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn 0;\n\t}\n\tq = lblanks(q+1);\n\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\treturn n;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static int colon_n(char *line);",
            "static char *colon_str(char *line);",
            "static char *colon_tag(char *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_dpct(int old, int d);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic int colon_n(char *line) {\n\tchar *q;\n\tint n;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn 0;\n\t}\n\tq = lblanks(q+1);\n\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\treturn n;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"height \""
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"width \""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "colon_str",
          "args": [
            "line"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "colon_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "702-716",
          "snippet": "static char *colon_str(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq = lblanks(q+1);\n\tp = strpbrk(q, \" \\t\\n\");\n\tif (p) {\n\t\t*p = '\\0';\n\t}\n\tt = strdup(q);\n\t*p = '\\n';\n\treturn t;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int colon_n(char *line);",
            "static char *colon_str(char *line);",
            "static char *colon_tag(char *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic char *colon_str(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq = lblanks(q+1);\n\tp = strpbrk(q, \" \\t\\n\");\n\tif (p) {\n\t\t*p = '\\0';\n\t}\n\tt = strdup(q);\n\t*p = '\\n';\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"palette \""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"depth \""
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "colon_tag",
          "args": [
            "line"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "colon_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "718-733",
          "snippet": "static char *colon_tag(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, '[');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq++;\n\tp = strrchr(q, ']');\n\tif (! p) {\n\t\treturn strdup(\"\");\n\t}\n\t*p = '\\0';\n\tt = strdup(q);\n\t*p = ']';\n\treturn t;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int colon_n(char *line);",
            "static char *colon_str(char *line);",
            "static char *colon_tag(char *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic char *colon_tag(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, '[');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq++;\n\tp = strrchr(q, ']');\n\tif (! p) {\n\t\treturn strdup(\"\");\n\t}\n\t*p = '\\0';\n\tt = strdup(q);\n\t*p = ']';\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"fmt.pix.pixelformat \""
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"fmt.pix.height \""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"fmt.pix.width \""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lb",
            "\"pixelformat \""
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"lb: %s\"",
            "lb"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"window\""
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"picture\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"video capture\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "out"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tmp",
            "\"r\""
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmp_fd"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"v4l-info '%s' > %s\"",
            "dev",
            "tmp"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guess_via_v4l_info running: v4l-info '%s'\\n\"",
            "dev"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"v4l-info\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guess_via_v4l_info: bad dev string: %s\\n\"",
            "dev"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "dev",
            "'\\''"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guess_via_v4l_info: cannot run external \"\n\t\t    \"command: v4l-info\\n\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"v4l-info\""
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define C_WINDOW        3\n#define C_PICTURE       2\n#define C_VIDEO_CAPTURE 1\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\nstatic void lookup_rgb(char *g_fmt, int *g_b, int *mask_rev);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\n\nstatic char *guess_via_v4l_info(char *dev, int *fd) {\n\tchar *atparms, *cmd;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tFILE *out;\n\tint tmp_fd, len, rc, curr = 0;\n\tint g_w = 0, g_h = 0, g_b = 0, mask_rev = 0;\n\tchar *g_fmt = NULL;\n\n\tif (*fd) {}\n\n\t/* v4l-info */\n\tif (no_external_cmds || !cmd_ok(\"v4l-info\")) {\n\t\trfbLog(\"guess_via_v4l_info: cannot run external \"\n\t\t    \"command: v4l-info\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (strchr(dev, '\\'')) {\n\t\trfbLog(\"guess_via_v4l_info: bad dev string: %s\\n\", dev);\n\t\treturn NULL;\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\treturn NULL;\n\t}\n\n\tlen =  strlen(\"v4l-info\")+1+1+strlen(dev)+1+1+1+1+strlen(tmp)+1; \n\tcmd = (char *) malloc(len);\n\trfbLog(\"guess_via_v4l_info running: v4l-info '%s'\\n\", dev);\n\tsprintf(cmd, \"v4l-info '%s' > %s\", dev, tmp);\n\n\tclose(tmp_fd);\n\tclose_exec_fds();\n\trc = system(cmd);\n\tif (rc != 0) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\n\tout = fopen(tmp, \"r\");\n\tif (out == NULL) {\n\t\tunlink(tmp);\n\t\treturn NULL;\n\t}\n\t\n\tcurr = 0;\n\twhile (fgets(line, sizeof line, out) != NULL) {\n\t\tchar *lb = lblanks(line);\n\t\tif (strstr(line, \"video capture\") == line) {\n\t\t\tcurr = C_VIDEO_CAPTURE;\n\t\t} else if (strstr(line, \"picture\") == line) {\n\t\t\tcurr = C_PICTURE;\n\t\t} else if (strstr(line, \"window\") == line) {\n\t\t\tcurr = C_WINDOW;\n\t\t}\n\nif (0) fprintf(stderr, \"lb: %s\", lb);\n\n\t\tif (curr == C_VIDEO_CAPTURE) {\n\t\t\tif (strstr(lb, \"pixelformat \") == lb) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t} else if (strstr(lb, \"fmt.pix.width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"fmt.pix.pixelformat \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_tag(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_PICTURE) {\n\t\t\tif (strstr(lb, \"depth \") == lb) {\n\t\t\t\tif (! g_b) {\n\t\t\t\t\tg_b = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"palette \") == lb) {\n\t\t\t\tif (! g_fmt) {\n\t\t\t\t\tg_fmt = colon_str(line);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curr == C_WINDOW) {\n\t\t\tif (strstr(lb, \"width \") == lb) {\n\t\t\t\tif (! g_w) {\n\t\t\t\t\tg_w = colon_n(line);\n\t\t\t\t}\n\t\t\t} else if (strstr(lb, \"height \") == lb) {\n\t\t\t\tif (! g_h) {\n\t\t\t\t\tg_h = colon_n(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(out);\n\tunlink(tmp);\n\n\tif (! g_w) {\n\t\trfbLog(\"could not guess device width.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device width:  %d\\n\", g_w);\n\n\tif (! g_h) {\n\t\trfbLog(\"could not guess device height.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device height: %d\\n\", g_h);\n\n\tif (g_fmt) {\n\t\trfbLog(\"guessed pixel fmt:     %s\\n\", g_fmt);\n\t\tlookup_rgb(g_fmt, &g_b, &mask_rev);\n\t}\n\tif (! g_b) {\n\t\trfbLog(\"could not guess device bpp.\\n\");\n\t\treturn NULL;\n\t}\n\trfbLog(\"guessed device bpp:    %d\\n\", g_b);\n\n\tatparms = (char *) malloc(100);\n\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_b);\n\treturn atparms;\n}"
  },
  {
    "function_name": "guess_via_v4l",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1086-1162",
    "snippet": "static char *guess_via_v4l(char *dev, int *fd) {\n#ifdef V4L_OK\n\tint dfd;\n\t\n\tif (*fd < 0) {\n\t\tdfd = open_dev(dev);\n\t\t*fd = dfd;\n\t}\n\tdfd = *fd;\n\tif (dfd < 0) {\n\t\treturn NULL;\n\t}\n\tif (v4l1_cap < 0) {\n\t\tv4l1_cap = v4l1_query(dfd, 1);\n\t}\n\tif (v4l2_cap < 0) {\n\t\tv4l2_cap = v4l2_query(dfd, 1);\n\t}\n\n\tif (v4l2_cap) {\n#if HAVE_V4L2\n\t\tint g_w = v4l2_format.fmt.pix.width;\n\t\tint g_h = v4l2_format.fmt.pix.height;\n\t\tint g_d = 0, g_rev;\n\n\t\tif (v4l2_format.fmt.pix.pixelformat) {\n\t\t\tchar *str = v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat);\n\t\t\tif (strcmp(str, \"unknown\")) {\n\t\t\t\tv4l2_lu_palette_str(str, &g_d, &g_rev);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (g_w > 0 && g_h > 0 && g_d > 0) {\n\t\t\tchar *atparms = (char *) malloc(200);\n\t\t\tchar *pal = v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat);\n\t\t\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_d);\n\t\t\tif (strstr(pal, \"RGB555\")) {\n\t\t\t\tstrcat(atparms, \":7c00/3e0/1f\");\n\t\t\t}\n\t\t\t*fd = dfd;\n\t\t\treturn atparms;\n\t\t}\n#endif\n\t}\n\tif (v4l1_cap) {\n\t\tint g_w = v4l1_window.width;\n\t\tint g_h = v4l1_window.height;\n\t\tint g_d = v4l1_picture.depth;\n\t\tint g_rev;\n\t\tif (g_d == 0) {\n\t\t\tchar *str = v4l1_lu_palette(v4l1_picture.palette);\n\t\t\tif (strcmp(str, \"unknown\")) {\n\t\t\t\tv4l1_lu_palette_str(str, &g_d, &g_rev);\n\t\t\t}\n\t\t}\nif (0) fprintf(stderr, \"v4l1: %d %d %d\\n\", g_w, g_h, g_d);\n\t\tif (g_w > 0 && g_h > 0 && g_d > 0) {\n\t\t\tchar *atparms = (char *) malloc(200);\n\t\t\tchar *pal = v4l1_lu_palette(v4l1_picture.palette);\n\t\t\tfprintf(stderr, \"palette: %s\\n\", pal);\n\t\t\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_d);\n\t\t\tif (strstr(pal, \"RGB555\")) {\n\t\t\t\tstrcat(atparms, \":7c00/3e0/1f\");\n\t\t\t}\n\t\t\t*fd = dfd;\n\t\t\treturn atparms;\n\t\t}\n\t}\n\n\t/* failure */\n\tclose(dfd);\n\treturn NULL;\n#else\n\tif (!dev || !fd) {}\n\treturn NULL;\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static void v4l_fmt(char *fmt);",
      "static char *v4l1_lu_palette(unsigned short palette);",
      "static char *v4l2_lu_palette(unsigned int palette);",
      "static int open_dev(char *dev);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static void parse_str(char *str, char **dev, char **settings, char **atparms);",
      "static int v4l1_cap = -1;",
      "static int v4l2_cap = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dfd"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "atparms",
            "\":7c00/3e0/1f\""
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "pal",
            "\"RGB555\""
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "atparms",
            "\"%dx%dx%d\"",
            "g_w",
            "g_h",
            "g_d"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"palette: %s\\n\"",
            "pal"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_lu_palette",
          "args": [
            "v4l1_picture.palette"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_lu_palette",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "750-772",
          "snippet": "static char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\n\nstatic char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"v4l1: %d %d %d\\n\"",
            "g_w",
            "g_h",
            "g_d"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_lu_palette_str",
          "args": [
            "str",
            "&g_d",
            "&g_rev"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_lu_palette_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "774-800",
          "snippet": "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"unknown\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "atparms",
            "\":7c00/3e0/1f\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "pal",
            "\"RGB555\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "atparms",
            "\"%dx%dx%d\"",
            "g_w",
            "g_h",
            "g_d"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l2_lu_palette",
          "args": [
            "v4l2_format.fmt.pix.pixelformat"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_lu_palette",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "802-835",
          "snippet": "static char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void v4l_fmt(char *fmt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_fmt(char *fmt);\n\nstatic char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l2_lu_palette_str",
          "args": [
            "str",
            "&g_d",
            "&g_rev"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_lu_palette_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "837-884",
          "snippet": "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"unknown\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l2_query",
          "args": [
            "dfd",
            "1"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "985-1065",
          "snippet": "static int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static void v4l_fmt(char *fmt);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_query",
          "args": [
            "dfd",
            "1"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "886-984",
          "snippet": "static int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_dev",
          "args": [
            "dev"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "open_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1067-1084",
          "snippet": "static int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int open_dev(char *dev);",
            "static void init_freqtab(char *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int open_dev(char *dev);\nstatic void init_freqtab(char *file);\n\nstatic int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic void parse_str(char *str, char **dev, char **settings, char **atparms);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic char *guess_via_v4l(char *dev, int *fd) {\n#ifdef V4L_OK\n\tint dfd;\n\t\n\tif (*fd < 0) {\n\t\tdfd = open_dev(dev);\n\t\t*fd = dfd;\n\t}\n\tdfd = *fd;\n\tif (dfd < 0) {\n\t\treturn NULL;\n\t}\n\tif (v4l1_cap < 0) {\n\t\tv4l1_cap = v4l1_query(dfd, 1);\n\t}\n\tif (v4l2_cap < 0) {\n\t\tv4l2_cap = v4l2_query(dfd, 1);\n\t}\n\n\tif (v4l2_cap) {\n#if HAVE_V4L2\n\t\tint g_w = v4l2_format.fmt.pix.width;\n\t\tint g_h = v4l2_format.fmt.pix.height;\n\t\tint g_d = 0, g_rev;\n\n\t\tif (v4l2_format.fmt.pix.pixelformat) {\n\t\t\tchar *str = v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat);\n\t\t\tif (strcmp(str, \"unknown\")) {\n\t\t\t\tv4l2_lu_palette_str(str, &g_d, &g_rev);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (g_w > 0 && g_h > 0 && g_d > 0) {\n\t\t\tchar *atparms = (char *) malloc(200);\n\t\t\tchar *pal = v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat);\n\t\t\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_d);\n\t\t\tif (strstr(pal, \"RGB555\")) {\n\t\t\t\tstrcat(atparms, \":7c00/3e0/1f\");\n\t\t\t}\n\t\t\t*fd = dfd;\n\t\t\treturn atparms;\n\t\t}\n#endif\n\t}\n\tif (v4l1_cap) {\n\t\tint g_w = v4l1_window.width;\n\t\tint g_h = v4l1_window.height;\n\t\tint g_d = v4l1_picture.depth;\n\t\tint g_rev;\n\t\tif (g_d == 0) {\n\t\t\tchar *str = v4l1_lu_palette(v4l1_picture.palette);\n\t\t\tif (strcmp(str, \"unknown\")) {\n\t\t\t\tv4l1_lu_palette_str(str, &g_d, &g_rev);\n\t\t\t}\n\t\t}\nif (0) fprintf(stderr, \"v4l1: %d %d %d\\n\", g_w, g_h, g_d);\n\t\tif (g_w > 0 && g_h > 0 && g_d > 0) {\n\t\t\tchar *atparms = (char *) malloc(200);\n\t\t\tchar *pal = v4l1_lu_palette(v4l1_picture.palette);\n\t\t\tfprintf(stderr, \"palette: %s\\n\", pal);\n\t\t\tsprintf(atparms, \"%dx%dx%d\", g_w, g_h, g_d);\n\t\t\tif (strstr(pal, \"RGB555\")) {\n\t\t\t\tstrcat(atparms, \":7c00/3e0/1f\");\n\t\t\t}\n\t\t\t*fd = dfd;\n\t\t\treturn atparms;\n\t\t}\n\t}\n\n\t/* failure */\n\tclose(dfd);\n\treturn NULL;\n#else\n\tif (!dev || !fd) {}\n\treturn NULL;\n#endif\n}"
  },
  {
    "function_name": "open_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "1067-1084",
    "snippet": "static int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int open_dev(char *dev);",
      "static void init_freqtab(char *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to rawfb file: %s O_RDONLY\\n\"",
            "dev"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to rawfb file: %s\\n\"",
            "dev"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "dev",
            "O_RDONLY"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to rawfb file: %s O_RDWR\\n\"",
            "dev"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int open_dev(char *dev);\nstatic void init_freqtab(char *file);\n\nstatic int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}"
  },
  {
    "function_name": "v4l2_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "985-1065",
    "snippet": "static int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static void v4l_fmt(char *fmt);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    format: %u %s\\n\"",
            "v4l2_format.fmt.pix.pixelformat",
            "v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l2_lu_palette",
          "args": [
            "v4l2_format.fmt.pix.pixelformat"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_lu_palette",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "802-835",
          "snippet": "static char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void v4l_fmt(char *fmt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_fmt(char *fmt);\n\nstatic char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    height: %d\\n\"",
            "v4l2_format.fmt.pix.height"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    width:  %d\\n\"",
            "v4l2_format.fmt.pix.width"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOC_G_FMT\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOC_G_FMT",
            "&v4l2_format"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\"",
            "i",
            "v4l2_fmtdesc.description",
            "v4l2_fmtdesc.type",
            "v4l2_fmtdesc.pixelformat"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOC_ENUM_FMT",
            "&v4l2_fmtdesc"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_fmtdesc",
            "0",
            "sizeof(v4l2_fmtdesc)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    tuner[%d]: %s\\ttype: %d\\n\"",
            "i",
            "v4l2_tuner.name",
            "v4l2_tuner.type"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOC_G_TUNER",
            "&v4l2_tuner"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_tuner",
            "0",
            "sizeof(v4l2_tuner)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    input[%d]: %s\\ttype: %d tuner: %d\\n\"",
            "i",
            "v4l2_input.name",
            "v4l2_input.type",
            "v4l2_input.tuner"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOC_ENUMINPUT",
            "&v4l2_input"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_input",
            "0",
            "sizeof(v4l2_input)"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    capabilities: %u\\n\"",
            "v4l2_capability.capabilities"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    version:      %d\\n\"",
            "v4l2_capability.version"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    bus_info:     %s\\n\"",
            "v4l2_capability.bus_info"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    card:         %s\\n\"",
            "v4l2_capability.card"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"    driver:       %s\\n\"",
            "v4l2_capability.driver"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"v4l-2 capability:\\n\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOC_QUERYCAP\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOC_QUERYCAP",
            "&v4l2_capability"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nV4L_2 query:\\n\""
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_format",
            "0",
            "sizeof(v4l2_format)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_fmtdesc",
            "0",
            "sizeof(v4l2_fmtdesc)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_tuner",
            "0",
            "sizeof(v4l2_tuner)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_input",
            "0",
            "sizeof(v4l2_input)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l2_capability",
            "0",
            "sizeof(v4l2_capability)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}"
  },
  {
    "function_name": "v4l1_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "886-984",
    "snippet": "static int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static char *v4l1_lu_palette(unsigned short palette);",
      "static char *v4l2_lu_palette(unsigned int palette);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     chromakey:   %d\\n\"",
            "v4l1_window.chromakey"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     height:      %d\\n\"",
            "v4l1_window.height"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     width:       %d\\n\"",
            "v4l1_window.width"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     y:           %d\\n\"",
            "v4l1_window.y"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     x:           %d\\n\"",
            "v4l1_window.x"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"v4l-1 window:\\n\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCGWIN\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGWIN",
            "&v4l1_window"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     palette:     %d  %s\\n\"",
            "v4l1_picture.palette",
            "v4l1_lu_palette(v4l1_picture.palette)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_lu_palette",
          "args": [
            "v4l1_picture.palette"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_lu_palette",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "750-772",
          "snippet": "static char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\n\nstatic char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     depth:       %d\\n\"",
            "v4l1_picture.depth"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     whiteness:   %d\\n\"",
            "v4l1_picture.whiteness"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     contrast:    %d\\n\"",
            "v4l1_picture.contrast"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     colour:      %d\\n\"",
            "v4l1_picture.colour"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     hue:         %d\\n\"",
            "v4l1_picture.hue"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     brightness:  %d\\n\"",
            "v4l1_picture.brightness"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"v4l-1 picture:\\n\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCGCHAN\""
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGPICT",
            "&v4l1_picture"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\"",
            "v4l1_tuner.tuner",
            "v4l1_tuner.name",
            "v4l1_tuner.flags",
            "mode"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGTUNER",
            "&v4l1_tuner"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_tuner",
            "0",
            "sizeof(v4l1_tuner)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\"",
            "i",
            "v4l1_channel.name",
            "v4l1_channel.tuners",
            "v4l1_channel.norm",
            "v4l1_channel.type",
            "type"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCGCHAN\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGCHAN",
            "&v4l1_channel"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_channel",
            "0",
            "sizeof(v4l1_channel)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     minheight: %d\\n\"",
            "v4l1_capability.minheight"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     minwidth:  %d\\n\"",
            "v4l1_capability.minwidth"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     maxheight: %d\\n\"",
            "v4l1_capability.maxheight"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     maxwidth:  %d\\n\"",
            "v4l1_capability.maxwidth"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     audios:    %d\\n\"",
            "v4l1_capability.audios"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     channels:  %d\\n\"",
            "v4l1_capability.channels"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"     name:      %s\\n\"",
            "v4l1_capability.name"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"v4l-1 capability:\\n\""
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCGCAP\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGCAP",
            "&v4l1_capability"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nV4L_1 query:\\n\""
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_window",
            "0",
            "sizeof(v4l1_window)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_picture",
            "0",
            "sizeof(v4l1_picture)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_tuner",
            "0",
            "sizeof(v4l1_tuner)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_channel",
            "0",
            "sizeof(v4l1_channel)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_capability",
            "0",
            "sizeof(v4l1_capability)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}"
  },
  {
    "function_name": "v4l2_lu_palette_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "837-884",
    "snippet": "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
      "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"GREY\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB32\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB4\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"BGR32\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"BGR4\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB24\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB3\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"BGR24\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"BGR3\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB565X\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGBR\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB555X\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGBQ\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB565\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGBP\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB555\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGBO\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB332\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB1\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "v4l2_lu_palette",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "802-835",
    "snippet": "static char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void v4l_fmt(char *fmt);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_fmt(char *fmt);\n\nstatic char *v4l2_lu_palette(unsigned int fmt) {\n\tswitch(fmt) {\n#if defined(V4L_OK) && HAVE_V4L2\n\t\tcase V4L2_PIX_FMT_RGB332:\treturn \"RGB332\";\n\t\tcase V4L2_PIX_FMT_RGB555:\treturn \"RGB555\";\n\t\tcase V4L2_PIX_FMT_RGB565:\treturn \"RGB565\";\n\t\tcase V4L2_PIX_FMT_RGB555X:\treturn \"RGB555X\";\n\t\tcase V4L2_PIX_FMT_RGB565X:\treturn \"RGB565X\";\n\t\tcase V4L2_PIX_FMT_BGR24:\treturn \"BGR24\";\n\t\tcase V4L2_PIX_FMT_RGB24:\treturn \"RGB24\";\n\t\tcase V4L2_PIX_FMT_BGR32:\treturn \"BGR32\";\n\t\tcase V4L2_PIX_FMT_RGB32:\treturn \"RGB32\";\n\t\tcase V4L2_PIX_FMT_GREY:\t\treturn \"GREY\";\n\t\tcase V4L2_PIX_FMT_YVU410:\treturn \"YVU410\";\n\t\tcase V4L2_PIX_FMT_YVU420:\treturn \"YVU420\";\n\t\tcase V4L2_PIX_FMT_YUYV:\t\treturn \"YUYV\";\n\t\tcase V4L2_PIX_FMT_UYVY:\t\treturn \"UYVY\";\n\t\tcase V4L2_PIX_FMT_YUV422P:\treturn \"YUV422P\";\n\t\tcase V4L2_PIX_FMT_YUV411P:\treturn \"YUV411P\";\n\t\tcase V4L2_PIX_FMT_Y41P:\t\treturn \"Y41P\";\n\t\tcase V4L2_PIX_FMT_NV12:\t\treturn \"NV12\";\n\t\tcase V4L2_PIX_FMT_NV21:\t\treturn \"NV21\";\n\t\tcase V4L2_PIX_FMT_YUV410:\treturn \"YUV410\";\n\t\tcase V4L2_PIX_FMT_YUV420:\treturn \"YUV420\";\n\t\tcase V4L2_PIX_FMT_YYUV:\t\treturn \"YYUV\";\n\t\tcase V4L2_PIX_FMT_HI240:\treturn \"HI240\";\n\t\tcase V4L2_PIX_FMT_MJPEG:\treturn \"MJPEG\";\n\t\tcase V4L2_PIX_FMT_JPEG:\t\treturn \"JPEG\";\n\t\tcase V4L2_PIX_FMT_DV:\t\treturn \"DV\";\n\t\tcase V4L2_PIX_FMT_MPEG:\t\treturn \"MPEG\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
  },
  {
    "function_name": "v4l1_lu_palette_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "774-800",
    "snippet": "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
      "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"GREY\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"HI240\""
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB32\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB24\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB565\""
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"RGB555\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "v4l1_lu_palette",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "750-772",
    "snippet": "static char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static char *v4l1_lu_palette(unsigned short palette);",
      "static char *v4l2_lu_palette(unsigned int palette);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\n\nstatic char *v4l1_lu_palette(unsigned short palette) {\n\tswitch(palette) {\n#ifdef V4L_OK\n\t\tcase VIDEO_PALETTE_GREY:\treturn \"GREY\";\n\t\tcase VIDEO_PALETTE_HI240:\treturn \"HI240\";\n\t\tcase VIDEO_PALETTE_RGB565:\treturn \"RGB565\";\n\t\tcase VIDEO_PALETTE_RGB24:\treturn \"RGB24\";\n\t\tcase VIDEO_PALETTE_RGB32:\treturn \"RGB32\";\n\t\tcase VIDEO_PALETTE_RGB555:\treturn \"RGB555\";\n\t\tcase VIDEO_PALETTE_YUV422:\treturn \"YUV422\";\n\t\tcase VIDEO_PALETTE_YUYV:\treturn \"YUYV\";\n\t\tcase VIDEO_PALETTE_UYVY:\treturn \"UYVY\";\n\t\tcase VIDEO_PALETTE_YUV420:\treturn \"YUV420\";\n\t\tcase VIDEO_PALETTE_YUV411:\treturn \"YUV411\";\n\t\tcase VIDEO_PALETTE_RAW:\t\treturn \"RAW\";\n\t\tcase VIDEO_PALETTE_YUV422P:\treturn \"YUV422P\";\n\t\tcase VIDEO_PALETTE_YUV411P:\treturn \"YUV411P\";\n\t\tcase VIDEO_PALETTE_YUV420P:\treturn \"YUV420P\";\n\t\tcase VIDEO_PALETTE_YUV410P:\treturn \"YUV410P\";\n#endif\n\t\tdefault:\t\t\treturn \"unknown\";\n\t}\n}"
  },
  {
    "function_name": "lookup_rgb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "735-748",
    "snippet": "static void lookup_rgb(char *fmt, int *bits, int *rev) {\n\tint tb, tr;\n\n\tif (v4l2_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n\tif (v4l1_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void v4l_fmt(char *fmt);",
      "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
      "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l1_lu_palette_str",
          "args": [
            "fmt",
            "&tb",
            "&tr"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_lu_palette_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "774-800",
          "snippet": "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l2_lu_palette_str",
          "args": [
            "fmt",
            "&tb",
            "&tr"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_lu_palette_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "837-884",
          "snippet": "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tif (!strcmp(name, \"RGB1\") || !strcmp(name, \"RGB332\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB332;\n\t} else if (!strcmp(name, \"RGBO\") || !strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB555;\n\t} else if (!strcmp(name, \"RGBP\") || !strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB565;\n\t} else if (!strcmp(name, \"RGBQ\") || !strcmp(name, \"RGB555X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB555X;\n\t} else if (!strcmp(name, \"RGBR\") || !strcmp(name, \"RGB565X\")) {\n\t\t*bits = 16;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_RGB565X;\n\t} else if (!strcmp(name, \"BGR3\") || !strcmp(name, \"BGR24\")) {\n\t\t*bits = 24;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR24;\n\t} else if (!strcmp(name, \"RGB3\") || !strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB24;\n\t} else if (!strcmp(name, \"BGR4\") || !strcmp(name, \"BGR32\")) {\n\t\t*bits = 32;\n\t\t*rev = 1;\n\t\treturn V4L2_PIX_FMT_BGR32;\n\t} else if (!strcmp(name, \"RGB4\") || !strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_RGB32;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\t*rev = 0;\n\t\treturn V4L2_PIX_FMT_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_fmt(char *fmt);\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic void lookup_rgb(char *fmt, int *bits, int *rev) {\n\tint tb, tr;\n\n\tif (v4l2_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n\tif (v4l1_lu_palette_str(fmt, &tb, &tr)) {\n\t\t*bits = tb;\n\t\t*rev  = tr;\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "colon_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "718-733",
    "snippet": "static char *colon_tag(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, '[');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq++;\n\tp = strrchr(q, ']');\n\tif (! p) {\n\t\treturn strdup(\"\");\n\t}\n\t*p = '\\0';\n\tt = strdup(q);\n\t*p = ']';\n\treturn t;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int colon_n(char *line);",
      "static char *colon_str(char *line);",
      "static char *colon_tag(char *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "q",
            "']'"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'['"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic char *colon_tag(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, '[');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq++;\n\tp = strrchr(q, ']');\n\tif (! p) {\n\t\treturn strdup(\"\");\n\t}\n\t*p = '\\0';\n\tt = strdup(q);\n\t*p = ']';\n\treturn t;\n}"
  },
  {
    "function_name": "colon_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "702-716",
    "snippet": "static char *colon_str(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq = lblanks(q+1);\n\tp = strpbrk(q, \" \\t\\n\");\n\tif (p) {\n\t\t*p = '\\0';\n\t}\n\tt = strdup(q);\n\t*p = '\\n';\n\treturn t;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int colon_n(char *line);",
      "static char *colon_str(char *line);",
      "static char *colon_tag(char *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "q",
            "\" \\t\\n\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "q+1"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic char *colon_str(char *line) {\n\tchar *q, *p, *t;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn strdup(\"\");\n\t}\n\tq = lblanks(q+1);\n\tp = strpbrk(q, \" \\t\\n\");\n\tif (p) {\n\t\t*p = '\\0';\n\t}\n\tt = strdup(q);\n\t*p = '\\n';\n\treturn t;\n}"
  },
  {
    "function_name": "colon_n",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "688-700",
    "snippet": "static int colon_n(char *line) {\n\tchar *q;\n\tint n;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn 0;\n\t}\n\tq = lblanks(q+1);\n\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\treturn n;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int v4l1_dpct(int old, int d);",
      "static int colon_n(char *line);",
      "static char *colon_str(char *line);",
      "static char *colon_tag(char *line);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"%d\"",
            "&n"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "q+1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_dpct(int old, int d);\nstatic int colon_n(char *line);\nstatic char *colon_str(char *line);\nstatic char *colon_tag(char *line);\n\nstatic int colon_n(char *line) {\n\tchar *q;\n\tint n;\n\tq = strrchr(line, ':');\n\tif (! q) {\n\t\treturn 0;\n\t}\n\tq = lblanks(q+1);\n\tif (sscanf(q, \"%d\", &n) == 1) {\n\t\treturn n;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "v4l_pointer_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "683-686",
    "snippet": "void v4l_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\t/* do not forget viewonly perms */\n\tif (mask || x || y || client) {}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void v4l_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid v4l_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid v4l_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\t/* do not forget viewonly perms */\n\tif (mask || x || y || client) {}\n}"
  },
  {
    "function_name": "v4l_key_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "621-680",
    "snippet": "void v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tallowed_input_t input;\n\n\tif (raw_fb_fd < 0) {\n\t\treturn;\t\t\n\t}\n\tif (! down) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tif (keysym == XK_b) {\n\t\tv4l_br(-1);\n\t} else if (keysym == XK_B) {\n\t\tv4l_br(+1);\n\t} else if (keysym == XK_h) {\n\t\tv4l_hu(-1);\n\t} else if (keysym == XK_H) {\n\t\tv4l_hu(+1);\n\t} else if (keysym == XK_c) {\n\t\tv4l_co(-1);\n\t} else if (keysym == XK_C) {\n\t\tv4l_co(+1);\n\t} else if (keysym == XK_n) {\n\t\tv4l_cn(-1);\n\t} else if (keysym == XK_N) {\n\t\tv4l_cn(+1);\n\t} else if (keysym == XK_s) {\n\t\tv4l_sz(-1);\n\t} else if (keysym == XK_S) {\n\t\tv4l_sz(+1);\n\t} else if (keysym == XK_i) {\n\t\tv4l_inp(-1);\n\t} else if (keysym == XK_I) {\n\t\tv4l_inp(-2);\n\t} else if (keysym == XK_Up) {\n\t\tv4l_sta(+0);\n\t} else if (keysym == XK_Down) {\n\t\tv4l_sta(-1);\n\t} else if (keysym == XK_F1) {\n\t\tv4l_fmt(\"HI240\");\n\t} else if (keysym == XK_F2) {\n\t\tv4l_fmt(\"RGB565\");\n\t} else if (keysym == XK_F3) {\n\t\tv4l_fmt(\"RGB24\");\n\t} else if (keysym == XK_F4) {\n\t\tv4l_fmt(\"RGB32\");\n\t} else if (keysym == XK_F5) {\n\t\tv4l_fmt(\"RGB555\");\n\t} else if (keysym == XK_F6) {\n\t\tv4l_fmt(\"GREY\");\n\t}\n\tif (client) {}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void v4l_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l_fmt",
          "args": [
            "\"GREY\""
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "611-619",
          "snippet": "static void v4l_fmt(char *fmt) {\n\tif (v4l1_setfmt(raw_fb_fd, fmt)) {\n\t\tv4l_requery();\n\n\t\tignore_all = 1;\n\t\tdo_new_fb(1);\n\t\tignore_all = 0;\n\t}\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void v4l_requery(void);",
            "static void v4l_fmt(char *fmt);",
            "static int ignore_all = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_requery(void);\nstatic void v4l_fmt(char *fmt);\nstatic int ignore_all = 0;\n\nstatic void v4l_fmt(char *fmt) {\n\tif (v4l1_setfmt(raw_fb_fd, fmt)) {\n\t\tv4l_requery();\n\n\t\tignore_all = 1;\n\t\tdo_new_fb(1);\n\t\tignore_all = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_sta",
          "args": [
            "-1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_sta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "551-585",
          "snippet": "static void v4l_sta(int sta) {\n#ifdef V4L_OK\n\tunsigned long freq = 0;\n\tint cur = lookup_station(last_freq);\n\n\tif (! last_freq) {\n\t\tif (sta == 0 || sta == -1) {\n\t\t\tsta = 11;\n\t\t}\n\t}\n\n\tif (sta == -1) {\n\t\twhile (cur > 0) {\n\t\t\tfreq = lookup_freq(--cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (sta == 0) {\n\t\twhile (cur < CHANNEL_MAX - 1) {\n\t\t\tfreq = lookup_freq(++cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfreq = lookup_freq(sta);\n\t\tcur = sta;\n\t}\n\tfprintf(stderr, \"to station %d / %d\\n\", cur, (int) freq);\n\tv4l1_setfreq(raw_fb_fd, freq, 0);\n#else\n\tif (!sta) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500",
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static void v4l_sta(int sta);",
            "static unsigned long lookup_freqtab(int sta);",
            "static unsigned long lookup_freq(int sta);",
            "static int lookup_station(unsigned long freq);",
            "static unsigned long last_freq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n#define V4L_OK\n\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long last_freq = 0;\n\nstatic void v4l_sta(int sta) {\n#ifdef V4L_OK\n\tunsigned long freq = 0;\n\tint cur = lookup_station(last_freq);\n\n\tif (! last_freq) {\n\t\tif (sta == 0 || sta == -1) {\n\t\t\tsta = 11;\n\t\t}\n\t}\n\n\tif (sta == -1) {\n\t\twhile (cur > 0) {\n\t\t\tfreq = lookup_freq(--cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (sta == 0) {\n\t\twhile (cur < CHANNEL_MAX - 1) {\n\t\t\tfreq = lookup_freq(++cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfreq = lookup_freq(sta);\n\t\tcur = sta;\n\t}\n\tfprintf(stderr, \"to station %d / %d\\n\", cur, (int) freq);\n\tv4l1_setfreq(raw_fb_fd, freq, 0);\n#else\n\tif (!sta) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_inp",
          "args": [
            "-2"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_inp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "587-609",
          "snippet": "static void v4l_inp(int inp) {\n#ifdef V4L_OK\n\tint next = -1;\n\tif (inp == -1) {\n\t\tinp = last_channel + 1;\n\t\tif (inp >= v4l1_capability.channels) {\n\t\t\tinp = 0;\n\t\t}\n\t\tnext = inp;\n\t} else if (inp == -2) {\n\t\tinp = last_channel - 1;\n\t\tif (inp < 0) {\n\t\t\tinp = v4l1_capability.channels - 1;\n\t\t}\n\t\tnext = inp;\n\t} else {\n\t\tnext = inp;\n\t}\n\tv4l1_set_input(raw_fb_fd, next);\n#else\n\tif (!inp) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static void v4l_inp(int inp);",
            "static int last_channel = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_inp(int inp);\nstatic int last_channel = 0;\n\nstatic void v4l_inp(int inp) {\n#ifdef V4L_OK\n\tint next = -1;\n\tif (inp == -1) {\n\t\tinp = last_channel + 1;\n\t\tif (inp >= v4l1_capability.channels) {\n\t\t\tinp = 0;\n\t\t}\n\t\tnext = inp;\n\t} else if (inp == -2) {\n\t\tinp = last_channel - 1;\n\t\tif (inp < 0) {\n\t\t\tinp = v4l1_capability.channels - 1;\n\t\t}\n\t\tnext = inp;\n\t} else {\n\t\tnext = inp;\n\t}\n\tv4l1_set_input(raw_fb_fd, next);\n#else\n\tif (!inp) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_sz",
          "args": [
            "+1"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "512-549",
          "snippet": "static void v4l_sz(int b) {\n#ifdef V4L_OK\n\tint w_old = v4l1_window.width;\n\tint h_old = v4l1_window.height;\n\tint w, h;\n\n\tif (w_old == 0) {\n\t\tw_old = 160;\n\t}\n\tif (h_old == 0) {\n\t\th_old = 120;\n\t}\n\n\tif (b == 1) {\n\t\tw = w_old + (int) (0.15 * w_old); \n\t\th = h_old + (int) (0.15 * h_old); \n\t} else if (b == -1) {\n\t\tw = w_old - (int) (0.15 * w_old); \n\t\th = h_old - (int) (0.15 * h_old); \n\t} else {\n\t\treturn;\n\t}\n\n\tif (! v4l1_resize(raw_fb_fd, w, h)) {\n\t\treturn;\n\t}\n\n\tv4l_requery();\n\n\tpush_black_screen(4);\n\n\tignore_all = 1;\n\tdo_new_fb(1);\n\tignore_all = 0;\n#else\n\tif (!b) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_width(int w);",
            "static int v4l1_height(int h);",
            "static int v4l1_resize(int fd, int w, int h);",
            "static void v4l_requery(void);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);",
            "static int ignore_all = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\nstatic int ignore_all = 0;\n\nstatic void v4l_sz(int b) {\n#ifdef V4L_OK\n\tint w_old = v4l1_window.width;\n\tint h_old = v4l1_window.height;\n\tint w, h;\n\n\tif (w_old == 0) {\n\t\tw_old = 160;\n\t}\n\tif (h_old == 0) {\n\t\th_old = 120;\n\t}\n\n\tif (b == 1) {\n\t\tw = w_old + (int) (0.15 * w_old); \n\t\th = h_old + (int) (0.15 * h_old); \n\t} else if (b == -1) {\n\t\tw = w_old - (int) (0.15 * w_old); \n\t\th = h_old - (int) (0.15 * h_old); \n\t} else {\n\t\treturn;\n\t}\n\n\tif (! v4l1_resize(raw_fb_fd, w, h)) {\n\t\treturn;\n\t}\n\n\tv4l_requery();\n\n\tpush_black_screen(4);\n\n\tignore_all = 1;\n\tdo_new_fb(1);\n\tignore_all = 0;\n#else\n\tif (!b) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_cn",
          "args": [
            "+1"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "500-510",
          "snippet": "static void v4l_cn(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.contrast;\n\n\tv4l1_picture.contrast = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static void v4l_requery(void);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_cn(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.contrast;\n\n\tv4l1_picture.contrast = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_co",
          "args": [
            "+1"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_co",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "488-498",
          "snippet": "static void v4l_co(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.colour;\n\n\tv4l1_picture.colour = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static void v4l_requery(void);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_co(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.colour;\n\n\tv4l1_picture.colour = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_hu",
          "args": [
            "+1"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_hu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "476-486",
          "snippet": "static void v4l_hu(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.hue;\n\n\tv4l1_picture.hue = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static void v4l_requery(void);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_hu(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.hue;\n\n\tv4l1_picture.hue = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_br",
          "args": [
            "+1"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_br",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "464-474",
          "snippet": "static void v4l_br(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.brightness;\n\n\tv4l1_picture.brightness = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static void v4l_requery(void);",
            "static void v4l_br(int b);",
            "static void v4l_hu(int b);",
            "static void v4l_co(int b);",
            "static void v4l_cn(int b);",
            "static void v4l_sz(int b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_br(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.brightness;\n\n\tv4l1_picture.brightness = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "client",
            "&input"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid v4l_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid v4l_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tallowed_input_t input;\n\n\tif (raw_fb_fd < 0) {\n\t\treturn;\t\t\n\t}\n\tif (! down) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tif (keysym == XK_b) {\n\t\tv4l_br(-1);\n\t} else if (keysym == XK_B) {\n\t\tv4l_br(+1);\n\t} else if (keysym == XK_h) {\n\t\tv4l_hu(-1);\n\t} else if (keysym == XK_H) {\n\t\tv4l_hu(+1);\n\t} else if (keysym == XK_c) {\n\t\tv4l_co(-1);\n\t} else if (keysym == XK_C) {\n\t\tv4l_co(+1);\n\t} else if (keysym == XK_n) {\n\t\tv4l_cn(-1);\n\t} else if (keysym == XK_N) {\n\t\tv4l_cn(+1);\n\t} else if (keysym == XK_s) {\n\t\tv4l_sz(-1);\n\t} else if (keysym == XK_S) {\n\t\tv4l_sz(+1);\n\t} else if (keysym == XK_i) {\n\t\tv4l_inp(-1);\n\t} else if (keysym == XK_I) {\n\t\tv4l_inp(-2);\n\t} else if (keysym == XK_Up) {\n\t\tv4l_sta(+0);\n\t} else if (keysym == XK_Down) {\n\t\tv4l_sta(-1);\n\t} else if (keysym == XK_F1) {\n\t\tv4l_fmt(\"HI240\");\n\t} else if (keysym == XK_F2) {\n\t\tv4l_fmt(\"RGB565\");\n\t} else if (keysym == XK_F3) {\n\t\tv4l_fmt(\"RGB24\");\n\t} else if (keysym == XK_F4) {\n\t\tv4l_fmt(\"RGB32\");\n\t} else if (keysym == XK_F5) {\n\t\tv4l_fmt(\"RGB555\");\n\t} else if (keysym == XK_F6) {\n\t\tv4l_fmt(\"GREY\");\n\t}\n\tif (client) {}\n}"
  },
  {
    "function_name": "v4l_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "611-619",
    "snippet": "static void v4l_fmt(char *fmt) {\n\tif (v4l1_setfmt(raw_fb_fd, fmt)) {\n\t\tv4l_requery();\n\n\t\tignore_all = 1;\n\t\tdo_new_fb(1);\n\t\tignore_all = 0;\n\t}\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void v4l_requery(void);",
      "static void v4l_fmt(char *fmt);",
      "static int ignore_all = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_setfmt",
          "args": [
            "raw_fb_fd",
            "fmt"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_setfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "252-275",
          "snippet": "static int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static void v4l_fmt(char *fmt);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic void v4l_fmt(char *fmt);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void v4l_requery(void);\nstatic void v4l_fmt(char *fmt);\nstatic int ignore_all = 0;\n\nstatic void v4l_fmt(char *fmt) {\n\tif (v4l1_setfmt(raw_fb_fd, fmt)) {\n\t\tv4l_requery();\n\n\t\tignore_all = 1;\n\t\tdo_new_fb(1);\n\t\tignore_all = 0;\n\t}\n}"
  },
  {
    "function_name": "v4l_inp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "587-609",
    "snippet": "static void v4l_inp(int inp) {\n#ifdef V4L_OK\n\tint next = -1;\n\tif (inp == -1) {\n\t\tinp = last_channel + 1;\n\t\tif (inp >= v4l1_capability.channels) {\n\t\t\tinp = 0;\n\t\t}\n\t\tnext = inp;\n\t} else if (inp == -2) {\n\t\tinp = last_channel - 1;\n\t\tif (inp < 0) {\n\t\t\tinp = v4l1_capability.channels - 1;\n\t\t}\n\t\tnext = inp;\n\t} else {\n\t\tnext = inp;\n\t}\n\tv4l1_set_input(raw_fb_fd, next);\n#else\n\tif (!inp) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static void v4l_inp(int inp);",
      "static int last_channel = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l1_set_input",
          "args": [
            "raw_fb_fd",
            "next"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_set_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "234-250",
          "snippet": "static void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void v4l1_set_input(int fd, int which);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static int last_channel = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_set_input(int fd, int which);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int last_channel = 0;\n\nstatic void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_inp(int inp);\nstatic int last_channel = 0;\n\nstatic void v4l_inp(int inp) {\n#ifdef V4L_OK\n\tint next = -1;\n\tif (inp == -1) {\n\t\tinp = last_channel + 1;\n\t\tif (inp >= v4l1_capability.channels) {\n\t\t\tinp = 0;\n\t\t}\n\t\tnext = inp;\n\t} else if (inp == -2) {\n\t\tinp = last_channel - 1;\n\t\tif (inp < 0) {\n\t\t\tinp = v4l1_capability.channels - 1;\n\t\t}\n\t\tnext = inp;\n\t} else {\n\t\tnext = inp;\n\t}\n\tv4l1_set_input(raw_fb_fd, next);\n#else\n\tif (!inp) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_sta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "551-585",
    "snippet": "static void v4l_sta(int sta) {\n#ifdef V4L_OK\n\tunsigned long freq = 0;\n\tint cur = lookup_station(last_freq);\n\n\tif (! last_freq) {\n\t\tif (sta == 0 || sta == -1) {\n\t\t\tsta = 11;\n\t\t}\n\t}\n\n\tif (sta == -1) {\n\t\twhile (cur > 0) {\n\t\t\tfreq = lookup_freq(--cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (sta == 0) {\n\t\twhile (cur < CHANNEL_MAX - 1) {\n\t\t\tfreq = lookup_freq(++cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfreq = lookup_freq(sta);\n\t\tcur = sta;\n\t}\n\tfprintf(stderr, \"to station %d / %d\\n\", cur, (int) freq);\n\tv4l1_setfreq(raw_fb_fd, freq, 0);\n#else\n\tif (!sta) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CHANNEL_MAX 500",
      "#define V4L_OK"
    ],
    "globals_used": [
      "static int v4l1_dpct(int old, int d);",
      "static void v4l_sta(int sta);",
      "static unsigned long lookup_freqtab(int sta);",
      "static unsigned long lookup_freq(int sta);",
      "static int lookup_station(unsigned long freq);",
      "static unsigned long last_freq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l1_setfreq",
          "args": [
            "raw_fb_fd",
            "freq",
            "0"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_setfreq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "214-232",
          "snippet": "static void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void v4l1_setfreq(int fd, unsigned long freq, int verb);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static int lookup_station(unsigned long freq);",
            "static unsigned long last_freq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long last_freq = 0;\n\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"to station %d / %d\\n\"",
            "cur",
            "(int) freq"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_freq",
          "args": [
            "sta"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1409-1420",
          "snippet": "static unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static void v4l_sta(int sta);",
            "static unsigned long lookup_freqtab(int sta);",
            "static unsigned long lookup_freq(int sta);",
            "static unsigned long ntsc_cable[CHANNEL_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\n\nstatic unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_station",
          "args": [
            "last_freq"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_station",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1422-1439",
          "snippet": "static int lookup_station(unsigned long freq) {\n\tint i;\n\tif (freqtab) {\n\t\tfor (i = 0; i < CHANNEL_MAX; i++) {\nif (0) fprintf(stderr, \"%lu %lu\\n\", freq, custom_freq[i]);\n\t\t\tif (freq == custom_freq[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 1; i <= 125; i++) {\n\t\t\tif (freq == ntsc_cable[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static int lookup_station(unsigned long freq);",
            "static unsigned long ntsc_cable[CHANNEL_MAX];",
            "static unsigned long custom_freq[CHANNEL_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\nstatic unsigned long custom_freq[CHANNEL_MAX];\n\nstatic int lookup_station(unsigned long freq) {\n\tint i;\n\tif (freqtab) {\n\t\tfor (i = 0; i < CHANNEL_MAX; i++) {\nif (0) fprintf(stderr, \"%lu %lu\\n\", freq, custom_freq[i]);\n\t\t\tif (freq == custom_freq[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 1; i <= 125; i++) {\n\t\t\tif (freq == ntsc_cable[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n#define V4L_OK\n\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long last_freq = 0;\n\nstatic void v4l_sta(int sta) {\n#ifdef V4L_OK\n\tunsigned long freq = 0;\n\tint cur = lookup_station(last_freq);\n\n\tif (! last_freq) {\n\t\tif (sta == 0 || sta == -1) {\n\t\t\tsta = 11;\n\t\t}\n\t}\n\n\tif (sta == -1) {\n\t\twhile (cur > 0) {\n\t\t\tfreq = lookup_freq(--cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (sta == 0) {\n\t\twhile (cur < CHANNEL_MAX - 1) {\n\t\t\tfreq = lookup_freq(++cur);\n\t\t\tif (freq) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfreq = lookup_freq(sta);\n\t\tcur = sta;\n\t}\n\tfprintf(stderr, \"to station %d / %d\\n\", cur, (int) freq);\n\tv4l1_setfreq(raw_fb_fd, freq, 0);\n#else\n\tif (!sta) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_sz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "512-549",
    "snippet": "static void v4l_sz(int b) {\n#ifdef V4L_OK\n\tint w_old = v4l1_window.width;\n\tint h_old = v4l1_window.height;\n\tint w, h;\n\n\tif (w_old == 0) {\n\t\tw_old = 160;\n\t}\n\tif (h_old == 0) {\n\t\th_old = 120;\n\t}\n\n\tif (b == 1) {\n\t\tw = w_old + (int) (0.15 * w_old); \n\t\th = h_old + (int) (0.15 * h_old); \n\t} else if (b == -1) {\n\t\tw = w_old - (int) (0.15 * w_old); \n\t\th = h_old - (int) (0.15 * h_old); \n\t} else {\n\t\treturn;\n\t}\n\n\tif (! v4l1_resize(raw_fb_fd, w, h)) {\n\t\treturn;\n\t}\n\n\tv4l_requery();\n\n\tpush_black_screen(4);\n\n\tignore_all = 1;\n\tdo_new_fb(1);\n\tignore_all = 0;\n#else\n\tif (!b) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static int v4l1_width(int w);",
      "static int v4l1_height(int h);",
      "static int v4l1_resize(int fd, int w, int h);",
      "static void v4l_requery(void);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);",
      "static int ignore_all = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_black_screen",
          "args": [
            "4"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "push_black_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xinerama.c",
          "lines": "502-515",
          "snippet": "void push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"blackout_t.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void push_sleep(int n);",
            "void push_black_screen(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"blackout_t.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid push_sleep(int n);\nvoid push_black_screen(int n);\n\nvoid push_black_screen(int n) {\n\tint Lx = dpy_x, Ly = dpy_y;\n\tif (!screen) {\n\t\treturn;\n\t}\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tLy = dpy_y * (1+ncache);\n\t}\n#endif\n\tzero_fb(0, 0, Lx, Ly);\n\tmark_rect_as_modified(0, 0, Lx, Ly, 0);\n\tpush_sleep(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_resize",
          "args": [
            "raw_fb_fd",
            "w",
            "h"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "173-212",
          "snippet": "static int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_width(int w);",
            "static int v4l1_height(int h);",
            "static int v4l1_resize(int fd, int w, int h);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\nstatic int ignore_all = 0;\n\nstatic void v4l_sz(int b) {\n#ifdef V4L_OK\n\tint w_old = v4l1_window.width;\n\tint h_old = v4l1_window.height;\n\tint w, h;\n\n\tif (w_old == 0) {\n\t\tw_old = 160;\n\t}\n\tif (h_old == 0) {\n\t\th_old = 120;\n\t}\n\n\tif (b == 1) {\n\t\tw = w_old + (int) (0.15 * w_old); \n\t\th = h_old + (int) (0.15 * h_old); \n\t} else if (b == -1) {\n\t\tw = w_old - (int) (0.15 * w_old); \n\t\th = h_old - (int) (0.15 * h_old); \n\t} else {\n\t\treturn;\n\t}\n\n\tif (! v4l1_resize(raw_fb_fd, w, h)) {\n\t\treturn;\n\t}\n\n\tv4l_requery();\n\n\tpush_black_screen(4);\n\n\tignore_all = 1;\n\tdo_new_fb(1);\n\tignore_all = 0;\n#else\n\tif (!b) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_cn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "500-510",
    "snippet": "static void v4l_cn(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.contrast;\n\n\tv4l1_picture.contrast = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static void v4l_requery(void);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "raw_fb_fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_dpct",
          "args": [
            "old",
            "b"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_dpct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "436-454",
          "snippet": "static int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L1_MAX 65535"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static double dval = 0.05;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_dpct(int old, int d);\nstatic double dval = 0.05;\n\nstatic int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_cn(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.contrast;\n\n\tv4l1_picture.contrast = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_co",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "488-498",
    "snippet": "static void v4l_co(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.colour;\n\n\tv4l1_picture.colour = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static void v4l_requery(void);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "raw_fb_fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_dpct",
          "args": [
            "old",
            "b"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_dpct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "436-454",
          "snippet": "static int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L1_MAX 65535"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static double dval = 0.05;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_dpct(int old, int d);\nstatic double dval = 0.05;\n\nstatic int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_co(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.colour;\n\n\tv4l1_picture.colour = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_hu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "476-486",
    "snippet": "static void v4l_hu(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.hue;\n\n\tv4l1_picture.hue = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static void v4l_requery(void);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "raw_fb_fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_dpct",
          "args": [
            "old",
            "b"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_dpct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "436-454",
          "snippet": "static int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L1_MAX 65535"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static double dval = 0.05;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_dpct(int old, int d);\nstatic double dval = 0.05;\n\nstatic int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_hu(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.hue;\n\n\tv4l1_picture.hue = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_br",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "464-474",
    "snippet": "static void v4l_br(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.brightness;\n\n\tv4l1_picture.brightness = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static void v4l_requery(void);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l_requery",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "v4l_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "456-462",
          "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void v4l_requery(void);",
            "static int v4l1_cap = -1;",
            "static int v4l2_cap = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "raw_fb_fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_dpct",
          "args": [
            "old",
            "b"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_dpct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "436-454",
          "snippet": "static int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L1_MAX 65535"
          ],
          "globals_used": [
            "static int v4l1_dpct(int old, int d);",
            "static double dval = 0.05;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_dpct(int old, int d);\nstatic double dval = 0.05;\n\nstatic int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic void v4l_requery(void);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\n\nstatic void v4l_br(int b) {\n#ifdef V4L_OK\n\tint old = v4l1_picture.brightness;\n\n\tv4l1_picture.brightness = v4l1_dpct(old, b);\n\tioctl(raw_fb_fd, VIDIOCSPICT, &v4l1_picture);\n\tv4l_requery();\n#else\n\tif (!b) {}\n#endif\n}"
  },
  {
    "function_name": "v4l_requery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "456-462",
    "snippet": "static void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void v4l_requery(void);",
      "static int v4l1_cap = -1;",
      "static int v4l2_cap = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l2_query",
          "args": [
            "raw_fb_fd",
            "1"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "985-1065",
          "snippet": "static int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static void v4l_fmt(char *fmt);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_query",
          "args": [
            "raw_fb_fd",
            "1"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "886-984",
          "snippet": "static int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void v4l_requery(void);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\n\nstatic void v4l_requery(void) {\n\tif (raw_fb_fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(raw_fb_fd, 1);\n\tv4l2_cap = v4l2_query(raw_fb_fd, 1);\n}"
  },
  {
    "function_name": "v4l1_dpct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "436-454",
    "snippet": "static int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L1_MAX 65535"
    ],
    "globals_used": [
      "static int v4l1_dpct(int old, int d);",
      "static double dval = 0.05;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_dpct(int old, int d);\nstatic double dval = 0.05;\n\nstatic int v4l1_dpct(int old, int d) {\n\tint newval, max = V4L1_MAX; \n\t\n\t/* -1 and 1 are special cases for \"small increments\" */\n\tif (d == -1) {\n\t\tnewval = old - (int) (dval * max);\n\t} else if (d == 1) {\n\t\tnewval = old + (int) (dval * max);\n\t} else {\n\t\tnewval = (d * max)/100;\n\t}\n\tif (newval < 0) {\n\t\tnewval = 0;\n\t}\n\tif (newval > max) {\n\t\tnewval = max;\n\t}\n\treturn newval;\n}"
  },
  {
    "function_name": "apply_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "279-432",
    "snippet": "static void apply_settings(char *dev, char *settings, int *fd) {\n#ifdef V4L_OK\n\tchar *str, *p, *fmt = NULL, *tun = NULL, *inp = NULL;\n\tint br = -1, co = -1, cn = -1, hu = -1;\n\tint w = -1, h = -1, b = -1;\n\tint sta = -1;\n\tint setcnt = 0;\n\tif (! settings || settings[0] == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(settings);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (strstr(p, \"br=\") == p) {\n\t\t\tbr = atoi(p+3);\n\t\t\tif (br >= 0) setcnt++;\n\t\t} else if (strstr(p, \"co=\") == p) {\n\t\t\tco = atoi(p+3);\n\t\t\tif (co >= 0) setcnt++;\n\t\t} else if (strstr(p, \"cn=\") == p) {\n\t\t\tcn = atoi(p+3);\n\t\t\tif (cn >= 0) setcnt++;\n\t\t} else if (strstr(p, \"hu=\") == p) {\n\t\t\thu = atoi(p+3);\n\t\t\tif (hu >= 0) setcnt++;\n\t\t} else if (strstr(p, \"w=\") == p) {\n\t\t\tw = atoi(p+2);\n\t\t\tif (w > 0) setcnt++;\n\t\t} else if (strstr(p, \"h=\") == p) {\n\t\t\th = atoi(p+2);\n\t\t\tif (h > 0) setcnt++;\n\t\t} else if (strstr(p, \"bpp=\") == p) {\n\t\t\tb = atoi(p+4);\n\t\t\tif (b > 0) setcnt++;\n\t\t} else if (strstr(p, \"fmt=\") == p) {\n\t\t\tfmt = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"tun=\") == p) {\n\t\t\ttun = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"inp=\") == p) {\n\t\t\tinp = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"sta=\") == p) {\n\t\t\tsta = atoi(p+4);\n\t\t\tsetcnt++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\tif (! setcnt) {\n\t\treturn;\n\t}\n\tif (*fd < 0) {\n\t\t*fd = open_dev(dev);\n\t}\n\tif (*fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n\n\tif (v4l1_cap && ! ignore_all) {\n\t\tif (br >= 0) v4l1_picture.brightness = v4l1_val(br);\n\t\tif (hu >= 0) v4l1_picture.hue        = v4l1_val(hu);\n\t\tif (co >= 0) v4l1_picture.colour     = v4l1_val(co);\n\t\tif (cn >= 0) v4l1_picture.contrast   = v4l1_val(cn);\n\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\t\tif (ioctl(*fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\t}\n\n\t\tif (fmt) {\n\t\t\tv4l1_setfmt(*fd, fmt);\n\t\t} else if (b > 0 && b != v4l1_picture.depth) {\n\t\t\tif (b == 8) {\n\t\t\t\tv4l1_setfmt(*fd, \"HI240\");\n\t\t\t} else if (b == 16) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB565\");\n\t\t\t} else if (b == 24) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB24\");\n\t\t\t} else if (b == 32) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB32\");\n\t\t\t}\n\t\t}\n\n\t\tv4l1_resize(*fd, w, h);\n\n\t\tif (tun) {\n\t\t\tint mode = -1;\n\t\t\tif (!strcasecmp(tun, \"PAL\")) {\n\t\t\t\tmode = VIDEO_MODE_PAL;\n\t\t\t} else if (!strcasecmp(tun, \"NTSC\")) {\n\t\t\t\tmode = VIDEO_MODE_NTSC;\n\t\t\t} else if (!strcasecmp(tun, \"SECAM\")) {\n\t\t\t\tmode = VIDEO_MODE_SECAM;\n\t\t\t} else if (!strcasecmp(tun, \"AUTO\")) {\n\t\t\t\tmode = VIDEO_MODE_AUTO;\n\t\t\t}\n\t\t\tif (mode != -1) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (! v4l1_channel.tuners) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (v4l1_channel.norm == mode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv4l1_channel.norm = mode;\n\t\t\t\t\tioctl(*fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inp) {\n\t\t\tchar s[2];\n\t\t\tint i, chan = -1;\n\n\t\t\ts[0] = inp[0];\n\t\t\ts[1] = '\\0';\n\t\t\tif (strstr(\"0123456789\", s)) {\n\t\t\t\tchan = atoi(inp);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp(v4l1_channel.name, inp)) {\n\t\t\t\t\t\tchan = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv4l1_set_input(*fd, chan);\n\t\t}\n\t\tif (sta >= 0) {\n\t\t\tunsigned long freq = lookup_freq(sta);\n\t\t\tv4l1_setfreq(*fd, freq, 1);\n\t\t}\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n#else\n\tif (!dev || !settings || !fd) {}\n\treturn;\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_width(int w);",
      "static int v4l1_height(int h);",
      "static int v4l1_resize(int fd, int w, int h);",
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static void v4l_br(int b);",
      "static void v4l_hu(int b);",
      "static void v4l_co(int b);",
      "static void v4l_cn(int b);",
      "static void v4l_sz(int b);",
      "static void v4l_sta(int sta);",
      "static void v4l_inp(int inp);",
      "static void v4l_fmt(char *fmt);",
      "static int open_dev(char *dev);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static unsigned long lookup_freqtab(int sta);",
      "static unsigned long lookup_freq(int sta);",
      "static int lookup_station(unsigned long freq);",
      "static int v4l1_cap = -1;",
      "static int v4l2_cap = -1;",
      "static int ignore_all = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v4l2_query",
          "args": [
            "*fd",
            "1"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "v4l2_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "985-1065",
          "snippet": "static int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static void v4l_fmt(char *fmt);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic void v4l_fmt(char *fmt);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l2_query(int fd, int v) {\n#if defined(V4L_OK) && HAVE_V4L2\n\tunsigned int i;\n\n\tmemset(&v4l2_capability, 0, sizeof(v4l2_capability));\n\tmemset(&v4l2_input,      0, sizeof(v4l2_input));\n\tmemset(&v4l2_tuner,      0, sizeof(v4l2_tuner));\n\tmemset(&v4l2_fmtdesc,    0, sizeof(v4l2_fmtdesc));\n\tmemset(&v4l2_format,     0, sizeof(v4l2_format));\n\n\tif (v) fprintf(stderr, \"\\nV4L_2 query:\\n\");\n#ifdef VIDIOC_QUERYCAP\n\tif (ioctl(fd, VIDIOC_QUERYCAP, &v4l2_capability) == -1) {\n\t\tperror(\"ioctl VIDIOC_QUERYCAP\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\n\tif (v) fprintf(stderr, \"v4l-2 capability:\\n\");\n\tif (v) fprintf(stderr, \"    driver:       %s\\n\", v4l2_capability.driver);\n\tif (v) fprintf(stderr, \"    card:         %s\\n\", v4l2_capability.card);\n\tif (v) fprintf(stderr, \"    bus_info:     %s\\n\", v4l2_capability.bus_info);\n\tif (v) fprintf(stderr, \"    version:      %d\\n\", v4l2_capability.version);\n\tif (v) fprintf(stderr, \"    capabilities: %u\\n\", v4l2_capability.capabilities);\n\n\tfor (i=0; ; i++) {\n\t\tmemset(&v4l2_input, 0, sizeof(v4l2_input));\n\t\tv4l2_input.index = i;\n\t\tif (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2_input) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (v) fprintf(stderr, \"    input[%d]: %s\\ttype: %d tuner: %d\\n\",\n\t\t    i, v4l2_input.name, v4l2_input.type, v4l2_input.tuner);\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_TUNER) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_tuner, 0, sizeof(v4l2_tuner));\n\t\t\tv4l2_tuner.index = i;\n\t\t\tif (ioctl(fd, VIDIOC_G_TUNER, &v4l2_tuner) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    tuner[%d]: %s\\ttype: %d\\n\",\n\t\t\t    i, v4l2_tuner.name, v4l2_tuner.type);\n\t\t}\n\t}\n\tif (v4l2_capability.capabilities & V4L2_CAP_VIDEO_CAPTURE) {\n\t\tfor (i=0; ; i++) {\n\t\t\tmemset(&v4l2_fmtdesc, 0, sizeof(v4l2_fmtdesc));\n\t\t\tv4l2_fmtdesc.index = i;\n\t\t\tv4l2_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\t\t\n\t\t\tif (ioctl(fd, VIDIOC_ENUM_FMT, &v4l2_fmtdesc) == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v) fprintf(stderr, \"    fmtdesc[%d]: %s\\ttype: %d\"\n\t\t\t    \" pixelformat: %d\\n\",\n\t\t\t    i, v4l2_fmtdesc.description, v4l2_fmtdesc.type,\n\t\t\t    v4l2_fmtdesc.pixelformat);\n\t\t}\n\t\tv4l2_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tif (ioctl(fd, VIDIOC_G_FMT, &v4l2_format) == -1) {\n\t\t\tperror(\"ioctl VIDIOC_G_FMT\");\n\t\t} else {\n\t\t\tif (v) fprintf(stderr, \"    width:  %d\\n\", v4l2_format.fmt.pix.width);\n\t\t\tif (v) fprintf(stderr, \"    height: %d\\n\", v4l2_format.fmt.pix.height);\n\t\t\tif (v) fprintf(stderr, \"    format: %u %s\\n\",\n\t\t\t    v4l2_format.fmt.pix.pixelformat,\n\t\t\t    v4l2_lu_palette(v4l2_format.fmt.pix.pixelformat));\n\t\t}\n\t}\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK && HAVE_V4L2 */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_query",
          "args": [
            "*fd",
            "1"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "886-984",
          "snippet": "static int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_query(int fd, int v) {\n#ifdef V4L_OK\n\tunsigned int i;\n\n\tmemset(&v4l1_capability, 0, sizeof(v4l1_capability));\n\tmemset(&v4l1_channel,    0, sizeof(v4l1_channel));\n\tmemset(&v4l1_tuner,      0, sizeof(v4l1_tuner));\n\tmemset(&v4l1_picture,    0, sizeof(v4l1_picture));\n\tmemset(&v4l1_window,     0, sizeof(v4l1_window));\n\n\tif (v) fprintf(stderr, \"\\nV4L_1 query:\\n\");\n#ifdef VIDIOCGCAP\n\tif (ioctl(fd, VIDIOCGCAP, &v4l1_capability) == -1) {\n\t\tperror(\"ioctl VIDIOCGCAP\");\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n#else\n\treturn 0;\n#endif\n\tif (v) fprintf(stderr, \"v4l-1 capability:\\n\");\n\tif (v) fprintf(stderr, \"     name:      %s\\n\", v4l1_capability.name);\n\tif (v) fprintf(stderr, \"     channels:  %d\\n\", v4l1_capability.channels);\n\tif (v) fprintf(stderr, \"     audios:    %d\\n\", v4l1_capability.audios);\n\tif (v) fprintf(stderr, \"     maxwidth:  %d\\n\", v4l1_capability.maxwidth);\n\tif (v) fprintf(stderr, \"     maxheight: %d\\n\", v4l1_capability.maxheight);\n\tif (v) fprintf(stderr, \"     minwidth:  %d\\n\", v4l1_capability.minwidth);\n\tif (v) fprintf(stderr, \"     minheight: %d\\n\", v4l1_capability.minheight);\n\n\tfor (i=0; (int) i < v4l1_capability.channels; i++) {\n\t\tchar *type = \"unknown\";\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = i;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (v4l1_channel.type == VIDEO_TYPE_TV) {\n\t\t\ttype = \"TV\";\n\t\t} else if (v4l1_channel.type == VIDEO_TYPE_CAMERA) {\n\t\t\ttype = \"CAMERA\";\n\t\t}\n\t\tif (v) fprintf(stderr, \"     channel[%d]: %s\\ttuners: %d norm: %d type: %d  %s\\n\",\n\t\t    i, v4l1_channel.name, v4l1_channel.tuners, v4l1_channel.norm,\n\t\t    v4l1_channel.type, type);\n\t}\n\n\tmemset(&v4l1_tuner, 0, sizeof(v4l1_tuner));\n\tif (ioctl(fd, VIDIOCGTUNER, &v4l1_tuner) != -1) {\n\t\tchar *mode = \"unknown\";\n\t\tif (v4l1_tuner.mode == VIDEO_MODE_PAL) {\n\t\t\tmode = \"PAL\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_NTSC) {\n\t\t\tmode = \"NTSC\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_SECAM) {\n\t\t\tmode = \"SECAM\";\n\t\t} else if (v4l1_tuner.mode == VIDEO_MODE_AUTO) {\n\t\t\tmode = \"AUTO\";\n\t\t}\n\n\t\tif (v) fprintf(stderr, \"     tuner[%d]:   %s\\tflags: 0x%x mode: %s\\n\",\n\t\t    v4l1_tuner.tuner, v4l1_tuner.name, v4l1_tuner.flags, mode);\n\t\t\n\t}\n\n\tif (ioctl(fd, VIDIOCGPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCGCHAN\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 picture:\\n\");\n\tif (v) fprintf(stderr, \"     brightness:  %d\\n\", v4l1_picture.brightness);\n\tif (v) fprintf(stderr, \"     hue:         %d\\n\", v4l1_picture.hue);\n\tif (v) fprintf(stderr, \"     colour:      %d\\n\", v4l1_picture.colour);\n\tif (v) fprintf(stderr, \"     contrast:    %d\\n\", v4l1_picture.contrast);\n\tif (v) fprintf(stderr, \"     whiteness:   %d\\n\", v4l1_picture.whiteness);\n\tif (v) fprintf(stderr, \"     depth:       %d\\n\", v4l1_picture.depth);\n\tif (v) fprintf(stderr, \"     palette:     %d  %s\\n\", v4l1_picture.palette,\n\t    v4l1_lu_palette(v4l1_picture.palette));\n\t\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\tperror(\"ioctl VIDIOCGWIN\");\n\t\tif (v) fprintf(stderr, \"\\n\");\n\t\treturn 0;\n\t}\n\tif (v) fprintf(stderr, \"v4l-1 window:\\n\");\n\tif (v) fprintf(stderr, \"     x:           %d\\n\", v4l1_window.x);\n\tif (v) fprintf(stderr, \"     y:           %d\\n\", v4l1_window.y);\n\tif (v) fprintf(stderr, \"     width:       %d\\n\", v4l1_window.width);\n\tif (v) fprintf(stderr, \"     height:      %d\\n\", v4l1_window.height);\n\tif (v) fprintf(stderr, \"     chromakey:   %d\\n\", v4l1_window.chromakey);\n\tif (v) fprintf(stderr, \"\\n\");\n\n\treturn 1;\n#else\n\tif (!fd || !v) {}\n\treturn 0;\n#endif\t/* V4L_OK */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_setfreq",
          "args": [
            "*fd",
            "freq",
            "1"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_setfreq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "214-232",
          "snippet": "static void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void v4l1_setfreq(int fd, unsigned long freq, int verb);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static int lookup_station(unsigned long freq);",
            "static unsigned long last_freq = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long last_freq = 0;\n\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_freq",
          "args": [
            "sta"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1409-1420",
          "snippet": "static unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHANNEL_MAX 500"
          ],
          "globals_used": [
            "static void v4l_sta(int sta);",
            "static unsigned long lookup_freqtab(int sta);",
            "static unsigned long lookup_freq(int sta);",
            "static unsigned long ntsc_cable[CHANNEL_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHANNEL_MAX 500\n\nstatic void v4l_sta(int sta);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic unsigned long ntsc_cable[CHANNEL_MAX];\n\nstatic unsigned long lookup_freq(int sta) {\n\tif (freqtab) {\n\t\treturn lookup_freqtab(sta);\n\t}\n\tif (sta >= CHANNEL_MAX) {\n\t\treturn (unsigned long) sta;\n\t}\n\tif (sta < 1 || sta > 125) {\n\t\treturn 0;\n\t}\n\treturn ntsc_cable[sta];\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_set_input",
          "args": [
            "*fd",
            "chan"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_set_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "234-250",
          "snippet": "static void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static void v4l1_set_input(int fd, int which);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);",
            "static int last_channel = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_set_input(int fd, int which);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int last_channel = 0;\n\nstatic void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "v4l1_channel.name",
            "inp"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*fd",
            "VIDIOCGCHAN",
            "&v4l1_channel"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_channel",
            "0",
            "sizeof(v4l1_channel)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "inp"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "\"0123456789\"",
            "s"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*fd",
            "VIDIOCSCHAN",
            "&v4l1_channel"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*fd",
            "VIDIOCGCHAN",
            "&v4l1_channel"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_channel",
            "0",
            "sizeof(v4l1_channel)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tun",
            "\"AUTO\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tun",
            "\"SECAM\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tun",
            "\"NTSC\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "tun",
            "\"PAL\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_resize",
          "args": [
            "*fd",
            "w",
            "h"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "173-212",
          "snippet": "static int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_width(int w);",
            "static int v4l1_height(int h);",
            "static int v4l1_resize(int fd, int w, int h);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static int v4l1_dpct(int old, int d);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_setfmt",
          "args": [
            "*fd",
            "\"RGB32\""
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_setfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "252-275",
          "snippet": "static int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "char *v4l_guess(char *str, int *fd);",
            "static int v4l1_setfmt(int fd, char *fmt);",
            "static void apply_settings(char *dev, char *settings, int *fd);",
            "static void v4l_fmt(char *fmt);",
            "static char *v4l1_lu_palette(unsigned short palette);",
            "static char *v4l2_lu_palette(unsigned int palette);",
            "static char *guess_via_v4l(char *dev, int *fd);",
            "static char *guess_via_v4l_info(char *dev, int *fd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic void v4l_fmt(char *fmt);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCSPICT\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "*fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"calling V4L_1: VIDIOCSPICT\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_val",
          "args": [
            "cn"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "134-145",
          "snippet": "static int v4l1_val(int pct) {\n\t/* pct is % */\n\tint val, max = V4L1_MAX; \n\tif (pct < 0) {\n\t\treturn 0;\n\t} else if (pct > 100) {\n\t\treturn max;\n\t}\n\tval = (pct * max)/100;\n\n\treturn val;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L1_MAX 65535"
          ],
          "globals_used": [
            "static int v4l1_val(int pct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_val(int pct);\n\nstatic int v4l1_val(int pct) {\n\t/* pct is % */\n\tint val, max = V4L1_MAX; \n\tif (pct < 0) {\n\t\treturn 0;\n\t} else if (pct > 100) {\n\t\treturn max;\n\t}\n\tval = (pct * max)/100;\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_dev",
          "args": [
            "dev"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "open_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "1067-1084",
          "snippet": "static int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int open_dev(char *dev);",
            "static void init_freqtab(char *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int open_dev(char *dev);\nstatic void init_freqtab(char *file);\n\nstatic int open_dev(char *dev) {\n\tint dfd = -1;\n\tif (! dev) {\n\t\treturn dfd;\n\t}\n\tdfd = open(dev, O_RDWR);\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s O_RDWR\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t\tdfd = open(dev, O_RDONLY);\n\t}\n\tif (dfd < 0) {\n\t\trfbLog(\"failed to rawfb file: %s\\n\", dev);\n\t\trfbLog(\"failed to rawfb file: %s O_RDONLY\\n\", dev);\n\t\trfbLogPerror(\"open\");\n\t}\n\treturn dfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+4"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sta=\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p+4"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"inp=\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p+4"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"tun=\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p+4"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"fmt=\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+4"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"bpp=\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+2"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"h=\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+2"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"w=\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+3"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"hu=\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+3"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"cn=\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+3"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"co=\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+3"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"br=\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "settings"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic void v4l_br(int b);\nstatic void v4l_hu(int b);\nstatic void v4l_co(int b);\nstatic void v4l_cn(int b);\nstatic void v4l_sz(int b);\nstatic void v4l_sta(int sta);\nstatic void v4l_inp(int inp);\nstatic void v4l_fmt(char *fmt);\nstatic int open_dev(char *dev);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic unsigned long lookup_freqtab(int sta);\nstatic unsigned long lookup_freq(int sta);\nstatic int lookup_station(unsigned long freq);\nstatic int v4l1_cap = -1;\nstatic int v4l2_cap = -1;\nstatic int ignore_all = 0;\n\nstatic void apply_settings(char *dev, char *settings, int *fd) {\n#ifdef V4L_OK\n\tchar *str, *p, *fmt = NULL, *tun = NULL, *inp = NULL;\n\tint br = -1, co = -1, cn = -1, hu = -1;\n\tint w = -1, h = -1, b = -1;\n\tint sta = -1;\n\tint setcnt = 0;\n\tif (! settings || settings[0] == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(settings);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (strstr(p, \"br=\") == p) {\n\t\t\tbr = atoi(p+3);\n\t\t\tif (br >= 0) setcnt++;\n\t\t} else if (strstr(p, \"co=\") == p) {\n\t\t\tco = atoi(p+3);\n\t\t\tif (co >= 0) setcnt++;\n\t\t} else if (strstr(p, \"cn=\") == p) {\n\t\t\tcn = atoi(p+3);\n\t\t\tif (cn >= 0) setcnt++;\n\t\t} else if (strstr(p, \"hu=\") == p) {\n\t\t\thu = atoi(p+3);\n\t\t\tif (hu >= 0) setcnt++;\n\t\t} else if (strstr(p, \"w=\") == p) {\n\t\t\tw = atoi(p+2);\n\t\t\tif (w > 0) setcnt++;\n\t\t} else if (strstr(p, \"h=\") == p) {\n\t\t\th = atoi(p+2);\n\t\t\tif (h > 0) setcnt++;\n\t\t} else if (strstr(p, \"bpp=\") == p) {\n\t\t\tb = atoi(p+4);\n\t\t\tif (b > 0) setcnt++;\n\t\t} else if (strstr(p, \"fmt=\") == p) {\n\t\t\tfmt = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"tun=\") == p) {\n\t\t\ttun = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"inp=\") == p) {\n\t\t\tinp = strdup(p+4);\n\t\t\tsetcnt++;\n\t\t} else if (strstr(p, \"sta=\") == p) {\n\t\t\tsta = atoi(p+4);\n\t\t\tsetcnt++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\tif (! setcnt) {\n\t\treturn;\n\t}\n\tif (*fd < 0) {\n\t\t*fd = open_dev(dev);\n\t}\n\tif (*fd < 0) {\n\t\treturn;\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n\n\tif (v4l1_cap && ! ignore_all) {\n\t\tif (br >= 0) v4l1_picture.brightness = v4l1_val(br);\n\t\tif (hu >= 0) v4l1_picture.hue        = v4l1_val(hu);\n\t\tif (co >= 0) v4l1_picture.colour     = v4l1_val(co);\n\t\tif (cn >= 0) v4l1_picture.contrast   = v4l1_val(cn);\n\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\t\tif (ioctl(*fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\t}\n\n\t\tif (fmt) {\n\t\t\tv4l1_setfmt(*fd, fmt);\n\t\t} else if (b > 0 && b != v4l1_picture.depth) {\n\t\t\tif (b == 8) {\n\t\t\t\tv4l1_setfmt(*fd, \"HI240\");\n\t\t\t} else if (b == 16) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB565\");\n\t\t\t} else if (b == 24) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB24\");\n\t\t\t} else if (b == 32) {\n\t\t\t\tv4l1_setfmt(*fd, \"RGB32\");\n\t\t\t}\n\t\t}\n\n\t\tv4l1_resize(*fd, w, h);\n\n\t\tif (tun) {\n\t\t\tint mode = -1;\n\t\t\tif (!strcasecmp(tun, \"PAL\")) {\n\t\t\t\tmode = VIDEO_MODE_PAL;\n\t\t\t} else if (!strcasecmp(tun, \"NTSC\")) {\n\t\t\t\tmode = VIDEO_MODE_NTSC;\n\t\t\t} else if (!strcasecmp(tun, \"SECAM\")) {\n\t\t\t\tmode = VIDEO_MODE_SECAM;\n\t\t\t} else if (!strcasecmp(tun, \"AUTO\")) {\n\t\t\t\tmode = VIDEO_MODE_AUTO;\n\t\t\t}\n\t\t\tif (mode != -1) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (! v4l1_channel.tuners) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (v4l1_channel.norm == mode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv4l1_channel.norm = mode;\n\t\t\t\t\tioctl(*fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inp) {\n\t\t\tchar s[2];\n\t\t\tint i, chan = -1;\n\n\t\t\ts[0] = inp[0];\n\t\t\ts[1] = '\\0';\n\t\t\tif (strstr(\"0123456789\", s)) {\n\t\t\t\tchan = atoi(inp);\n\t\t\t} else {\n\t\t\t\tfor (i=0; i< v4l1_capability.channels; i++) {\n\t\t\t\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\t\t\t\tv4l1_channel.channel = i;\n\t\t\t\t\tif (ioctl(*fd, VIDIOCGCHAN, &v4l1_channel) == -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp(v4l1_channel.name, inp)) {\n\t\t\t\t\t\tchan = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv4l1_set_input(*fd, chan);\n\t\t}\n\t\tif (sta >= 0) {\n\t\t\tunsigned long freq = lookup_freq(sta);\n\t\t\tv4l1_setfreq(*fd, freq, 1);\n\t\t}\n\t}\n\tv4l1_cap = v4l1_query(*fd, 1);\n\tv4l2_cap = v4l2_query(*fd, 1);\n#else\n\tif (!dev || !settings || !fd) {}\n\treturn;\n#endif\n}"
  },
  {
    "function_name": "v4l1_setfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "252-275",
    "snippet": "static int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_setfmt(int fd, char *fmt);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static void v4l_fmt(char *fmt);",
      "static char *v4l1_lu_palette(unsigned short palette);",
      "static char *v4l2_lu_palette(unsigned int palette);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "fmt"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "raw_fb_pixfmt"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCSPICT\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCSPICT",
            "&v4l1_picture"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"calling V4L_1: VIDIOCSPICT\\n\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_lu_palette_str",
          "args": [
            "fmt",
            "&bnew",
            "&rnew"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_lu_palette_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "774-800",
          "snippet": "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);",
            "static unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev);\nstatic unsigned int v4l2_lu_palette_str(char *name, int *bits, int *rev);\n\nstatic unsigned short v4l1_lu_palette_str(char *name, int *bits, int *rev) {\n#ifdef V4L_OK\n\t*rev = 0;\n\tif (!strcmp(name, \"RGB555\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB555;\n\t} else if (!strcmp(name, \"RGB565\")) {\n\t\t*bits = 16;\n\t\treturn VIDEO_PALETTE_RGB565;\n\t} else if (!strcmp(name, \"RGB24\")) {\n\t\t*bits = 24;\n\t\treturn VIDEO_PALETTE_RGB24;\n\t} else if (!strcmp(name, \"RGB32\")) {\n\t\t*bits = 32;\n\t\treturn VIDEO_PALETTE_RGB32;\n\t} else if (!strcmp(name, \"HI240\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_HI240;\n\t} else if (!strcmp(name, \"GREY\")) {\n\t\t*bits = 8;\n\t\treturn VIDEO_PALETTE_GREY;\n\t}\n#else\n\tif (!name || !bits || !rev) {}\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_setfmt(int fd, char *fmt);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic void v4l_fmt(char *fmt);\nstatic char *v4l1_lu_palette(unsigned short palette);\nstatic char *v4l2_lu_palette(unsigned int palette);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_setfmt(int fd, char *fmt) {\n#ifdef V4L_OK\n\tunsigned short fnew;\n\tint bnew, rnew;\n\n\tfnew = v4l1_lu_palette_str(fmt, &bnew, &rnew);\n\tif (fnew) {\n\t\tv4l1_picture.depth = bnew; \n\t\tv4l1_picture.palette = fnew;\n\t}\n\tfprintf(stderr, \"calling V4L_1: VIDIOCSPICT\\n\");\n\tif (ioctl(fd, VIDIOCSPICT, &v4l1_picture) == -1) {\n\t\tperror(\"ioctl VIDIOCSPICT\");\n\t\treturn 0;\n\t}\n\tif (raw_fb_pixfmt) {\n\t\tfree(raw_fb_pixfmt);\n\t}\n\traw_fb_pixfmt = strdup(fmt);\n#else\n\tif (!fd || !fmt) {}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "v4l1_set_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "234-250",
    "snippet": "static void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static void v4l1_set_input(int fd, int which);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static int last_channel = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCSCHAN",
            "&v4l1_channel"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"setting input channel to %d: %s\\n\"",
            "which",
            "v4l1_channel.name"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGCHAN",
            "&v4l1_channel"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_channel",
            "0",
            "sizeof(v4l1_channel)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_set_input(int fd, int which);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int last_channel = 0;\n\nstatic void v4l1_set_input(int fd, int which) {\n#ifdef V4L_OK\n\tif (which != -1) {\n\t\tmemset(&v4l1_channel, 0, sizeof(v4l1_channel));\n\t\tv4l1_channel.channel = which;\n\t\tif (ioctl(fd, VIDIOCGCHAN, &v4l1_channel) != -1) {\n\t\t\tv4l1_channel.channel = which;\n\t\t\tfprintf(stderr, \"setting input channel to %d: %s\\n\",\n\t\t\t    which, v4l1_channel.name);\n\t\t\tlast_channel = which;\n\t\t\tioctl(fd, VIDIOCSCHAN, &v4l1_channel);\n\t\t}\n\t}\n#else\n\tif (!fd || !which) {}\n#endif\n}"
  },
  {
    "function_name": "v4l1_setfreq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "214-232",
    "snippet": "static void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static void v4l1_setfreq(int fd, unsigned long freq, int verb);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);",
      "static int lookup_station(unsigned long freq);",
      "static unsigned long last_freq = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read freq: %d\\n\"",
            "(int) f0"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGFREQ",
            "&f0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCSFREQ\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCSFREQ",
            "&f1"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"read freq: %d\\n\"",
            "(int) f0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGFREQ",
            "&f0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\nstatic int lookup_station(unsigned long freq);\nstatic unsigned long last_freq = 0;\n\nstatic void v4l1_setfreq(int fd, unsigned long freq, int verb) {\n#ifdef V4L_OK\n\tunsigned long f0, f1;\n\tf1 = (freq * 16) / 1000;\n\tioctl(fd, VIDIOCGFREQ, &f0);\n\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\tif (freq > 0) {\n\t\tif (ioctl(fd, VIDIOCSFREQ, &f1) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSFREQ\");\n\t\t} else {\n\t\t\tioctl(fd, VIDIOCGFREQ, &f0);\n\t\t\tif (verb) fprintf(stderr, \"read freq: %d\\n\", (int) f0);\n\t\t\tlast_freq = freq;\n\t\t}\n\t}\n#else\n\tif (!fd || !freq || !verb) {}\n#endif\n}"
  },
  {
    "function_name": "v4l1_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "173-212",
    "snippet": "static int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "char *v4l_guess(char *str, int *fd);",
      "static int v4l1_width(int w);",
      "static int v4l1_height(int h);",
      "static int v4l1_resize(int fd, int w, int h);",
      "static void apply_settings(char *dev, char *settings, int *fd);",
      "static int v4l1_dpct(int old, int d);",
      "static char *guess_via_v4l(char *dev, int *fd);",
      "static char *guess_via_v4l_info(char *dev, int *fd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl VIDIOCSWIN\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCSWIN",
            "&v4l1_window"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"trying new size %dx%d\\n\"",
            "v4l1_window.width",
            "v4l1_window.height"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"calling V4L_1: VIDIOCSWIN\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCSWIN",
            "&v4l1_window"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4l1_height",
          "args": [
            "h"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_height",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "159-171",
          "snippet": "static int v4l1_height(int h) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minheight;\n\tint max = v4l1_capability.maxheight;\n\tif (h < min) {\n\t\th = min;\n\t}\n\tif (h > max) {\n\t\th = max;\n\t}\n#endif\n\treturn h;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_height(int h);",
            "static int v4l1_resize(int fd, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\n\nstatic int v4l1_height(int h) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minheight;\n\tint max = v4l1_capability.maxheight;\n\tif (h < min) {\n\t\th = min;\n\t}\n\tif (h > max) {\n\t\th = max;\n\t}\n#endif\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4l1_width",
          "args": [
            "w"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "v4l1_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
          "lines": "146-158",
          "snippet": "static int v4l1_width(int w) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minwidth;\n\tint max = v4l1_capability.maxwidth;\n\tif (w < min) {\n\t\tw = min;\n\t}\n\tif (w > max) {\n\t\tw = max;\n\t}\n#endif\n\treturn w;\n}",
          "includes": [
            "#include <linux/videodev.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define V4L_OK"
          ],
          "globals_used": [
            "static int v4l1_width(int w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_width(int w);\n\nstatic int v4l1_width(int w) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minwidth;\n\tint max = v4l1_capability.maxwidth;\n\tif (w < min) {\n\t\tw = min;\n\t}\n\tif (w > max) {\n\t\tw = max;\n\t}\n#endif\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "VIDIOCGWIN",
            "&v4l1_window"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v4l1_window",
            "0",
            "sizeof(v4l1_window)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nchar *v4l_guess(char *str, int *fd);\nstatic int v4l1_width(int w);\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\nstatic void apply_settings(char *dev, char *settings, int *fd);\nstatic int v4l1_dpct(int old, int d);\nstatic char *guess_via_v4l(char *dev, int *fd);\nstatic char *guess_via_v4l_info(char *dev, int *fd);\n\nstatic int v4l1_resize(int fd, int w, int h) {\n#ifdef V4L_OK\n\tint dowin = 0;\n\n\tmemset(&v4l1_window, 0, sizeof(v4l1_window));\n\tif (ioctl(fd, VIDIOCGWIN, &v4l1_window) == -1) {\n\t\treturn 0;\n\t}\n\n\tif (w > 0) w = v4l1_width(w);\n\n\tif (w > 0 && w != (int) v4l1_window.width) {\n\t\tdowin = 1;\n\t}\n\n\tif (h > 0) h = v4l1_height(h);\n\n\tif (h > 0 && h != (int) v4l1_window.height) {\n\t\tdowin = 1;\n\t}\n\n\tif (dowin) {\n\t\tv4l1_window.x = 0;\n\t\tv4l1_window.y = 0;\n\t\tioctl(fd, VIDIOCSWIN, &v4l1_window);\n\t\tif (w > 0) v4l1_window.width = w;\n\t\tif (h > 0) v4l1_window.height = h;\n\t\tfprintf(stderr, \"calling V4L_1: VIDIOCSWIN\\n\");\n\t\tfprintf(stderr, \"trying new size %dx%d\\n\",\n\t\t    v4l1_window.width, v4l1_window.height);\n\t\tif (ioctl(fd, VIDIOCSWIN, &v4l1_window) == -1) {\n\t\t\tperror(\"ioctl VIDIOCSWIN\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#else\n\tif (!fd || !w || !h) {}\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "v4l1_height",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "159-171",
    "snippet": "static int v4l1_height(int h) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minheight;\n\tint max = v4l1_capability.maxheight;\n\tif (h < min) {\n\t\th = min;\n\t}\n\tif (h > max) {\n\t\th = max;\n\t}\n#endif\n\treturn h;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static int v4l1_height(int h);",
      "static int v4l1_resize(int fd, int w, int h);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_height(int h);\nstatic int v4l1_resize(int fd, int w, int h);\n\nstatic int v4l1_height(int h) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minheight;\n\tint max = v4l1_capability.maxheight;\n\tif (h < min) {\n\t\th = min;\n\t}\n\tif (h > max) {\n\t\th = max;\n\t}\n#endif\n\treturn h;\n}"
  },
  {
    "function_name": "v4l1_width",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "146-158",
    "snippet": "static int v4l1_width(int w) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minwidth;\n\tint max = v4l1_capability.maxwidth;\n\tif (w < min) {\n\t\tw = min;\n\t}\n\tif (w > max) {\n\t\tw = max;\n\t}\n#endif\n\treturn w;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L_OK"
    ],
    "globals_used": [
      "static int v4l1_width(int w);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L_OK\n\nstatic int v4l1_width(int w);\n\nstatic int v4l1_width(int w) {\n#ifdef V4L_OK\n\tint min = v4l1_capability.minwidth;\n\tint max = v4l1_capability.maxwidth;\n\tif (w < min) {\n\t\tw = min;\n\t}\n\tif (w > max) {\n\t\tw = max;\n\t}\n#endif\n\treturn w;\n}"
  },
  {
    "function_name": "v4l1_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/v4l.c",
    "lines": "134-145",
    "snippet": "static int v4l1_val(int pct) {\n\t/* pct is % */\n\tint val, max = V4L1_MAX; \n\tif (pct < 0) {\n\t\treturn 0;\n\t} else if (pct > 100) {\n\t\treturn max;\n\t}\n\tval = (pct * max)/100;\n\n\treturn val;\n}",
    "includes": [
      "#include <linux/videodev.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"connections.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define V4L1_MAX 65535"
    ],
    "globals_used": [
      "static int v4l1_val(int pct);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/videodev.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define V4L1_MAX 65535\n\nstatic int v4l1_val(int pct);\n\nstatic int v4l1_val(int pct) {\n\t/* pct is % */\n\tint val, max = V4L1_MAX; \n\tif (pct < 0) {\n\t\treturn 0;\n\t} else if (pct > 100) {\n\t\treturn max;\n\t}\n\tval = (pct * max)/100;\n\n\treturn val;\n}"
  }
]